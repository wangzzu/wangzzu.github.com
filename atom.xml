<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matt&#39;s Blog</title>
  <subtitle>wangzzu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://matt33.com/"/>
  <updated>2017-08-12T10:21:02.000Z</updated>
  <id>http://matt33.com/</id>
  
  <author>
    <name>Matt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈一谈 Java IO 模型</title>
    <link href="http://matt33.com/2017/08/12/java-nio/"/>
    <id>http://matt33.com/2017/08/12/java-nio/</id>
    <published>2017-08-12T09:51:56.000Z</published>
    <updated>2017-08-12T10:21:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java IO 模型对于 Java 开发工程师来说，是日常工作中经常接触的内容，特别是随着分布式系统的兴起，IO 也显得越来越重要，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现，不熟悉这一部分内容的话，可以先看一下上篇文章<a href="http://matt33.com/2017/08/06/unix-io/">Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</a>，本文跟上篇的内容是紧密相连的，特别是本文的重点 —— Java NIO 部分，其底层原理就是 UNIX 的 IO 多路复用，IO 多路复用在上篇文章中讲述了很多。</p>
<p>这篇文章大概内容如下：</p>
<ol>
<li>Java IO 模型的简单介绍；</li>
<li>BIO 、NIO、AIO 模型的介绍，会详细介绍 NIO；</li>
<li>几种 IO 模型的对比。</li>
</ol>
<h1 id="Java-IO-模型介绍"><a href="#Java-IO-模型介绍" class="headerlink" title="Java IO 模型介绍"></a>Java IO 模型介绍</h1><p>在 JDK 推出 Java NIO 之前，基于 Java 的所有 Socket 通信都采用了同步阻塞模式（BIO），这种一对一的通信模型虽然简化了开发的难度，但在性能和可靠性方面却存在这巨大的瓶颈，特别是无法处理高并发的场景，使得 Java 在服务器端应用十分有限。</p>
<p>正是由于 Java 传统 BIO 的拙劣表现，使得 Java 不得不去开发新版的 IO 模型，最终，JDK1.4 提供了新的 NIO 类库，Java 可以支持非阻塞 IO；之后，JDK1.7 正式发布，不但对 NIO 进行了升级，还提供了 AIO 功能。本文就是在对 Java 这些 IO 模型学习后，总结的一篇笔记。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>网络编程的基本模型是 Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的 IP 地址和端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接成功，双方就可以通过网络套接字（socket）进行通信（可以参考<a href="http://localhost:8080/2016/08/30/http-protocol/" target="_blank" rel="external">TCP的三次握手和四次挥手</a>），下面先看一下两种对 IO 模型常见的分类方式。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>描述的是用户线程与内核的交互方式，与消息的通知机制有关：</p>
<ol>
<li>同步：当一个同步调用发出后，需要等待返回消息（用户线程不断去询问），才能继续进行；</li>
<li>异步：当一个异步调用发出后，调用者不能立即得到返回消息，完成后会通过状态、通知和回调来通知调用者。</li>
</ol>
<p>简单来说就是：</p>
<ol>
<li>同步：同步等待消息通知，消息返回才能继续进行；</li>
<li>异步：异步等待消息通知，完成后被调系统通过回调等来通过调用者。</li>
</ol>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞指的是不能立刻得到结果之前，会不会阻塞当前线程。</p>
<ol>
<li>阻塞：当前线程会被挂起，直到结果返回；</li>
<li>非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（会导致线程切换的增加）。</li>
</ol>
<p>举个栗子说明：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>示例</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td>在银行排队，不干别的事情</td>
<td>效率最低</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>排队时，边打电话边抬头看是否到自己了</td>
<td>效率低下</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>在银行领一个号后，在银行里等，不能做别的事情</td>
<td></td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>领完号后，在忙着自己的事情，直到柜台通知</td>
<td>效率较高</td>
</tr>
</tbody>
</table>
<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>BIO 模型是 Java IO 最开始提供的一种 IO 模型，BIO 又可以细分为两种模型，一是传统的同步阻塞模型，二是在对传统 BIO 模型的基本上进行的优化，又称为伪异步 IO 模型。</p>
<h2 id="传统的-BIO-模型"><a href="#传统的-BIO-模型" class="headerlink" title="传统的 BIO 模型"></a>传统的 BIO 模型</h2><p>传统 BIO 中，ServerSocket 负责绑定 IP 地址，启动监听端口；Socket 负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通信。采用 BIO 通信模型的 Server，通常由一个独立的 Acceptor 线程负责监听 Client 端的连接，它接受到 Client 端连接请求后为每个 Client 创建一个新的线程进行处理，处理完之后，通过输出流返回给 Client 端，线程销毁，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="/images/java/BIO.png" alt="传统 Java BIO 模型"></p>
<p>这个模型最大的问题是：</p>
<ul>
<li>缺乏扩展性，不能处理高性能、高并发场景，线程是 JVM 中非常宝贵的资源，当线程数膨胀后，系统的性能就会急剧下降，随着并发访问量的继续增大，系统就会出现线程堆栈溢出、创建新线程失败等问题，导致 Server 不能对外提供服务。</li>
</ul>
<p>示例代码参考 <a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/bio/" target="_blank" rel="external">Java BIO 示例</a>。</p>
<h2 id="伪异步-IO-模型"><a href="#伪异步-IO-模型" class="headerlink" title="伪异步 IO 模型"></a>伪异步 IO 模型</h2><p>为了改进这种一对一的连接模型，后来又演进出了一种通过线程池或者消息队列实现 1 个或者多个线程处理所有 Client 请求的模型，由于它底层依然是同步阻塞 IO，所以被称为【伪异步 IO 模型】。相比于传统 BIO 后端不断创建新的线程处理 Client 请求，它在后端使用一个<strong>线程池</strong>来代替，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程资源耗尽，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="/images/java/BIO2.png" alt="伪异步 IO 模型"></p>
<p>看似这个模型解决了 BIO 面对的问题，实际上，由于它是面向数据流的模型，底层依然是同步阻塞模型，在处理一个 socket 输入流，它会一直阻塞下去，除非：有数据可读、可用数据读取完毕、有异常，否则会一直一直阻塞下去。这个模型最大的问题是：</p>
<ul>
<li>阻塞的时间取决于对应 IO 线程的处理速度和网络 IO 的传输速度，处理效率不可控。</li>
</ul>
<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><p>Java NIO 是 Java IO 模型中最重要的 IO 模型，也是本文主要讲述的内容，正式由于 NIO 的出现，Java 才能在服务端获得跟 C 和 C++ 一样的运行效率，NIO 是 New IO（或者 Non-block IO）的简称。</p>
<p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同套接字通道的实现，它们都支持阻塞和非阻塞两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞 IO 以降低复杂度，但是高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在 NIO 中有三种非常重要的概念：</p>
<ul>
<li>缓冲区（buffer）：本质上是一个数组，它包含一些要读写的数据；</li>
<li>通道（channel）：是一个通道，通过它读写数据，类似于自来水管；</li>
<li>多路复用器（selector）：用于选择已经就绪的任务，selector 会轮询注册在其上的 channel，选出已经就绪的 channel。</li>
</ul>
<p><img src="/images/java/NIO.png" alt="NIO 的简单模型"></p>
<p>三者之间的关系如上图所示，这里先简单概括一下：</p>
<ul>
<li>Buffer：是缓冲区，任何时候访问 NIO 数据，都是通过 Buffer 进行；</li>
<li>Channel：通过它读写 Buffer 中的数据，可以用于读、写或同时读写；</li>
<li>Selector：多路复用器，Selector 不断轮询注册在其上的 Channel，如果某个 Channel 有新的 TCP 链接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮组出来，然后通过<code>SelectionKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</li>
</ul>
<p>下面详细介绍一下这三个概念。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是全双工的，可以比流更好地映射底层操作系统的 API，与流也非常相似，有以下几点区别：</p>
<ul>
<li>Channel 可以读也可以写，但流（InputStream 或 OutputStream）是单向的；</li>
<li>通道可以异步读写；</li>
<li>它是基于缓冲区（Buffer）进行读写；</li>
</ul>
<p>在 Java 中提供以下几种 Channel：</p>
<ol>
<li>FileChannel：用于文件的读写；</li>
<li>DatagramChannel：用于 UDP 数据读写；</li>
<li>SocketChannel：用于 Socket 数据读写；</li>
<li>ServerSocketChannel：监听 TCP 连接请求。</li>
</ol>
<p>这些 Channel 类之间的继承关系如下图所示</p>
<p><img src="/images/java/channel.png" alt="Channel 之间的继承关系"></p>
<p>从上图中，可以看出，Channel 可以分为两大类：用于网络读写的 <code>SelectableChannel</code> 和用于文件操作的 <code>FileChannel</code>。</p>
<p>其中，FileChannel 只能在阻塞模式下工作，具体可以参考<a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-filechannel.html" target="_blank" rel="external">Java NIO FileChannel文件通道</a>。</p>
<h4 id="NIO-Scatter-Gather"><a href="#NIO-Scatter-Gather" class="headerlink" title="NIO Scatter/Gather"></a>NIO Scatter/Gather</h4><p>Java NIO 发布时内置了对 scatter/gather的支持：</p>
<ul>
<li>Scattering read 指的是从通道读取的操作能把数据写入多个 Buffer，也就是 sctters 代表了数据从一个 Channel 到多个 Buffer的过程。</li>
<li>Gathering write 则正好相反，表示的是从多个 Buffer 把数据写入到一个 Channel中。</li>
</ul>
<p><img src="/images/java/scatter-gather.png" alt="Channel 之间的继承关系"></p>
<p>示例如下，具体参考 <a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-scatter-gather.html" target="_blank" rel="external">Java NIO Scatter / Gather</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Scattering read</span></div><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line">channel.read(bufferArray);</div><div class="line"></div><div class="line"><span class="comment">// Gathering write</span></div><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line">channel.write(bufferArray);</div></pre></td></tr></table></figure>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer，本质上是一块内存区，可以用来读写数据，它包含一些要写入或者要读出的数据。在 NIO 中，所有数据都是通过 Buffer 处理的，读取数据时，它是直接读到缓冲区中，写入数据时，写入到缓冲区。</p>
<p>最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组，除了 ByteBuffer，还有其他的一些 Buffer，如：CharBuffer、IntBuffer 等，它们之间的关系如下图所示。</p>
<p><img src="/images/java/buffer.png" alt="Buffer 之间的继承关系"></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Buffer 基本用法（读写数据过程）：</p>
<ol>
<li>把数据写入 Buffer；</li>
<li>调用 <code>flip()</code>，Buffer 由写模式变为读模式；</li>
<li>Buffer 中读取数据；</li>
<li>调用 <code>clear()</code> 清空 buffer，等待下次写入。</li>
</ol>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] req = <span class="string">"QUERY TIME ORDER"</span>.getBytes();</div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(req.length);</div><div class="line">byteBuffer.put(req);</div><div class="line">byteBuffer.flip();</div><div class="line"><span class="keyword">while</span> (byteBuffer.hasRemaining())&#123;</div><div class="line">     System.out.println((<span class="keyword">char</span>) byteBuffer.get());</div><div class="line">&#125;</div><div class="line">byteBuffer.clear();</div></pre></td></tr></table></figure>
<h4 id="Buffer-位置信息"><a href="#Buffer-位置信息" class="headerlink" title="Buffer 位置信息"></a>Buffer 位置信息</h4><p>Buffer 实质上就是一块内存，用于读写数据，这块内存被 NIO Buffer 管理，一个 Buffer 有三个属性是必须掌握的，分别是：</p>
<ul>
<li>capacity：容量；</li>
<li>position：位置；</li>
<li>limit：限制；</li>
</ul>
<p>其中，position 和 limit 的具体含义取决于当前 buffer 的模式，capacity 在两种模式下都表示容量，Buffer 读模式和写模式如下图所示。</p>
<p><img src="/images/java/buffer-position.png" alt="Buffer 的位置信息"></p>
<ol>
<li>容量（capacity）<ul>
<li>Buffer 有一块固定的内存，其大小就是 capacity，一旦 Buffer 写满，就需要清空已读数据以便下次继续写入新的数据；</li>
</ul>
</li>
<li>位置（Position）<ul>
<li>写模式时，当写入数据到 Buffer 的时候从一个确定的位置开始，初始化时这个位置 position 为0，写入数据后，position 的值就会指向数据之后的单元，position 最大的值可以达到 <code>capacity-1</code>；</li>
<li>读模式时，也需要从一个确定的位置开始，Buffer 从写模式变为读模式时，position 会归零，每次读取后，position 向后移动；</li>
</ul>
</li>
<li>上限（limit）<ul>
<li>写模式时，limit 就是能写入的最大数据量，等同于 Buffer 的容量；</li>
<li>读模式时，limit 代表我们能读取的最大容量，它的值等同于写模式下 position 位置。</li>
</ul>
</li>
</ol>
<h4 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h4><ul>
<li><code>flip()</code>：把 buffer 从模式调整为读模式，在读模式下，可以读取所有已经写入的数据；</li>
<li><code>clear()</code>：清空整个 buffer；</li>
<li><code>compact()</code>：只清空已读取的数据，未被读取的数据会被移动到 buffer 的开始位置，写入位置则紧跟着未读数据之后；</li>
<li><code>rewind()</code>：将 position 置为0，这样我们可以重复读取 Buffer 中的数据，limit 保持不变；</li>
<li><code>mark()</code>和<code>reset()</code>：通过mark方法可以标记当前的position，通过reset来恢复mark的位置</li>
<li><code>equals()</code>：判断两个 Buffer 是否相等，需满足：类型相同、Buffer 中剩余字节数相同、所有剩余字节相等；</li>
<li><code>compareTo()</code>：compareTo 比较 Buffer 中的剩余元素，只不过这个方法适用于比较排序的。</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector 是 Java NIO 核心部分，简单来说，它的作用就是：Selector 不断轮询注册在其上的 Channel，如果某个 Channel 上面有新的 TCP 连接、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 <code>SelectorKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</p>
<p>一个 Selector 可以轮询多个 Channel，由于 JDK 底层使用了 <code>epoll()</code> 实现，它并没有最大连接句柄 1024/2048 的限制，这就意味着只需要一个线程负责 Selector 的轮询，就可以连接上千上万的 Client。</p>
<h4 id="注册-Channel"><a href="#注册-Channel" class="headerlink" title="注册 Channel"></a>注册 Channel</h4><p>举一个栗子，简单介绍 <code>Selector</code> 的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 Selector</span></div><div class="line">Selector selector = Selector.open();</div><div class="line"><span class="comment">// 将一个 Channel 注册到 Selector 上</span></div><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</div></pre></td></tr></table></figure>
<p><code>register()</code> 的第二个参数代表的是 selector 监听的事件类型，Selector 可以监听事件类型总共有以下四种：</p>
<ol>
<li>SelectionKey.OP_CONNECT：只会注册一次，成功之后（TCP 连接建立之后），这个监听事件就取消了；</li>
<li>SelectionKey.OP_ACCEPT：主要用于服务端，就是监听是否有新的连接请求；</li>
<li>SelectionKey.OP_READ：注册之后不会取消；</li>
<li>SelectionKey.OP_WRITE：每次调用一个 send，就注册一次，send 成功后，就取消。</li>
</ol>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p><code>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</code> 返回的是已经就绪的 Channel 集合，<code>SelectionKey</code> 对象的详细属性如下图所示。</p>
<p><img src="/images/java/SelectionKey.png" alt="SelectionKey 的详情"></p>
<h2 id="NIO-原理"><a href="#NIO-原理" class="headerlink" title="NIO 原理"></a>NIO 原理</h2><p>Java NIO 实现的关键是 IO 多路复用（具体可以参考上篇文章：<a href="http://matt33.com/2017/08/06/unix-io/#Linux-的-IO-多路复用模型">Linux 的 IO 多路复用模型</a>），在 Linux 平台，Java NIO 是基于 epoll（2.6以上，之前是 Select） 来实现的。</p>
<p>Linux 的 select/epoll  使用的是 Reactor 网络 IO 模式。网络编程中，有两种常用的设计模式，它们都是基于事件驱动：</p>
<ul>
<li>Reactor 模式：主动模式，应用程序不断去轮询，问操作系统 IO 是否就绪，实际的 IO 操作还是由应用实现（IO 多路复用采用的模式）；</li>
<li>Proactor 模式：被动模式，操作系统把 IO 完成后通知应用程序，此时数据已经就绪。</li>
</ul>
<p>这两种模式详细内容可以参考<a href="http://daoluan.net/linux/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2013/08/20/two-high-performance-io-design-patterns.html" target="_blank" rel="external">两种高性能 I/O 设计模式 Reactor 和 Proactor</a>一文。</p>
<h2 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h2><p>关于 Java NIO，有两种最常见的使用方式：</p>
<ul>
<li>使用原生的 Java NIO（如 Kafka）；</li>
<li>使用 Netty（Hadoop 的 RPC 框架 Avro 底层使用 Netty 做通信框架）。</li>
</ul>
<p>在实际使用中，推荐第二种，使用 Netty 将会大大提高开发效率，后续会写篇关于 Netty 的文章，介绍一下 Netty 的具体内容，这里使用一个基于 Java 原生 NIO API 的小示例，讲述一下 NIO 的使用方法。</p>
<h3 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h3><p>NIO Client 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="/images/java/nio-client.png" alt="NIO Client 端序列图"></p>
<p>具体的代码及注释参考：<a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/client/" target="_blank" rel="external">NIO Client 端代码</a>。</p>
<h3 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h3><p>NIO Server 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="/images/java/nio-server.png" alt="NIO Server 端序列图"></p>
<p>具体的代码及注释参考：<a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/server/" target="_blank" rel="external">NIO Server 端代码</a>。</p>
<h1 id="IO-模型对比"><a href="#IO-模型对比" class="headerlink" title="IO 模型对比"></a>IO 模型对比</h1><p>在对比之前，先简单介绍 Java AIO 模型，这里就不再进行相应的展开了。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>NIO 2.0 中引入异步通道的概念，并提供了异步文件通道和异步套接字导通的实现，它是真正的异步非阻塞I IO，底层是利用事件驱动（AIO）实现，不需要多路复用器（Selector）对注册的通道进行轮组操作即可实现异步读写。</p>
<p>可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/" target="_blank" rel="external">在 Java 7 中体会 NIO.2 异步执行的快乐</a></p>
<h2 id="几种-IO-模型功能和特性对比"><a href="#几种-IO-模型功能和特性对比" class="headerlink" title="几种 IO 模型功能和特性对比"></a>几种 IO 模型功能和特性对比</h2><table>
<thead>
<tr>
<th></th>
<th>传统 BIO</th>
<th>伪异步 IO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>client 数：IO 线程数</td>
<td>1：1</td>
<td>M：N（M 可以大于 N）</td>
<td>M：1</td>
<td>M：0（不需要额外的线程，被动回调）</td>
</tr>
<tr>
<td>IO 类型（阻塞）</td>
<td>阻塞IO</td>
<td>阻塞IO</td>
<td>非阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>IO 类型（同步）</td>
<td>同步 IO</td>
<td>同步 IO</td>
<td>同步 IO（IO 多路复用）</td>
<td>异步 IO</td>
</tr>
<tr>
<td>可靠性</td>
<td>非常差</td>
<td>差</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>本文主要是对 Java IO 模型总结，特别是对 NIO 模型的总结。</p>
<hr>
<p>参考</p>
<ul>
<li>《Netty 权威指南》；</li>
<li>Java NIO <a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="external">英文版</a>，<a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">中文版</a>；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java IO 模型对于 Java 开发工程师来说，是日常工作中经常接触的内容，特别是随着分布式系统的兴起，IO 也显得越来越重要，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现，不熟悉这一部分内容的话，可以先看一下上篇文章&lt;a href=&quot;http://m
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</title>
    <link href="http://matt33.com/2017/08/06/unix-io/"/>
    <id>http://matt33.com/2017/08/06/unix-io/</id>
    <published>2017-08-06T14:19:56.000Z</published>
    <updated>2017-08-06T14:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段在看 Kafka 的网络模型时，遇到了很多 Java NIO 的内容，在学习 Java NIO 的过程中，发现需要把 UNIX 的这几种网络 IO 模型以及 Linux 的 IO 多路复用理解清楚，才能更好地理解 Java NIO，本文就是在学习 UNIX 的五种网络 IO 模型以及 Linux IO 多路复用模型后，做的一篇总结。</p>
<p>本文主要探讨的问题有以下两个：</p>
<ol>
<li>Unix 中的五种网络 IO 模型；</li>
<li>Linux 中 IO 多路复用的实现。</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在介绍网络模型之前，先简单介绍一些基本概念。</p>
<h3 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h3><p>文件描述符（file descriptor，简称 fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>在 Linux 中，内核将所有的外部设备都当做一个文件来进行操作，而对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd，对一个 socket 的读写也会有相应的描述符，称为 socketfd（socket 描述符），实际上描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性）。</p>
<h3 id="用户空间与内核空间、内核态与用户态"><a href="#用户空间与内核空间、内核态与用户态" class="headerlink" title="用户空间与内核空间、内核态与用户态"></a>用户空间与内核空间、内核态与用户态</h3><p>这个是经常提到的概念，具体含义可以参考这篇文章<a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间，进程上下文与中断上下文【总结】</a>，大概内容如下：</p>
<p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 linux 操作系统而言（以32位操作系统为例）</p>
<ul>
<li>将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间；</li>
<li>将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</li>
</ul>
<p>每个进程可以通过系统调用进入内核，因此，Linux 内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<ul>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（<strong>内核态</strong>）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈；</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（<strong>用户态</strong>）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当一个进程在执行时，CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。</p>
<p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在 Linux 中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。</p>
<h2 id="UNIX-的网络-IO-模型"><a href="#UNIX-的网络-IO-模型" class="headerlink" title="UNIX 的网络 IO 模型"></a>UNIX 的网络 IO 模型</h2><p>根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了以下 5 种 IO 模型。</p>
<h3 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h3><p>最常用的 IO 模型就是阻塞 IO 模型，在缺省条件下，所有文件操作都是阻塞的，以 socket 读为例来介绍一下此模型，如下图所示。</p>
<p><img src="/images/linux/BIO.png" alt="阻塞 IO 模型"></p>
<p>在用户空间调用 <code>recvfrom</code>，系统调用直到数据包达到且被复制到应用进程的缓冲区中或中间发生异常返回，在这个期间进程会一直等待。进程从调用 <code>recvfrom</code> 开始到它返回的整段时间内都是被阻塞的，因此，被称为阻塞 IO 模型。</p>
<h3 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h3><p><code>recvfrom</code> 从应用到内核的时，如果该缓冲区没有数据，就会直接返回 <code>EWOULDBLOCK</code> 错误，一般都对非阻塞 IO 模型进行轮询检查这个状态，看看内核是不是有数据到来，流程如下图所示。</p>
<p><img src="/images/linux/N-BIO.png" alt="非阻塞 IO 模型"></p>
<p>也就是说非阻塞的 <code>recvform</code> 系统调用调用之后，进程并没有被阻塞，内核马上返回给进程。</p>
<ul>
<li>如果数据还没准备好，此时会返回一个 error。进程在返回之后，可以干点别的事情，然后再发起 <code>recvform</code> 系统调用。重复上面的过程，循环往复的进行 <code>recvform</code> 系统调用，这个过程通常被称之为<strong>轮询</strong>。</li>
</ul>
<p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<p>在 Linux 下，可以通过设置 socket 使其变为 non-blocking。</p>
<h3 id="IO-多路复用模型"><a href="#IO-多路复用模型" class="headerlink" title="IO 多路复用模型"></a>IO 多路复用模型</h3><p>Linux 提供 select、poll、epoll，进程通过讲一个或者多个 fd 传递给 select、poll、epoll 系统调用，阻塞在 select 操作（这个是内核级别的调用）上，这样的话，可以同时监听多个 fd 是否处于就绪状态。其中，</p>
<ul>
<li>select/poll 是顺序扫描 fd 是否就绪，而且支持的 fd 数量有限；</li>
<li>epoll 是基于事件驱动方式代替顺序扫描性能更高。</li>
</ul>
<p>这个后面详细讲述，具体流程如下图所示。</p>
<p><img src="/images/linux/Multi-IO.png" alt="IO 多路复用模型"></p>
<p>多路复用的特点是通过一种机制一个进程能同时等待 IO 文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll 函数就可以返回，它最大的优势就是可以同时处理多个连接。</p>
<h3 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h3><p>首先需要开启 socket 信号驱动 IO 功能，并通过系统调用 <code>sigaction</code> 执行一个信号处理函数（非阻塞，立即返回）。当数据就绪时，会为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 <code>recvfrom</code> 来读取数据，并通知主循环喊出处理数据，流程如下图所示。</p>
<p><img src="/images/linux/single-IO.png" alt="信号驱动 IO 模型"></p>
<h3 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h3><p>告知内核启动某个事件，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通过我们，流程如下图所示。</p>
<p><img src="/images/linux/AIO.png" alt="异步 IO 模型"></p>
<p>与信号驱动模式的主要区别是：</p>
<ul>
<li>信号驱动 IO 由内核通知我们何时可以开始一个 IO 操作；</li>
<li>异步 IO 操作由内核通知我们 IO 何时完成。</li>
</ul>
<p>内核是通过向应用程序发送 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉用户 read 操作已经完成，在 Linux 中，通知的方式是信号：</p>
<ol>
<li>当进程正处于用户态时，应用需要立马进行处理，一般情况下，是先将事件登记一下，放进一个队列中；</li>
<li>当进程正处于内核态时，比如正在以同步阻塞模式读磁盘，那么只能先把这个通知挂起来，等内核态的事情完成之后，再触发信号通知；</li>
<li>如果这个进程现在被挂起来了，比如 sleep，那就把这个进程唤醒，等 CPU 空闲时，就会调度这个进程，触发信号通知。</li>
</ol>
<h3 id="几种-IO-模型比较"><a href="#几种-IO-模型比较" class="headerlink" title="几种 IO 模型比较"></a>几种 IO 模型比较</h3><p><img src="/images/linux/IO-compact.png" alt="几种模型的比较"></p>
<h2 id="Linux-的-IO-多路复用模型"><a href="#Linux-的-IO-多路复用模型" class="headerlink" title="Linux 的 IO 多路复用模型"></a>Linux 的 IO 多路复用模型</h2><p>IO 多路复用通过把多个 IO 阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下，可以同时处理多个 client 请求，与传统的多线程/多进程模型相比，IO 多路复用的最大优势是系统开销小，系统不需要创建新的额外的进程或线程，也不需要维护这些进程和线程的运行，节省了系统资源，IO 多路复用的主要场景如下：</p>
<ol>
<li>Server 需要同时处理多个处于监听状态或者连接状态的 socket；</li>
<li>Server 需要同时处理多种网络协议的 socket。</li>
</ol>
<p>IO 多路复用实际上就是通过一种机制，一个进程可以监视多个描 fd，一旦某个 fd 就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，目前支持 IO 多路复用的系统有 select、pselect、poll、epoll，但它们本质上都是同步 IO。</p>
<p>在 Linux 网络编程中，最初是选用 select 做轮询和网络事件通知，然而 select 的一些固有缺陷导致了它的应用受到了很大的限制，最终 Linux 选择 epoll。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 函数监视的 fd 分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后select 函数会阻塞，直到有 fd 就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当select函数返回后，可以通过遍历 fdset，来找到就绪的 fd。</p>
<p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一个最大的缺陷就是单个进程对打开的 fd 是有一定限制的，它由 <code>FD_SETSIZE</code> 限制，默认值是1024，如果修改的话，就需要重新编译内核，不过这会带来网络效率的下降。</p>
<p>select 和 poll 另一个缺陷就是随着 fd 数目的增加，可能只有很少一部分 socket 是活跃的，但是 select/poll 每次调用时都会线性扫描全部的集合，导致效率呈现线性的下降。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样以下两个缺点：</p>
<ol>
<li>大量的 fd 的数组被整体复制于用户态和内核地址空间之间；</li>
<li>poll 还有一个特点是【水平触发】，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd；</li>
<li>fd 增加时，线性扫描导致性能下降。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 变为就绪态，并且只会通知一次。还有一个特点是，epoll 使用【事件】的就绪通知方式，通过 <code>epoll_ctl</code> 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，<code>epoll_wait</code> 便可以收到通知。</p>
<p>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，它支持的 fd 上限受操作系统最大文件句柄数；</li>
<li>效率提升，不是轮询的方式，不会随着 fd 数目的增加效率下降。epoll 只会对【活跃】的 socket 进行操作，这是因为在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的，只有【活跃】的 socket 才会主动的去调用 callback 函数，其他 idle 状态的 socket 则不会。epoll 的性能不会受 fd 总数的限制。</li>
<li>select/poll 都需要内核把 fd 消息通知给用户空间，而 epoll 是通过内核和用户空间 <code>mmap</code> 同一块内存实现。</li>
</ol>
<p>epoll 对 fd 的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT 模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件，下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件；</li>
<li>ET 模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件，如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h3 id="三种模型的区别"><a href="#三种模型的区别" class="headerlink" title="三种模型的区别"></a>三种模型的区别</h3><table>
<thead>
<tr>
<th>类别</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持的最大连接数</td>
<td>由 <code>FD_SETSIZE</code> 限制</td>
<td>基于链表存储，没有限制</td>
<td>受系统最大句柄数限制</td>
</tr>
<tr>
<td>fd 剧增的影响</td>
<td>线性扫描 fd 导致性能很低</td>
<td>同 select</td>
<td>基于 fd 上 callback 实现，没有性能下降的问题</td>
</tr>
<tr>
<td>消息传递机制</td>
<td>内核需要将消息传递到用户空间，需要内核拷贝</td>
<td>同 select</td>
<td>epoll 通过内核与用户空间共享内存来实现</td>
</tr>
</tbody>
</table>
<p>介绍完 IO 多路复用之后，后续我们看一下 Java 网络编程中的 NIO 模型及其背后的实现机制。</p>
<hr>
<p>参考</p>
<ul>
<li>《Netty 权威指南》</li>
<li><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间，进程上下文与中断上下文【总结】</a></li>
<li><a href="http://www.jianshu.com/p/486b0965c296" target="_blank" rel="external">聊聊 Linux 中的五种 IO 模型</a></li>
<li><a href="http://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="external">聊聊IO多路复用之select、poll、epoll详解</a></li>
<li><a href="http://www.jianshu.com/p/2461535c38f3" target="_blank" rel="external">高性能Server—Reactor模型</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段在看 Kafka 的网络模型时，遇到了很多 Java NIO 的内容，在学习 Java NIO 的过程中，发现需要把 UNIX 的这几种网络 IO 模型以及 Linux 的 IO 多路复用理解清楚，才能更好地理解 Java NIO，本文就是在学习 UNIX 的五种网络 
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 topic 创建过程（三）</title>
    <link href="http://matt33.com/2017/07/21/kafka-topic-create/"/>
    <id>http://matt33.com/2017/07/21/kafka-topic-create/</id>
    <published>2017-07-21T15:49:03.000Z</published>
    <updated>2017-07-21T15:42:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 Kafka 源码解析的第三篇，主要讲述一个 topic 的创建过程，从 topic 是如何创建到 topic 真正创建成功的中间详细过程，文章主要内容可以分为以下几个部分：</p>
<ol>
<li>topic 是如何创建的？<ul>
<li>命令行创建；</li>
<li>Producer 发送数据时，自动创建；</li>
</ul>
</li>
<li>topic 创建时，replicas 是如何分配的？<ul>
<li>指定 replicas 的分配；</li>
<li>自动 replicas 分配；</li>
</ul>
</li>
<li>replicas 更新到 zk 后，底层如何创建一个 topic？<ul>
<li>创建 Partition 对象及状态更新；</li>
<li>创建 Partition 的 replica 对象及状态更新。</li>
</ul>
</li>
</ol>
<p>一个 topic 的完整创建过程如下图所示（以 topic 的 replicas 自动创建，且 broker 没有机架感知为例）</p>
<p><img src="/images/kafka/create_topic.png" alt="Topic 完整创建过程"></p>
<p>上图只是列出一些主要的方法调用，具体内容下面会详细讲述（在看下面的内容时，最后配合上面这张图来看）。</p>
<h2 id="topic-介绍"><a href="#topic-介绍" class="headerlink" title="topic 介绍"></a>topic 介绍</h2><p>topic 是 Kafka 中的一个消息队列的标识，也可以认为是消息队列的一个 id，用于区分不同的消息队列，一个 topic 由多个 partition 组成，这些 partition 是通常是分布在不同的多台 Broker 上的，为了保证数据的可靠性，一个 partition 又会设置为多个副本（replica），通常会设置两副本或三副本。如下图所示，这个一个名为『topic』的 topic，它由三个 partition 组成，两副本，假设 Kafka 集群有三台 Broker（replica 0_1 代表 partition 0 的第一个副本）。</p>
<p><img src="/images/kafka/topic-replicas.png" alt="Kafka Topic 的组成"></p>
<p>在设置副本时，副本数是必须大于集群的 Broker 数的，副本只有设置在不同的机器上才有作用。</p>
<h2 id="topic-如何创建"><a href="#topic-如何创建" class="headerlink" title="topic 如何创建"></a>topic 如何创建</h2><p>topic 在创建时有两种方式：</p>
<ol>
<li>通过 <code>kafka-topics.sh</code> 创建一个 topic，可以设置相应的副本数让 Server 端自动进行 replica 分配，也可以直接指定手动 replica 的分配；</li>
<li>Server 端如果 <code>auto.create.topics.enable</code> 设置为 true 时，那么当 Producer 向一个不存在的 topic 发送数据时，该 topic 同样会被创建出来，此时，副本数默认是1。</li>
</ol>
<p>下面看一下这两种方式的底层实现。</p>
<h3 id="kafka-topics-sh-创建-topic"><a href="#kafka-topics-sh-创建-topic" class="headerlink" title="kafka-topics.sh 创建 topic"></a>kafka-topics.sh 创建 topic</h3><p>在 Kafka 的安装目录下，通过下面这条命令可以创建一个 partition 为3，replica 为2的 topic（test）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --partitions 3 --replication-factor 2</div></pre></td></tr></table></figure>
<p><code>kafka-topics.sh</code> 实际上是调用 <code>kafka.admin.TopicCommand</code> 的方法来创建 topic，其实现如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 创建 topic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>, opts: <span class="type">TopicCommandOptions</span>) &#123;</div><div class="line">  <span class="keyword">val</span> topic = opts.options.valueOf(opts.topicOpt)</div><div class="line">  <span class="keyword">val</span> configs = parseTopicConfigsToBeAdded(opts)</div><div class="line">  <span class="keyword">val</span> ifNotExists = opts.options.has(opts.ifNotExistsOpt)</div><div class="line">  <span class="keyword">if</span> (<span class="type">Topic</span>.hasCollisionChars(topic))</div><div class="line">    println(<span class="string">"WARNING: Due to limitations in metric names, topics with a period ('.') or underscore ('_') could collide. To avoid issues it is best to use either, but not both."</span>)</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (opts.options.has(opts.replicaAssignmentOpt)) &#123;<span class="comment">//note: 指定 replica 的分配,直接向 zk 更新即可</span></div><div class="line">      <span class="keyword">val</span> assignment = parseReplicaAssignment(opts.options.valueOf(opts.replicaAssignmentOpt))</div><div class="line">      <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, assignment, configs, update = <span class="literal">false</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//note: 未指定 replica 的分配,调用自动分配算法进行分配</span></div><div class="line">      <span class="type">CommandLineUtils</span>.checkRequiredArgs(opts.parser, opts.options, opts.partitionsOpt, opts.replicationFactorOpt)</div><div class="line">      <span class="keyword">val</span> partitions = opts.options.valueOf(opts.partitionsOpt).intValue</div><div class="line">      <span class="keyword">val</span> replicas = opts.options.valueOf(opts.replicationFactorOpt).intValue</div><div class="line">      <span class="keyword">val</span> rackAwareMode = <span class="keyword">if</span> (opts.options.has(opts.disableRackAware)) <span class="type">RackAwareMode</span>.<span class="type">Disabled</span></div><div class="line">                          <span class="keyword">else</span> <span class="type">RackAwareMode</span>.<span class="type">Enforced</span></div><div class="line">      <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, partitions, replicas, configs, rackAwareMode)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Created topic \"%s\"."</span>.format(topic))</div><div class="line">  &#125; <span class="keyword">catch</span>  &#123;</div><div class="line">    <span class="keyword">case</span> e: <span class="type">TopicExistsException</span> =&gt; <span class="keyword">if</span> (!ifNotExists) <span class="keyword">throw</span> e</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果指定了 partition 各个 replica 的分布，那么将 partition replicas 的结果验证之后直接更新到 zk 上，验证的 replicas 的代码是在 <code>parseReplicaAssignment</code> 中实现的，如下所示</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseReplicaAssignment</span></span>(replicaAssignmentList: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">  <span class="keyword">val</span> partitionList = replicaAssignmentList.split(<span class="string">","</span>)</div><div class="line">  <span class="keyword">val</span> ret = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]]()</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until partitionList.size) &#123;</div><div class="line">    <span class="keyword">val</span> brokerList = partitionList(i).split(<span class="string">":"</span>).map(s =&gt; s.trim().toInt)</div><div class="line">    <span class="keyword">val</span> duplicateBrokers = <span class="type">CoreUtils</span>.duplicates(brokerList)</div><div class="line">    <span class="keyword">if</span> (duplicateBrokers.nonEmpty)<span class="comment">//note: 同一个 partition 对应的 replica 是不能相同的</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminCommandFailedException</span>(<span class="string">"Partition replica lists may not contain duplicate entries: %s"</span>.format(duplicateBrokers.mkString(<span class="string">","</span>)))</div><div class="line">    ret.put(i, brokerList.toList)</div><div class="line">    <span class="keyword">if</span> (ret(i).size != ret(<span class="number">0</span>).size)<span class="comment">//note: 同一个 topic 的副本数必须相同</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Partition "</span> + i + <span class="string">" has different replication factor: "</span> + brokerList)</div><div class="line">  &#125;</div><div class="line">  ret.toMap</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有指定 parittion replicas 分配的话，将会调用 <code>AdminUtils.createTopic</code> 方法创建 topic，这个方法首先会检测当前的 Kafka 集群是否机架感知，如果有的话先获取 Broker 的机架信息，接着再使用 Replica 自动分配算法来分配 Partition 的 replica，最后就跟指定 replica 方式一样，将 replicas 的结果更新到 zk 中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>,</div><div class="line">                topic: <span class="type">String</span>,</div><div class="line">                partitions: <span class="type">Int</span>,</div><div class="line">                replicationFactor: <span class="type">Int</span>,</div><div class="line">                topicConfig: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>,</div><div class="line">                rackAwareMode: <span class="type">RackAwareMode</span> = <span class="type">RackAwareMode</span>.<span class="type">Enforced</span>) &#123;</div><div class="line">  <span class="keyword">val</span> brokerMetadatas = getBrokerMetadatas(zkUtils, rackAwareMode)<span class="comment">//note: 有机架感知的情况下,返回 Broker 与机架之间的信息</span></div><div class="line">  <span class="keyword">val</span> replicaAssignment = <span class="type">AdminUtils</span>.assignReplicasToBrokers(brokerMetadatas, partitions, replicationFactor)<span class="comment">//note: 获取 partiiton 的 replicas 分配</span></div><div class="line">  <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, replicaAssignment, topicConfig)<span class="comment">//note: 更新到 zk 上</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Producer-创建-topic"><a href="#Producer-创建-topic" class="headerlink" title="Producer 创建 topic"></a>Producer 创建 topic</h3><p>只有当 Server 端的 <code>auto.create.topics.enable</code> 设置为 true 时，Producer 向一个不存在的 topic 发送数据，该 topic 才会被自动创建。</p>
<p>当 Producer 在向一个 topic 发送 produce 请求前，会先通过发送 Metadata 请求来获取这个 topic 的 metadata。Server 端在处理 Metadata 请求时，如果发现要获取 metadata 的 topic 不存在但 Server 允许 producer 自动创建 topic 的话（如果开启权限时，要求 Producer 需要有相应权限：对 topic 有 Describe 权限，并且对当前集群有 Create 权限），那么 Server 将会自动创建该 topic.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 获取 topic 的 metadata 信息</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getTopicMetadata</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], listenerName: <span class="type">ListenerName</span>, errorUnavailableEndpoints: <span class="type">Boolean</span>): <span class="type">Seq</span>[<span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> topicResponses = metadataCache.getTopicMetadata(topics, listenerName, errorUnavailableEndpoints)</div><div class="line">  <span class="keyword">if</span> (topics.isEmpty || topicResponses.size == topics.size) &#123;</div><div class="line">    topicResponses</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> nonExistentTopics = topics -- topicResponses.map(_.topic).toSet<span class="comment">//note: 集群上暂时不存在的 topic 列表</span></div><div class="line">    <span class="keyword">val</span> responsesForNonExistentTopics = nonExistentTopics.map &#123; topic =&gt;</div><div class="line">      <span class="keyword">if</span> (topic == <span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>) &#123;</div><div class="line">        createGroupMetadataTopic()</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.autoCreateTopicsEnable) &#123;<span class="comment">//note: auto.create.topics.enable 为 true 时,即允许自动创建 topic</span></div><div class="line">        createTopic(topic, config.numPartitions, config.defaultReplicationFactor)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>, topic, <span class="literal">false</span>,</div><div class="line">          java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    topicResponses ++ responsesForNonExistentTopics</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>createTopic</code> 还是调用了 <code>AdminUtils.createTopic</code> 来创建 topic，与命令行创建的底层实现是一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(topic: <span class="type">String</span>,</div><div class="line">                        numPartitions: <span class="type">Int</span>,</div><div class="line">                        replicationFactor: <span class="type">Int</span>,</div><div class="line">                        properties: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>()): <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span> = &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//note: 还是调用 AdminUtils 命令创建 topic</span></div><div class="line">    <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, numPartitions, replicationFactor, properties, <span class="type">RackAwareMode</span>.<span class="type">Safe</span>)</div><div class="line">    info(<span class="string">"Auto creation of topic %s with %d partitions and replication factor %d is successful"</span></div><div class="line">      .format(topic, numPartitions, replicationFactor))</div><div class="line">    <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">      java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> _: <span class="type">TopicExistsException</span> =&gt; <span class="comment">// let it go, possibly another broker created this topic</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">    <span class="keyword">case</span> ex: <span class="type">Throwable</span>  =&gt; <span class="comment">// Catch all to prevent unhandled errors</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.forException(ex), topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="replica-如何分配"><a href="#replica-如何分配" class="headerlink" title="replica 如何分配"></a>replica 如何分配</h2><p>通过前面的内容，可以看到，无论使用哪种方式，最后都是通过 <code>AdminUtils.createOrUpdateTopicPartitionAssignmentPathInZK()</code> 将 topic 的 Partition replicas 的更新到 zk 上，这中间关键的一点在于：Partition 的 replicas 是如何分配的。在创建时，我们既可以指定相应 replicas 分配，也可以使用默认的算法自动分配。</p>
<h3 id="创建时指定-replicas-分配"><a href="#创建时指定-replicas-分配" class="headerlink" title="创建时指定 replicas 分配"></a>创建时指定 replicas 分配</h3><p>在创建 topic 时，可以通过以下形式直接指定 topic 的 replica</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --replica-assignment 1:2,3:4,5:6</div></pre></td></tr></table></figure>
<p>该 topic 有三个 partition，其中，partition 0 的 replica 分布在1和2上，partition 1 的 replica 分布在3和4上，partition 3 的 replica 分布在4和5上。</p>
<p>这样情况下，在创建 topic 时，Server 端会将该 replica 分布直接更新到 zk 上。</p>
<h3 id="replicas-自动分配算法"><a href="#replicas-自动分配算法" class="headerlink" title="replicas 自动分配算法"></a>replicas 自动分配算法</h3><p>在创建 topic 时，Server 通过 <code>AdminUtils.assignReplicasToBrokers()</code> 方法来获取该 topic partition 的 replicas 分配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 副本分配时,有三个原则:</div><div class="line">   * 1. 将副本平均分布在所有的 Broker 上;</div><div class="line">   * 2. partition 的多个副本应该分配在不同的 Broker 上;</div><div class="line">   * 3. 如果所有的 Broker 有机架信息的话, partition 的副本应该分配到不同的机架上。</div><div class="line">   *</div><div class="line">   * 为实现上面的目标,在没有机架感知的情况下，应该按照下面两个原则分配 replica:</div><div class="line">   * 1. 从 broker.list 随机选择一个 Broker,使用 round-robin 算法分配每个 partition 的第一个副本;</div><div class="line">   * 2. 对于这个 partition 的其他副本,逐渐增加 Broker.id 来选择 replica 的分配。</div><div class="line">   *</div><div class="line">   * @param brokerMetadatas</div><div class="line">   * @param nPartitions</div><div class="line">   * @param replicationFactor</div><div class="line">   * @param fixedStartIndex</div><div class="line">   * @param startPartitionId</div><div class="line">   * @return</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokers</span></span>(brokerMetadatas: <span class="type">Seq</span>[<span class="type">BrokerMetadata</span>],</div><div class="line">                             nPartitions: <span class="type">Int</span>,</div><div class="line">                             replicationFactor: <span class="type">Int</span>,</div><div class="line">                             fixedStartIndex: <span class="type">Int</span> = <span class="number">-1</span>,</div><div class="line">                             startPartitionId: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">if</span> (nPartitions &lt;= <span class="number">0</span>) <span class="comment">// note: 要增加的 partition 数需要大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidPartitionsException</span>(<span class="string">"number of partitions must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &lt;= <span class="number">0</span>) <span class="comment">//note: replicas 应该大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">"replication factor must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &gt; brokerMetadatas.size) <span class="comment">//note: replicas 超过了 broker 数</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">s"replication factor: <span class="subst">$replicationFactor</span> larger than available brokers: <span class="subst">$&#123;brokerMetadatas.size&#125;</span>"</span>)</div><div class="line">   <span class="keyword">if</span> (brokerMetadatas.forall(_.rack.isEmpty))<span class="comment">//note: 没有开启机架感知</span></div><div class="line">     assignReplicasToBrokersRackUnaware(nPartitions, replicationFactor, brokerMetadatas.map(_.id), fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   <span class="keyword">else</span> &#123; <span class="comment">//note: 机架感知的情况</span></div><div class="line">     <span class="keyword">if</span> (brokerMetadatas.exists(_.rack.isEmpty)) <span class="comment">//note: 并不是所有的机架都有机架感知</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Not all brokers have rack information for replica rack aware assignment"</span>)</div><div class="line">     assignReplicasToBrokersRackAware(nPartitions, replicationFactor, brokerMetadatas, fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里没有开启机架感知模式来介绍 topic partition replicas 的分配情况，其分配算法主要是 <code>assignReplicasToBrokersRackUnaware()</code> 方法中实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: partition 分配</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokersRackUnaware</span></span>(nPartitions: <span class="type">Int</span>,</div><div class="line">                                                replicationFactor: <span class="type">Int</span>,</div><div class="line">                                                brokerList: <span class="type">Seq</span>[<span class="type">Int</span>],</div><div class="line">                                                fixedStartIndex: <span class="type">Int</span>,</div><div class="line">                                                startPartitionId: <span class="type">Int</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">val</span> ret = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]]()</div><div class="line">   <span class="keyword">val</span> brokerArray = brokerList.toArray</div><div class="line">   <span class="keyword">val</span> startIndex = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length) <span class="comment">//note: 随机选择一个Broker</span></div><div class="line">   <span class="keyword">var</span> currentPartitionId = math.max(<span class="number">0</span>, startPartitionId) <span class="comment">//note: 开始增加的第一个 partition</span></div><div class="line">   <span class="keyword">var</span> nextReplicaShift = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length)</div><div class="line">   <span class="keyword">for</span> (_ &lt;- <span class="number">0</span> until nPartitions) &#123; <span class="comment">//note: 对每个 partition 进行分配</span></div><div class="line">     <span class="keyword">if</span> (currentPartitionId &gt; <span class="number">0</span> &amp;&amp; (currentPartitionId % brokerArray.length == <span class="number">0</span>))</div><div class="line">       nextReplicaShift += <span class="number">1</span> <span class="comment">//note: 防止 partition 过大时,其中某些 partition 的分配（leader、follower）完全一样</span></div><div class="line">     <span class="keyword">val</span> firstReplicaIndex = (currentPartitionId + startIndex) % brokerArray.length <span class="comment">//note: partition 的第一个 replica</span></div><div class="line">     <span class="keyword">val</span> replicaBuffer = mutable.<span class="type">ArrayBuffer</span>(brokerArray(firstReplicaIndex))</div><div class="line">     <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until replicationFactor - <span class="number">1</span>) <span class="comment">//note: 其他 replica 的分配</span></div><div class="line">       replicaBuffer += brokerArray(replicaIndex(firstReplicaIndex, nextReplicaShift, j, brokerArray.length))</div><div class="line">     ret.put(currentPartitionId, replicaBuffer)</div><div class="line">     currentPartitionId += <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   ret</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: 为 partition 设置完第一个 replica 后,其他 replica 分配的计算</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">replicaIndex</span></span>(firstReplicaIndex: <span class="type">Int</span>, secondReplicaShift: <span class="type">Int</span>, replicaIndex: <span class="type">Int</span>, nBrokers: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">   <span class="keyword">val</span> shift = <span class="number">1</span> + (secondReplicaShift + replicaIndex) % (nBrokers - <span class="number">1</span>)<span class="comment">//note: 在 secondReplicaShift 的基础上增加一个 replicaIndex</span></div><div class="line">   (firstReplicaIndex + shift) % nBrokers</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里举一个栗子，假设一个 Kafka 集群有5个节点，新建的 topic 有10个 partition，并且是三副本，假设最初随机选择的 <code>startIndex</code> 和 <code>nextReplicaShift</code> 节点均为0</p>
<ul>
<li>partition 为0时，那第一副本在 <code>(0+0)%5=0</code>，第二个副本在 <code>(0+(1+(0+0)%5)))%5=1</code>，第三副本在 <code>(0+(1+(0+1)%5)))%5=2</code>；</li>
<li>partition 为2时，那第一副本在 <code>(0+2)%5=2</code>，第二个副本在 <code>(2+(1+(0+0)%5)))%5=3</code>，第三副本在 <code>(2+(1+(0+1)%5)))%5=4</code>；</li>
<li>partition 为5时，那第一副本在 <code>(0+5)%5=0</code>，第二个副本在 <code>(0+(2+(0+0)%5)))%5=2</code>，第三副本在 <code>(0+(2+(0+1)%5)))%5=3</code>（partition 数是 Broker 数一倍时，<code>nextReplicaShift</code> 值会增加1）；</li>
<li>partition 为8时，那第一副本在 <code>(0+8)%5=3</code>，第二个副本在 <code>(3+(2+(0+0)%5)))%5=0</code>，第三副本在 <code>(3+(2+(0+1)%5)))%5=1</code>。</li>
</ul>
<p>分配如下表所示：</p>
<table>
<thead>
<tr>
<th>broker-0</th>
<th>broker-1</th>
<th>broker-2</th>
<th>broker-3</th>
<th>broker-4</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>p4</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p3</td>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>(3nd replica)</td>
</tr>
<tr>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>(3nd replica)</td>
</tr>
</tbody>
</table>
<h2 id="replicas-更新到-zk-后触发的操作"><a href="#replicas-更新到-zk-后触发的操作" class="headerlink" title="replicas 更新到 zk 后触发的操作"></a>replicas 更新到 zk 后触发的操作</h2><p>这一部分的内容是由 Kafka Controller 来控制的（Kafka Controller 将会在后续文章中讲解），当一个 topic 的 replicas 更新到 zk 上后，监控 zk 这个目录的方法会被触发（<code>TopicChangeListener.doHandleChildChange()</code>方法），可以配合文章第一张图来看。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 zk 上 topic 节点上有变更时,这个方法就会调用</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doHandleChildChange</span></span>(parentPath: <span class="type">String</span>, children: <span class="type">Seq</span>[<span class="type">String</span>]) &#123;</div><div class="line">      inLock(controllerContext.controllerLock) &#123;</div><div class="line">        <span class="keyword">if</span> (hasStarted.get) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">val</span> currentChildren = &#123;</div><div class="line">              debug(<span class="string">"Topic change listener fired for path %s with children %s"</span>.format(parentPath, children.mkString(<span class="string">","</span>)))</div><div class="line">              children.toSet</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">val</span> newTopics = currentChildren -- controllerContext.allTopics<span class="comment">//note: 新创建的 topic 列表</span></div><div class="line">            <span class="keyword">val</span> deletedTopics = controllerContext.allTopics -- currentChildren<span class="comment">//note: 已经删除的 topic 列表</span></div><div class="line">            controllerContext.allTopics = currentChildren</div><div class="line"></div><div class="line">            <span class="comment">//note: 新创建 topic 对应的 partition 列表</span></div><div class="line">            <span class="keyword">val</span> addedPartitionReplicaAssignment = zkUtils.getReplicaAssignmentForTopics(newTopics.toSeq)</div><div class="line">            controllerContext.partitionReplicaAssignment = controllerContext.partitionReplicaAssignment.filter(p =&gt;</div><div class="line">              !deletedTopics.contains(p._1.topic))<span class="comment">//note: 把已经删除 partition 过滤掉</span></div><div class="line">            controllerContext.partitionReplicaAssignment.++=(addedPartitionReplicaAssignment)<span class="comment">//note: 将新增的 tp-replicas 更新到缓存中</span></div><div class="line">            info(<span class="string">"New topics: [%s], deleted topics: [%s], new partition replica assignment [%s]"</span>.format(newTopics,</div><div class="line">              deletedTopics, addedPartitionReplicaAssignment))</div><div class="line">            <span class="keyword">if</span> (newTopics.nonEmpty)<span class="comment">//note: 处理新建的 topic</span></div><div class="line">              controller.onNewTopicCreation(newTopics, addedPartitionReplicaAssignment.keySet)</div><div class="line">          &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while handling new topic"</span>, e)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法主要做了以下内容：</p>
<ul>
<li>获取 zk 的 topic 变更信息，得到新创建的 topic 列表（<code>newTopics</code>）以及被删除的 topic 列表（<code>deletedTopics</code>）；</li>
<li>将 <code>deletedTopics</code> 的 replicas 从 controller 的缓存中删除，并将新增 topic 的 replicas 更新到 controller 的缓存中；</li>
<li>调用 KafkaController 的 <code>onNewTopicCreation()</code> 创建 partition 和 replica 对象。</li>
</ul>
<p>KafkaController 中 <code>onNewTopicCreation()</code> 方法先对这些 topic 注册 <code>PartitionChangeListener</code>，然后再调用 <code>onNewPartitionCreation()</code> 方法创建 partition 和 replicas 的实例对象，<strong>topic 创建的主要实现是在 KafkaController <code>onNewPartitionCreation()</code> 这个方法中</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition state machine 监控到有新 topic 或 partition 时,这个方法将会被调用</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">   * 1. 注册 partition change listener;</div><div class="line">   * 2. 触发 the new partition callback,也即是 onNewPartitionCreation()</div><div class="line">   * 3. 发送 metadata 请求给所有的 Broker</div><div class="line">   * @param topics</div><div class="line">   * @param newPartitions</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewTopicCreation</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New topic creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   <span class="comment">// subscribe to partition changes</span></div><div class="line">   topics.foreach(topic =&gt; partitionStateMachine.registerPartitionChangeListener(topic))</div><div class="line">   onNewPartitionCreation(newPartitions)</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: topic 变化时,这个方法将会被调用</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 partition 置为 NewPartition 状态; 2.从 NewPartition 改为 OnlinePartition 状态</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 Replica 置为 NewReplica 状态; 2.从 NewReplica 改为 OnlineReplica 状态</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewPartitionCreation</span></span>(newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New partition creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">NewPartition</span>)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">NewReplica</span>)</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">OnlinePartition</span>, offlinePartitionSelector)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">OnlineReplica</span>)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在详细介绍这四个方法的调用之前，先简单详述一下 Partition 和 Replica 状态机的变化。</p>
<h3 id="Partition-状态机"><a href="#Partition-状态机" class="headerlink" title="Partition 状态机"></a>Partition 状态机</h3><p>关于 Partition 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/PartitionStateMachine.scala" target="_blank" rel="external">PartitionStateMachine</a>，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/partition_stat.png" alt="Partition 状态机"></p>
<p>一个 Partition 对象有四种状态：</p>
<ol>
<li><code>NonExistentPartition</code>：这个 partition 不存在；</li>
<li><code>NewPartition</code>：这个 partition 刚创建，有对应的 replicas，但还没有 leader 和 isr；</li>
<li><code>OnlinePartition</code>：这个 partition 的 leader 已经选举出来了，处理正常的工作状态；</li>
<li><code>OfflinePartition</code>：partition 的 leader 挂了。</li>
</ol>
<p>partition 只有在 <code>OnlinePartition</code> 这个状态时，才是可用状态。</p>
<h3 id="Replica-状态机"><a href="#Replica-状态机" class="headerlink" title="Replica 状态机"></a>Replica 状态机</h3><p>关于 Replica 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/ReplicaStateMachine.scala" target="_blank" rel="external">ReplicaStateMachine</a>，，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/replica_stat.png" alt="Replica 状态机"></p>
<p>Replica 对象有七种状态，中文解释的比较难以理解，直接上原文对这几种状态的解释。</p>
<ol>
<li><code>NewReplica</code>：The controller can create new replicas during partition reassignment. In this state, a replica can only get become follower state change request.</li>
<li><code>OnlineReplica</code>：Once a replica is started and part of the assigned replicas for its partition, it is in this state. In this state, it can get either become leader or become follower state change requests.</li>
<li><code>OfflineReplica</code>：If a replica dies, it moves to this state. This happens when the broker hosting the replica is down.</li>
<li><code>ReplicaDeletionStarted</code>：If replica deletion starts, it is moved to this state.</li>
<li><code>ReplicaDeletionSuccessful</code>：If replica responds with no error code in response to a delete replica request, it is moved to this state.</li>
<li><code>ReplicaDeletionIneligible</code>：If replica deletion fails, it is moved to this state.</li>
<li><code>NonExistentReplica</code>：If a replica is deleted successfully, it is moved to this state.</li>
</ol>
<h3 id="onNewPartitionCreation-详解"><a href="#onNewPartitionCreation-详解" class="headerlink" title="onNewPartitionCreation() 详解"></a><code>onNewPartitionCreation()</code> 详解</h3><p>这个方法有以下四步操作：</p>
<ol>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, NewPartition)</code>： 创建 Partition 对象，并将其状态置为 <code>NewPartition</code> 状态</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), NewReplica)</code>：创建 Replica 对象，并将其状态置为 <code>NewReplica</code> 状态；</li>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, OnlinePartition, offlinePartitionSelector)</code>：将 partition 对象从 <code>NewPartition</code> 改为 <code>OnlinePartition</code> 状态；</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), OnlineReplica)</code>：将 Replica 对象从 <code>NewReplica</code> 改为 <code>OnlineReplica</code> 状态。</li>
</ol>
<h4 id="partitionStateMachine-gt-NewPartition"><a href="#partitionStateMachine-gt-NewPartition" class="headerlink" title="partitionStateMachine &gt; NewPartition"></a>partitionStateMachine &gt; NewPartition</h4><p>这部分的作用是，创建分区对象，并将其状态设置为 <code>NewPartition</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">  <span class="comment">//note: 新建一个 partition</span></div><div class="line">  assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NonExistentPartition</span>), <span class="type">NewPartition</span>)</div><div class="line">  partitionState.put(topicAndPartition, <span class="type">NewPartition</span>) <span class="comment">//note: 缓存 partition 的状态</span></div><div class="line">  <span class="keyword">val</span> assignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition).mkString(<span class="string">","</span>)</div><div class="line">  stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed partition %s state from %s to %s with assigned replicas %s"</span></div><div class="line">                            .format(controllerId, controller.epoch, topicAndPartition, currState, targetState,</div><div class="line">                                    assignedReplicas))</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-NewReplica"><a href="#replicaStateMachine-gt-NewReplica" class="headerlink" title="replicaStateMachine &gt; NewReplica"></a>replicaStateMachine &gt; NewReplica</h4><p>这部分是为每个 Partition 创建对应的 replica 对象，并将其状态设置为 <code>NewReplica</code>，参照状态机的变化图更好理解。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica, <span class="type">List</span>(<span class="type">NonExistentReplica</span>), targetState)  <span class="comment">//note: 验证</span></div><div class="line">          <span class="comment">// start replica as a follower to the current leader for its partition</span></div><div class="line">          <span class="keyword">val</span> leaderIsrAndControllerEpochOpt = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topic, partition)</div><div class="line">          leaderIsrAndControllerEpochOpt <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">Some</span>(leaderIsrAndControllerEpoch) =&gt;</div><div class="line">              <span class="keyword">if</span>(leaderIsrAndControllerEpoch.leaderAndIsr.leader == replicaId)<span class="comment">//note: 这个状态的 Replica 不能作为 leader</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(<span class="string">"Replica %d for partition %s cannot be moved to NewReplica"</span></div><div class="line">                  .format(replicaId, topicAndPartition) + <span class="string">"state as it is being requested to become leader"</span>)</div><div class="line">              <span class="comment">//note: 向所有 replicaId 发送 LeaderAndIsr 请求,这个方法同时也会向所有的 broker 发送 updateMeta 请求</span></div><div class="line">              brokerRequestBatch.addLeaderAndIsrRequestForBrokers(<span class="type">List</span>(replicaId),</div><div class="line">                                                                  topic, partition, leaderIsrAndControllerEpoch,</div><div class="line">                                                                  replicaAssignment)</div><div class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// new leader request will be sent to this replica when one gets elected</span></div></pre></td></tr></table></figure>
<h4 id="partitionStateMachine-gt-OnlinePartition"><a href="#partitionStateMachine-gt-OnlinePartition" class="headerlink" title="partitionStateMachine &gt; OnlinePartition"></a>partitionStateMachine &gt; OnlinePartition</h4><p>这个方法的主要的作用是将 partition 对象的状态由 <code>NewPartition</code> 设置为 <code>OnlinePartition</code>，从状态机图中可以看到，会有以下两步操作：</p>
<ol>
<li>初始化 leader 和 isr，replicas 中的第一个 replica 将作为 leader，所有 replica 作为 isr，并把 leader 和 isr 信息更新到 zk；</li>
<li>发送 LeaderAndIsr 请求给所有的 replica，发送 UpdateMetadata 给所有 Broker。</li>
</ol>
<p>具体操作如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// post: partition has been assigned replicas</span></div><div class="line">       <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt;</div><div class="line">         assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NewPartition</span>, <span class="type">OnlinePartition</span>, <span class="type">OfflinePartition</span>), <span class="type">OnlinePartition</span>)</div><div class="line">         partitionState(topicAndPartition) <span class="keyword">match</span> &#123;</div><div class="line">           <span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">             <span class="comment">// initialize leader and isr path for new partition</span></div><div class="line">             initializeLeaderAndIsrForPartition(topicAndPartition) <span class="comment">//note: 为新建的 partition 初始化 leader 和 isr</span></div><div class="line">           <span class="keyword">case</span> <span class="type">OfflinePartition</span> =&gt;</div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt; <span class="comment">// invoked when the leader needs to be re-elected</span></div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> _ =&gt; <span class="comment">// should never come here since illegal previous states are checked above</span></div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<p>实际的操作是在 <code>initializeLeaderAndIsrForPartition()</code> 方法中完成，这个方法是当 partition 对象的状态由 NewPartition 变为 OnlinePartition 时触发的，用来初始化该 partition 的 leader 和 isr。简单来说，就是选取 Replicas 中的第一个 Replica 作为 leader，所有的 Replica 作为 isr，最后调用 <code>brokerRequestBatch.addLeaderAndIsrRequestForBrokers</code> 向所有 replicaId 发送 LeaderAndIsr 请求以及向所有的 broker 发送 UpdateMetadata 请求（关于 Server 对 LeaderAndIsr 和 UpdateMetadata 请求的处理将会后续文章中讲述）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition 状态由 NewPartition 变为 OnlinePartition 时,将触发这一方法,用来初始化 partition 的 leader 和 isr</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initializeLeaderAndIsrForPartition</span></span>(topicAndPartition: <span class="type">TopicAndPartition</span>) &#123;</div><div class="line">   <span class="keyword">val</span> replicaAssignment = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">   <span class="keyword">val</span> liveAssignedReplicas = replicaAssignment.filter(r =&gt; controllerContext.liveBrokerIds.contains(r))</div><div class="line">   liveAssignedReplicas.size <span class="keyword">match</span> &#123;</div><div class="line">     <span class="keyword">case</span> <span class="number">0</span> =&gt;</div><div class="line">       <span class="keyword">val</span> failMsg = (<span class="string">"encountered error during state change of partition %s from New to Online, assigned replicas are [%s], "</span> +</div><div class="line">                      <span class="string">"live brokers are [%s]. No assigned replica is alive."</span>)</div><div class="line">                        .format(topicAndPartition, replicaAssignment.mkString(<span class="string">","</span>), controllerContext.liveBrokerIds)</div><div class="line">       stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">     <span class="keyword">case</span> _ =&gt;</div><div class="line">       debug(<span class="string">"Live assigned replicas for partition %s are: [%s]"</span>.format(topicAndPartition, liveAssignedReplicas))</div><div class="line">       <span class="comment">// make the first replica in the list of assigned replicas, the leader</span></div><div class="line">       <span class="keyword">val</span> leader = liveAssignedReplicas.head <span class="comment">//note: replicas 中的第一个 replica 选做 leader</span></div><div class="line">       <span class="keyword">val</span> leaderIsrAndControllerEpoch = <span class="keyword">new</span> <span class="type">LeaderIsrAndControllerEpoch</span>(<span class="keyword">new</span> <span class="type">LeaderAndIsr</span>(leader, liveAssignedReplicas.toList),</div><div class="line">         controller.epoch)</div><div class="line">       debug(<span class="string">"Initializing leader and isr for partition %s to %s"</span>.format(topicAndPartition, leaderIsrAndControllerEpoch))</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         zkUtils.createPersistentPath(</div><div class="line">           getTopicPartitionLeaderAndIsrPath(topicAndPartition.topic, topicAndPartition.partition),</div><div class="line">           zkUtils.leaderAndIsrZkData(leaderIsrAndControllerEpoch.leaderAndIsr, controller.epoch))<span class="comment">//note: zk 上初始化节点信息</span></div><div class="line">         <span class="comment">// <span class="doctag">NOTE:</span> the above write can fail only if the current controller lost its zk session and the new controller</span></div><div class="line">         <span class="comment">// took over and initialized this partition. This can happen if the current controller went into a long</span></div><div class="line">         <span class="comment">// GC pause</span></div><div class="line">         controllerContext.partitionLeadershipInfo.put(topicAndPartition, leaderIsrAndControllerEpoch)</div><div class="line">         brokerRequestBatch.addLeaderAndIsrRequestForBrokers(liveAssignedReplicas, topicAndPartition.topic,</div><div class="line">           topicAndPartition.partition, leaderIsrAndControllerEpoch, replicaAssignment)<span class="comment">//note: 向 live 的 Replica 发送  LeaderAndIsr 请求</span></div><div class="line">       &#125; <span class="keyword">catch</span> &#123;</div><div class="line">         <span class="keyword">case</span> _: <span class="type">ZkNodeExistsException</span> =&gt;</div><div class="line">           <span class="comment">// read the controller epoch</span></div><div class="line">           <span class="keyword">val</span> leaderIsrAndEpoch = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topicAndPartition.topic,</div><div class="line">             topicAndPartition.partition).get</div><div class="line">           <span class="keyword">val</span> failMsg = (<span class="string">"encountered error while changing partition %s's state from New to Online since LeaderAndIsr path already "</span> +</div><div class="line">                          <span class="string">"exists with value %s and controller epoch %d"</span>)</div><div class="line">                            .format(topicAndPartition, leaderIsrAndEpoch.leaderAndIsr.toString(), leaderIsrAndEpoch.controllerEpoch)</div><div class="line">           stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-OnlineReplica"><a href="#replicaStateMachine-gt-OnlineReplica" class="headerlink" title="replicaStateMachine &gt; OnlineReplica"></a>replicaStateMachine &gt; OnlineReplica</h4><p>这一步也就是最后一步，将 Replica 对象的状态由 <code>NewReplica</code> 更新为 <code>OnlineReplica</code> 状态，这些 Replica 才真正可用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">OnlineReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica,</div><div class="line">            <span class="type">List</span>(<span class="type">NewReplica</span>, <span class="type">OnlineReplica</span>, <span class="type">OfflineReplica</span>, <span class="type">ReplicaDeletionIneligible</span>), targetState)</div><div class="line">          replicaState(partitionAndReplica) <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">              <span class="comment">// add this replica to the assigned replicas list for its partition</span></div><div class="line">              <span class="comment">//note: 向 the assigned replicas list 添加这个 replica（正常情况下这些 replicas 已经更新到 list 中了）</span></div><div class="line">              <span class="keyword">val</span> currentAssignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">              <span class="keyword">if</span>(!currentAssignedReplicas.contains(replicaId))</div><div class="line">                controllerContext.partitionReplicaAssignment.put(topicAndPartition, currentAssignedReplicas :+ replicaId)</div><div class="line">              stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed state of replica %d for partition %s from %s to %s"</span></div><div class="line">                                        .format(controllerId, controller.epoch, replicaId, topicAndPartition, currState,</div><div class="line">                                                targetState))</div></pre></td></tr></table></figure>
<p>一直到这一步，一个 topic 就才算真正被创建完成。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/huxi2b/p/5923252.html" target="_blank" rel="external">Kafka如何创建topic？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 Kafka 源码解析的第三篇，主要讲述一个 topic 的创建过程，从 topic 是如何创建到 topic 真正创建成功的中间详细过程，文章主要内容可以分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;topic 是如何创建的？&lt;ul&gt;
&lt;li&gt;命令行创建；&lt;/li&gt;
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用的一些系统命令</title>
    <link href="http://matt33.com/2017/07/16/linux-system-cmd/"/>
    <id>http://matt33.com/2017/07/16/linux-system-cmd/</id>
    <published>2017-07-16T02:31:47.000Z</published>
    <updated>2017-07-16T02:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章的内容，基本来自<a href="http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">每日一个 linux 命令</a>，选取了几个在工作常用的命令，有：top、iostat、netstat 、free 和 ps，本文的主要目的是在学习这几条命令的过程中，简单做一些记录，便于日后工作中更加熟练地使用这些命令。</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>top 命令是 Linux 下面实时展示系统运行情况的一个命令，它也可以显示当前每个任务的系统信息。在对系统的性能进行分析，它是一个最常用的命令。</p>
<h2 id="命令常用参数"><a href="#命令常用参数" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><ol>
<li>命令格式：<ul>
<li>top [参数]</li>
</ul>
</li>
<li>命令功能：<ul>
<li>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</li>
</ul>
</li>
<li>命令参数：<ul>
<li><code>-b</code>: 批处理</li>
<li><code>-c</code>: 显示完整的治命令</li>
<li><code>-I</code>: 忽略失效过程</li>
<li><code>-s</code>: 保密模式</li>
<li><code>-S</code>: 累积模式</li>
<li><code>-i&lt;时间&gt;</code>: 设置间隔时间</li>
<li><code>-u&lt;用户名&gt;</code>: 指定用户名</li>
<li><code>-p&lt;进程号&gt;</code>: 指定进程</li>
<li><code>-n&lt;次数&gt;</code>: 循环显示的次数</li>
</ul>
</li>
</ol>
<h2 id="显示说明"><a href="#显示说明" class="headerlink" title="显示说明"></a>显示说明</h2><p>在命令行输入 <code>top</code> 命令，终端会展示当前系统的信息，如下所示</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ top</div><div class="line">top - 21:04:19 up 129 days, 20:31,  1 user,  load average: 58.32, 57.85, 57.50</div><div class="line">Tasks: 589 total,   1 running, 584 sleeping,   0 stopped,   4 zombie</div><div class="line">Cpu(s): 22.3%us, 11.8%sy,  0.0%ni, 63.2%id,  0.2%wa,  0.0%hi,  2.5%si,  0.0%st</div><div class="line">Mem:  132103752k total, 122070628k used, 10033124k free,    42940k buffers</div><div class="line">Swap:        0k total,        0k used,        0k free, 58734284k cached</div><div class="line"></div><div class="line">   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</div><div class="line"> 51179	matt   20   0 70.6g  24g  80m S 704.9 19.2  39244,38 java</div><div class="line">     1 root      20   0 1155m 1.1g  592 S  0.0  0.9   4020:57 init</div><div class="line">     2 root      20   0     0    0    0 S  0.0  0.0   0:00.01 kthreadd</div></pre></td></tr></table></figure>
<p>上面只是截取了部分的信息，这里介绍以下上面的一些信息的说明。上面的前五行是当前系统情况整体的统计信息区。</p>
<ol>
<li>任务的队列信息，同 uptime 命令的执行结果<ul>
<li><code>21:04:19</code>: 当前系统时间；</li>
<li><code>up 129 days, 20:31</code>: 系统已经运行了129天20小时31分钟（这期间系统没有重启）；</li>
<li><code>1 users</code>: 当前有1个用户登录系统；</li>
<li><code>load average: 58.32, 57.85, 57.50</code>: load average 后面的三个数分别是1分钟、5分钟、15分钟的负载情况（<strong>这个数除以逻辑 CPU 的数量，结果高于5的时候就表明系统在超负荷运转</strong>）</li>
</ul>
</li>
<li>Tasks — 任务（进程）的统计信息<ul>
<li>系统现在共有589个进程，其中处于运行中的有1个，584个在休眠（sleep），stoped 状态的有0个，zombie 状态（僵尸）的有4个；</li>
</ul>
</li>
<li>cpu 的状态信息<ul>
<li><code>22.3%us</code>: 用户空间占用 CPU 的百分比</li>
<li><code>11.8% sy</code>: 内核空间占用 CPU 的百分比</li>
<li><code>0.0% ni</code>: 改变过优先级的进程占用 CPU 的百分比</li>
<li><code>63.2% id</code>: 空闲 CPU 百分比</li>
<li><code>0.2% wa</code>: IO 等待占用 CPU 的百分比</li>
<li><code>0.0% hi</code>: 硬中断（Hardware IRQ）占用 CPU 的百分比</li>
<li><code>2.5% si</code>: 软中断（Software Interrupts）占用 CPU 的百分比</li>
<li><code>0.0% st</code>: 虚拟机占用的百分比</li>
</ul>
</li>
<li>内存的状态信息<ul>
<li><code>132103752k total</code>： 物理内存总量（128GB）</li>
<li><code>122070628k used</code>： 使用中的内存总量（118GB）</li>
<li><code>10033124k free</code>： 空闲内存总量（10GB）</li>
<li><code>42940k buffers</code>： 缓存的内存量 （42M）</li>
</ul>
</li>
<li>swap交换分区信息<ul>
<li><code>0k total</code>: 交换区总量（0K）</li>
<li><code>0k used</code>: 使用的交换区总量（0K）</li>
<li><code>0k free</code>: 空闲交换区总量（0K）</li>
<li><code>58734284k cached</code>: 缓冲的交换区总量（56GB）</li>
</ul>
</li>
<li>空行，作为系统信息与进程信息的分界线</li>
<li>各进程（任务）的状态监控<ul>
<li><code>PID</code>: 进程id</li>
<li><code>USER</code>: 进程所有者</li>
<li><code>PR</code>: 进程优先级</li>
<li><code>NI</code>: nice 值，负值表示高优先级，正值表示低优先级</li>
<li><code>VIRT</code>: 进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES</li>
<li><code>RES</code>: 进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA</li>
<li><code>SHR</code>: 共享内存大小，单位 kb</li>
<li><code>S</code>: 进程状态。D= 不可中断的睡眠状态 R= 运行 S= 睡眠 T= 跟踪/停止 Z= 僵尸进程</li>
<li><code>%CPU</code>: 上次更新到现在的CPU时间占用百分比</li>
<li><code>%MEM</code>: 进程使用的物理内存百分比</li>
<li><code>TIME+</code>: 进程使用的CPU时间总计，单位1/100秒</li>
<li><code>COMMAND</code>: 进程名称</li>
</ul>
</li>
</ol>
<p>其中，第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到 free 中去，因此在 linux 上 free 内存会越来越少，但不用为此担心。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>在工作中，常用的几个命令在 <a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a> 都已经介绍得比较全面了，这里，再简单重复一下。</p>
<h3 id="多-CPU-监控"><a href="#多-CPU-监控" class="headerlink" title="多 CPU 监控"></a>多 CPU 监控</h3><p>在 top 的基本视图中，按键盘数字<strong>1</strong>，可监控每个逻辑CPU的状况：</p>
<p><img src="/images/linux/top1.png" alt="TOP 多 CPU 监控"></p>
<h3 id="高亮显示当前进程"><a href="#高亮显示当前进程" class="headerlink" title="高亮显示当前进程"></a>高亮显示当前进程</h3><p>敲击键盘<strong>b</strong>（打开/关闭加亮效果），top 的视图变化如下（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top2.png" alt="TOP 高亮"></p>
<h3 id="进程字段排序"><a href="#进程字段排序" class="headerlink" title="进程字段排序"></a>进程字段排序</h3><p>默认进入 top 时，各进程是按照 CPU 的占用量来排序的，敲击键盘<strong>x</strong>（打开/关闭排序列的加亮效果），top 的视图变化如下所示，会将 CPU 占用量这行高亮（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top4.png" alt="TOP 按 CPU 占用量排序"></p>
<p>通过 <code>shift + &gt;</code>或<code>shift + &lt;</code>可以向右或左改变排序列，下图是按一次<code>shift + &gt;</code>的效果图，视图现在已经按照 <code>%MEM</code> 来排序（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top5.png" alt="TOP 按内存排序"></p>
<h3 id="显示进程完成命令"><a href="#显示进程完成命令" class="headerlink" title="显示进程完成命令"></a>显示进程完成命令</h3><p>敲击键盘<strong>c</strong>（打开/关闭进程完成命令），top 的视图变化如下（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top6.png" alt="TOP 显示完整命令"></p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li><code>top -p 574</code>: 显示指定的进程信息</li>
<li><code>top -d 3</code>: 设置信息更新时间</li>
<li><code>top -n 2</code>: 设置信息更新次数</li>
<li><code>top -S</code>: 以累积模式显示程序信息</li>
</ul>
<h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><p>iostat 也即 I/O statistics（输入/输出统计），iostat 会对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出 CPU 使用情况。但它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。</p>
<h2 id="命令常用参数-1"><a href="#命令常用参数-1" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><p>1．命令格式：</p>
<ul>
<li>iostat [参数][时间][次数]<br>2．命令功能：</li>
<li>通过 iostat 方便查看 CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况，负载信息。<br>3．命令参数：</li>
<li><code>-C</code>: 显示CPU使用情况</li>
<li><code>-d</code>: 显示磁盘使用情况</li>
<li><code>-k</code>: 以 KB 为单位显示</li>
<li><code>-m</code>: 以 M 为单位显示</li>
<li><code>-N</code>: 显示磁盘阵列(LVM) 信息</li>
<li><code>-n</code>: 显示NFS 使用情况</li>
<li><code>-p[磁盘]</code>: 显示磁盘和分区的情况</li>
<li><code>-t</code>: 显示终端和CPU的信息</li>
<li><code>-x</code>: 显示详细信息</li>
<li><code>-V</code>: 显示版本信息</li>
</ul>
<h2 id="显示说明-1"><a href="#显示说明-1" class="headerlink" title="显示说明"></a>显示说明</h2><p>使用 iostat 命令时，终端会显示很多很多的信息，这里介绍一下这些信息的含义。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ iostat</div><div class="line">Linux 2.6.32-431.20.3.el6.mt20150216.x86_64 (XXX) 	2017年07月16日 	_x86_64_	(32 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">          22.28    0.00   14.26    0.25    0.00   63.22</div><div class="line"></div><div class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</div><div class="line">sda              20.65       205.78       452.71 9429827972 20744862776</div></pre></td></tr></table></figure>
<ol>
<li>CPU 属性值说明：<ul>
<li><code>%user</code>：CPU 处在用户模式下的时间百分比</li>
<li><code>%nice</code>：CPU 处在带 NICE 值的用户模式下的时间百分比</li>
<li><code>%system</code>：CPU 处在系统模式下的时间百分比</li>
<li><code>%iowait</code>：CPU 等待输入输出完成时间的百分比</li>
<li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比</li>
<li><code>%idle</code>：CPU 空闲时间百分比</li>
</ul>
</li>
<li>disk 属性<ul>
<li><code>tps</code>：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。</li>
<li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li>
<li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li>
<li><code>kB_read</code>：读取的总数据量；</li>
<li><code>kB_wrtn</code>：写入的总数量数据量，这些单位都为Kilobytes。</li>
</ul>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ iostat -xm 3</div><div class="line">Linux 2.6.32-431.20.3.el6.mt20150216.x86_64 (XXX) 	2017年07月16日 	_x86_64_	(32 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">          22.28    0.00   14.26    0.25    0.00   63.21</div><div class="line"></div><div class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await  svctm  %util</div><div class="line">sda               0.50    42.34    6.47   14.18     0.10     0.22    31.90     0.02    1.20   0.44   0.90</div></pre></td></tr></table></figure>
<p>这里 disk 属性与上面的不太相同</p>
<ul>
<li><code>rrqm/s</code>: 每秒进行 merge 的读操作数目。即 rmerge/s</li>
<li><code>wrqm/s</code>: 每秒进行 merge 的写操作数目。即 wmerge/s</li>
<li><code>r/s</code>: 每秒完成的读 I/O 设备次数。即 rio/s</li>
<li><code>w/s</code>: 每秒完成的写 I/O 设备次数。即 wio/s</li>
<li><code>rsec/s</code>: 每秒读扇区数。即 rsect/s</li>
<li><code>wsec/s</code>: 每秒写扇区数。即 wsect/s</li>
<li><code>rkB/s</code>: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li>
<li><code>wkB/s</code>: 每秒写K字节数。是 wsect/s 的一半。</li>
<li><code>avgrq-sz</code>: 平均每次设备 I/O 操作的数据大小 (扇区)。</li>
<li><code>avgqu-sz</code>: 平均 I/O 队列长度。</li>
<li><code>await</code>: 平均每次设备 I/O 操作的等待时间 (毫秒)。</li>
<li><code>svctm</code>: 平均每次设备 I/O 操作的服务时间 (毫秒)。</li>
<li><code>%util</code>: 一秒中有百分之多少的时间用于 I/O 操作，即被 IO 消耗的 CPU 百分比。</li>
</ul>
<p>其中，下面是在实践中积累的一些经验</p>
<ol>
<li>如果 <code>%iowait</code> 的值过高，表示硬盘存在 I/O 瓶颈；</li>
<li><code>%idle</code> 值高，表示 CPU 较空闲，如果 <code>%idle</code> 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。<code>%idle</code> 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</li>
<li>如果 <code>%util</code> 接近 100%，说明产生的I/O请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈，其值大于 70% 时，磁盘的压力就很大了；</li>
<li>如果 <code>svctm</code> 比较接近 <code>await</code>，说明 I/O 几乎没有等待时间；如果 <code>await</code> 远大于 <code>svctm</code>，说明 I/O 队列太长，IO 响应太慢，则需要进行必要优化；</li>
<li>如果 <code>avgqu-sz</code> 比较大，也表示有当量 IO 在等待，它是 IO 调优时需要注意的地方，它是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小；</li>
<li>await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。</li>
</ol>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><ul>
<li><code>iostat 2 3</code>: 每隔 2 秒刷新显示，且显示 3 次；</li>
<li><code>iostat -d sda</code>: 显示指定磁盘信息；</li>
<li><code>iostat -t</code>: 显示 tty 和 CPU 信息；</li>
<li><code>iostat -m</code>: 以M为单位显示所有信息；</li>
<li><code>iostat -d -k 1 1</code>: 查看TPS和吞吐量信息；</li>
<li><code>iostat -c 1 3</code>: 查看cpu状态；</li>
</ul>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>ps —— 是 process status 的简称，它列出的是当前时刻那些进程的快照，如果想要动态的显示进程信息内容，可以使用 top 命令。</p>
<p>使用 ps 可以做以下事情：</p>
<ul>
<li>确定有哪些进程正在运行、查看运行的状态；</li>
<li>进程是否结束；</li>
<li>进程有没有僵死；</li>
<li>哪些进程占用了过多的资源等等。</li>
</ul>
<h2 id="Linux-进程的五种状态"><a href="#Linux-进程的五种状态" class="headerlink" title="Linux 进程的五种状态"></a>Linux 进程的五种状态</h2><p>在 Linux 上进程有5种状态，每种状态对应着不同的标识，如下表所示：</p>
<table>
<thead>
<tr>
<th>Linux 上状态</th>
<th>ps 的状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行（正在运行或在运行队列中等待）</td>
<td>R（running or on run queue）</td>
</tr>
<tr>
<td>中断（休眠中、受阻、在等待某个条件的形成和接收到信号）</td>
<td>S（sleeping）</td>
</tr>
<tr>
<td>不可中断（收到信号不唤醒和不可运行, 进程必须等待直到有中断发生）</td>
<td>D（uninterruptible sleep）</td>
</tr>
<tr>
<td>僵死（进程已终止，但进程描述符存在，直到父进程调用wait4()后才会释放）</td>
<td>Z（a defunct zombie process）</td>
</tr>
<tr>
<td>停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行）</td>
<td>T（traced or stopped）</td>
</tr>
</tbody>
</table>
<h2 id="命令常用参数-2"><a href="#命令常用参数-2" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><ol>
<li>命令格式<ul>
<li>ps [参数]</li>
</ul>
</li>
<li>命令参数<ul>
<li><code>a</code>：显示所有进程</li>
<li><code>-a</code>：显示同一终端下的所有程序</li>
<li><code>-A</code>：显示所有进程</li>
<li><code>c</code>：显示进程的真实名称</li>
<li><code>-N</code>：反向选择</li>
<li><code>e</code>：显示环境变量</li>
<li><code>f</code>：显示程序间的关系</li>
<li><code>-H</code>：显示树状结构</li>
<li><code>r</code>：显示当前终端的进程</li>
<li><code>T</code>：显示当前终端的所有程序</li>
<li><code>u</code>：指定用户的所有进程</li>
<li><code>-au</code>：显示较详细的资讯</li>
<li><code>-aux</code>：显示所有包含其他使用者的行程</li>
<li><code>-C&lt;命令&gt;</code>：列出指定命令的状况</li>
<li><code>--lines&lt;行数&gt;</code>：每页显示的行数</li>
<li><code>--width&lt;字符数&gt;</code>：每页显示的字符数</li>
<li><code>--help</code>：显示帮助信息</li>
<li><code>--version</code>：显示版本显示</li>
</ul>
</li>
</ol>
<h2 id="显示说明-2"><a href="#显示说明-2" class="headerlink" title="显示说明"></a>显示说明</h2><h3 id="将当前这次登入的-PID-与相关信息列示出来"><a href="#将当前这次登入的-PID-与相关信息列示出来" class="headerlink" title="将当前这次登入的 PID 与相关信息列示出来"></a>将当前这次登入的 PID 与相关信息列示出来</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ ps <span class="_">-l</span></div><div class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S   10 120177 120176  0  80   0 - 27078 <span class="built_in">wait</span>   pts/0    00:00:00 bash</div><div class="line">0 R   10 137912 120177  0  80   0 - 27031 -      pts/0    00:00:00 ps</div></pre></td></tr></table></figure>
<p>上面各个参数的含义：</p>
<ul>
<li><code>F</code>: 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>
<li><code>S</code>: 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</li>
<li><code>UID</code>: 程序被该 UID 所拥有</li>
<li><code>PID</code>: 就是这个程序的 ID</li>
<li><code>PPID</code>: 则是其上级父程序的ID</li>
<li><code>C</code>: CPU 使用的资源百分比</li>
<li><code>PRI</code>: 这个是 Priority (优先执行序) 的缩写</li>
<li><code>NI</code>: 这个是 Nice 值</li>
<li><code>ADDR</code>: 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>
<li><code>SZ</code>: 使用掉的内存大小</li>
<li><code>WCHAN</code>: 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>
<li><code>TTY</code>: 登入者的终端机位置</li>
<li><code>TIME</code>: 使用掉的 CPU 时间。</li>
<li><code>CMD</code>: 所下达的指令为何</li>
</ul>
<h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ ps aux</div><div class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root          1  0.5  0.8 1184632 1166268 ?     Ss    2016 4029:48 /sbin/init</div><div class="line">root          2  0.0  0.0      0     0 ?        S     2016   0:00 [kthreadd]</div><div class="line">root          3  0.0  0.0      0     0 ?        S     2016  36:36 [migration/0]</div></pre></td></tr></table></figure>
<p>上面各个参数的含义：</p>
<ul>
<li><code>USER</code>：该 process 属于那个使用者账号的</li>
<li><code>PID</code>：该 process 的号码</li>
<li><code>%CPU</code>：该 process 使用掉的 CPU 资源百分比</li>
<li><code>%MEM</code>：该 process 所占用的物理内存百分比</li>
<li><code>VSZ</code>：该 process 使用掉的虚拟内存量 (Kbytes)</li>
<li><code>RSS</code>：该 process 占用的固定的内存量 (Kbytes)</li>
<li><code>TTY</code>：该 process 是在那个终端机上面运作，若与终端机无关，则显示 <code>?</code>，若为 <code>pts/0</code> 等等的，则表示为由网络连接进主机的程序。</li>
<li><code>STAT</code>：该程序目前的状态</li>
<li><code>START</code>：该 process 被触发启动的时间</li>
<li><code>TIME</code>：该 process 实际使用 CPU 运作的时间</li>
<li><code>COMMAND</code>：该程序的实际指令</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>ps 的常用命令主要有以下几种用法：</p>
<ul>
<li><code>ps -A</code>: 显示所有进程信息</li>
<li><code>ps -u root</code>: 显示指定用户信息</li>
<li><code>ps -ef</code>: 显示所有进程信息，连同命令行</li>
<li>与 <code>grep</code> 一起，来查看指定的进程。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2013/03/08/2949194.html" target="_blank" rel="external">每天一个linux命令（56）：netstat命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/28/2837345.html" target="_blank" rel="external">每天一个linux命令（47）：iostat命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="external">每天一个linux命令（41）：ps命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/25/2831814.html" target="_blank" rel="external">每天一个linux命令（45）：free 命令</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章的内容，基本来自&lt;a href=&quot;http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 Producer Metadata 更新机制（二）</title>
    <link href="http://matt33.com/2017/07/08/kafka-producer-metadata/"/>
    <id>http://matt33.com/2017/07/08/kafka-producer-metadata/</id>
    <published>2017-07-08T15:51:00.000Z</published>
    <updated>2017-07-09T01:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，已经介绍了 Producer 的发送模型，Producer <code>dosend()</code> 方法中的第一步，就是获取相关的 topic 的 metadata，但在上篇中并没有深入展开，因为这部分的内容比较多，所以本文单独一篇文章进行介绍，本文主要来讲述以下三个问题：</p>
<ol>
<li>metadata 内容是什么；</li>
<li>Producer 更新 metadata 的流程；</li>
<li>Producer 在什么情况下会去更新 metadata；</li>
</ol>
<h2 id="Metadata-内容"><a href="#Metadata-内容" class="headerlink" title="Metadata 内容"></a>Metadata 内容</h2><p>Metadata 信息的内容可以通过源码看明白：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个类被 client 线程和后台 sender 所共享,它只保存了所有 topic 的部分数据,当我们请求一个它上面没有的 topic meta 时,它会通过发送 metadata update 来更新 meta 信息,</span></div><div class="line"><span class="comment">// 如果 topic meta 过期策略是允许的,那么任何 topic 过期的话都会被从集合中移除,</span></div><div class="line"><span class="comment">// 但是 consumer 是不允许 topic 过期的因为它明确地知道它需要管理哪些 topic</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Metadata</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Metadata.class);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_MS = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_NEEDS_UPDATE = -<span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> refreshBackoffMs; <span class="comment">// metadata 更新失败时,为避免频繁更新 meta,最小的间隔时间,默认 100ms</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> metadataExpireMs; <span class="comment">// metadata 的过期时间, 默认 60,000ms</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version; <span class="comment">// 每更新成功1次，version自增1,主要是用于判断 metadata 是否更新</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRefreshMs; <span class="comment">// 最近一次更新时的时间（包含更新失败的情况）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastSuccessfulRefreshMs; <span class="comment">// 最近一次成功更新的时间（如果每次都成功的话，与前面的值相等, 否则，lastSuccessulRefreshMs &lt; lastRefreshMs)</span></div><div class="line">    <span class="keyword">private</span> Cluster cluster; <span class="comment">// 集群中一些 topic 的信息</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needUpdate; <span class="comment">// 是都需要更新 metadata</span></div><div class="line">    <span class="comment">/* Topics with expiry time */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; topics; <span class="comment">// topic 与其过期时间的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Listener&gt; listeners; <span class="comment">// 事件监控者</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResourceListeners clusterResourceListeners; <span class="comment">//当接收到 metadata 更新时, ClusterResourceListeners的列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needMetadataForAllTopics; <span class="comment">// 是否强制更新所有的 metadata</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> topicExpiryEnabled; <span class="comment">// 默认为 true, Producer 会定时移除过期的 topic,consumer 则不会移除</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 topic 的详细信息（leader 所在节点、replica 所在节点、isr 列表）都是在 <code>Cluster</code> 实例中保存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并不是一个全集,metadata的主要组成部分</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 从命名直接就看出了各个变量的用途</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBootstrapConfigured;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Node&gt; nodes; <span class="comment">// node 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; unauthorizedTopics; <span class="comment">// 未认证的 topic 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; internalTopics; <span class="comment">// 内置的 topic 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition; <span class="comment">// partition 的详细信息</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic; <span class="comment">// topic 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic; <span class="comment">//  可用（leader 不为 null）的 topic 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode; <span class="comment">// node 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; nodesById; <span class="comment">// node 与 id 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResource clusterResource;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// org.apache.kafka.common.PartitionInfo</span></div><div class="line"><span class="comment">// topic-partition: 包含 topic、partition、leader、replicas、isr</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node leader;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] replicas;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] inSyncReplicas;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Cluster</code> 实例主要是保存：</p>
<ol>
<li>broker.id 与 <code>node</code> 的对应关系；</li>
<li>topic 与 partition （<code>PartitionInfo</code>）的对应关系；</li>
<li><code>node</code> 与 partition （<code>PartitionInfo</code>）的对应关系。</li>
</ol>
<h2 id="Producer-的-Metadata-更新流程"><a href="#Producer-的-Metadata-更新流程" class="headerlink" title="Producer 的 Metadata 更新流程"></a>Producer 的 Metadata 更新流程</h2><p>Producer 在调用 <code>dosend()</code> 方法时，第一步就是通过 <code>waitOnMetadata</code> 方法获取该 topic 的 metadata 信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等待 metadata 的更新</span></div><div class="line"><span class="function"><span class="keyword">private</span> ClusterAndWaitTime <span class="title">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    metadata.add(topic);<span class="comment">// 在 metadata 中添加 topic 后,如果 metadata 中没有这个 topic 的 meta，那么 metadata 的更新标志设置为了 true</span></div><div class="line">    Cluster cluster = metadata.fetch();</div><div class="line">    Integer partitionsCount = cluster.partitionCountForTopic(topic);<span class="comment">// 如果 topic 已经存在 meta 中,则返回该 topic 的 partition 数,否则返回 null</span></div><div class="line"></div><div class="line">    <span class="comment">// 当前 metadata 中如果已经有这个 topic 的 meta 的话,就直接返回</span></div><div class="line">    <span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> begin = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</div><div class="line">    <span class="keyword">long</span> elapsed;</div><div class="line"></div><div class="line">    <span class="comment">// 发送 metadata 请求,直到获取了这个 topic 的 metadata 或者请求超时</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        log.trace(<span class="string">"Requesting metadata update for topic &#123;&#125;."</span>, topic);</div><div class="line">        <span class="keyword">int</span> version = metadata.requestUpdate();<span class="comment">// 返回当前版本号,初始值为0,每次更新时会自增,并将 needUpdate 设置为 true</span></div><div class="line">        sender.wakeup();<span class="comment">// 唤起 sender，发送 metadata 请求</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            metadata.awaitUpdate(version, remainingWaitMs);<span class="comment">// 等待 metadata 的更新</span></div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</div><div class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</div><div class="line">        &#125;</div><div class="line">        cluster = metadata.fetch();</div><div class="line">        elapsed = time.milliseconds() - begin;</div><div class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);<span class="comment">// 超时</span></div><div class="line">        <span class="keyword">if</span> (cluster.unauthorizedTopics().contains(topic))<span class="comment">// 认证失败，对当前 topic 没有 Write 权限</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TopicAuthorizationException(topic);</div><div class="line">        remainingWaitMs = maxWaitMs - elapsed;</div><div class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</div><div class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="keyword">null</span>);<span class="comment">// 不停循环,直到 partitionsCount 不为 null（即直到 metadata 中已经包含了这个 topic 的相关信息）</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (partition != <span class="keyword">null</span> &amp;&amp; partition &gt;= partitionsCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(</div><div class="line">                String.format(<span class="string">"Invalid partition given with record: %d is not in the range [0...%d)."</span>, partition, partitionsCount));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, elapsed);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 metadata 中不存在这个 topic 的 metadata，那么就请求更新 metadata，如果 metadata 没有更新的话，方法就一直处在 <code>do ... while</code> 的循环之中，在循环之中，主要做以下操作：</p>
<ol>
<li><code>metadata.requestUpdate()</code> 将 metadata 的 <code>needUpdate</code> 变量设置为 true（强制更新），并返回当前的版本号（version），通过版本号来判断 metadata 是否完成更新；</li>
<li><code>sender.wakeup()</code> 唤醒 sender 线程，sender 线程又会去唤醒 <code>NetworkClient</code> 线程，<code>NetworkClient</code> 线程进行一些实际的操作（后面详细介绍）；</li>
<li><code>metadata.awaitUpdate(version, remainingWaitMs)</code> 等待 metadata 的更新。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新 metadata 信息（根据当前 version 值来判断）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">awaitUpdate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> lastVersion, <span class="keyword">final</span> <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxWaitMs &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Max time to wait for metadata updates should not be &lt; 0 milli seconds"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.version &lt;= lastVersion) &#123;<span class="comment">// 不断循环,直到 metadata 更新成功,version 自增</span></div><div class="line">        <span class="keyword">if</span> (remainingWaitMs != <span class="number">0</span>)</div><div class="line">            wait(remainingWaitMs);<span class="comment">// 阻塞线程，等待 metadata 的更新</span></div><div class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - begin;</div><div class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)<span class="comment">// timeout</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</div><div class="line">        remainingWaitMs = maxWaitMs - elapsed;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Metadata.awaitUpdate()</code> 方法中，线程会阻塞在 <code>while</code> 循环中，直到 metadata 更新成功或者 timeout。</p>
<p>从前面可以看出，此时 Producer 线程会阻塞在两个 <code>while</code> 循环中，直到 metadata 信息更新，那么 metadata 是如何更新的呢？如果有印象的话，前面应该已经介绍过了，主要是通过 <code>sender.wakeup()</code> 来唤醒 sender 线程，间接唤醒 NetworkClient 线程，NetworkClient 线程来负责发送 Metadata 请求，并处理 Server 端的响应。</p>
<p>在 <a href="http://matt33.com/2017/06/25/kafka-producer-send-module/">Kafka 源码分析之 Producer 发送模型（一）</a> 中介绍 Producer 发送模型时，在第五步 <code>sender</code> 线程会调用 <code>NetworkClient.poll()</code> 方法进行实际的操作，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);<span class="comment">// 判断是否需要更新 meta,如果需要就更新（请求更新 metadata 的地方）</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"Unexpected error during I/O"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// process completed actions</span></div><div class="line">        <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</div><div class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        handleAbortedSends(responses);</div><div class="line">        handleCompletedSends(responses, updatedNow);<span class="comment">// 通过 selector 中获取 Server 端的 response</span></div><div class="line">        handleCompletedReceives(responses, updatedNow);<span class="comment">// 在返回的 handler 中，会处理 metadata 的更新</span></div><div class="line">        handleDisconnections(responses, updatedNow);</div><div class="line">        handleConnections();</div><div class="line">        handleInitiateApiVersionRequests(updatedNow);</div><div class="line">        handleTimedOutRequests(responses, updatedNow);</div><div class="line"></div><div class="line">        <span class="comment">// invoke callbacks</span></div><div class="line">        <span class="keyword">for</span> (ClientResponse response : responses) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response.onComplete();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                log.error(<span class="string">"Uncaught error in request completion:"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> responses;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，主要会以下操作：</p>
<ul>
<li><code>metadataUpdater.maybeUpdate(now)</code>：判断是否需要更新 Metadata，如果需要更新的话，先与 Broker 建立连接，然后发送更新 metadata 的请求；</li>
<li>处理 Server 端的一些响应，这里主要讨论的是 <code>handleCompletedReceives(responses, updatedNow)</code> 方法，它会处理 Server 端返回的 Metadata 结果。</li>
</ul>
<p>先看一下 <code>metadataUpdater.maybeUpdate()</code> 的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="comment">// should we update our metadata?</span></div><div class="line">        <span class="comment">// metadata 是否应该更新</span></div><div class="line">        <span class="keyword">long</span> timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);<span class="comment">// metadata 下次更新的时间（需要判断是强制更新还是 metadata 过期更新,前者是立马更新,后者是计算 metadata 的过期时间）</span></div><div class="line">        <span class="comment">// 如果一条 metadata 的 fetch 请求还未从 server 收到恢复,那么时间设置为 waitForMetadataFetch（默认30s）</span></div><div class="line">        <span class="keyword">long</span> waitForMetadataFetch = <span class="keyword">this</span>.metadataFetchInProgress ? requestTimeoutMs : <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</div><div class="line">        <span class="keyword">if</span> (metadataTimeout &gt; <span class="number">0</span>) &#123;<span class="comment">// 时间未到时,直接返回下次应该更新的时间</span></div><div class="line">            <span class="keyword">return</span> metadataTimeout;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node node = leastLoadedNode(now);<span class="comment">// 选择一个连接数最小的节点</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            log.debug(<span class="string">"Give up sending metadata request since no node is available"</span>);</div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> maybeUpdate(now, node); <span class="comment">// 可以发送 metadata 请求的话,就发送 metadata 请求</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a metadata request to the list of sends if we can make one</div><div class="line">     */</div><div class="line">    <span class="comment">// 判断是否可以发送请求,可以的话将 metadata 请求加入到发送列表中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now, Node node)</span> </span>&#123;</div><div class="line">        String nodeConnectionId = node.idString();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (canSendRequest(nodeConnectionId)) &#123;<span class="comment">// 通道已经 ready 并且支持发送更多的请求</span></div><div class="line">            <span class="keyword">this</span>.metadataFetchInProgress = <span class="keyword">true</span>; <span class="comment">// 准备开始发送数据,将 metadataFetchInProgress 置为 true</span></div><div class="line">            MetadataRequest.Builder metadataRequest; <span class="comment">// 创建 metadata 请求</span></div><div class="line">            <span class="keyword">if</span> (metadata.needMetadataForAllTopics())<span class="comment">// 强制更新所有 topic 的 metadata（虽然默认不会更新所有 topic 的 metadata 信息，但是每个 Broker 会保存所有 topic 的 meta 信息）</span></div><div class="line">                metadataRequest = MetadataRequest.Builder.allTopics();</div><div class="line">            <span class="keyword">else</span> <span class="comment">// 只更新 metadata 中的 topics 列表（列表中的 topics 由 metadata.add() 得到）</span></div><div class="line">                metadataRequest = <span class="keyword">new</span> MetadataRequest.Builder(<span class="keyword">new</span> ArrayList&lt;&gt;(metadata.topics()));</div><div class="line"></div><div class="line"></div><div class="line">            log.debug(<span class="string">"Sending metadata request &#123;&#125; to node &#123;&#125;"</span>, metadataRequest, node.id());</div><div class="line">            sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);/ 发送 metadata 请求</div><div class="line">            <span class="keyword">return</span> requestTimeoutMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If there's any connection establishment underway, wait until it completes. This prevents</span></div><div class="line">        <span class="comment">// the client from unnecessarily connecting to additional nodes while a previous connection</span></div><div class="line">        <span class="comment">// attempt has not been completed.</span></div><div class="line">        <span class="keyword">if</span> (isAnyNodeConnecting()) &#123;<span class="comment">// 如果 client 正在与任何一个 node 的连接状态是 connecting,那么就进行等待</span></div><div class="line">            <span class="comment">// Strictly the timeout we should return here is "connect timeout", but as we don't</span></div><div class="line">            <span class="comment">// have such application level configuration, using reconnect backoff instead.</span></div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;<span class="comment">// 如果没有连接这个 node,那就初始化连接</span></div><div class="line">            <span class="comment">// we don't have a connection to this node right now, make one</span></div><div class="line">            log.debug(<span class="string">"Initialize connection to node &#123;&#125; for sending metadata request"</span>, node.id());</div><div class="line">            initiateConnect(node, now);<span class="comment">// 初始化连接</span></div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Long.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="comment">// 发送 Metadata 请求   </span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInternalMetadataRequest</span><span class="params">(MetadataRequest.Builder builder,</span></span></div><div class="line">                                         String nodeConnectionId, <span class="keyword">long</span> now) &#123;</div><div class="line">    ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, <span class="keyword">true</span>);<span class="comment">// 创建 metadata 请求</span></div><div class="line">    doSend(clientRequest, <span class="keyword">true</span>, now);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，每次 Producer 请求更新 metadata 时，会有以下几种情况：</p>
<ol>
<li>如果 node 可以发送请求，则直接发送请求；</li>
<li>如果该 node 正在建立连接，则直接返回；</li>
<li>如果该 node 还没建立连接，则向 broker 初始化链接。</li>
</ol>
<p>而 KafkaProducer 线程之前是一直阻塞在两个 <code>while</code> 循环中，直到 metadata 更新</p>
<ol>
<li>sender 线程第一次调用 <code>poll()</code> 方法时，初始化与 node 的连接；</li>
<li>sender 线程第二次调用 <code>poll()</code> 方法时，发送 <code>Metadata</code> 请求；</li>
<li>sender 线程第三次调用 <code>poll()</code> 方法时，获取 <code>metadataResponse</code>，并更新 metadata。</li>
</ol>
<p>经过上述 sender 线程三次调用 <code>poll()</code>方法，所请求的 metadata 信息才会得到更新，此时 Producer 线程也不会再阻塞，开始发送消息。</p>
<p><code>NetworkClient</code> 接收到 Server 端对 Metadata 请求的响应后，更新 Metadata 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理任何已经完成的接收响应</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCompletedReceives</span><span class="params">(List&lt;ClientResponse&gt; responses, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (NetworkReceive receive : <span class="keyword">this</span>.selector.completedReceives()) &#123;</div><div class="line">            String source = receive.source();</div><div class="line">            InFlightRequest req = inFlightRequests.completeNext(source);</div><div class="line">            AbstractResponse body = parseResponse(receive.payload(), req.header);</div><div class="line">            log.trace(<span class="string">"Completed receive from node &#123;&#125;, for key &#123;&#125;, received &#123;&#125;"</span>, req.destination, req.header.apiKey(), body);</div><div class="line">            <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> MetadataResponse)<span class="comment">// 如果是 meta 响应</span></div><div class="line">                metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> ApiVersionsResponse)</div><div class="line">                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body); <span class="comment">// 如果是其他响应</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                responses.add(req.completed(body, now));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理 Server 端对 Metadata 请求处理后的 response</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCompletedMetadataResponse</span><span class="params">(RequestHeader requestHeader, <span class="keyword">long</span> now, MetadataResponse response)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.metadataFetchInProgress = <span class="keyword">false</span>;</div><div class="line">            Cluster cluster = response.cluster();</div><div class="line">            <span class="comment">// check if any topics metadata failed to get updated</span></div><div class="line">            Map&lt;String, Errors&gt; errors = response.errors();</div><div class="line">            <span class="keyword">if</span> (!errors.isEmpty())</div><div class="line">                log.warn(<span class="string">"Error while fetching metadata with correlation id &#123;&#125; : &#123;&#125;"</span>, requestHeader.correlationId(), errors);</div><div class="line"></div><div class="line">            <span class="comment">// don't update the cluster if there are no valid nodes...the topic we want may still be in the process of being</span></div><div class="line">            <span class="comment">// created which means we will get errors and no nodes until it exists</span></div><div class="line">            <span class="keyword">if</span> (cluster.nodes().size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.metadata.update(cluster, now);<span class="comment">// 更新 meta 信息</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 metadata 中 node 信息无效,则不更新 metadata 信息</span></div><div class="line">                log.trace(<span class="string">"Ignoring empty metadata response with correlation id &#123;&#125;."</span>, requestHeader.correlationId());</div><div class="line">                <span class="keyword">this</span>.metadata.failedUpdate(now);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="Producer-Metadata-的更新策略"><a href="#Producer-Metadata-的更新策略" class="headerlink" title="Producer Metadata 的更新策略"></a>Producer Metadata 的更新策略</h2><p>Metadata 会在下面两种情况下进行更新</p>
<ol>
<li>KafkaProducer 第一次发送消息时强制更新，其他时间周期性更新，它会通过 Metadata 的 <code>lastRefreshMs</code>, <code>lastSuccessfulRefreshMs</code> 这2个字段来实现；</li>
<li>强制更新： 调用 <code>Metadata.requestUpdate()</code> 将 <code>needUpdate</code> 置成了 true 来强制更新。</li>
</ol>
<p>在 NetworkClient 的 <code>poll()</code> 方法调用时，就会去检查这两种更新机制，只要达到其中一种，就行触发更新操作。</p>
<p>Metadata 的强制更新会在以下几种情况下进行：</p>
<ol>
<li><code>initConnect</code> 方法调用时，初始化连接；</li>
<li><code>poll()</code> 方法中对 <code>handleDisconnections()</code> 方法调用来处理连接断开的情况，这时会触发强制更新；</li>
<li><code>poll()</code> 方法中对 <code>handleTimedOutRequests()</code> 来处理请求超时时；</li>
<li>发送消息时，如果无法找到 partition 的 leader；</li>
<li>处理 Producer 响应（<code>handleProduceResponse</code>），如果返回关于 Metadata 过期的异常，比如：没有 topic-partition 的相关 meta 或者 client 没有权限获取其 metadata。</li>
</ol>
<p>强制更新主要是用于处理各种异常情况。</p>
<p>参考文档：</p>
<ul>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52622422" target="_blank" rel="external">Kafka源码深度解析－序列2 －Producer －Metadata的数据结构与读取、更新策略</a>；</li>
<li><a href="http://luodw.cc/2017/05/02/kafka02/" target="_blank" rel="external">kafka源码分析之Producer</a>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，已经介绍了 Producer 的发送模型，Producer &lt;code&gt;dosend()&lt;/code&gt; 方法中的第一步，就是获取相关的 topic 的 metadata，但在上篇中并没有深入展开，因为这部分的内容比较多，所以本文单独一篇文章进行介绍，本文主要
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>买房感想</title>
    <link href="http://matt33.com/2017/07/02/buy-little-room/"/>
    <id>http://matt33.com/2017/07/02/buy-little-room/</id>
    <published>2017-07-02T13:38:38.000Z</published>
    <updated>2017-07-03T15:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>落户+买房的事情终于搞定得差不多了（就差贷款合同的签署），六月份这个月已经往来杭州3趟，从四月底开始看房到现在，这一路真是五味杂粮、感慨颇多，亲身地感觉到生活之不易，无忧无虑的生活从离开大学的那一刻开始就已经结束，读研这两年半看似浑浑噩噩，但早已没有大学时的那种轻松惬意，或许这就是成长。</p>
<h2 id="去库存历史进程"><a href="#去库存历史进程" class="headerlink" title="去库存历史进程"></a>去库存历史进程</h2><p>从四月底看房到7.1签合同，杭州房价整体至少涨了20%（间接地上涨，刚需买房的成本涨得更多），简单举几个例子，都是个人的亲身经历：</p>
<ul>
<li>万科杭宸，成品装修，同学三月购入，当时三成首付、单价 2w 出头，五月我去看房时，销售态度也很好，让等认筹通知，等到六月份时，杭宸通知只接受全款或七成首付（最后情况是只接受全款）；</li>
<li>西溪璞园，四月底去看，当时有特价房，125 平大概 245w（均价1.9w，位置还好），6月初通知有一套小户型房源，顶楼，单价2.2w，遂吧；</li>
<li>东海闲湖城，三月开盘三幢楼，由于政府限价，均价只有1.2w，结果很明显，两三天就被抢完（当时市场还并不是太热），后面由于备案价格上不去，开发商目前选择直接封盘（后面三幢据说下半年开盘），车位从5月开始由 13w 涨到 16w；</li>
<li>万家之星，六月初去看盘，销售不怎么搭理，直接明说，现在要买的话只能去找关系，让去找滨江或旭辉的内部人员；</li>
<li>雅居乐国际花园，六月初第一次看，开盘当天小户型全部售罄，只剩 128 平，不过户型很好，只是没有看上这个小区，感觉小区人太多、楼太高（32层，4000户），后来六月再次开盘时，小户型依然是难抢；</li>
<li>….</li>
</ul>
<p>上面都是自己去踩过的盘，也都是真实的信息，我们可以再看一下去年7月份之前一些楼盘的价格，比如杭宸1.8w（现在2.3w）、桃源小镇 8k（现在1.8w）、科技城 1.5w（现在中心地带已经 3w+）、蒋村二手 2w 多点（现在 3.7w+）…，如果按 2016 年初的价格现在基本平均已经翻了 2-3 倍，当然并不是仅仅是杭州，全国一线城市和强二线城市都一样，郑州东区均价都到 1.5w、北京东西城均价 13w+ 朝阳海淀均价 9w+（目前调控虽说降了，但没什么卵用）、天津杭州均价到了 2w（之前是 1w），浩浩荡荡，当一线二线城市开始猛涨时，我们才意识到原来特么这就是<strong>去库存</strong>，通过房子把政府的债务轻轻松松转移到了普通百姓的身上，我们拿着纸面上的财富开始为银行打工。当然如果你有机会去为银行打工，那证明你还算是幸运的，因为你抓住机会已经买了房，更多的人根本就没抓住机会（就像楼主我），有人在这一历史进程中 all in 杭州，在短短一年的时间赚了几百万。</p>
<p>能看到机会的人毕竟是少数，当所有人都意识到机会的时候，市场已经变得疯狂，而且各种限购政策开始实施，这时候入场的人能赚到大钱的已经很少，很多可能已经开始站岗。去库存这一历史进程，在共和国、乃至中华民族史上都是可以载入史册的大事件（好坏无法评论，很多东西只有过些年才能看清楚其意义），它让一线城市有房的人身价迅速加了 500w+（多套房的就增加了千万），强二线城市有房的人身价涨了 100w+，这一切短短只需要一年，在这之前恐怕很少人相信现实是这么疯狂。而对于那些房价没有翻倍的城市，从此消彼长的角度看相当于其财富洗劫了，被一线二线城市洗劫，而且即使三四线城市的房价翻一倍，也免不了被洗劫的命运，北京翻一倍就是几百万上千万，而三四线只是几十万，这没有任何可比性。去库存造就了多少百万富翁，实在想不出来建国以来除了改革开放还有什么能造就这么多富翁。</p>
<p>任何事情都有好坏两方面，对于政府来说，可以实现两个效果：一、地方债务转移；二、一二线城市开始驱逐低收入或者买不起房的人，表面上看对于政府都是利好的，深层次分析，就不好说了，长征五号连续发射失败对于政府应该是一个警钟。从个人的角度来说，买到房的人（上车的人）个人资产迅速翻倍，没有买到房的人离买房越来越遥远。而买到房抓住机会的永远是少数，大部分人是这次去库存的受害者，去库存前可能马上就攒够了首付的钱，但一年之后却发现首付涨得远远超过了攒钱的速度，收入高点的还好说，可以去二线城市占坑，但另外一些人，他们已经被遗忘了。</p>
<p>现实就是这么残酷，没有人会去同情，我们只能去依靠自己，努力工作，为自己也为家人，其他的我们又能做些什么呢？</p>
<p>亲身经历浩浩荡荡的去库存历史进程，也算是大开眼界，这种事情在全世界史上都不是很常见，我们再次用了极短的时间完成发达国家几十年甚至上百年的进程，不出意外，未来我们还会经历更多可以载入史册的事件，但此时我们希望的是自己能够抓住机会，历史告诉我们，大事件背后隐藏的都是巨大的机会（过去的已经成为历史，历史不会重复，但我们可以从历史中去学习经验）。就像雄安一出来，那么多人跑过去买房，但是雄安早已封盘，而且雄安的商品房规划可能会像新加坡一样，政府全面提供廉租房，商品房在雄安将会退出历史舞台，这并不是那些炒房客的机会，他们只是得了去库存的后遗症。</p>
<h2 id="一线赶人，二线抢人"><a href="#一线赶人，二线抢人" class="headerlink" title="一线赶人，二线抢人"></a>一线赶人，二线抢人</h2><p>小时候，我们一直被灌输一种概念：人口是负担，如果我们人少一些，我们也可以过上美国人一样的生活。但是，现在我们却发现，人口是国家财富，看看那些鬼城，没有人的话规划得再好，没有任何用。北上深，这三个一线城市，他们在过去三十年的快速发展，既有政府集全国之力去发展（深圳除外，主要指北京和上海），可以修建的东方明珠、鸟巢，花得是全国公民的钱，但是却修在了上海和北京，这就是政策利好，然后到现在，以北京为例，出了以下这些政策：</p>
<ul>
<li>北京落户名额每年都在缩减；</li>
<li>北京控地，近两年新增住宅用地达到历史最低水平；</li>
<li>北京高校对非京籍博士总额做限制；</li>
<li>疏解低端产业，未来北京人口减少到 X；</li>
<li>…</li>
</ul>
<p>这都在向我们传递一个信号：北京不是想呆就能呆的地方，曾经<code>北京欢迎你</code>的时代已经过去，现在是一个新的时代。同时，也可以看到政府规划了各种城市群，来缓解一线的压力，中国 2016 的城市化率是 57%，经验告诉我们，一旦达到这个值之后，后面的城市化率将会以更快速度的增长，在之前，大部分高校毕业生都去了一线城市，做起了北漂、上漂、深漂，然而这几个大城市的容量是有限的，早些年来的人已经在一线扎根，现在六个我们的就会已经很少了。现在政府开始鼓励毕业生去二线城市发展，比较牛的二线城市，像杭州、南京、武汉以及一线城市深圳，都开始搞出了各种吸引人才政策，希望能把相关专业的高校毕业生（所谓的才人）吸引到本地，杭州和深圳本地高校少，只能从外地吸引，武汉和南京本地高校多，想的是怎么把自己培养的毕业生留下来，不得不说这几个城市哪个能吸引到更多高校毕业生，哪个城市未来的潜力就会更大一些。对于高校毕业生来说，大家主要关心是两方面：一个就业机会、一个是房价，一线城市的房价已经远远超出普通人的承受能力，甚至可以说，年薪100w（税前）在北上深都很有压力。所以对于二线城市来说，拥有较好就业机会以及较低房价的城市，未来肯定会吸引到更多的人才，只有把人吸引来了，这个城市未来才能飞速发展，中国确实需要培养更多的大城市，仅仅靠北上深三个城市，是带不起整个中国的。</p>
<h2 id="生活之不易，最难的永远在后面"><a href="#生活之不易，最难的永远在后面" class="headerlink" title="生活之不易，最难的永远在后面"></a>生活之不易，最难的永远在后面</h2><p>在国内，这几年讨论最多的就是房价，记得高中时，房价就已经是家常便饭，尤其是《蜗居》这部电视剧热播，全民开始讨论房价，但从现在来看，那时的房价真叫一个便宜。房子是我们的生活必需品，更何况房子跟户口、学校都是绑定在一起的，这就让房子成为家庭的必需品，结婚要婚房、小孩上学要学区房。。。一套房贷款之后，基本上要还30年，未来就要为银行工作30年，如果不买房，自己就是在为房东打工，甚至随时都会面对房租的上涨，所有的一切都逼着你去买房。</p>
<p>昨天正式签了合同，刚需的问题总算解决了，买的位置不是很好，未来的前景很难说，但是不买又没办法，今天还能买这，过半年可能就只能买更远的地方了。买完之后，跟一个朋友聊天，突然觉得压力更大了，贷款的压力还可以接受。但未来一旦有了孩子，孩子的支出、上学等等，这些都不是小数目，真的怀疑自己能不能承受住这么大支出，现在真的很理解那些选择不要孩子的一族。经济越发达的地方，生育率就越低，尤其是东亚这边深受儒家文化影响的民族，像日本韩国生育率比欧洲、澳洲、美洲低很多，东亚民族普遍对孩子投入较多，导致父母压力更大，所以越来越多的人不愿意去生孩子。</p>
<p>眼前的问题解决了，去年定一个的最重要的年度计划完成了，但是更大、更难的问题还在后面，然而<strong>现在能做的只能是花更多的时间去投资自己</strong>，不然的话真的害怕自己没有足够的能力为家庭提供一个好的生活。内地一年毕业600w+的大学生，在这样的竞争压力下，你若不努力，就会被淘汰，这就是现实社会中的达尔文主义。</p>
<h2 id="寒门再难在一二线扎根"><a href="#寒门再难在一二线扎根" class="headerlink" title="寒门再难在一二线扎根"></a>寒门再难在一二线扎根</h2><p>之前看到一个说法，说的是：中国70-90年代的精英大多来自农村，而90年代后的精英大都来自中产阶级。以互联网为例，这些大佬们，马云、马化腾、李彦宏、周鸿祎、刘强东、王兴等，家境较差的也只有刘强东了，其他人的家庭背景至少都是中产，农村走出来的人，在目前的精英阶层中还占有一定比例，未来的话这个比例估计会越来越低，最明显的是今年（2017）的高考状元，没有一个农村出身（网上的新闻），虽然这个并不能完全反映，但至少间接地反映了一些问题。</p>
<p>回到本文的主题 —- 房子，现在普遍有一种说法，想在北京扎根，家庭至少要能提供 200w 资金，要不然几乎不太有可能在北京扎根，昌平顺义的房子现在都已经 4w+ 了，离地铁近的恐怕都得 5w+，一般家庭的人如何负担得起。在去库存的这一历史进程中，一二城市的房价都已经翻倍，没有房子的人，相当于自己的财富被洗劫了一番，因为他并没有增加任何财富，而自己未来购房的成本却翻了不止一倍。对于普通人，尤其是来自农村家庭的孩子，感觉未来真的很难在一二线城市扎根，农村的孩子受到的教育本来就比城市差一些，而且父母管教得也不多，如果这些孩子再不知道努力的话，他们以后如何突破？甚至有可能会导致一个恶性循环，就像美国贫民区一样。</p>
<p>以前的时候在政治、历史书老是看到什么农民阶级的愚昧无知，鲁迅先生经常就会批判，因为自己出身于农村，每次回到家里，其实都能明显感觉到这一点，他们对于很多新鲜的事务都不是很了解、不懂理财不懂投资、更不懂得去投资自己，想想这样教育出来好孩子的几率有多大？成长的环境、父母的局限性对孩子性格、思维的培养影响是很大的，可是又能怎么办？这些父母可能并不知道未来他们孩子的竞争压力有多大，今年一个高考状元的采访，大概就是说：自己在城市长大，能接触到更好的学习方法、教育资源，而且父母对自己教育也非常上心，但农村孩子，很多人大学之前可能连电脑都没摸过，很难跟这些城市的孩子去竞争。唉，这就是残酷的现实，未来随着更多人去二线城市扎根，相信二线城市的房价还会再上升一部分，而这些想二线城市扎根的人付出的成本将会更大，给寒门出身的孩子们，留得机会并不多了，希望他们都能努力些。</p>
<h2 id="杂想"><a href="#杂想" class="headerlink" title="杂想"></a>杂想</h2><p>想想自己有了孩子之后，可能要为孩子牺牲很多，然后去慢慢培养孩子，等孩子长大后孩子在接着重复着我之前的生活，那人生的意义到底在哪里？仅仅为了繁衍么？近段在看《未来简史》，现在人文主义主宰世界，犹如之前宗教之于世界，人类不断为自己的生命寻找意义，以前我们认为自己是上帝伟大计划的一部分，这就是我们人类的全部意义，可是现在，估计很少有人相信这些，每个人都在寻找自己的信仰——follow your heart，都在试图找寻自己人生的意义。每当想到这些，看到那些为了孩子牺牲自己很多的父母时，我感觉到很可悲，这样的人生意义在哪里？以前很不明白为什么这样，现在有些明白了，但这完全不是我想要的生活。之前网上听到北京四中的校长讲到：一个为孩子付出一切的家庭，最后得到的往往是悲剧。这句话用在农村里，真的不为过，我们这代人，父母多生于文革年代，记事时赶上了恢复高考、改革开放，村里抓住机会的那批人已经在一站二线城市扎根，有的甚至已经在国外定居，每个乡每个镇多多少少都会有这样的人，这些走出去的人现在被称为当今社会的精英阶层，能走去的这些人大部分靠得都是高考，少数靠得是头脑和商机，他们的生活让依然生活在农村的父母一代羡慕。有长远眼光的父母就会从小对孩子管理严格，教育上投入更大，当然，在农村，投入更大也只是意味着找关系送礼上个当地更好的学校，最多寒暑假再上个补习班，幸运的是，我的父母属于这一类，父母一直希望我能走出农村，虽然他们只是初中文凭，但他们知道未来没有学历没有知识在这个社会很难有好的出路，打我记事开始，父母工作就很努力（在镇上做小生意），他们希望的是当我未来买房或者结婚的时候，能给我提供更大的支持，希望我能在二线甚至一线生存下去，非常感谢自己的父母，这么多年来，父母对自己默默付出了那么多。现在每次看到曾经的小学同学早已结婚生子，现在很多都在大城市里打工，在农村，如果没有考上大学，大部分走的都是这条路，这种生活明显不是我想要的生活，但是少年时代的自己并不知道这些、并不知道什么是自己想要的什么不是自己想要的，很幸运自己能够考上大学，走了农村孩子的另外一条路。而大部分的农村孩子并没有这种幸运，当然也有一些孩子，父母不怎么管教最后走出了一条很好的路，一是这种孩子较少，另一个是一个孩子性格的养成离不开其生活环境，父母在教育上没有管理太多，但在其他方面（隐性方面）对孩子的投入不见得小，这种孩子也很幸运，因为他们进入了一个正循环中，但是最多的那种，是没有考上大学而父母也没有为其提供一个很好出路的农村孩子，他们父母在孩子的投入不见得比别的孩子少，但结果并不如想象的那样，这中间有个体差异的原因，但是更多的是可悲、是无可奈何、或者说是不公平，这些孩子跟城里孩子是一样的，然而不同的生活环境造就了不同的人生路径，出身对一个人的影响有多大是不言而喻的，正所谓橘生淮南则为橘、橘生淮北则为枳。BBC有个纪录片叫做《七年》，有兴趣的朋友可以看一下，让人生走向一个正循环多么重要，而一个社会底层的人要想让人生走向正循环比例很低，中产阶级的孩子比例会大很多倍，这些中产阶级的孩子从小会接受更好的教育，成长的环境也比农村孩子强太多倍，但未来这些孩子们都将在同一个赛道上竞争，公平在这里显得苍白无力，随着经济的发展，更多私立中小学的兴起，公平又会从何而来？内心感觉很悲凉，可又无可奈何，未来自己终究也会走入这样的漩涡，明知不知道自己想要的生活，但又无法摆脱这种束缚，当想到这时，就会不由自主地去质疑人生的意义何在？《未来简史》没有告诉我答案，有信仰的人为自己的信仰而生，而我这种没有信仰的人却又当如何？为房子而活？为未来的孩子而活？为家庭而活？这都不是我想要的答案，为民族而活这句话说出来我自己都不相信，这些都不是我人生的意义，但又该是什么呢？我自己现在也不知道，但我会不停地去寻找答案。</p>
<h2 id="杭州看房的一些建议"><a href="#杭州看房的一些建议" class="headerlink" title="杭州看房的一些建议"></a>杭州看房的一些建议</h2><p>最后，再说一下买房的一些建议吧，杭州看房的话，有两个网站比较推荐：</p>
<ol>
<li>透明房，新房的最新消息，预售证信息、备案家都会在这个网站发布；</li>
<li>口水楼市，杭州方式论坛楼盘的论坛，有很多重要信息。</li>
</ol>
<p>我在看房的时候，主要记录以下这些信息，大家可以自行参考，选择自己认为比较重要的部分。</p>
<table>
<thead>
<tr>
<th>楼盘名</th>
<th>板块</th>
<th>状态</th>
<th>单价（中间套/边套）</th>
<th>面积</th>
<th>大概总价</th>
<th>得房率</th>
<th>交房时间</th>
<th>精装/毛坯</th>
<th>楼盘优惠</th>
<th>地铁（规划）</th>
<th>幼儿园</th>
<th>小学</th>
</tr>
</thead>
<tbody>
<tr>
<td>滨江旭辉·万家之星</td>
<td>勾庄北、拱辰北</td>
<td>目前还有三幢等待开售，预计价格是2.1-2.2万</td>
<td>2.2万</td>
<td>89 平</td>
<td>195w</td>
<td>-</td>
<td>-</td>
<td>毛坯</td>
<td>-</td>
<td>4号线</td>
<td>良渚通运幼儿园(公办)、勾庄中心幼儿园(公办)、12班幼儿园(规划)</td>
<td>运河小学(在建)、良渚二小运河校区</td>
</tr>
<tr>
<td>海德公园</td>
<td>勾庄北、拱辰北</td>
<td>开盘都已经卖完，下个月会在开盘一幢</td>
<td>~</td>
<td>83、89平</td>
<td>-</td>
<td>76%</td>
<td>2019年中旬交付</td>
<td>毛坯</td>
<td>-</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>最后，这篇文章是在杭州回北京的火车上完成的，这一路真的是感慨颇多，文章也如流水账一番，逻辑性不是很强，或许几年之后回头再看，就会嘲笑自己当年怎么这么无知。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;落户+买房的事情终于搞定得差不多了（就差贷款合同的签署），六月份这个月已经往来杭州3趟，从四月底开始看房到现在，这一路真是五味杂粮、感慨颇多，亲身地感觉到生活之不易，无忧无虑的生活从离开大学的那一刻开始就已经结束，读研这两年半看似浑浑噩噩，但早已没有大学时的那种轻松惬意，或
    
    </summary>
    
      <category term="随笔" scheme="http://matt33.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://matt33.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 Producer 发送模型（一）</title>
    <link href="http://matt33.com/2017/06/25/kafka-producer-send-module/"/>
    <id>http://matt33.com/2017/06/25/kafka-producer-send-module/</id>
    <published>2017-06-25T04:53:39.000Z</published>
    <updated>2017-06-25T15:06:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>早就开始计划写 Kafka 源码分析的文章，但却一直迟迟没有动手，直到看到一位同事的博客 <a href="http://blog.bcmeng.com/" target="_blank" rel="external">编程小梦</a>，彻底受到了打击，这位同事是去年本科毕业，年龄算起来应该比我小两岁，但是非常厉害，在刚工作半年的时候就成为了 Apache Kylin 的 commiter，看到身边同事这么优秀，而且还这么努力 （<a href="http://blog.bcmeng.com/post/booklist.html" target="_blank" rel="external">编程小梦-我的书单</a>），自己实在没有理由不努力了，因此，在 github 上给自己提了一个 issue <a href="https://github.com/wangzzu/awesome/issues/7" target="_blank" rel="external">Kafka 源码分析系列</a>，希望自己能够在未来半年里，至少每两周输出一篇 Kafka 源码分析的文章，本文是这个系列的第一篇 —— Producer 的发送模型（以 <strong>Kafka 0.10.2</strong> 为例）。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kafka，作为目前在大数据领域应用最为广泛的消息队列，其内部实现和设计有很多值得深入研究和分析的地方。</p>
<p>再 0.10.2 的 Kafka 中，其 Client 端是由 Java 实现，Server 端是由 Scala 来实现的，在使用 Kafka 时，Client 是用户最先接触到部分，因此，计划写的源码分析也会从 Client 端开始，会先从 Producer 端开始，今天讲的是 Producer 端的发送模型的实现。</p>
<h1 id="Producer-使用"><a href="#Producer-使用" class="headerlink" title="Producer 使用"></a>Producer 使用</h1><p>在分析 Producer 发送模型之前，先看一下用户是如何使用 Producer 向 Kafka 写数据的，下面是一个关于 Producer 最简单的应用示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/7/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String topicName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> msgNum;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> key;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:9092,127.0.0.2:9092"</span>);</div><div class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line"></div><div class="line">        topicName = <span class="string">"test"</span>;</div><div class="line">        msgNum = <span class="number">10</span>; <span class="comment">// 发送的消息数</span></div><div class="line"></div><div class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; msgNum; i++) &#123;</div><div class="line">            String msg = i + <span class="string">" This is matt's blog."</span>;</div><div class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topicName, msg));</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出 Kafka 为用户提供了非常简单的 API，在使用时，只需要如下两步：</p>
<ol>
<li>初始化 <code>KafkaProducer</code> 实例；</li>
<li>调用 <code>send</code> 接口发送数据。</li>
</ol>
<p>本文主要是围绕着 Producer 在内部是如何实现 <code>send</code> 接口而展开的。</p>
<h1 id="Producer-数据发送流程"><a href="#Producer-数据发送流程" class="headerlink" title="Producer 数据发送流程"></a>Producer 数据发送流程</h1><p>下面通过对 <code>send</code> 源码分析来一步步剖析 Producer 数据的发送流程。</p>
<h2 id="Producer-的-send-实现"><a href="#Producer-的-send-实现" class="headerlink" title="Producer 的 send 实现"></a>Producer 的 send 实现</h2><p>用户是直接使用 <code>producer.send()</code> 发送的数据，先看一下 <code>send()</code> 接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步向一个 topic 发送数据</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> send(record, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向 topic 异步地发送数据，当发送确认后唤起回调函数</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</div><div class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></div><div class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? record : <span class="keyword">this</span>.interceptors.onSend(record);</div><div class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据发送的最终实现还是调用了 Producer 的 <code>doSend()</code> 接口。</p>
<h2 id="Producer-的-doSend-实现"><a href="#Producer-的-doSend-实现" class="headerlink" title="Producer 的 doSend 实现"></a>Producer 的 doSend 实现</h2><p>下面是 <code>doSend()</code> 的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</div><div class="line">       TopicPartition tp = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 1.确认数据要发送到的 topic 的 metadata 是可用的</span></div><div class="line">           ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</div><div class="line">           <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</div><div class="line">           Cluster cluster = clusterAndWaitTime.cluster;</div><div class="line">           <span class="comment">// 2.序列化 record 的 key 和 value</span></div><div class="line">           <span class="keyword">byte</span>[] serializedKey;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               serializedKey = keySerializer.serialize(record.topic(), record.key());</div><div class="line">           &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert key of class "</span> + record.key().getClass().getName() +</div><div class="line">                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</div><div class="line">                       <span class="string">" specified in key.serializer"</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">byte</span>[] serializedValue;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               serializedValue = valueSerializer.serialize(record.topic(), record.value());</div><div class="line">           &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert value of class "</span> + record.value().getClass().getName() +</div><div class="line">                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</div><div class="line">                       <span class="string">" specified in value.serializer"</span>);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 3. 获取该 record 的 partition 的值（可以指定,也可以根据算法计算）</span></div><div class="line">           <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</div><div class="line">           <span class="keyword">int</span> serializedSize = Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);</div><div class="line">           ensureValidRecordSize(serializedSize); <span class="comment">// record 的字节超出限制或大于内存限制时,就会抛出 RecordTooLargeException 异常</span></div><div class="line">           tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</div><div class="line">           <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp(); <span class="comment">// 时间戳</span></div><div class="line">           log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</div><div class="line">           Callback interceptCallback = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? callback : <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</div><div class="line">           <span class="comment">// 4. 向 accumulator 中追加数据</span></div><div class="line">           RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);</div><div class="line">           <span class="comment">// 5. 如果 batch 已经满了,唤醒 sender 线程发送数据</span></div><div class="line">           <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</div><div class="line">               log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</div><div class="line">               <span class="keyword">this</span>.sender.wakeup();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> result.future;</div><div class="line">       &#125; <span class="keyword">catch</span> (ApiException e) &#123;</div><div class="line">           log.debug(<span class="string">"Exception occurred during message send:"</span>, e);</div><div class="line">           <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</div><div class="line">               callback.onCompletion(<span class="keyword">null</span>, e);</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> FutureFailure(e);</div><div class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptException(e);</div><div class="line">       &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">this</span>.metrics.sensor(<span class="string">"buffer-exhausted-records"</span>).record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在 <code>dosend()</code> 方法的实现上，一条 Record 数据的发送，可以分为以下五步：</p>
<ol>
<li>确认数据要发送到的 topic 的 metadata 是可用的（如果该 partition 的 leader 存在则是可用的，如果开启权限时，client 有相应的权限），如果没有 topic 的 metadata 信息，就需要获取相应的 metadata；</li>
<li>序列化 record 的 key 和 value；</li>
<li>获取该 record 要发送到的 partition（可以指定，也可以根据算法计算）；</li>
<li>向 accumulator 中追加 record 数据，数据会先进行缓存；</li>
<li>如果追加完数据后，对应的 RecordBatch 已经达到了 batch.size 的大小（或者batch 的剩余空间不足以添加下一条 Record），则唤醒 <code>sender</code> 线程发送数据。</li>
</ol>
<p>数据的发送过程，可以简单总结为以上五点，下面会这几部分的具体实现进行详细分析。</p>
<h1 id="发送过程详解"><a href="#发送过程详解" class="headerlink" title="发送过程详解"></a>发送过程详解</h1><h2 id="获取-topic-的-metadata-信息"><a href="#获取-topic-的-metadata-信息" class="headerlink" title="获取 topic 的 metadata 信息"></a>获取 topic 的 metadata 信息</h2><p>Producer 通过 <code>waitOnMetadata()</code> 方法来获取对应 topic 的 metadata 信息，这部分后面会单独抽出一篇文章来介绍，这里就不再详述，总结起来就是：在数据发送前，需要先该 topic 是可用的。</p>
<h2 id="key-和-value-的序列化"><a href="#key-和-value-的序列化" class="headerlink" title="key 和 value 的序列化"></a>key 和 value 的序列化</h2><p>Producer 端对 record 的 <code>key</code> 和 <code>value</code> 值进行序列化操作，在 Consumer 端再进行相应的反序列化，Kafka 内部提供的序列化和反序列化算法如下图所示：</p>
<p><img src="/images/kafka/serialize.png" alt="Kafka serialize &amp; deserialize"></p>
<p>当然我们也是可以自定义序列化的具体实现，不过一般情况下，Kafka 内部提供的这些方法已经足够使用。</p>
<h2 id="获取-partition-值"><a href="#获取-partition-值" class="headerlink" title="获取 partition 值"></a>获取 partition 值</h2><p>关于 partition 值的计算，分为三种情况：</p>
<ol>
<li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li>
<li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</li>
<li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 <code>round-robin</code> 算法。</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当 record 中有 partition 值时，直接返回，没有的情况下调用 partitioner 的类的 partition 方法去计算（KafkaProducer.class）</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</div><div class="line">    Integer partition = record.partition();</div><div class="line">    <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</div><div class="line">            partition :</div><div class="line">            partitioner.partition(</div><div class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Producer 默认使用的 <code>partitioner</code> 是 <code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>，用户也可以自定义 partition 的策略，下面是这个类两个方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</div><div class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</div><div class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</div><div class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;<span class="comment">// 没有指定 key 的情况下</span></div><div class="line">            <span class="keyword">int</span> nextValue = nextValue(topic); <span class="comment">// 第一次的时候产生一个随机整数,后面每次调用在之前的基础上自增;</span></div><div class="line">            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</div><div class="line">            <span class="comment">// leader 不为 null,即为可用的 partition</span></div><div class="line">            <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</div><div class="line">                <span class="keyword">return</span> availablePartitions.get(part).partition();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 有 key 的情况下,使用 key 的 hash 值进行计算</span></div><div class="line">            <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; <span class="comment">// 选择 key 的 hash 值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据 topic 获取对应的整数变量</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</div><div class="line">        AtomicInteger counter = topicCounterMap.get(topic);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == counter) &#123; <span class="comment">// 第一次调用时，随机产生</span></div><div class="line">            counter = <span class="keyword">new</span> AtomicInteger(<span class="keyword">new</span> Random().nextInt());</div><div class="line">            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);</div><div class="line">            <span class="keyword">if</span> (currentCounter != <span class="keyword">null</span>) &#123;</div><div class="line">                counter = currentCounter;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter.getAndIncrement(); <span class="comment">// 后面再调用时，根据之前的结果自增</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这就是 Producer 中默认的 partitioner 实现。</p>
<h2 id="向-accumulator-写数据"><a href="#向-accumulator-写数据" class="headerlink" title="向 accumulator 写数据"></a>向 accumulator 写数据</h2><p>Producer 会先将 record 写入到 buffer 中，当达到一个 <code>batch.size</code> 的大小时，再唤起 <code>sender</code> 线程去发送 <code>RecordBatch</code>（第五步），这里先详细分析一下 Producer 是如何向 buffer 中写入数据的。</p>
<p>Producer 是通过 <code>RecordAccumulator</code> 实例追加数据，<code>RecordAccumulator</code> 模型如下图所示，一个重要的变量就是 <code>ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches</code>，每个 <code>TopicPartition</code> 都会对应一个 <code>Deque&lt;RecordBatch&gt;</code>，当添加数据时，会向其 topic-partition 对应的这个 queue 最新创建的一个 <code>RecordBatch</code> 中添加 record，而发送数据时，则会先从 queue 中最老的那个 <code>RecordBatch</code> 开始发送。</p>
<p><img src="/images/kafka/recordbatch.png" alt="Producer RecordAccumulator 模型"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// org.apache.kafka.clients.producer.internals.RecordAccumulator</span></div><div class="line">     <span class="comment">// 向 accumulator 添加一条 record，并返回添加后的结果（结果主要包含: future metadata、batch 是否满的标志以及新 batch 是否创建）其中， maxTimeToBlock 是 buffer.memory 的 block 的最大时间</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></div><div class="line">                                     <span class="keyword">long</span> timestamp,</div><div class="line">                                     <span class="keyword">byte</span>[] key,</div><div class="line">                                     <span class="keyword">byte</span>[] value,</div><div class="line">                                     Callback callback,</div><div class="line">                                     <span class="keyword">long</span> maxTimeToBlock) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        appendsInProgress.incrementAndGet();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Deque&lt;RecordBatch&gt; dq = getOrCreateDeque(tp);<span class="comment">// 每个 topicPartition 对应一个 queue</span></div><div class="line">            <span class="keyword">synchronized</span> (dq) &#123;<span class="comment">// 在对一个 queue 进行操作时,会保证线程安全</span></div><div class="line">                <span class="keyword">if</span> (closed)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</div><div class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq); <span class="comment">// 追加数据</span></div><div class="line">                <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)<span class="comment">// 这个 topic-partition 已经有记录了</span></div><div class="line">                    <span class="keyword">return</span> appendResult;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 为 topic-partition 创建一个新的 RecordBatch, 需要初始化相应的 RecordBatch，要为其分配的大小是: max（batch.size, 加上头文件的本条消息的大小）</span></div><div class="line">            <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</div><div class="line">            log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</div><div class="line">            ByteBuffer buffer = free.allocate(size, maxTimeToBlock);<span class="comment">// 给这个 RecordBatch 初始化一个 buffer</span></div><div class="line">            <span class="keyword">synchronized</span> (dq) &#123;</div><div class="line">                <span class="keyword">if</span> (closed)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</div><div class="line"></div><div class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq);</div><div class="line">                <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;<span class="comment">// 如果突然发现这个 queue 已经存在，那么就释放这个已经分配的空间</span></div><div class="line">                    free.deallocate(buffer);</div><div class="line">                    <span class="keyword">return</span> appendResult;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 给 topic-partition 创建一个 RecordBatch</span></div><div class="line">                MemoryRecordsBuilder recordsBuilder = MemoryRecords.builder(buffer, compression, TimestampType.CREATE_TIME, <span class="keyword">this</span>.batchSize);</div><div class="line">                RecordBatch batch = <span class="keyword">new</span> RecordBatch(tp, recordsBuilder, time.milliseconds());</div><div class="line">                <span class="comment">// 向新的 RecordBatch 中追加数据</span></div><div class="line">                FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</div><div class="line"></div><div class="line">                dq.addLast(batch);<span class="comment">// 将 RecordBatch 添加到对应的 queue 中</span></div><div class="line">                incomplete.add(batch);<span class="comment">// 向未 ack 的 batch 集合添加这个 batch</span></div><div class="line">                <span class="comment">// 如果 dp.size()&gt;1 就证明这个 queue 有一个 batch 是可以发送了</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            appendsInProgress.decrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>总结一下其 record 写入的具体流程如下图所示：</p>
<p><img src="/images/kafka/RecordBatch_append.png" alt="Producer RecordAccumulator record 写入流程"></p>
<ol>
<li>获取该 topic-partition 对应的 queue，没有的话会创建一个空的 queue；</li>
<li>向 queue 中追加数据，先获取 queue 中最新加入的那个 <code>RecordBatch</code>，如果不存在或者存在但剩余空余不足以添加本条 record 则返回 null，成功写入的话直接返回结果，写入成功；</li>
<li>创建一个新的 <code>RecordBatch</code>，初始化内存大小根据 <code>max(batch.size, Records.LOG_OVERHEAD + Record.recordSize(key, value))</code> 来确定（防止单条 record 过大的情况）；</li>
<li>向新建的 <code>RecordBatch</code> 写入 record，并将 <code>RecordBatch</code> 添加到 queue 中，返回结果，写入成功。</li>
</ol>
<h2 id="发送-RecordBatch"><a href="#发送-RecordBatch" class="headerlink" title="发送 RecordBatch"></a>发送 RecordBatch</h2><p>当 record 写入成功后，如果发现 <code>RecordBatch</code> 已满足发送的条件（通常是 queue 中有多个 batch，那么最先添加的那些 batch 肯定是可以发送了），那么就会唤醒 <code>sender</code> 线程，发送 <code>RecordBatch</code>。</p>
<p><code>sender</code> 线程对 <code>RecordBatch</code> 的处理是在 <code>run()</code> 方法中进行的，该方法具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        Cluster cluster = metadata.fetch();</div><div class="line">        <span class="comment">// 获取那些已经可以发送的 RecordBatch 对应的 nodes</span></div><div class="line">        RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</div><div class="line"></div><div class="line">        <span class="comment">// 如果有 topic-partition 的 leader 是未知的,就强制 metadata 更新</span></div><div class="line">        <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</div><div class="line">            <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</div><div class="line">                <span class="keyword">this</span>.metadata.add(topic);</div><div class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果与node 没有连接（如果可以连接,同时初始化该连接）,就证明该 node 暂时不能发送数据,暂时移除该 node</span></div><div class="line">        Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</div><div class="line">        <span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Node node = iter.next();</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</div><div class="line">                iter.remove();</div><div class="line">                notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.connectionDelay(node, now));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 返回该 node 对应的所有可以发送的 RecordBatch 组成的 batches（key 是 node.id）,并将 RecordBatch 从对应的 queue 中移除</span></div><div class="line">        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="keyword">this</span>.maxRequestSize, now);</div><div class="line">        <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</div><div class="line">            <span class="comment">//记录将要发送的 RecordBatch</span></div><div class="line">            <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</div><div class="line">                <span class="keyword">for</span> (RecordBatch batch : batchList)</div><div class="line">                    <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将由于元数据不可用而导致发送超时的 RecordBatch 移除</span></div><div class="line">        List&lt;RecordBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.abortExpiredBatches(<span class="keyword">this</span>.requestTimeout, now);</div><div class="line">        <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</div><div class="line">            <span class="keyword">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</div><div class="line"></div><div class="line">        sensors.updateProduceRequestMetrics(batches);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</div><div class="line">        <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</div><div class="line">            log.trace(<span class="string">"Nodes with data ready to send: &#123;&#125;"</span>, result.readyNodes);</div><div class="line">            pollTimeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 发送 RecordBatch</span></div><div class="line">        sendProduceRequests(batches, now);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.client.poll(pollTimeout, now); <span class="comment">// 关于 socket 的一些实际的读写操作（其中包括 meta 信息的更新）</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码前面有很多是其他的逻辑处理，如：移除暂时不可用的 node、处理由于元数据不可用导致的超时 <code>RecordBatch</code>，真正进行发送发送 <code>RecordBatch</code> 的是 <code>sendProduceRequests(batches, now)</code> 这个方法，具体是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Transfer the record batches into a list of produce requests on a per-node basis</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequests</span><span class="params">(Map&lt;Integer, List&lt;RecordBatch&gt;&gt; collated, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;RecordBatch&gt;&gt; entry : collated.entrySet())</div><div class="line">        sendProduceRequest(now, entry.getKey(), acks, requestTimeout, entry.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a produce request from the given record batches</div><div class="line"> */</div><div class="line"><span class="comment">// 发送 produce 请求</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequest</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">int</span> destination, <span class="keyword">short</span> acks, <span class="keyword">int</span> timeout, List&lt;RecordBatch&gt; batches)</span> </span>&#123;</div><div class="line">    Map&lt;TopicPartition, MemoryRecords&gt; produceRecordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</div><div class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, RecordBatch&gt; recordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</div><div class="line">    <span class="keyword">for</span> (RecordBatch batch : batches) &#123;</div><div class="line">        TopicPartition tp = batch.topicPartition;</div><div class="line">        produceRecordsByPartition.put(tp, batch.records());</div><div class="line">        recordsByPartition.put(tp, batch);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ProduceRequest.Builder requestBuilder =</div><div class="line">            <span class="keyword">new</span> ProduceRequest.Builder(acks, timeout, produceRecordsByPartition);</div><div class="line">    RequestCompletionHandler callback = <span class="keyword">new</span> RequestCompletionHandler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(ClientResponse response)</span> </span>&#123;</div><div class="line">            handleProduceResponse(response, recordsByPartition, time.milliseconds());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    String nodeId = Integer.toString(destination);</div><div class="line">    ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != <span class="number">0</span>, callback);</div><div class="line">    client.send(clientRequest, now);</div><div class="line">    log.trace(<span class="string">"Sent produce request to &#123;&#125;: &#123;&#125;"</span>, nodeId, requestBuilder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码就简单很多，总来起来就是，将 <code>batches</code> 中 leader 为同一个 node 的所有 RecordBatch 放在一个请求中进行发送。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文是对 Kafka Producer 端发送模型的一个简单分析，下一篇文章将会详细介绍 metadata 相关的内容，包括 metadata 的内容以及在 Producer 端 metadata 的更新机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就开始计划写 Kafka 源码分析的文章，但却一直迟迟没有动手，直到看到一位同事的博客 &lt;a href=&quot;http://blog.bcmeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;编程小梦&lt;/a&gt;，彻底受到了打击，这位同事是去年本科毕
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>CSS 一些常用方法的总结</title>
    <link href="http://matt33.com/2017/06/21/css-summary/"/>
    <id>http://matt33.com/2017/06/21/css-summary/</id>
    <published>2017-06-20T17:03:30.000Z</published>
    <updated>2017-06-20T17:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 指的是层叠样式表（Cascading StyleSheet），在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制，本文对 css 一些基本内容及常用功能进行一下总结，总结的内容主要是来自实验楼的 <a href="https://www.shiyanlou.com/courses/53" target="_blank" rel="external">CSS 速成教程</a>，这篇文章会实时更新，后续如果遇到什么好的有用功能，也会更新到这篇文章中。</p>
<h1 id="css-基础语法"><a href="#css-基础语法" class="headerlink" title="css 基础语法"></a>css 基础语法</h1><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">selector &#123;</div><div class="line">    declaration1;</div><div class="line">    declaration2;</div><div class="line">    ...</div><div class="line">    declarationN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择器通常是需要改变的 HTML 元素，每条声明都由一个属性和一个值组成，每个属性都有一个值，属性和值被冒号分开。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">   <span class="attribute">color</span>:red;</div><div class="line">   <span class="attribute">font-size</span>:<span class="number">14px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="css-基本样式"><a href="#css-基本样式" class="headerlink" title="css 基本样式"></a>css 基本样式</h1><p>介绍 css 的一些基本样式，这些都是 css 中一些常用的设置。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>css 是允许使用纯色作为背景，也允许使用背景图像实现一些相当复杂的效果。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-attachment</td>
<td>背景图像是否固定或者随着页面的其余部分滚动</td>
</tr>
<tr>
<td>background-color</td>
<td>设置元素的背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>把图片设置为背景</td>
</tr>
<tr>
<td>background-position</td>
<td>设置背景图片的起始位置</td>
</tr>
<tr>
<td>background-repeat</td>
<td>设置背景图片是否及如何重复，其中，<code>no-repeat</code>：表示不能重复，<code>repeat</code>：可重复（默认值），<code>repeat-x</code>：表示 x 轴重复，<code>repeat-y</code>：表示 y 轴重</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
</tbody>
</table>
<p>举个例子，如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">   background-color: red;</div><div class="line">   background-image: url("hha.jpg");</div><div class="line">   background-repeat: no-repeat;</div><div class="line">   background-position: center top;</div><div class="line">   background-attachment: fixed;</div><div class="line">   background-size：100px 100px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p&#123;</div><div class="line">    width: 150px;</div><div class="line">    padding: 10px;</div><div class="line">    background-color: #0014ff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果如下下图所示：</p>
<p><img src="/images/web/css1.png" alt="效果图"></p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>css 文本可定义文本的外观，通过文本的属性，可以改变文本的颜色、字符间距、对齐方式等等。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>文本颜色</td>
</tr>
<tr>
<td>direction</td>
<td>文本方向</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字符间距</td>
</tr>
<tr>
<td>text-align</td>
<td>对齐元素中的文本，可选择 left、right 和 center</td>
</tr>
<tr>
<td>text-decoration</td>
<td>向文本添加修饰</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进元素中文本的首行</td>
</tr>
<tr>
<td>text-transform</td>
<td>元素中的字母</td>
</tr>
<tr>
<td>unicode-bidi</td>
<td>设置文本方向</td>
</tr>
<tr>
<td>white-space</td>
<td>元素中空白的处理方式</td>
</tr>
<tr>
<td>word-spacing</td>
<td>字间距</td>
</tr>
</tbody>
</table>
<p>应用时，可以进行以下设置</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">   <span class="attribute">color</span>: red;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>: <span class="number">5em</span>;&#125;</div></pre></td></tr></table></figure>
<p>在网页展现时，标签 <code>body</code> 和 <code>p</code> 中元素就会按照设置进行显示。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在 css 的链接属性中，可以对其颜色、字体、背景进行相应的设置，不同的状态我们可以设置对应的样式。</p>
<h3 id="4种链接状态"><a href="#4种链接状态" class="headerlink" title="4种链接状态"></a>4种链接状态</h3><p>css 共有以下几种链接状态：</p>
<ol>
<li><code>a:link</code>：普通的、未被访问的链接；</li>
<li><code>a:visited</code>：用户已访问的链接；</li>
<li><code>a:hover</code>：鼠标指针位于链接的上方；</li>
<li><code>a:active</code>：链接被点击的时刻。</li>
</ol>
<p>在进行设置中，有以下两种要求：</p>
<ul>
<li><code>a:hover</code> 必须位于 <code>a:link</code> 和 <code>a:visited</code> 之后；</li>
<li><code>a:active</code> 必须位于 <code>a:hover</code> 之后。</li>
</ul>
<h3 id="修改链接下划线"><a href="#修改链接下划线" class="headerlink" title="修改链接下划线"></a>修改链接下划线</h3><p>只需要在链接属性中添加 <code>text-decoration</code> 属性，将对应的值设置为空即可。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>:<span class="number">#B2FF99</span>;</div><div class="line">    <span class="attribute">text-decoration</span>:none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FFFF85</span>;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</div></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在 html 中学习过列表的一些设置，这里主要讲述的是如何通过 css 进行列表的设置。</p>
<h3 id="简单的列表类型"><a href="#简单的列表类型" class="headerlink" title="简单的列表类型"></a>简单的列表类型</h3><p>列表有无序、有序之分，无序列表又可以用不同的标记来区分，而 <code>list-style-type</code> 这个属性我们就可以用来控制标记类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* html 中添加以下内容 */</div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>wawa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">olclass="square"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>wawa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">/* css 中的设置 */</div><div class="line">ul.circle &#123;list-style-type:circle&#125;</div><div class="line">ol.square &#123;list-style-type:upper-roman&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="列表项图片"><a href="#列表项图片" class="headerlink" title="列表项图片"></a>列表项图片</h3><p>在无序列表中，除了进行一些默认的设置外，并没有其他可选的内容，但是 css 可以提供图片来作为标记。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.img1</span>&#123;<span class="attribute">list-style-image</span>:<span class="built_in">url</span>(<span class="string">"1.ico"</span>)&#125;</div></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在 css 表格的设置中，需要先了解一下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-collapse</td>
<td>设置是否把表格边框合并为单一的边框</td>
</tr>
<tr>
<td>border-spacing</td>
<td>设置分隔单元格边框的距离。</td>
</tr>
<tr>
<td>caption-side</td>
<td>设置表格标题的位置。</td>
</tr>
<tr>
<td>empty-cells</td>
<td>设置是否显示表格中的空单元格。</td>
</tr>
<tr>
<td>table-layout</td>
<td>设置显示单元、行和列的算法。</td>
</tr>
</tbody>
</table>
<p>这里也以一个例子来说明：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"tb"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>number<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"tr2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"tr2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* css 部分*/</span></div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span>&#123;</div><div class="line">    <span class="attribute">border-collapse</span>: collapse;</div><div class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">th</span>&#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">background-color</span>: lightseagreen;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">tr</span><span class="selector-class">.tr2</span> <span class="selector-tag">td</span>&#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#B2FF99</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下图</p>
<p><img src="/images/web/css3.png" alt="效果图"></p>
<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。CSS outline 属性规定元素轮廓的样式、颜色和宽度。涉及到的属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>outline</td>
<td>在一个声明中设置所有的轮廓属性。</td>
</tr>
<tr>
<td>outline-color</td>
<td>设置轮廓的颜色.</td>
</tr>
<tr>
<td>outline-style</td>
<td>设置轮廓的样式。</td>
</tr>
<tr>
<td>outline-width</td>
<td>设置轮廓的宽度。</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span>This is mtt's blog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">#p1&#123;</div><div class="line">    outline-color: #FF704D;</div><div class="line">    outline-style: groove;</div><div class="line">    outline-width: 10px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#p2&#123;</div><div class="line">    outline-style: dotted;</div><div class="line">    outline-color: green;</div><div class="line">    outline-width: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下图所示：</p>
<p><img src="/images/web/css2.png" alt="效果图"></p>
<h1 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h1><p>选择器是 css 中最常用的组件，本节就介绍一下 css 中最常见的几种选择器。</p>
<h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><p>最常见的选择器就是元素选择器，文档的元素的就是最基本的选择器。比如<code>h1</code>、<code>a</code>等，在 css 中可以这样实现：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*第一种，直接对某个元素进行相应的设置*/</span></div><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第二种，对多个元素执行同样的操作*/</span></div><div class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第三种，对没有特别特定元素设置的元素都执行同样的操作（除 h4外，其他执行的操作都一样）*/</span></div><div class="line">*&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h4</span>&#123;</div><div class="line">    <span class="attribute">color</span>: darkslategray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器允许以一种独立与文档元素的方式来制定样式。<code>.class{}</code> 这是类选择器的标志，点后面是属性名，大括号里面就是具体的设置，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*第一种，最简单的使用方法*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;div class="div"&gt;matt&lt;/div&gt; */</span></div><div class="line"><span class="selector-class">.div</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第二种，将类选择器结合元素选择器来使用，下面的例子这个 .div 就只会对 h1 起作用*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;h1 class="div"&gt;matt&lt;/div&gt; */</span></div><div class="line"><span class="selector-tag">h1</span><span class="selector-class">.div</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第三种，多类选择器（.class.class&#123;&#125;），它可以继承多个类的作用*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;p class="p1 p2"&gt;shiyanlou is my home&lt;/p&gt; */</span></div><div class="line"><span class="selector-class">.p1</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.p1</span><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">font-style</span>: italic;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h2><p>id 选择器类似于类选择器，id 选择器的引入是用<code>#</code>，就和类选择器的<code>.</code>是一样的效果，它与类选择器的区别是：</p>
<ul>
<li>id 顾名思义只能在文档中使用一次，而类可以使用多次；</li>
<li>id 选择器不能像刚才类选择器一样结合使用。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* html 中的用法 */</div><div class="line">&lt;p id="div"&gt;matt's blog&lt;/p&gt;</div><div class="line"></div><div class="line">/* css 中的配置*/</div><div class="line">#div&#123;</div><div class="line">    color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>对带有指定属性的 HTML 元素设置样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 第一种，对带有 title 属性的所有元素设置样式 */</span></div><div class="line"><span class="selector-attr">[title]</span> &#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 第二种，为 title="te" 的所有元素设置样式 */</span></div><div class="line"><span class="selector-attr">[title=te]</span>&#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 第三种，为 href="http://matt33.com" 的标签 a 设置元素样式 */</span></div><div class="line"><span class="comment">/* 调用方式：&lt;a href="http://matt33.com"&gt;matt's blog&lt;/a&gt; */</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://matt33.com"]</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cornflowerblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h2><p>其他的还有：</p>
<ul>
<li>后代选择器</li>
<li>子元素选择器</li>
<li>相邻兄弟选择器</li>
</ul>
<p>下面仅列出一种后代选择器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;p&gt;This is &lt;strong&gt;my&lt;/strong&gt; blog.&lt;/p&gt;</div><div class="line"></div><div class="line">/* css */</div><div class="line">p strong&#123;</div><div class="line">    color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="css-盒子模型"><a href="#css-盒子模型" class="headerlink" title="css 盒子模型"></a>css 盒子模型</h1><p> css 的盒子模型主要适用于网页的布局。</p>
<h2 id="盒子模型概述"><a href="#盒子模型概述" class="headerlink" title="盒子模型概述"></a>盒子模型概述</h2><p>盒子的组成包括：</p>
<ul>
<li>margin(外边距)：边框以外就是外边距，默认外边距是透明的（可以为负）；</li>
<li>border(边框)：内边距的边缘就是边框；</li>
<li>padding(内边距)：直接包围内容的部分，它呈现了元素的背景；</li>
<li>content(内容)：正文框的最内部分就是实际的内容.</li>
</ul>
<p>其中，内边距、边框和外边距都是可选的，默认值是0。下面用一张简单的图来描述它们的结构</p>
<p><img src="/images/web/css4.png" alt="盒子模型"></p>
<h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>内边据在正文（content）外、边框（border）内，控制该区域最简单的属性是 <code>padding</code> 属性</p>
<ul>
<li><code>padding</code> 属性接受长度值或百分比值，但不允许使用负值；</li>
<li>也可以进行统一的内边距设置，也可以进行单边的内边距设置。</li>
<li>设置某一边的边据时，可以通过以下四个属性：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code>.</li>
</ul>
<p>举个栗子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">h1 &#123;</div><div class="line">    padding-left: 5cm;</div><div class="line">    padding-right: 5cm;</div><div class="line">    padding-top: 30px;</div><div class="line">    padding-bottom: 30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/web/css5.png" alt="内边距"></p>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。</p>
<ul>
<li>边框的宽度可以通过这几个参数来设置：<code>border-top-width</code>、<code>border-right-width</code>、<code>border-bottom-width</code>、<code>border-left-width</code>；</li>
<li>同样可以使用属性控制各个边框的颜色：<code>border-top-color</code>、<code>border-right-color</code>、<code>border-bottom-color</code>、<code>border-left-color</code>。</li>
</ul>
<h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p> 外边距就是围绕在内容框的区域，也可以使用任何长度的单位、百分数来进行设置。</p>
<ul>
<li>宽度的设置：<code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code>、<code>margin-left</code>；</li>
<li>margin 的默认值是 0;</li>
<li>在宽度设置时，可以借助于对称复制；</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wb"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bk"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nj"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"zw"</span>&gt;</span></div><div class="line">                matt's blog</div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.wb&#123;</div><div class="line">    margin: 100px;</div><div class="line">&#125;</div><div class="line">.bk&#123;</div><div class="line">    border-style: groove;</div><div class="line">&#125;</div><div class="line">.nj&#123;</div><div class="line">    padding: 10px;</div><div class="line">&#125;</div><div class="line">.zw&#123;</div><div class="line">    background-color: cornflowerblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/web/css5.png" alt="盒子模型举例"></p>
<h1 id="css-一些高级用法"><a href="#css-一些高级用法" class="headerlink" title="css 一些高级用法"></a>css 一些高级用法</h1><p> 这里是 css 中一些高级的常见用法</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位，就是定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</p>
<p>在 css 中，有三种基本的定位机制：</p>
<ol>
<li>普通流：在位置顺序决定排版顺序；</li>
<li>浮动：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止；</li>
<li>绝对定位：绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。</li>
</ol>
<p>定位有以下几个属性:</p>
<ul>
<li>position：将元素放在一个静态的，相对的，绝对的或固定的位置；</li>
<li>通过对 top、left、right、bottom 这四个属性的赋值让元素向对应的方向偏移；</li>
<li>overflow：设置元素溢出其区域发生的事情；</li>
<li>clip：设置元素的显示形状，多用于图片；</li>
<li>vertical-align：设置元素的垂直对其方式；</li>
<li>z-index：设置元素的堆叠顺序。</li>
</ul>
<p><code>position</code> 属性，有以下四种设置：</p>
<ol>
<li>relative：就是普通流；</li>
<li>absolute：这个就是绝对定位，该元素区域会与文档区域重合，因为它使用该元素与文档流无关；</li>
<li>fixed：将元素固定下来,就算滚动屏幕,它也会在同一个地方不会动；</li>
<li>static：设置以后,偏移量什么的就没用了。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.position1</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">background-color</span>: cornflowerblue;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">left</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>这里涉及到的属性就是 <code>float</code>，其值可以赋值为：</p>
<ul>
<li>left: 元素向左浮动；</li>
<li>right: 元素向右浮动；</li>
<li>none: 不浮动；</li>
<li>inherit: 从父级继承浮动的属性；</li>
<li>clear: 主要用于去掉向各方向的浮动属性(包括继承来的属性)。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"qd"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wd"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ed"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.qd&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightskyblue;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">.wd&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightseagreen;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">.ed&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightsalmon;</div><div class="line">    float: right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/images/web/css7.png" alt="css 浮动"></p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>尺寸属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。涉及到的属性有：</p>
<ul>
<li>height– 设置元素的高度。</li>
<li>line-height –设置行高。</li>
<li>max-height– 设置元素的最大高度。</li>
<li>max-width –设置元素的最大宽度。</li>
<li>min-height –设置元素的最小高度。</li>
<li>min-width –设置元素的最小宽度。</li>
<li><p>width –设置元素的宽度。</p>
<p>举例说明</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-class">.p1</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: normal;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.p3</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">200%</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p>这里通过一个示例来实现导航栏的功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">ul&#123;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">li&#123;</div><div class="line">    float:left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a:link,a:visited&#123;</div><div class="line">   text-decoration: none;</div><div class="line">   background-color: lightgray;</div><div class="line">   display: block;</div><div class="line">   width: 100px;</div><div class="line">   margin:5px 10px;</div><div class="line">&#125;</div><div class="line">a:active,a:hover&#123;</div><div class="line">    background-color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="/images/web/css9.png" alt="水平导航栏"></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>插入一张图片，加上一句描述符，使用 <code>div</code> 继承</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./hha.jpg"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hha.jpg"</span> <span class="attr">width</span>=<span class="string">"150px"</span> <span class="attr">height</span>=<span class="string">"150px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.image&#123;</div><div class="line">    border: 2px solid darkgrey;</div><div class="line">    width: auto;</div><div class="line">    height: auto;</div><div class="line">    float: left;</div><div class="line">    text-align: center;</div><div class="line">    padding: 5px;</div><div class="line">&#125;</div><div class="line">img&#123;</div><div class="line">    padding: 5px;</div><div class="line">&#125;</div><div class="line">.text&#123;</div><div class="line">    font-size: 20px;</div><div class="line">    margin-bottom: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="/images/web/css8.png" alt="css 图片"></p>
<p>然后可以通过 <code>opacity</code> 属性来设置透明度，属性值的范围为0-1，0是完全透明，1是完全不透明。</p>
<p>到这里，css 基本内容已经总结完了，不过本文后续会一直更新，遇到什么常用的设置，都会更新到本文中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 指的是层叠样式表（Cascading StyleSheet），在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制，本文对 css 一些基本内容及常用功能进行一下总结，总结的内容主要是来自实验楼的 &lt;a href=&quot;h
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://matt33.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>HTML 一些常用方法的总结</title>
    <link href="http://matt33.com/2017/06/18/html-summary/"/>
    <id>http://matt33.com/2017/06/18/html-summary/</id>
    <published>2017-06-17T16:24:31.000Z</published>
    <updated>2017-06-17T16:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 是一种语言，是用来描述网页的语言，它是一种标记语言，HTML 就是使用标记标签来描述网页。</p>
<p>HTML 算是最容易学习的语言之一，它也是必须掌握的一门语言，之前对 HTML 只是大概了解，并没有开发过前端页面，现在在工作中，会使用前端框架已经成为了一项必备技能，所以花了点时间简单看了一下<a href="https://www.shiyanlou.com/courses/19" target="_blank" rel="external">实验楼-HTML 基础课</a>，稍微再学习一下 HTML 的相关知识，本文记录一下一些常用的 HTML 内容，后期还会对 css 简单总结一下。</p>
<h1 id="HTML-最基本用法"><a href="#HTML-最基本用法" class="headerlink" title="HTML 最基本用法"></a>HTML 最基本用法</h1><p>这里先介绍一下 HTML 的最基本用法。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>HTML 文档也被称为网页，它包括标签和文本。Web 浏览器的作用就是读取 HTML 文档，并以网页的形式显示出它们，浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>first paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面是最简单的一个网页，其中：</p>
<ol>
<li>&lt; html&gt; 与 &lt; /html&gt; 之间的文本描述网页；</li>
<li>&lt; body&gt; 与 &lt; /body&gt; 之间的文本是可见的页面内容；</li>
<li>&lt; h1&gt; 与 &lt; /h1&gt; 之间的文本被显示为标题；</li>
<li>&lt; p&gt; 与 &lt; /p&gt; 之间的文本被显示为段落。</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>标签：就是上面这些 <code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;table&gt;</code> 等被尖括号<code>&lt;</code>和<code>&gt;</code>包起来的对象，绝大部分的标签都是成对出现的，如 <code>&lt;table&gt;&lt;/talbe&gt;</code>、<code>&lt;form&gt;&lt;/form&gt;</code>；</li>
<li>标签对中的第一个标签是开始标签，第二个标签是结束标签，开始和结束标签也被称为开放标签和闭合标签；</li>
<li>也有少部分不是成对出现的，如<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>等；</li>
<li>标签就是用来标记 HTML 元素的，位于起始标签和结束标签之间的文本就是HTML元素的内容。</li>
<li>HTML 元素就是通过使用 HTML 标签进行定义的，比如 <code>&lt;p&gt;</code> 这就是一个标签，而 <code>&lt;p&gt;内容&lt;/p&gt;</code> 这就是一个<strong>元素</strong>，也就是说<code>元素由一个开始的标签和结束的标签组成，用来包含某些内容</code>，这里有一个值得注意的例外，即 <code>&lt;br&gt;</code> 本身既是开始标签也是结束标签，但不包含任何内容，所以这只是个标签。</li>
</ul>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>四种最基本的标签：</p>
<ol>
<li>标题：通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 等标签进行定义的；</li>
<li>段落：通过 <code>&lt;p&gt;</code> 标签进行定义的；</li>
<li>链接：是通过 <code>&lt;a&gt;</code> 标签进行定义的，<code>&lt;a href=&quot;http://matt33.com&quot;&gt;matt&lt;/a&gt;</code>；</li>
<li>图像：通过 <code>&lt;img&gt;</code> 标签进行定义的，<code>&lt;img src=&quot;matt.jpg&quot; width=&quot;100&quot; height=&quot;142&quot; /&gt;</code>；</li>
</ol>
<p>注： HTML 标签对大小写不敏感：<code>&lt;P&gt;</code> 等同于 <code>&lt;p&gt;</code>.</p>
<h1 id="HTML-文本"><a href="#HTML-文本" class="headerlink" title="HTML 文本"></a>HTML 文本</h1><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p><strong>HTML 元素</strong>指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>HTML网页实际上就是由许许多多各种各样的HTML元素构成的文本文件，并且任何网页浏览器都可以直接运行HTML文件。</p>
<h3 id="元素语法"><a href="#元素语法" class="headerlink" title="元素语法"></a>元素语法</h3><p>元素语法特点：</p>
<ul>
<li>HTML 元素以开始标签起始；</li>
<li>HTML 元素以结束标签终止；</li>
<li>元素的内容是开始标签与结束标签之间的内容；</li>
<li>某些 HTML 元素具有空内容（empty content）；</li>
<li>空元素在开始标签中进行关闭（以开始标签的结束而结束）；</li>
<li>大多数 HTML 元素可拥有属性。</li>
</ul>
<h3 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h3><p>HTML 元素的内容是开始标签与结束标签之间的内容，而某些 HTML 元素具有空内容（empty content），这种元素被叫做<strong>空元素</strong>，比如说换行符<code>&lt;br&gt;</code>。</p>
<p>为了规范起见，换行符最好还是用 <code>&lt;br/&gt;</code>。</p>
<p><code>&lt;p&gt;</code> 标签结束以后也后一个换行的动作，那 <code>&lt;p&gt;</code> 标签和 <code>&lt;br/&gt;</code> 标签有什么异同呢？</p>
<ol>
<li>相同之处是 <code>&lt;br&gt;</code> 和 <code>&lt;p&gt;</code> 都是有换行的属性及作用；</li>
<li>区别 <code>&lt;br/&gt;</code> 是只需一个单独使用，而 <code>&lt;p&gt;</code> 和 <code>&lt;/p&gt;</code> 是一对使用；</li>
<li><code>&lt;br/&gt;</code> 标签是小换行提行（相当于我们平时文本中输入一个回车），<code>&lt;p&gt;</code> 标签是大换行（分段，相当与两个回车）,隔行作用。</li>
</ol>
<h2 id="HTML-属性"><a href="#HTML-属性" class="headerlink" title="HTML 属性"></a>HTML 属性</h2><p>某些标签要按照开发者的意愿来实现在网页上，就得需要一定信息的补充，这信息就叫<strong>属性</strong>，HTML 标签可以加上属性的描述，属性提供了有关 HTML 元素的更多的信息。</p>
<p>关于属性有以下语法规则：</p>
<ul>
<li>是在 HTML 元素的开始标签中定义；</li>
<li>总是以名称和值对应的形式出现，比如：<code>name=&quot;value&quot;</code>。</li>
<li>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。</li>
</ul>
<p>举例，下面这个就是 <code>&lt;a&gt;</code> 标签的属性，是对 <code>&lt;a&gt;</code> 标签的补充说明，既指向网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>大多数的标签都会有各种各样的属性，没必要记住所有的属性，只需要在实践中多积累，知道哪些属性是常用的，知道如何查资料即可。</p>
<h2 id="HTML-文本格式化"><a href="#HTML-文本格式化" class="headerlink" title="HTML 文本格式化"></a>HTML 文本格式化</h2><p>一般我们在网页中能看见有各种各样的字体、文本样式，这就是文本格式化标签的功劳。下面的文本格式化标签是比较常用的：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;b&gt;</code></td>
<td>（bold）粗体</td>
</tr>
<tr>
<td><code>&lt;big&gt;</code></td>
<td>（big）大字体</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>（emphasized）强调字</td>
</tr>
<tr>
<td><code>&lt;i&gt;</code></td>
<td>（italic）斜体</td>
</tr>
<tr>
<td><code>&lt;small&gt;</code></td>
<td>（small）小字体</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>(strong)加重语气</td>
</tr>
</tbody>
</table>
<h2 id="HTML-样式"><a href="#HTML-样式" class="headerlink" title="HTML 样式"></a>HTML 样式</h2><p>style 提供了一种改变所有 HTML 元素的样式的通用方法。这里可以将，背景颜色，字体样式，字体尺寸，字体颜色，对齐方式一并定义好。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center;font-family:verdana;color:gray"</span>&gt;</span> verdana and white<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-family:time;color:greeen"</span>&gt;</span> time and green words<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="HTML-超文本"><a href="#HTML-超文本" class="headerlink" title="HTML 超文本"></a>HTML 超文本</h1><h2 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h2><p>通过网页中超链接，可以连接到自己感兴趣的地方。</p>
<h3 id="给文字及图片添加超链接"><a href="#给文字及图片添加超链接" class="headerlink" title="给文字及图片添加超链接"></a>给文字及图片添加超链接</h3><p>最简单的链接就是将文字添加链接连接到网页和另外的 HTML 文件，给图片添加链接。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"matt.html"</span>&gt;</span>another html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"touxiang.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接的打开方式"><a href="#超链接的打开方式" class="headerlink" title="超链接的打开方式"></a>超链接的打开方式</h3><p>打开方式分为在本页打开和在新的浏览器窗口打开，超级链接标签提供了 <code>target</code> 属性进行设置，取值分别为<code>_self</code>（在本页打开，默认）、<code>_blank</code>（创建新窗口打开新）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接添加提示文字"><a href="#超链接添加提示文字" class="headerlink" title="超链接添加提示文字"></a>超链接添加提示文字</h3><p>有些时候超链接文字不足以说明点击以后所要链接的内容，所以这个时候我们就需要给超链接添加提示文字，加以描述下一个链接的内容，当光标停留在超链接上时，提示语言就会显现，会让页面显现的很简介。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span> <span class="attr">title</span>=<span class="string">"this word will link to the wed of matt's blog."</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接实现书签"><a href="#超链接实现书签" class="headerlink" title="超链接实现书签"></a>超链接实现书签</h3><p>在阅读小说时，会发现当在点击相应章节的题目时，可以跳转到相应的章节，想实现这种效果，就必须要了解什么是锚（anchor），实际上就是锚用于在单个网页内不同位置的跳转，锚也叫做书签。</p>
<ul>
<li>涉及到的标签还是 <code>&lt;a&gt;</code> 标签，超级链接标签的 <code>name</code> 属性用于定义锚的名称；</li>
<li>一个页面可以定义多个锚，通过超级链接的 <code>href</code> 属性可以根据 <code>name</code> 跳转到对应的锚。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:20px"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span>HTML LEARNING<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c1"</span>&gt;</span>  HTML first<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c2"</span>&gt;</span>HTML second <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c3"</span>&gt;</span>HTML third <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 1 first HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c2"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 2 second HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c3"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 3 chaowenben 1 HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML 表格"></a>HTML 表格</h2><p>表格在 HTML 中是不可缺少的元素，表格主要包括了 <code>table</code>、<code>tr</code> 和 <code>td</code> 这几个标签：</p>
<ol>
<li>表格由 <code>&lt;table&gt;</code> 标签来定义；</li>
<li>每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义）；</li>
<li>每行被分割为若干单元格（由 <code>&lt;td&gt;</code> 标签定义）;</li>
<li>字母 <code>td</code> 指表格数据（table data），即数据单元格的内容。<code>&lt;th&gt;</code>标签用来定义表头;</li>
<li><code>border=&quot;1&quot;</code>定义的是最外面边框粗细，为1，你也可以设置为0，就是不显示边框；</li>
<li><code>colspan</code>：控制此单位所占列数；</li>
<li><code>rowspan</code>：控制此单位所占行数；</li>
</ol>
<p>还有一些其他的属性：</p>
<ul>
<li>标签：<code>&lt;th&gt;表头&lt;/th&gt;</code>：设置表头；</li>
<li>标签：<code>&lt;caption&gt;标题&lt;/caption&gt;</code>：设置表的标题；</li>
<li>属性：<code>cellpadding=&quot;...&quot;</code> 设置单元格边距；</li>
<li><p>属性：<code>bgcolor=&quot;...&quot;</code> 设置表格背景颜色；</p>
</li>
<li><p>属性：<code>background=&quot;...&quot;</code> 以某张图片作为表格背景。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span> &gt;</span>TABLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:30px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span>table practice<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span>  <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">border</span>=<span class="string">"15"</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>first row and first column<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>second row and first column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>second row and second column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> &gt;</span>second row and third column<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>third row and first column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>third row and second column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p>对于 HTML 图像，一般涉及到的就是以下几类：</p>
<ul>
<li>将图片作为背景；</li>
<li>插入图片</li>
<li>将图片作为链接。</li>
</ul>
<h3 id="图片作为背景"><a href="#图片作为背景" class="headerlink" title="图片作为背景"></a>图片作为背景</h3><p>在 <code>body</code> 属性中添加 <code>background</code> 属性来添加背景图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">"./qwe.gif"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="插入一张图片"><a href="#插入一张图片" class="headerlink" title="插入一张图片"></a>插入一张图片</h3><p>通过 <code>img</code> 标签给网页插入一张图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片的路径"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在 <code>&lt;img&gt;</code> 标签中加入 <code>align</code> 属性，来对其进行调整，可以进行调整的参数有：</p>
<ul>
<li>可以上下调整的参数有：<code>bottom</code>、<code>middle</code>、<code>top</code>，默认是 <code>bottom</code>；</li>
<li>可以左右调整的参数有：<code>right</code> 和 <code>left</code>，默认为 <code>right</code>；</li>
<li>尺寸的调整：<code>width</code> 和 <code>height</code> 两个属性。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> align top<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./julizi.png"</span> <span class="attr">align</span>=<span class="string">"top"</span> <span class="attr">width</span>=<span class="string">"10%"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="将图片作为链接"><a href="#将图片作为链接" class="headerlink" title="将图片作为链接"></a>将图片作为链接</h3><p>将图片做链接，一般情况下，触发链接的方式就是点击图片的任何地方都可以链接到跳转地址，但有时需要实现，点击图片的不同地方跳转到不同的地方，也就是，一张图片可以创建带有可供点击区域的图像地图，其中每个区域就是一个超链接。</p>
<p>涉及到的标签就是 <code>&lt;map&gt;</code> 标签，用来指定图片，<code>&lt;area&gt;</code> 用来指定超链接区域。</p>
<p>在 <code>&lt;area&gt;</code> 标签中我们会涉及到 <code>shape</code> ，<code>coords</code>， <code>href</code> 属性，分别用来指定超链接区域形状，超链接区域坐标，还有超链接跳转地。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;image test&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body background="./qwe.gif"&gt;</div><div class="line"></div><div class="line">    &lt;p&gt;tap the li zi &lt;/p&gt;</div><div class="line">    &lt;img src="./julizi.png" usemap="#lizi"/&gt;</div><div class="line"></div><div class="line">    &lt;map name="lizi"&gt;</div><div class="line">     &lt;area shape="rect" coords="50,10,100,60" href="img.html" target="_blank"</div><div class="line">    &lt;/map&gt;  </div><div class="line"></div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>shape</code> 属性的取值可以是：<code>rect</code>(矩形)、<code>circle</code>(圆形)、<code>poly</code>(多边形)和 <code>default</code> (整个图像区域)，这里采用的是矩形。</li>
<li><code>coords</code> 属性对于矩形而言，<code>coords</code> 有4个值，分别用逗号隔开，表示矩形区域左上角x坐标、左上角y坐标、右下角x坐标和右下角y坐标，这里获取坐标的方式，就用截图工具帮忙就好。</li>
</ul>
<h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表始于 <code>&lt;ol&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code> 标签。列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</p>
<p>在有序列表中我们还能定义其他的排序方式，上面是默认的数字排序，下面我们再加上字母排序和罗马数字排序</p>
<ol>
<li>通过添加 <code>type</code> 属性来设置排序方式，<code>a</code> 表示以小写字母来排序，<code>A</code> 就是使用大写字母来排序，<code>i</code> 就是以小写罗马数字来排序，<code>I</code> 就是以大写罗马数字来排序；</li>
<li>还可以添加 <code>start</code> 属性，决定起始的序号。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:20px;background-color:gray"</span> &gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"2"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>c <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"a"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>c <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表始于 <code>&lt;ul&gt;</code> 标签，每个列表项始于 <code>&lt;li&gt;</code>。</p>
<p>无需列表排序的时候就是给每个列表项加各种小符号其中分为<code>Disc</code>（默认）实心黑点，<code>Circle</code>小圈，<code>square</code>方点，与有序列表的属性都是用的一样的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"circle"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="定义性列表"><a href="#定义性列表" class="headerlink" title="定义性列表"></a>定义性列表</h3><p>定义列表通常用于术语的定义和解释。定义列表由 <code>&lt;dl&gt;</code> 开始，术语由 <code>&lt;dt&gt;</code> 开始，解释说明由 <code>&lt;dd&gt;</code> 开始，<code>&lt;dd&gt;....&lt;/dd&gt;</code> 里的文字缩进显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>it's useful!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ti's nice!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-块"><a href="#HTML-块" class="headerlink" title="HTML 块"></a>HTML 块</h2><p>HTML元素被定义为块级元素或内联元素。</p>
<ul>
<li>块级元素(block)特性：<ol>
<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示；</li>
<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制，就像以前用到的 <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;table&gt;</code>标签。</li>
</ol>
</li>
<li>内联元素(inline)特性：<ol>
<li>和相邻的内联元素在同一行；</li>
<li>宽度(width)、高度(height)、内边距的 <code>top</code>/<code>bottom</code>(<code>padding-top</code>/<code>padding-bottom</code>)和外边距的<code>top</code>/<code>bottom</code>(<code>margin-top</code>/<code>margin-bottom</code>)都不可改变，就是里面文字或图片的大小，就像以前用到的<code>&lt;b&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code> 标签。</li>
</ol>
</li>
</ul>
<p>在这里我们先介绍两个标签 <code>&lt;div&gt;</code> 标签和 <code>&lt;span&gt;</code> 标签。</p>
<ul>
<li><code>&lt;div&gt;</code> 用来定义文档中的分区或节（division/section），没有特定的含义，它是可用于组合其他 HTML 元素的容器；</li>
<li><code>&lt;span&gt;</code> 用来组合文档中的行内元素，也没有特定的含义.</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:white"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is a header.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragrph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-布局"><a href="#HTML-布局" class="headerlink" title="HTML 布局"></a>HTML 布局</h2><p>大多的网页布局是需要配合 css 来完成，后面会总结一篇关于 css 基本用法的文章，这里先不涉及太多。</p>
<p>这里通过一个示例，它是使用 <code>&lt;table&gt;</code> 元素和 <code>&lt;div&gt;</code> 元素实现的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"gray"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"1000"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">style</span>=<span class="string">"background-color: royalblue"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>matt' blog<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"background-color: darkorange;width:300px"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>list of blogs<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;<span class="name">dd</span>&gt;</span></div><div class="line">                          <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>kafka<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"background-color: forestgreen;height:500px;width:700px;"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"font-size: 20px;text-align: center"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                    this is matt's blog</div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">style</span>=<span class="string">"background-color: powderblue;text-align:center;height: 100px"</span>&gt;</span></div><div class="line">                    good good study day day up<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过表格来设计一个网页如下图所示。</p>
<p><img src="/images/web/html_lianxi.png" alt="示例"></p>
<p>上面的示例使用表格来进行表示的一个网页，如果使用 <code>div</code> 元素应该怎么做，下面使用 <code>div</code> 元素来重新设计一下上面的网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">            <span class="selector-tag">div</span><span class="selector-id">#container</span>&#123;<span class="attribute">width</span>:<span class="number">1000px</span>&#125;</div><div class="line">            <span class="selector-tag">div</span><span class="selector-id">#header</span> &#123;<span class="attribute">background-color</span>: royalblue ;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">text-align</span>:center;<span class="attribute">font-size</span>: <span class="number">20px</span>&#125;</div><div class="line">            <span class="selector-tag">div</span><span class="selector-id">#sidebar</span>&#123;<span class="attribute">background-color</span>: darkorange;<span class="attribute">height</span>:<span class="number">400px</span>;<span class="attribute">width</span>:<span class="number">300px</span>;<span class="attribute">float</span>:left;&#125;</div><div class="line">            <span class="selector-tag">div</span><span class="selector-id">#mainbody</span> &#123;<span class="attribute">background-color</span>: forestgreen;<span class="attribute">height</span>:<span class="number">400px</span>;<span class="attribute">width</span>:<span class="number">700px</span>;<span class="attribute">float</span>:left;&#125;</div><div class="line">            <span class="selector-tag">div</span><span class="selector-id">#footer</span> &#123;<span class="attribute">background-color</span>: powderblue;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">clear</span>:both;<span class="attribute">text-align</span>:center;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>list of blogs<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">dd</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>kafka<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mainbody"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello word<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>good good study day day up<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单标签是什么呢？这个是在网页是很常见的，表单标签就是用于网页中的数据提交，比如我们注册网页，在留言板中留言、评论等可以填写数据，提交处理地方都需要表单标签，<code>form</code> 表单标签内有输入框 input、单选、多选、<code>select</code> 下拉列表菜单与跳转菜单、提交按钮等标签内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    user：</div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    password：</div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> /&gt;</span> Male</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span> /&gt;</span> Female</div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"married"</span> /&gt;</span></div><div class="line">    married</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"have a job"</span> /&gt;</span></div><div class="line">    have a job</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"chinese"</span> /&gt;</span></div><div class="line">    chinese</div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，name 是明文显示，password 是隐藏的，<code>radio</code> 属性是单选，<code>checkbox</code> 属性是双选，上面展示的效果如下图所示。</p>
<p><img src="/images/web/html_form.png" alt="示例"></p>
<p>后面还会单独写一篇文章对 css 进行一下总结，html 和 css 的这两篇文章，会不定时更新，以后用到什么比较常用内容或者遇到什么好的方法，会更新到这两篇文章中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML 是一种语言，是用来描述网页的语言，它是一种标记语言，HTML 就是使用标记标签来描述网页。&lt;/p&gt;
&lt;p&gt;HTML 算是最容易学习的语言之一，它也是必须掌握的一门语言，之前对 HTML 只是大概了解，并没有开发过前端页面，现在在工作中，会使用前端框架已经成为了一项
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://matt33.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>入职培训感想</title>
    <link href="http://matt33.com/2017/05/27/induction-training-think/"/>
    <id>http://matt33.com/2017/05/27/induction-training-think/</id>
    <published>2017-05-27T13:44:51.000Z</published>
    <updated>2017-05-29T02:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周参加了公司的封闭式入职培训，总共是五天的时间，今年是公司第一次进行校招封闭式培训。记得去年七月份来公司实习，一起入职的校招同事参加的入职培训才两天时间，而且也不是封闭式的，一年的时间，变化还是很大的，这也间接证明公司的发展速度很快。作为公司第一届参加封闭式入职培训的员工（不是这届的第一批），在这五天中明显感觉到了收获了很多，这里记录总结一下。</p>
<h2 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h2><p>今天上午九点从公司出发到酒店，早上起来的时候还只是小雨，九点多出发的时候已经变成了大到暴雨，京城的雨本来就很少，但是很多时候一旦雨一下来就收不住了。从公司门口到大巴车只有短短的100米，但全身已被淋湿了很多，好在到了酒店之后雨已经差不多停了。</p>
<p>到了酒店会议室之后，已经快到中午了，同组同学相互认识一下，然后负责培训的同事介绍一下培训期间的一些规则，之后就到了吃午饭的时间（关于伙食就不想多介绍了，冷暖自知😂）。</p>
<h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>下午的第一节课，是对公司的一些基本介绍，第一节课讲课的老师是大熊老师，大熊老师现在在公司从事人力资源方向的工作，有近十年的工作经验，从他身上看到了一些值得我们去学习的地方：</p>
<ol>
<li>他对公司业务的理解，虽然大熊老师现在是从事人力资源方向，但是无论在技术还是业务方向都有很多认识，尤其是在业务方面，他思考的还很深的，包括对公司发展战略、客户的需求等方面，他都有一些很独特的见解；</li>
<li>对新事物充满<strong>好奇心</strong>，课上大熊老师问了一句：有多少人用过快手？好像当时课上没什么人举手，但是大熊老师说：快手现在这么火，我们还是应该去试用一下，看看这个产品为什么这么火，对这些新事物，我们应该保持一颗好奇心（包括阿里提出的”新零售”战略）；</li>
<li>思考问题时，很多时候并不能只站在自己的角度去想，上个台阶去看问题，可能会就会明白公司或者领导的要求了，<strong>低头做事时也要时常抬头，要有大局观</strong>；</li>
</ol>
<p>下午后面几节课就是介绍公司的一些规章制度，不过作为一名资深的老员工（实习近八个月），这些我基本上已经很了解了😄。</p>
<p>课程结束后，接着就去了酒店一楼的餐厅吃饭，饭后直接回到了会议室等待晚上的课程，结果竟错过北京近几年来最美的晚霞，只能默默在朋友圈欣赏他人的晚霞了，很可惜（这里选了一张网上的图片镇楼）。</p>
<p><img src="/images/essary/070522night.jpeg" alt="难得一遇的晚霞"></p>
<h3 id="晚上-《国家联盟》"><a href="#晚上-《国家联盟》" class="headerlink" title="晚上 《国家联盟》"></a>晚上 《国家联盟》</h3><p>这个游戏可能很多公司的培训都会使用，我是第一次玩这个游戏，我们组是巨人国，我们国家的战力很强，但是却极度缺乏资源，所以我们在第二年的时候为了完成目标就率先发动了战争，但是战争的结果并不如预期那样，如果严格按照比赛规则的话，可能我们就直接被淘汰了。关于这个游戏，个人有以下几点感想：</p>
<ol>
<li>首先我们并没有完全搞清楚游戏的规则，规则没有搞懂就进入了游戏，这基本上就注定了失败的结局；</li>
<li>在与其他团队沟通的过程中，应该有相应的技巧，在谈判的过程中，要理性地看待问题，然而时间紧迫的情况下，很多人并不理性，也包括我自己；</li>
<li>与他人合作的过程中，我们应该更多是考虑共赢合作，而不是损人利己；</li>
<li>既然彼此要合作，就应该相互信任；</li>
</ol>
<p>游戏结束，就进入了一个很开心的游戏——狼人杀，狼人杀在培训期间给我们增加了很多的欢乐，在高玩的带领下，学到了很多的技巧😀。</p>
<h2 id="周二"><a href="#周二" class="headerlink" title="周二"></a>周二</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>今天上午只有一节课 —— 职场必修课，这个应该算是入职培训的标配课程吧。</p>
<p>课程的核心有以下几点：</p>
<ul>
<li>人生的职业生涯大致分为几个阶段，在前期最主要的是<strong>学习、成长</strong>；</li>
<li>对于职场小白，如何学习、如何成长？其中很关键的一点是要有人去带你，<strong>跟着带你的人去学习成长</strong>；</li>
<li>职场礼仪：与他人沟通时要注意<strong>聆听</strong>，对同时表扬或称赞时，要<strong>基于事实去称赞</strong>。</li>
</ul>
<p>讲解这门课程的老师，在培训行业深耕近十年，她曾经在 LG 的培训界创造了很多的神话，现在她依然奋战在培训行业的第一线，未来的职业规划也是继续从事培训行业，很优秀、职业规划很清晰的一位培训老师。</p>
<h3 id="下午-户外拓展活动"><a href="#下午-户外拓展活动" class="headerlink" title="下午 户外拓展活动"></a>下午 户外拓展活动</h3><p>今天下午是一节户外扩展课，全员分为四组进行比赛，比赛的项目基本都是围绕着团队合作的目的进行的。这节课是这几天培训中最让人印象深刻的课程之一，这里说一下个人的感想以及一些感悟和收获：</p>
<ul>
<li><strong>增强了队员之间的相互了解</strong>，在之前大家基本上都是在上课，只是混了个面熟，并不是很熟悉，名字也没有记很清楚，但经过这个活动之后，至少我们小组内部（11个人）有了更多的了解；</li>
<li><strong>团队合作</strong>，五个比赛的小项目，都是需要全员参与的，需要团队之间的相互配合；</li>
<li>整个过程中，游戏并不难，难的地方主要在于大家的互相合作，大家之前并不认识，性格、思维也有很大差异，但却需要我们一起在短时间内完成一个需要强力配合的游戏，这对我们也是很大的挑战，<strong>在很短的时间内，大家要熟悉起来，并且找到默契</strong>。</li>
</ul>
<p>活动大概是6点结束的，很遗憾我们组只拿到了第二名，与第一名只有1分之差，不过这个活动最赞的地方是给了我们大家一个互相了解的机会，它并不是一个简简单单的比赛。</p>
<h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3><p>今晚的讲师是公司一位很优秀的员工，他15年本科毕业，现在正式入职还不到两年，已经开始带了7个人的团队，个人有以下几点感想：</p>
<ol>
<li>他的升职历程，在其他行业可能是不可思议的，但是在互联网行业，由于公司业务发展迅速，这样例子是数不胜数的，<strong>既是机遇也是挑战，做好准备的人才能脱颖而出</strong>；</li>
<li>虽然他工作不到两年，但他却从工作和管理的过程中，总结了很多方法论，先不说方法论的对错，仅这些就能证明他这个人很好学、爱总结，他是一个<strong>爱看书、爱总结、上进心很强</strong>的一个工程师；</li>
<li><strong>对新技术的关注以及对业务的理解</strong>，全程我可能提到了很多次这个概念 —— 对业务的理解，主要是因为我一直处于一个唯技术论的圈子里，大家讨论更多的是技术，对业务关注不是很多，然而<strong>经济是检验技术的唯一标准</strong>（当然有些技术的价值可能需要长远才能体现出来，但牛逼的技术依然是需要有经济价值的），所以每次遇到对业务理解很深的人，我都会不自由自主地感觉这个人很厉害。</li>
<li>他的演讲能力很不错，这个要跟他的工作年限一起看，非常值得我去学习。</li>
</ol>
<p>课程结束之后，又到了狼人杀时间，印象最深的就是猎人被假冒预言家的狼查杀但是却没有将狼带走、而且预言家还没有上警，这局游戏竟然成了一个我们培训中的一个槽点了😂。</p>
<h2 id="周三"><a href="#周三" class="headerlink" title="周三"></a>周三</h2><h3 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h3><p>今天上午的课程 —— 客服听音，对于服务性的企业，很多公司也都会有这项课程，主要有以下几点感想：</p>
<ol>
<li><strong>以客户为中心</strong> 是公司的价值观与企业文化，但是如何将这个条进行落实，客服是挽回用户的最后一道防线，所以客服这项工作对于公司整体发展而言是非常重要的，之前用过很多次美团，当时对美团的印象非常好，就是因为客服非常 nice，效率很高；</li>
<li>给用户提供超预期的服务。</li>
</ol>
<h3 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h3><p>下午是关于公司业务流程的讲解，有五六个前辈来讲解，印象最深的有两个：一个外卖，另一个是丽人。</p>
<h4 id="外卖业务"><a href="#外卖业务" class="headerlink" title="外卖业务"></a>外卖业务</h4><p>关于外卖，这个是公司最近几年最重视的业务，通过这位前辈的讲解，对外卖的整体有了更进一步的了解：</p>
<ul>
<li>前辈完整地经历过外卖的发展和成长，虽然在外卖领域我们是后来者，但是最后我们与饿了么一起进入了下半场，而且从目前的数据来看美团外卖的优势会更明显一些，美团有自己的智能配送系统，有可能未来会向京东物流一样发展成一个配送平台，而反观饿了么现在正在与阿里云合作去做智能配送（这两天刚爆出的新闻），这也间接地证明了美团外卖在配送领域确实与饿了么拉开了一定的差距；</li>
<li>从她的介绍过程中，明确能感觉到他对整个行业那洞察力，对商业、战略的理解已经远超我们普通人，着实很厉害，<strong>如果在一个公司里能跟随一个新业务迅速成长起来，这是非常幸运的，这样迅速成长的机会并不是常有的</strong>；</li>
<li>虽然与饿了么是竞争对手，但是外卖这边还是很<strong>尊重竞争对手的（学习对方的长处）</strong> ，饿了么那边的团队也是非常厉害的，要不然两家不会焦灼这么长时间，美团这边也是很希望有个竞争对手的，因为这样才能逼迫着我们自己去进步；</li>
<li>外卖市场现在还没有哪一家公司是占有绝对优势的，稍不留神可能就会被对手远远甩在后面，外卖现在是不盈利的，而且我们并不着急地去盈利，<strong>不为了盈利而盈利，否则就可能会损害用户的利益</strong>；</li>
<li><strong>产品在设计时一定要走在业务之前</strong>，要为业务开展以及未来的发展做准备，而不是说业务有这个需要了才开始去改进产品（期间也一定要考虑风控，这个是很重要，要不然很多的钱可能就白花了）；</li>
<li>竞争时，<strong>差异化竞争很重要，但前提是你走的是正确的道路</strong>，如果对手选择了一个正确的道路，你这时候选择差异化，那么就是在自己作死。</li>
</ul>
<p>虽然前辈只讲了不到两个小时，但让我们感觉收获了很多，无论是关于公司业务的理解还是关于一些商业行为的思考，很感谢！</p>
<h4 id="丽人业务"><a href="#丽人业务" class="headerlink" title="丽人业务"></a>丽人业务</h4><p>丽人业务，在之前并没有了解太多，后来才知道丽人业务里也有三驾马车——美发、美甲、美容美体（细心的人可能会发现这就是美团 app 中丽人栏目里的三个大图标），虽然丽人并不是一个很高频的业务，但是从这位前辈的讲述中，能感觉到的是这个团队非常有战斗力和自信心，有以下几点感触：</p>
<ul>
<li>每个细分领域，都面对着很多竞争对手，但前辈给人的感觉是他们这个团队非常有激情、对这块业务非常自信；</li>
<li>他们这个团队在这个细分的领域做了很多的事情，并没有因为这是个低频业务就不重视，他们紧紧追随着竞争对手的步伐，并没有丝毫懈怠，很赞。</li>
</ul>
<h3 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h3><p>晚上是趣味运动会，也是一些考察团队合作的小项目，只不过这些活动是可以在室内做的，运动量也不大，总体来说玩得还是很开心的。</p>
<p>之后，又进行了2局的狼人杀，都是九人局的，唉，不堪回首，全输了，不做太多解释，第一局猎人背锅，第二局女巫背锅。</p>
<h2 id="周四"><a href="#周四" class="headerlink" title="周四"></a>周四</h2><h3 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h3><p>今天上午只有一节课 —— 有效沟通，从两个方面来说：一是对老师的感觉，二是课程的内容：</p>
<p>关于对老师的感觉：</p>
<ol>
<li>这节课的内容<strong>总结了很多的方法论</strong>，这证明这位老师平时还是很喜欢读书和思考的；</li>
<li>课程也涉及了一些心理学的内容，再次证明了这位老师爱看书；</li>
<li>他自己是带团队的，在工作过程中，也需要跟其他的部门进行合作，课程的内容也是根据他看到的一些方法论和工作经验进行总结的，<strong>学以致用，并在用的过程中进行总结</strong>，这点是很值得学习的。</li>
</ol>
<p>关于课程内容，核心内容主要有以下四点：</p>
<ol>
<li>Ask；</li>
<li>Listen：听明白事、感受、以及背后被满足与不满足的需要；</li>
<li>Look：肢体语言，在不同场合着装、动作都要注意；</li>
<li>Speak：察情传理，主要是要考虑他人的感受。</li>
</ol>
<h3 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h3><p>今天下午的课程，是一位公司的高 P 来讲解的，这节课主要是讲解思维方式的。这里先总结一下课程的内容：</p>
<ul>
<li>思维方式分类<ol>
<li>惯性思维：是靠经验、直觉是判断；</li>
<li>逻辑思维：推理+逻辑分析（垂直思维）；</li>
<li>水平思维：创意天马行空，很有可能碰撞出一个非常好的灵感；</li>
<li>结构化思维：先框架再细节，强调快速、系统地解决问题。</li>
</ol>
</li>
<li>结构化思维的分析方式：<ol>
<li>先聚焦问题与目标；</li>
<li>从假设入手进行分析；</li>
<li>分析问题的关键；</li>
<li>从这些关键点入手。</li>
</ol>
</li>
<li>分析的三个原则：<ol>
<li>以终为始；</li>
<li>MECE：建立分析结构（相互独立、完全穷尽）；</li>
<li>二八原则：抓住关键的少数。</li>
</ol>
</li>
<li>麦肯锡的电梯理论：<ol>
<li>最短的时间把问题表达清楚——直奔主题与结果；</li>
<li>归纳的话，尽量三条以内。</li>
</ol>
</li>
</ul>
<p>老师的课程很风趣，课上互动也较多，从课程中也能明显地感觉到这位老师是一位<strong>爱思考、爱读书、爱总结</strong>的优秀工程师。无论是在各行各业，那些优秀人才基本上都有这些共性，这几点可以说成为优秀人才的至尊宝典，只是能够一直坚持下去的人很少，我本人的毅力也不是很强，很多的时候只能逼迫自己呆在一个充满竞争力的环境中，让竞争激烈的环境逼迫着自己去努力，也希望自己未来能够从主观上有所改变。</p>
<h3 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h3><p>今晚没有安排额外的课程，然而却比上课都累，因为明天下午我们要做毕业呈现，各个小组的产品设计要进行比赛，我们团队基本上是通宵进行的产品设计，自从上了研究生之后就没怎么熬过夜了，第一次熬那么久，还是值得记录一下的。</p>
<ol>
<li>方向篇：想在一晚上就把一个产品的设计方案做出来还是很难的，不说别的，单纯的方向就很难找。我们刚开始想的是把美团与慈善结合起来，后来发现太难做了，而且可行性较差，后来又想到的是借鉴趣运动，做运动场馆的预定。美团app在运动场馆方面只能进行团购，而不能去预定时间段，这是不能够满足用户需求的，这是一个很好的方向，而且实施起来比较简单。本来方向已经确定了这个，结果我再次查看美团app时，发现我经常去的那个场馆已经可以直接预定时间段了，天呐，美团已经开始做了！！！我们只能放弃这个方案，去寻找新的方向，后来突然想到了 app 的积分商城，我们就确定了去做积分商城这个方向，这个时候已经是晚上10点了，我们才确定了产品的方向。</li>
<li>产品设计篇：然后就是具体的改进方向，我们决定设计了一个美食达人类似的晋级策略，鼓励用户使用美团品尝美食，然后进行达人升级，后面就是具体产品实现、落地档案以及产品呈现。细节还没有讨论清楚会议室就到了关门时间，我们全组只好转战到了酒店的二楼继续进行。</li>
<li>激烈讨论：在讨论的过程中，我们有很多的争执，做 RD 的总是感觉没必要这么较真，一直聚焦在产品细节的设计上，时间有限，应该直接开始做，后面有时间的话，我们再去优化产品。而组里的另外两名 QA 和 PM 却认为这很重要，一直聚焦在产品的具体表现形式上。最后觉得争执也没有什么用，我只好开始先做 PPT，具体产品实现由他们来做。</li>
<li>感慨：通过这次的产品设计，能明确感受到我们之间思维的差异，这当然没有对错之分，作为工程师，我们在乎的是能不能按时完成，或者是更有效率地完成，而产品经理考虑则是产品的细节上。</li>
</ol>
<p>最后奋战到了凌晨四点半，直到 PPT 做得差不多了，我们才回去休息，这时候脑袋基本上已经停止了思考，实在是太困了，这是近三年来睡得最晚的一次。</p>
<h2 id="周五"><a href="#周五" class="headerlink" title="周五"></a>周五</h2><p>凌晨5点才睡觉，睡到早上九点爬起来去上课。</p>
<h3 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h3><p>上午的课程是介绍产品相关的内容，但是这节课说实话并不是很好，可能一个是自己比较困，并没有认真听讲，但在跟其他的学员交流后，发现我们的感受都差不多，在课程中并没有想象中收获的那么多。培训的同学大都是 rd，pm 很少，我们很希望这门课应该是一个产品经理的入门课程，通过这节课至少会对一个产品经理的日常工作以及产品的设计方面有一个基本的了解，但是这节课的安排并没有那么好，感觉太偏理论性，先介绍理论然后快速把案例过了一下，并没有很好地将理论与具体的案例结合起来，这样的话培训的效果就会很差，作为一个入门的产品小白，并没有从这节课中收获到更多的东西。</p>
<h3 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h3><p>上午的课程结束之后，我们就赶紧修改了我们的 PPT，好在最后在1点半前把 PPT 完成了，由于 PPT 的第一部分是我写的，所以这部分的内容是由我来讲解的，在台上讲解并没有想象中的那么紧张😝，但是演讲技能还是需要很大提高的，很多的时候心里想的东西，在台上讲解时就很自然地忘记了，还是有待锻炼的。虽然我们产品的呈现并不是很理想，但在这个过程中，收获了很多，有以下几点感想：</p>
<ol>
<li>现在我依然认为我们确实是找到了产品的一个缺陷，但是业内目前都没有一个很好的解决方案，应用场景基本上都一致，但是我们在分析其他公司的积分商城时，只考虑 IT 行业，并没有去研究一些传统行业的做法，没有<strong>使用水平思维去看待问题</strong>；</li>
<li>优秀的产品一定要是简单，我们产品设计和呈现都有些过于复杂， 而且还没有对他人讲解清楚，一个好的产品呈现，应该是能够简单清晰地表达出来的；</li>
<li>并没有更多地去分析如果推出了这个产品之后的效果，是不是会像预期的效果那样，用户会不会去 care 这样的一个变动；</li>
<li>其他组的产品在呈现上设计得更加优美，而且有几个产品的设计得确实很不错，简单名了。</li>
</ol>
<p>虽然我们并没有拿到大奖，但是通过这次活动，了解到了一个产品设计的设计过程，尤其是当你去寻找方向时，会发现很多的领域都已经被巨头占领了，创业公司很难能够有所突破。</p>
<h3 id="高管交流会"><a href="#高管交流会" class="headerlink" title="高管交流会"></a>高管交流会</h3><p>这次来交流的是公司的穆总，去年初到公司时，就听同事说到过穆总的大名，后来也参加过一次搜狐的高管交流会，中间也听到了搜狐北研的负责人讲起了穆总当年的那些事，而这次终于有机会能够与穆总面对面交流。听穆总讲话确实收获颇丰，交流会全程分为两个部分：先是穆总给我们的一些建议，后面是穆总的一些 QA。</p>
<p>穆总给我们的三个建议，也是穆总的一些感概：</p>
<ol>
<li><strong>学习成长，持续的学习和成长</strong>，这个社会变化很快，离开学校只是一个起点，并不是学习的终点，未来的社会可能会变化更快，这就要求我们必须<strong>活到老学到老</strong>，去拥抱变化；</li>
<li>要<strong>下苦功夫</strong>，10000小时理论是大家广泛周知的一个理论，听说过这个理论可能有50%的人，但真正去做的可能不到25%，而最后能够下苦功夫坚持做下来的连10%也不到，而最终能够做到的这10%的人将会去管理这剩下90%的人；</li>
<li><strong>耐心</strong>，现在的互联网发展很快，也使得很多人都变得浮躁，没有耐心去认真地做事情，当年（07年左右）从 BAT 离职创业的那些人90%的并没有他们之前的同事过得更好，现在我们的面前充满着各种各样的”机会”，但是我们要去分辨着这些”机会”，看看这些是不是真的”机会”（通过商业的本质去分析一家公司的机会）。</li>
</ol>
<p>穆总讲完这三点之后，给我们留了足够的时间进行 QA，QA 的三个问题都是业务方面，能明确感受到大家对美团点评前景的担心，毕竟公司的负面新闻太多，我们确实也在各个领域均遇到强劲的对手，在穆总的耐心解答中，总结了以下几点，有对穆总的感觉，也有穆总对公司业务的分析：</p>
<ul>
<li>穆总对商业的洞察力、对产品的思考，都很深入的，<strong>商业的本质就是去解决现实中存在的问题</strong>；</li>
<li>穆总非常<strong>务实</strong>，他现在负责美团金融，我们问未来美团会不会出一款类似与微信支付或支付宝的产品时，穆总很直接地说了，现在的市场是不需要一家类似于支付宝或微信支付的产品，但是我们依然有东西要去做，当把一些基本的东西做好之后，未来如果出现新的变革，我们就有机会去做一些事情；</li>
<li>创新：应该多去尝试，很多业务都是尝试出来的，以现在要发展的美团打车为例，打车领域有巨头，但不代表我们必须要放弃这个市场，出行市场是足够大的，不应该只有一家公司存在，如果这样的话，其实对于用户也不是很好的选择，<strong>就像电商领域，虽然阿里占据垄断地位，但是京东、唯品会依然过得不错</strong>，打车领域做到第一很难，但我们可以去做第二或第三，既然打车是吃喝玩乐的一部分，而美团点评是定位为吃喝玩乐一站式的平台，那么打车就必须要做，还有一点是很重要就是：打车领域的需求并不是都被满足了，至少对于打车师傅而言，由于滴滴抽成太高师傅们都是不满的；</li>
<li>居安思危：这点从穆总的交流中，能明显感觉出来，美团是一家很谨慎的公司，创业公司稍不留神可能就会被淘汰，所以美团的高管们<strong>危机意识</strong>很强，在去年的时候，当时我就能感受到未来支付宝可能是美团最强劲的对手，而糯米并不足以为率，当时只是纳闷为什么美团不进行正面反击，支付宝通过口碑、饿了么对美团发起强攻，但美团除了外卖高歌猛进其他的业务似乎是一直在守，这个令我很不解，现在再去回头看，就清晰很多了，一个是公司没有那么大的财力去多线强烈作战，另一个是公司在过去一到两年里一直在勤练内功，避免像 BAT 那样浪费资源，相信过不了多久美团就会强力反击，但前提是内功要先练好；</li>
<li>总结教训：穆总是从百度出来的，离开百度的时候还是 BAT，现在已经变成 AT 了，百度的没落有很多种原因，我们能做的就是从中吸取教训，避免走百度的老路，可能<strong>谷歌的退出就是百度没落的开始</strong>，没有竞争对手就会让一家企业忘乎所以。</li>
</ul>
<p>通过近两个多小时的交流，关于业务一些不理解的地方，瞬间开朗了很多，也对公司未来的前景非常看好。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>五天的培训，很快就结束了，通过这次培训，感觉很幸运能够加入美团点评 —— 一个认真做实事的公司，希望美团点评明天更好，下面是一张我们全体学员的合照，希望大家明天更好！</p>
<p><img src="/images/essary/070523training.jpeg" alt="大家庭"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周参加了公司的封闭式入职培训，总共是五天的时间，今年是公司第一次进行校招封闭式培训。记得去年七月份来公司实习，一起入职的校招同事参加的入职培训才两天时间，而且也不是封闭式的，一年的时间，变化还是很大的，这也间接证明公司的发展速度很快。作为公司第一届参加封闭式入职培训的员工
    
    </summary>
    
      <category term="随笔" scheme="http://matt33.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://matt33.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>腾讯传，一个激情澎湃的时代</title>
    <link href="http://matt33.com/2017/04/16/tencent-read/"/>
    <id>http://matt33.com/2017/04/16/tencent-read/</id>
    <published>2017-04-16T08:11:14.000Z</published>
    <updated>2017-06-21T00:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两周把<a href="https://book.douban.com/subject/26929955/" target="_blank" rel="external">《腾讯传》</a>看完了，这本书去年出版的时候就想去看，但是一拖就拖到了现在，直到上周出去玩，回来的时候路上遇到了堵车，车上实在无聊，就开始看这本书。我平时是比较喜欢看这类科技史或科技公司史的书，第一次看这种类型的书，读的吴军老师的<a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">《浪潮之巅》</a>，当时真叫是一个过瘾，至今还记得当时那种情景 —— 怎一个爽字了得，一口气连着两天在图书馆把这本书看完了。可是现在在看《腾讯传》时，已经没有了那种感觉，但最后还是在两周的时间里把这本书看完了，跟着吴晓波一起重温了一个伟大互联网公司（3Q 之后的腾讯）发展历程 —— 一个激情澎湃的时代。</p>
<p>改革开放三十多年以来，个人认为给中国经济带来最大贡献的应该是两个方面：制造业和互联网。这十几年来，互联网公司上市造富神话，可以说是激励一批又一批的有志青年投身创业大潮。互联网这个行业应该可以说是所有行业里面竞争最透明、最激烈的行业了，它成功冲破了国企垄断的壁垒、也幸运地战胜了美国的一些互联网巨头的入侵，使得中国市场在全球显得独树一帜。从八十年代中国第一次连入到全球互联网开始，中国的互联网主要经历了三个重要阶段：</p>
<ol>
<li>1999年左右，以新闻行业（靠广告挣钱）为基本生态，出现了新浪、搜狐和网易三巨头；</li>
<li>2007年之后，出现了以应用平台为基本业态的大洗牌，门户们陷入“模式困境”，出现了成长乏力的态势，而百度、阿里巴巴和腾讯则分别从搜索、电子商务和即时通信工具三个方向出发，到2010年前后完成了反向超越，成为“新三巨头”，它们被合称为 BAT。</li>
<li>从2012年开始，智能手机异军突起，互联网的用户重心从电脑端向移动端快速平移，移动互联网时代开始，出现了诸如小米、美团、滴滴、头条的几个小巨头，百度在不到5年的时间里由于没有抓住机遇迅速衰退，互联网进入白热化时代 —— 腾讯阿里争霸时代。</li>
</ol>
<p>曾经有段时间，我们感觉互联网行业好像机会已经很少了，各个方向都有巨头在做，可是在2014年，大数据开始火热，2016年，人工智能开始迅速走进了所有人的视野，斯坦福也开始设置数据科学的专业，美国中国的政府都开始发力，抢占人工智能的风口。可以这样说从2016年开始，互联网开始进入人工智能争战的时代，估计在2020年左右也会出现几个像美团、滴滴、头条这样的小巨头，互联网行业似乎时刻都充满着机会，竞争也从来没有间断，稍不留心可能就会被对手迅速甩开。但腾讯似乎总能抓住这些热潮，至少从目前来看是这样的，这本书就是带领我们去看一下腾讯这家巨头的发家史。</p>
<p>说到腾讯发家史，有个故事，大家应该都听过 —— 马化腾当年要以100W 的价格将 QQ 卖掉，可是别人只出50W，最后因为价格没谈拢，交易就没成功。那个时期应该是腾讯起家时最困难的一段时间，其他的公司，像网易通过卖邮件系统和广告、搜狐新浪也是通过卖广告已经过得很滋润了，甚至都开始到美国上市了，而腾讯当时还在破产边缘挣扎。腾讯在推出 QQ 之后，并没有找到一个合适的商业模式，后来随着 QQ 用户达到100W、1000W，需要越来越多的服务器，腾讯在其他领域挣的钱全都投入到 QQ 这个项目上了，但公司维持起来依然很艰难，幸好腾讯在2000年互联网泡沫前拿到了风险投资，否则腾讯可能真的就不撑不下去了。</p>
<p>拿到投资之后的腾讯，暂时缓解资金的压力，但是如果找不到合适的变现途径，这种模式依然是不能持续下去的。腾讯甚至在一段时间里由于用户量暴增，不得不对每天的 QQ 注册量进行限制，在这期间，腾讯可以说被用户骂得要死，而且其他的竞争对手公司，像网易都开始推出自己的即时通信工具（网易泡泡）来狙击腾讯，腾讯被迫只能继续开放 QQ 免费注册。腾讯在这段时间内依然面对着巨大的资金压力，腾讯找到的第一个商业模式，就是与中国移动合作，当时中国移动刚从中国电信中独立出来，同样需要迅速找到一种商业模式与中国电信、联通进行竞争，于是乎推出了一个移动梦网的项目，腾讯从这中间拿到分成，曾经一度这个项目就是腾讯生存下去的基础（如果后来不是移动自己推出飞信并取消其他公司分成的话，恐怕腾讯也不会变得这么骁勇）。直到后来 QQ 秀的出现，这应该是腾讯历史上的一个重要事件，算是腾讯找到了第二个商业模式。QQ 秀是从韩国的一款产品中借鉴而来的，腾讯对其进行了本土化的改造，中间进行了很多的微创新，腾讯自己都没想到这款款产品一推出就获得出乎意料的欢迎，腾讯推出第一个砖石系列以及 QQ 币等支付产品，这是腾讯第一次从 QQ 用户直接获取收入，腾讯这个时候才开始意识到 QQ 强大的商业价值。在很长的时间里，腾讯陆续推出了网游、棋牌、QQ 空间（偷菜）、QQ 音乐、腾讯网门户网站、搜搜等产品，大多数的产品都获得了巨大的成功，腾讯过得是不亦乐乎，腾讯也基本上也形成了抄袭+微创新+对产品打磨这个套路，靠着这个套路，腾讯攻城掠地，到了2010年，腾讯已经成为了中国互联网的老大。腾讯自己过得很滋润，正所谓此消彼长，其他人过得就不如人意了，尤其是那些被腾讯抄袭并彻底打垮的公司。腾讯凭借自己 QQ 强大的用户基础不断抄袭（借鉴）其他公司的产品，并将其移植到自己的生态下，而被抄袭的企业后来基本上都跪了。</p>
<p>在当时，对于这位互联网老大，整个业界都是敢怒不敢言，当时很多创业公司在融资时，都会面对一个问题 —— 如果腾讯也做这个的话，怎么办？后来就出现了互联网史上比较出名的 3Q 大战。具体的孰对孰错，现在来说已经不重要了，不过这个事件显示了业界对腾讯的愤怒，腾讯几乎成了众矢之的。腾讯在这次危机中，面临着很大的舆论压力，后来腾讯开始进入半年的调整期，后来决定拥抱开放（互联网的基本精神）。腾讯确定了”连接一切”的战略，开始开放自己的平台，也开始承担自己应该承担的责任，陆续投资了很多的互联网公司，像大众点评、滴滴、微票儿等等，建立了一个很强大的生态（又称腾讯系），现在也只有阿里可以与之抗衡。可以说，如果没有 3Q 大战，就没有后来的腾讯，腾讯在移动互联网之争中，就很有可能与百度一样被阿里甩到后面。所以说，遇到危机，如果能从吸取教训，那么在下次机会到来时就有可能抓住机会。</p>
<p>还有一点要说的是，腾讯在发展的过程中，有两点非常值得学习：</p>
<ol>
<li>产品的打磨：腾讯应该第一个对产品这么重视的公司，毕竟腾讯的产品都是直接与用户打交道的，腾讯的产品文化，很值得学习；</li>
<li>公司内部的赛马机制：这个机制本来是为了鼓励一些中层领导的团队之间相互竞争，它最成功的产品就是微信，现在微信可以说是已经彻底融入到我们的生活中了。</li>
</ol>
<p>腾讯的成功，有很多的原因，最大的原因应该就是机遇 —— 合适的时间做了合适的事情，在一个激情澎湃的时代，与一群志同道合的人，做了一件不甘于平凡的事情。</p>
<hr>
<p>读书中记录的笔记</p>
<blockquote>
<p>中国互联网发生过三次“圈地运动”。第一次是在1999年前后，以新闻门户为基本业态，出现了新浪、搜狐和网易“三巨头”。2007年之后，出现了以应用平台为基本业态的大洗牌，门户们陷入“模式困境”，出现了成长乏力的态势，而百度、阿里巴巴和腾讯则分别从搜索、电子商务和即时通信工具三个方向出发，到2010年前后完成了反向超越，成为“新三巨头”，它们被合称为BAT。而从2012年开始，智能手机异军突起，互联网的用户重心从电脑端向移动端快速平移，由此发生了第三次“圈地运动”。—— Kindle Edition. loc. 151-156.</p>
</blockquote>
<p>Notes: 1) 互联网的三个重要时期,现在理论上应该处于第四个时期—人工智能。</p>
<blockquote>
<p>马化腾的七种武器”，它们包括： 第一种武器：产品极简主义。—— Kindle Edition. loc. 183-183.</p>
</blockquote>
<p>Notes: 1) 简单是美</p>
<blockquote>
<p>第二种武器：用户驱动战略。—— Kindle Edition. loc. 188-188.</p>
</blockquote>
<p>Notes: 1) 用户为核心。</p>
<blockquote>
<p>第三种武器：内部赛马机制。—— Kindle Edition. loc. 192-192.</p>
</blockquote>
<p>Notes: 1) 中层通过创新的产品可以实现超越。</p>
<blockquote>
<p>第四种武器：试错迭代策略。—— Kindle Edition. loc. 196-196.</p>
</blockquote>
<p>Notes: 1) 就如同小米提出的“快,极致,专注口碑”。</p>
<blockquote>
<p>第五种武器：生态养成模式。—— Kindle Edition. loc. 199-200.</p>
</blockquote>
<p>Notes: 1) 管理。</p>
<blockquote>
<p>第六种武器：资本整合能力。—— Kindle Edition. loc. 204-204.</p>
</blockquote>
<p>Notes: 1) 资本为公司生态服务。</p>
<blockquote>
<p>第七种武器：专注创业初心。—— Kindle Edition. loc. 207-207.</p>
</blockquote>
<p>Notes: 1) 勿忘初心</p>
<blockquote>
<p>在中国乃至全球的互联网史上，从1998年到1999年的两年间，是一个神秘的时期，错过了这一段，也就错过了一个世代。—— Kindle Edition. loc. 621-622.</p>
</blockquote>
<p>Notes: 1) 正好与前两天雄安新区设立形成对比,当年人创业激情非常饱满,对成功很渴望,而现在的人则 2) 正好与前两天雄安新区设立形成对比,当年人创业激情非常饱满,对成功很渴望,而现在的人则变了很多。</p>
<blockquote>
<p>OICQ在日后被业界评价为一个不可多得的“天才产品”，宣称其系统架构在用户发展至亿级时仍然能够支撑。唯有张志东清楚其中的艰辛，所谓的“天才”都是靠徐钢武、吴宵光以及后来无数工程师不断“重写”和优化的结果。“用户快速增长，性能瓶颈不断出现，为了不让用户失望，逼得团队不断优化性能，不断克服瓶颈。说到底，都是逼出来的结果。”张志东日后回忆至此，无限感喟。——<br> Kindle Edition. loc. 814-818.</p>
</blockquote>
<p>Notes: 1) 传言并不准确,系统后来还是zuole 很多优化的,技术是为业务而服务的。</p>
<blockquote>
<p>这就是创业到第20个月的腾讯：在走了一段弯路之后，它找到了核心产品，拥有了一支志同道合的团队和一个可爱的品牌形象，它还不知道该如何盈利，不过已经有人愿意为它的未来买单。—— Kindle Edition. loc. 1121-1122.</p>
</blockquote>
<p>Notes: 1) 腾讯的发展着实曲折,没有盈利模式的互联网企业在融资过程中只是会面对资金匮乏的过程情况,可是那么牛逼的互联网公司在初创时期又有几个能直接就找到盈利模式的。</p>
<blockquote>
<p>市场在不停地变化，企业所在行业的利润来源区也不停在变，企业必须随着利润区的变化而变换自己的企业设计和盈利模式。（亚德里安·斯莱沃斯基（美国管理学家），《发现利润区》）—— Kindle Edition. loc. 1125-1126.</p>
</blockquote>
<p>Notes: 1) 多观察其他领域的盈利模式,说不定就会找到一些借鉴之处。</p>
<blockquote>
<p>在腾讯的历史，乃至中国互联网史上，QQ秀都堪称一款革命性的收费产品，它可以被视为全球互联网产业的一次“东方式应用创新”。腾讯不是这一创新的发起者，可是它却凭借这一创新获得真正商业上的成功。而比商业利益更有价值的是，QQ秀让腾讯与它的亿级用户建立了情感上的归属关系。—— Kindle Edition. loc. 1422-1424.</p>
</blockquote>
<p>Notes: 1) 没想到qq 秀启到的作用竟然这么大,虽然不是腾讯首先提出的,但腾讯却将它利用得淋漓尽致。</p>
<blockquote>
<p>围绕“QQ人”，为他们提供各种服务是腾讯商业模式的本质。—— Kindle Edition. loc. 1461-1462.</p>
</blockquote>
<p>Notes: 1) 人们需要的聊天工具并不是只有聊天的功能。</p>
<blockquote>
<p>程苓峰敏锐地窥视出了腾讯多元化战略中的一个特征：紧盯市场动态，以最快的方式复制成功者模式，利用QQ用户优势进行后发超越。—— Kindle Edition. loc. 2030-2031.</p>
</blockquote>
<p>Notes: 1) 腾讯在开始形成的一个传统,这个传统也给腾讯未来带来了很多的负面问题。</p>
<blockquote>
<p>“模仿而不创新”“以天下为敌”和“拒绝开放”便成为腾讯的“三宗罪”。—— Kindle Edition. loc. 2043-2043.</p>
</blockquote>
<p>Notes: 1) 腾讯在最开始时,不断寻找自己的商业模式,一直在盈利而发愁,直到qq 秀的出现让腾讯意识到原来自己是可以通过用户导流量、从用户身上获取利润的。qq 秀也是腾讯借鉴的商业模式,让腾讯开始尝到了甜头,在后来腾讯慢慢形成了后发制人,由于自己强大的用户规模,明目张胆抄袭他人的商业模式,近而在一段时间甚至成了全民公敌。</p>
<blockquote>
<p>腾讯在此次事件中所遭遇到的舆论攻击更让马化腾一度意兴阑珊，在访谈中，我能够非常清楚地感受到他的困惑与郁闷，甚至在某些时刻，他的价值观都有点动摇。正如黑格尔所言，获得认可的欲望是人类生存最基本的愿望，马化腾一向自诩为产品经理，日夜所思皆是用户体验及得到他们的认可，然而，就是在这个层面上，他遭遇了致命的质疑。—— Kindle Edition. loc. 3676-3679.</p>
</blockquote>
<p>Notes: 1) 3q 大战之后,腾讯开始改变了自己的策略,从一个封闭、向全行业开战的平台变成了一个开放的平台,这也使得腾讯能够在下一波互联网战争中(移动互联网时代),没有失去自己的先机,反观百度,已经落后了很多。</p>
<blockquote>
<p>过去，我们总在思考什么是对的。但是现在，我们要更多地想一想什么是能被认同的。 （马化腾，《给全体员工的邮件》）—— Kindle Edition. loc. 3683-3684.<br>Notes: 1) 换句话说,对的东西并不一代被认同。</p>
<p>无论是年轻化方向、娱乐社交战略，还是场景化通信的打法，QQ在移动互联网时代的玩法渐渐清晰，与微信之间的关系也更加明朗。通过完善两大社交平台的生态，腾讯用两条腿走路的整体布局成为可能。—— Kindle Edition. loc. 4245-4247.</p>
</blockquote>
<p>Notes: 1) qq 是偏年轻化的一款产品,功能太多,对于成年人来说甚至有些臃肿,但微信就会简单很多,遵循互联网的极简主义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两周把&lt;a href=&quot;https://book.douban.com/subject/26929955/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《腾讯传》&lt;/a&gt;看完了，这本书去年出版的时候就想去看，但是一拖就拖到了现在，直到上周出去玩，回来的
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>欧洲简史</title>
    <link href="http://matt33.com/2017/04/04/read/"/>
    <id>http://matt33.com/2017/04/04/read/</id>
    <published>2017-04-04T08:11:14.000Z</published>
    <updated>2017-07-21T15:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近几周把这本<a href="https://book.douban.com/subject/5366248/" target="_blank" rel="external">你一定爱读的极简欧洲史</a>读完了，在阅读的过程中，感觉真的是很爽，不愧是豆瓣的8+分图书。读完本书，可以对欧洲的历史有一个大概的了解，即便是最后很多的细节记不清楚，但是整个历史过程还是会有一定的印象，能建立一个大概的时间线。读完本书，如果再有人问你<code>为什么现代科学、政治制度会诞生在西方，而不是一直领先的中国？</code>你应该也能说几个理由的。</p>
<p>全本主要分为两个部分，第一部分整体介绍了一下欧洲的大概历史进程，第二部分选取了其中的六个比较重要的方面进行介绍。纵观欧洲整个历史，大题可分为三个时代：古典时期、中世纪和近代，如下图所示。古典时期主要是古希腊和古罗马时代，而中世纪又称黑暗的中世纪，直到公元十五世纪开始文艺复兴之后，欧洲才逐渐从中世纪中走出来，进入到近代。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/573840-8f214b350ec6cd08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欧洲历史年表"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/573840-07a2b5d47fe3f014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宗教与西方"></p>
<p>从最开始看这本书，到这本书看完，大概花了三周时间，看书的时间依然在上下班的途中，都是利用一些零碎的时间去看的，到了现在书中能记住的东西已经不是很多，这里根据脑海中残留的大概印象对以上三个时代做一下总结：</p>
<ul>
<li>古典时期：那是个百花齐放的时代，科技、文化、政治都能达到了很大的高度，在西方人民的心中（特别是中世纪人民），那个时代简直可望而不可即，所以那个时期被称为古典时期。那个时代出现了苏格拉底、柏拉图、亚里士多德（古希腊三贤）等人，在天文上也提出了“地心说”的理论，古希腊在几何的贡献也是我们现代数学的基础，当年雅典也出现了很多的民主制度，后来的古罗马基本继承了古希腊的制度，进一步发扬了古希腊文化。在古罗马时代，出现了很多的宗教，可以说百家争鸣，后来的基督教在当时还是很小众的一个教派，直到后来古罗马帝国的君士坦丁堡大帝开始信奉基督教，导致了基督教开始走进古罗马的权力中心，开始影响欧洲历史之路。</li>
<li>中世纪：中世纪之所以被称为<strong>黑暗中世纪</strong>，完全是因为在那个时代，人们没有宗教信仰自由，只能信奉基督教，也就是天主教，其他的教派（新教、伊斯兰教等）都被称为异教；也没有读书自由（暂且这样说吧），很多古罗马时代书都被教皇保留下来，但教皇是为了通过这些著作也印证基督教的真实正确；也没有民主等等。当年人们为了死后进入天堂也是煞费苦心，教皇发放救赎劵，教众们就会去买，也不管教皇拿着这些钱作何用途（事实上是为了十字军东征）。说起这个时代的开始，就离不开日耳曼民族，当然现在的日尔曼民族已经不是当年的日尔曼民族，现在欧洲大部分的人应该都是当年日尔曼民族的后代，那个时代的日尔曼民族又叫做<strong>日尔曼蛮族</strong>，它们类似于现在的非洲部落，虽说都是日尔曼蛮族，但是却有多方的势力，并没有形成一个统一的组织，但就是这样一批人，把当年不可一世的古罗马帝国灭掉了（确切说应该是西罗马帝国），西罗马帝国被灭掉当然也有其自身衰落的原因。日尔曼蛮族虽然灭掉了西罗马帝国，但他们只是来抢东西，并没有统治这片土地的意思，而且他们最后居然保留了基督教，甚至很多人都开始慢慢信奉基督教。当时的西方虽然被很多封主、国王统治，但基督教却是一个非常统一的组织。可以说在当时君权和教皇各是一个权力终端，它们相互制约、相互牵制、相互斗争，有时候甚至是相互利用。有句话叫做有压迫就由反抗，后来马丁路德建立起新教学说就是对现任教皇的一个反抗，新教从个人的自由出发，很快就吸引了很多的民众，新教和天主教只是对《圣经》的不同解读。</li>
<li>近代：近代应该是从文艺复兴开始，文艺复兴实际上就是对古希腊罗马学术的发现和再发现，他们不希望一直接受一个被教会阉割的古典。在以前，教会虽然保留了很多古希腊罗马的学术，但是都是为了用来印证《圣经》、为教会而服务，但是现在，大家突然发现原来古希腊罗马的学术不是这样的，原来古典时期的学术、制度是那么发达，令当代人敬仰。不过随着文艺复兴的影响进一步加深，当代的思想得到很大的解放，一批如哥白尼、伽利略、牛顿等人的出现，让当时的人民觉得原来我们一点也不比古希腊罗马人笨、甚至还比他们更聪明，他们也发现原来古希腊罗马的学术并不一定全是正确的，于是各种科学开始迅速发展，为现代文明奠定基础。</li>
</ul>
<p>在本书的第二部分，重点从以下六个小的方面开始讲述欧洲历史的发展，这六个方面可以说是欧洲文明的重点组成，甚至可以说是现代欧洲文明的基石：</p>
<ol>
<li>争战一千年。从最开始的日尔曼蛮族入侵，欧洲在之后的一千年里，几乎是纷争不断，后来的穆斯林入侵、维京人入侵、十字军东征，不过这也激发了欧洲人爱冒险的血性，对后来的大航海时代也有一定的作用。</li>
<li>民主意识，这样开始的。欧洲文明给人类带来的一个重大财富就是——民主，民主最开始是诞生在古希腊，后来随着中世纪的到来，欧洲人民并没有实质意义上的民主，但也因为欧洲在罗马帝国之后就再也没有出现过一个统一的帝国，这才幸运地阻止了欧洲陷入东亚帝王专制的世界里。</li>
<li>有国王的民主，没国王的极权。这部分主要是指英国与欧洲大陆，英帝国有国王，但是因为新教（崇尚个人自由）和国会（对国王的选择起很大的作用）的缘故，使得英帝国率先走向君主立宪制，建立了民主的英帝国。反观欧洲大陆，有的地方却很极权，比如法国，最后导致了法国大革命，不过民主终究胜于极权。</li>
<li>皇帝和教皇到底谁大？欧洲有一个很特殊的现象，那就是它有两个很强大的权力系统，一个是教会，一个是政府，这两个冤家相互争斗、相互利用，都是为了各自的利益。只要皇帝并没有建立一个统一的帝国，皇帝终究是摆脱了教会的束缚，而教会也会为了自己的利益利用手中的权力来约束皇帝的权利，反而给民主提供了很好的土壤。</li>
<li>语言：从两种变几十种。欧洲的主要语言体系应该是两种：日尔曼语系和罗曼语系（拉丁语系）。</li>
<li>平民百姓的生活面貌。在工业革命之前，一千多年，欧洲85%以上的人口就是从事农业相关，这也是西方人见面经常会问天气的原因，因为天气会影响到大部分人的生活。</li>
</ol>
<p>读完本书，确实会对欧洲大概的历史有一个认识，但毕竟是欧洲简史，如果想了解欧洲历史的细节，这本书是远远不够的，但这本书会给你打开一个欧洲文明史的大门，非常推荐。</p>
<hr>
<p>下面是在读书过程中对一些自认为比较重要的内容，做的一些笔记。</p>
<blockquote>
<p>第二次的大侵略来自穆斯林，时为7世纪到8世纪，距离日耳曼蛮族入侵仅仅两百年。伊斯兰教始祖穆罕默德原为阿拉伯商人，得到神的天启后创立该教。他这支借由神助发展出来的宗教，与犹太教和基督教有紧密联系；穆斯林也承认耶稣和耶稣之前的先知们确实是先知，但深信穆罕默德是世上最后一位先知，能指引大家走向唯一真神安拉的怀抱。伊斯兰教比起基督教来说简单许多。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 800-804</p>
</blockquote>
<p>Notes: 1) 伊斯兰教发源</p>
<blockquote>
<p>国王，也就是先前的日耳曼战士首领，他将土地分发给自己的子弟兵，而这些下属必须提供国王打仗所需的战力作为回报，一个国家就建基于这样的关系上。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1112-1113</p>
</blockquote>
<p>Notes: 1) 君主处于弱势的开始,君主对于土地、税收不再直接掌控,而这些权力尽数被封主拿去。</p>
<blockquote>
<p>由于立足点薄弱，封建制度的君主必须征询国内权势人士的建言。他们没有一支自己能够全权控制的军队，也没有常态的征税制度或行政部门，因此，在做决定之前，他们会邀集重要人士，听取这些人的意见并征得同意才能拍板定案。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1143-1145</p>
</blockquote>
<p>Notes: 1) 间接地限制了国王的权力,这也是西方没有形成封建专制的原因。</p>
<blockquote>
<p>英国国会让自己成了宪政体制的一个常设单位。整个过程没有流一滴血，史称“光荣革命”。—— 约翰•赫斯特, 你一定爱读的极简欧洲史， loc. 1265-1266</p>
</blockquote>
<p>Notes: 1) 欧洲大陆在走向专制的过程中,英国并没有步入后尘,宗教在这过程中起到了很大的作用,英国此时已是新教的天下,国王想通过天主教达到自己的目的反而适得其反。</p>
<blockquote>
<p>新教教义从一开始便是以保障个人自由为出发点，因为它干犯教皇和主教的权威，提升了个人的意识和地位。在英国，它与自由的关系更是密不可分，因为英国的敌人——法国和西班牙的专制君主都是天主教徒，而那些试图架空议会的英国国王不是信奉天主教就是对天主教手软之辈。保存国会与保存新教信仰合而为一，成了殊途同归的新教志业。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1281-1285</p>
</blockquote>
<p>Notes: 1) 在西方,自从罗马帝国之后,宗教与政治就变得密不可分,而天主教更侧重于上层人的利益,甚至是专制,新教则是从个人出发,更侧重于个人的自由,限制了君主的权力,比较符合国会的利益,因此,英国甚至把新教写进权力法案,以保护国会的权力。(当然国会最开始代表的并不是普通民众的利益)。</p>
<blockquote>
<p>查理大帝建立的帝国消失了，教皇也失去了保护他的强人。有一段时间教皇得过且过，哪个地方王侯支持他，他就把谁加冕为王。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1435-1436</p>
</blockquote>
<p>Notes: 1) 教皇也逐渐成了政治的一部分,教皇也只是为了寻找一个保护伞。</p>
<blockquote>
<p>双方（皇帝和教皇）都承认对方的存在有其必要，争的只是彼此的相对权力。这是西罗马帝国一个非常重要的特色，也是它和东罗马帝国的分野所在。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1495-1496</p>
</blockquote>
<p>Notes: 1) 东罗马帝国的教皇则完全由皇帝指定。</p>
<blockquote>
<p>拉丁语，跟罗马帝国的概念一样，已经气若游丝很久了。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1748-1749</p>
</blockquote>
<p>Notes: 1) 拉丁语跟罗马帝国一样,可以说是一直存在着,对后世影响深远。</p>
<blockquote>
<p>所有的人都老是为收成担心害怕。谈天气不是为了没话找话说，而是一群人在忧心自己的命运。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1810-1811</p>
</blockquote>
<p>Notes: 1) 西方见面聊天气原来是这个原因,有很多的历史背景,在工业革命之前西方基本上85%以上从事农业相关,所以大部分人都对天气非常重视。</p>
<blockquote>
<p>在欧洲，当国王的总是强敌环伺，而中国皇帝的君权无人能比，这是他们拥有的优势——或者说是陷阱。欧洲国家之间相互为敌，是它们向海外扩张的一股推动力量。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1949-1950</p>
</blockquote>
<p>Notes: 1) 中国皇帝权力过大,而西方的国王从未有如此之强权。</p>
<blockquote>
<p>欧洲的历史演进泰半从奠基的这一刻起便已注定。政府对人民毫无掌控能力，它们必须殚思竭虑，才可能争取到人民的服从。它们若想扩张势力，就得提供良好的政府——也就是维护治安作为回报，它们不能像亚洲和中东不计其数的帝国及王国那样，光靠收税机制和进贡就能运转。 数百年来，这些国王最大的威胁是他们最有权势的下属——土地贵族阶级。这些权臣最后终于俯首，但因为已在自己的领土上雄霸够久，早就为自己也为他们土地上的人民争取到私有财产的保障。“不是所有的东西都属于国王”，这是欧洲自由和繁荣的基石。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1956-1962</p>
</blockquote>
<p>Notes: 1) 这是西方与东方政府的主要区别,没有东方这种“普天之下,莫非王臣,普天之地,莫非王土”思想,政府对人民并没有绝对的控制力,人民有自己的私有财产,这也是公民限制政府权力的基础。</p>
<blockquote>
<p>在中国，权力是极其明确地集中在皇帝手里，以儒家为尊的精英文化对君权统治也支持有加。无论是个人修为或待人处世，中国人莫不以儒家思想为圭臬，它已深深扎根于整个社会和国家。统治者不管有没有合法性都得熟读四书五经，而你得通过儒家经典考试才能当上国家官员。 反观欧洲，权力不但分散，精英文化也是个大拼盘，与君权统治之间的系带并不牢固。中国人非常聪明，可是他们的聪明从来不会脱轨失控，纵有奇思异想，基本上都不曾造成纷扰。欧洲社会的开放则是源远流长。<br>近代欧洲在经济上爆发力十足，智识生活百家争鸣，皆是基于一个事实：不管是好是坏，从来没有一个单一强权掌控过它、形塑过它。它多元的历史遗产因此能被充分发掘、延伸；希腊的数学观念在科学革命时期得到实现，从而建立起科技创新的一个新基础。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1991-1997</p>
</blockquote>
<p>Notes: 1) 分析了欧洲与中国的一个巨大区别</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几周把这本&lt;a href=&quot;https://book.douban.com/subject/5366248/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;你一定爱读的极简欧洲史&lt;/a&gt;读完了，在阅读的过程中，感觉真的是很爽，不愧是豆瓣的8+分图书。读
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Storm 对 0.10.x 版 Kafka 支持解析</title>
    <link href="http://matt33.com/2017/03/17/storm-kafka-0-10-1/"/>
    <id>http://matt33.com/2017/03/17/storm-kafka-0-10-1/</id>
    <published>2017-03-17T14:24:31.000Z</published>
    <updated>2017-07-23T07:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于 0.10.x 版 Kafka 与 0.8.x 版有很大的变化，这种变化对下游 Storm 有非常大的影响，0.10.x 版的 Kafka 不但增加了权限管理的功能，而且还将 simple 和 high consumer 的 offsets 进行统一管理，也就意味着在 0.8.x 中 Storm 需要去负责管理 offsets，而在 0.10.x 中，Storm 不需要关心 consumer 的 offsets 的问题，这对 KafkaSpout 的设计有很大的影响，本文就是对 <code>Storm 对 0.10.x 版 Kafka 支持的实现</code>部分的解析。</p>
<h1 id="0-10-x-版-KafkaSpout-的实现"><a href="#0-10-x-版-KafkaSpout-的实现" class="headerlink" title="0.10.x 版 KafkaSpout 的实现"></a>0.10.x 版 KafkaSpout 的实现</h1><p>社区对新版 Kafka 的支持，总体分为两种情况：</p>
<ol>
<li>一种是选择自动 commit 机制；</li>
<li>另一种是非自动 commit，就是将 commit 的权利交与 Storm 来控制。</li>
</ol>
<p>下面分别对这两种情况进行分析。</p>
<p>Kafka Consumer 的一些配置会对 Storm 的性能很大影响，下面的三个参数的设置对其性能的影响最大（默认值是根据<a href="https://hortonworks.com/blog/microbenchmarking-storm-1-0-performance/" target="_blank" rel="external">MICROBENCHMARKING APACHE STORM 1.0 PERFORMANCE</a>测试得到）：</p>
<ul>
<li><code>fetch.min.bytes</code>：默认值 200；</li>
<li><code>fetch.max.wait.ms</code>：默认值 30000（30s）；</li>
<li><code>Kafka Consumer instance poll timeout</code>, 它可以在通过 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java" target="_blank" rel="external">KafkaSpoutConfig</a> 的方法 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L180-L184" target="_blank" rel="external">setPollTimeoutMs</a> 来配置，默认值是 10000000；</li>
</ul>
<h2 id="自动-commit-模式"><a href="#自动-commit-模式" class="headerlink" title="自动 commit 模式"></a>自动 commit 模式</h2><p>自动 commit 模式就是 commit 的时机由 Consumer 来控制，本质上是异步 commit，当定时达到时，就进行 commit。而 Storm 端并没有进行任何记录，也就是这部分的容错完全由 Consumer 端来控制，而 Consumer 并不会关心数据的处理成功与否，只关心数据是否 commit，如果未 commit，就会重新发送数据，那么就有可能导致下面这个后果：</p>
<h3 id="造成那些已经-commit、但-Storm-端处理失败的数据丢失"><a href="#造成那些已经-commit、但-Storm-端处理失败的数据丢失" class="headerlink" title="造成那些已经 commit、但 Storm 端处理失败的数据丢失"></a>造成那些已经 commit、但 Storm 端处理失败的数据丢失</h3><p><strong>丢失的原因</strong></p>
<p>一些数据发送到 Spout 之后，恰好 commit 的定时到达，进行了 commit，但是这中间有某条或者几条数据处理失败，这就是说，这几条处理失败的数据已经进行 commit 了，Kafka 端也就不会重新进行发送。</p>
<p>可能出现的这种后果也确定了自动 commit 模式不能满足我们的需求，为了保证数据不丢，需要数据在 Storm 中 ack 之后才能被 commit，因此，commit 还是应该由 Storm 端来进行控制，才能保证数据被正确处理。</p>
<h2 id="非自动-commit-模式"><a href="#非自动-commit-模式" class="headerlink" title="非自动 commit 模式"></a>非自动 commit 模式</h2><p>当选用非自动的 commit 机制（实际上就是使用 Consumer 的同步 commit 机制）时，需要手动去设置 commit 的参数，有以下两项需要设置：</p>
<ul>
<li><code>offset.commit.period.ms</code>：设置 spout 多久向 Kafka commit一次，在 KafkaSpoutConfig 的 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L189-L193" target="_blank" rel="external">setOffsetCommitPeriodMs</a> 中配置；</li>
<li><code>max.uncommitted.offsets</code>：控制在下一次拉取数据之前最多可以有多少数据在等待 commit，在 KafkaSpoutConfig 的 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L211-L217" target="_blank" rel="external">setMaxUncommittedOffsets</a> 中配置；</li>
</ul>
<h3 id="spout-的处理过程"><a href="#spout-的处理过程" class="headerlink" title="spout 的处理过程"></a>spout 的处理过程</h3><p>关于 Kafka 的几个 offset 的概念，可以参考<a href="http://matt33.com/2017/01/16/kafka-group/#offset-那些事"> offset的一些相关概念</a></p>
<p>KafkaSpout 的处理过程主要是在 <code>nextTuple()</code> 方法，其处理过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialized) &#123;</div><div class="line">        <span class="keyword">if</span> (commit()) &#123;<span class="comment">// Step1 非自动 commit,并且定时达到</span></div><div class="line">            commitOffsetsForAckedTuples();<span class="comment">// 对所有已经 ack 的 msgs 进行 commit</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (poll()) &#123;<span class="comment">//Step2 拉取的数据都已经发送,并且未 commit 的消息数小于设置的最大 uncommit 数</span></div><div class="line">            setWaitingToEmit(pollKafkaBroker());</div><div class="line">            <span class="comment">//将拉取的所有 record 都放到 waitingToEmit 集合中,可能会重复拉取数据（由于一些 msg 需要重试，通过修改 Last Committed Offset 的值来实现的）</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (waitingToEmit()) &#123;<span class="comment">//Step3 waitingToEmit 中还有数据</span></div><div class="line">            emit();<span class="comment">//发送数据,但会跳过已经 ack 或者已经发送的消息</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        LOG.debug(<span class="string">"Spout not initialized. Not sending tuples until initialization completes"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面主要分为三步：</p>
<ol>
<li>如果是非自动 commit，并且 commit 定时达到，那么就将所有已经 ack 的数据（<strong>这些数据的 offset 必须是连续的</strong>，不连续的数据不会进行 commit）进行 commit；</li>
<li>如果拉取的数据都已经发送，并且未 commit 的消息数（记录在 <code>numUncommittedOffsets</code> 中）小于设置的最大 uncommit 数，那么就根据更新后的 offset （将 offset 重置到需要重试的 msg 的最小 offset，这样该 offset 后面的 msg 还是会被重新拉取）拉取数据，并将拉取到的数据存储到 <code>waitingToEmit</code> 集合中；</li>
<li>如果 <code>waitingToEmit</code> 集合中还有数据，就发送数据，但在发送数据的过程中，会进行判断，只发送没有 ack 的数据。</li>
</ol>
<h3 id="KafkaSpout-如何进行容错"><a href="#KafkaSpout-如何进行容错" class="headerlink" title="KafkaSpout 如何进行容错"></a>KafkaSpout 如何进行容错</h3><p>举个示例，如下图所示</p>
<p><img src="/images/kafka/KafkaSpout-error.png" alt="consumer offset"></p>
<ol>
<li>图1表示一个 <code>nextTuple()</code> 循环结束之后，offset 为14那条数据处理失败，而offset 为15-18的数据处理成功；</li>
<li>图2表示在下次循环 Step 1 结束之后、Step 2 开始之前，Consumer 会将 the last committed offset 重置到 offset 为14的位置。</li>
</ol>
<p>也就是说从 offset 为14开始，后面的数据会重新发送。</p>
<p><strong>有人可能会问，那样的话会不会造成数据重复发送？</strong></p>
<p>Storm 是如何解决这个问题的呢？答案就是 Storm 会用一个 map 记录已经 ack 的数据（<code>acked</code>），Storm 在进行 commit 的时候也是根据这个 map 的数据进行 commit 的，不过 commit 数据的 offset 必须是连续的，如上图所示，只能将 offset 为11-13的数据 commit，而15-18的数据由于 offset 为14的数据未处理成功而不能 commit。offset 为11-13的数据在 commit 成功后会从 map 中移除，而 offset 为15-18的数据依然在 map 中，Storm 在将从 Kafka 拉取的数据加入到 <code>waitingToEmit</code> 集合时后，进行 emit 数据时，会先检测该数据是否存在 <code>acked</code> 中，如果存在的话，就证明该条数据已经处理过了，不会在进行发送。</p>
<p>这里有几点需要注意的：</p>
<ol>
<li>对已经 ack 的 msg 进行 commit 时，所 commit 的 msg 的 offset 必须是<strong>连续</strong>的（该 msg 存储在一个 TreeMap 中，按 offset 排序），断续的数据会暂时接着保存在集合中，不会进行 commit，如果出现断续，那就证明中间有数据处理失败，需要重新处理；</li>
<li>storm 处理 failed 的 msg，会保存到一个专门的集合中，在每次拉取数据时（是拉取数据，不是发送数据，发送数据时会检测该数据是否已经成功处理），会遍历该集合中包含的所有 TopicPartiion，获取该 partition 的 Last Committed Offset；</li>
</ol>
<p>这样设计有一个副作用就是：如果有一个 msg 一直不成功，就会导致 KafkaSpout 因为这一条数据的影响而不断地重复拉取这批数据，造成整个拓扑卡在这里。</p>
<h3 id="Kafka-Rebalance-的影响"><a href="#Kafka-Rebalance-的影响" class="headerlink" title="Kafka Rebalance 的影响"></a>Kafka Rebalance 的影响</h3><p>Kafka Rebalance 可以参考<a href="http://matt33.com/2017/01/16/kafka-group/#Consumer-Rebalance">Consumer Rebalance</a>.</p>
<p>KafkaSpout 实现了一个内部类用来监控 Group Rebalance 的情况，实现了两个回调函数，一旦发现 group 的状态变为 <code>preparingRabalance</code> 之后</p>
<ol>
<li><code>onPartitionsRevoked</code> 这个方法会在 Consumer 停止拉取数据之后、group 进行 rebalance 操作之前调用，作用是对已经 ack 的 msg 进行 commit；</li>
<li><code>onPartitionsAssigned</code> 这个方法 group 已经进行 reassignment 之后，开始拉取数据之前调用，作用是清理内存中不属于这个线程的 msg、获取 partition 的 last committed offset。</li>
</ol>
<h3 id="潜在的风险点"><a href="#潜在的风险点" class="headerlink" title="潜在的风险点"></a>潜在的风险点</h3><p>这部分还是有可能导致数据重复发送的，设想下面一种情况：</p>
<p>如果之前由于一个条消息处理失败（Partition 1），造成部分数据没有 commit 成功，在进行 rebalance 后，恰好 Partition 1 被分配到其他 spout 线程时，那么当前的 spout 就会关于 Partition 1 的相关数据删除掉，导致部分已经 commit 成功的数据（记录在 acked 中）被删除，而另外的 spout 就会重新拉取这部分数据进行处理，那么就会导致这部分已经成功处理的数据<strong>重复处理</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 0.10.x 版 Kafka 与 0.8.x 版有很大的变化，这种变化对下游 Storm 有非常大的影响，0.10.x 版的 Kafka 不但增加了权限管理的功能，而且还将 simple 和 high consumer 的 offsets 进行统一管理，也就意味着在 
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
      <category term="storm" scheme="http://matt33.com/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 之 Group 状态变化分析及 Rebalance 过程</title>
    <link href="http://matt33.com/2017/01/16/kafka-group/"/>
    <id>http://matt33.com/2017/01/16/kafka-group/</id>
    <published>2017-01-16T11:07:32.000Z</published>
    <updated>2017-07-23T07:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间看一下 Kafka 的部分源码（0.10.1.0 版），对一些地方做了一些相应的总结。本文主要就 Kafka Group 方面的内容做一下详细的讲述，重点讲述 Consumer Client 如何进行初始化、Server 端对应的 Consumer Group 状态如何进行变化以及对一些 Kafka 的新设计（与旧版不同之处）简单介绍一下。</p>
<h1 id="Group-状态机"><a href="#Group-状态机" class="headerlink" title="Group 状态机"></a>Group 状态机</h1><p>在 0.9.0.0 之后的 Kafka，出现了几个新变动，一个是在 Server 端增加了 GroupCoordinator 这个角色，另一个较大的变动是将 topic 的 offset 信息由之前存储在 zookeeper 上改为存储到一个特殊的 topic 中（<code>__consumer_offsets</code>）。</p>
<h2 id="offset-那些事"><a href="#offset-那些事" class="headerlink" title="offset 那些事"></a>offset 那些事</h2><p>在 Kafka 中，无论是写入 topic，还是从 topic 读取数据，都免不了与 offset 打交道，关于 Kafka 的 offset 主要有以下几个概念，如下图。</p>
<p><img src="/images/kafka/consumer-figure2.png" alt="consumer offset"></p>
<p>其中，Last Committed Offset 和 Current Position 是与 Consumer Client 有关，High Watermark 和 Log End Offset 与 Producer Client 数据写入和 replica 之间的数据同步有关。</p>
<ul>
<li>Last Committed Offset：这是 group 最新一次 commit 的 offset，表示这个 group 已经把 Last Committed Offset 之前的数据都消费成功了；</li>
<li>Current Position：group 当前消费数据的 offset，也就是说，Last Committed Offset 到 Current Position 之间的数据已经拉取成功，可能正在处理，但是还未 commit；</li>
<li>Log End Offset：Producer 写入到 Kafka 中的最新一条数据的 offset；</li>
<li>High Watermark：已经成功备份到其他 replicas 中的最新一条数据的 offset，也就是说 Log End Offset 与 High Watermark 之间的数据已经写入到该 partition 的 leader 中，但是还未成功备份到其他的 replicas 中，这部分数据被认为是不安全的，是不允许 Consumer 消费的。</li>
</ul>
<h2 id="Topic-consumer-offsets"><a href="#Topic-consumer-offsets" class="headerlink" title="Topic __consumer_offsets"></a>Topic <code>__consumer_offsets</code></h2><p><code>__consumer_offsets</code> 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有50个 partition，每个 partition 三副本，而具体 group 的消费情况要存储到哪一个 partition 上，是根据 <code>abs(GroupId.hashCode()) % NumPartitions</code> 来计算（其中，<code>NumPartitions</code> 是<code>__consumer_offsets</code> 的 partition 数，默认是50个）的。</p>
<h2 id="GroupCoordinator"><a href="#GroupCoordinator" class="headerlink" title="GroupCoordinator"></a>GroupCoordinator</h2><p>根据上面所述，一个具体的 group，是根据其 group 名进行 hash 并计算得到其具对应的 partition 值，该 partition leader 所在 Broker 即为该 Group 所对应的 GroupCoordinator，GroupCoordinator 会存储与该 group 相关的所有的 Meta 信息。</p>
<p>在 Broker 启动时，每个 Broker 都会启动一个 GroupCoordinator 服务，但只有 <code>__consumer_offsets</code> 的 partition 的 leader 才会直接与 Consumer Client 进行交互，也就是其 group 的 GroupCoordinator，其他的 GroupCoordinator 只是作为备份，一旦作为 leader 的 Broker 挂掉之后及时进行替代。</p>
<h2 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h2><p>Server 端，Consumer 的 Group 共定义了五个状态</p>
<ul>
<li>Empty：Group 没有任何成员，如果所有的 offsets 都过期的话就会变成 Dead，一般当 Group 新创建时是这个状态，也有可能这个 Group 仅仅用于 offset commits 并没有任何成员（Group has no more members, but lingers until all offsets have expired. This state also represents groups which use Kafka only for offset commits and have no members.）；</li>
<li>PreparingRebalance：Group 正在准备进行 Rebalance（Group is preparing to rebalance）；</li>
<li>AwaitingSync：Group 正在等待来 group leader 的 assignment（Group is awaiting state assignment from the leader）；</li>
<li>Stable：稳定的状态（Group is stable）；</li>
<li>Dead：Group 内已经没有成员，并且它的 Meta 已经被移除（Group has no more members and its metadata is being removed）。</li>
</ul>
<p>其各个状态的定义及转换都在 <a href="https://github.com/apache/kafka/blob/0.10.1/core/src/main/scala/kafka/coordinator/GroupMetadata.scala" target="_blank" rel="external">GroupMetadata</a> 中定义，根据状态转移的条件和转移的结果做一个状态转移图如下所示</p>
<p><img src="/images/kafka/group.png" alt="group-state"></p>
<p>各个状态转化的情况，只有有对应箭头才能进行转移，比如 Empty 到 PreparingRebalance 是可以转移的，而 Dead 到 PreparingRebalance 是不可以的。后面会根据一个 Consumer Client 启动的过程，讲述一下其 Group 状态变化情况。</p>
<h1 id="Consumer-初始化"><a href="#Consumer-初始化" class="headerlink" title="Consumer 初始化"></a>Consumer 初始化</h1><p>Server 端 Group 状态的变化，其实更多的时候是由 Client 端触发的，一个 group 在最初初始化的过程总其实就是该 Group 第一个 Consumer Client 初始化的过程。</p>
<h2 id="Consumer-poll-过程解析"><a href="#Consumer-poll-过程解析" class="headerlink" title="Consumer poll 过程解析"></a>Consumer poll 过程解析</h2><p>对 Consumer 的初始化，正如 <a href="http://matt33.com/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍</a> 这篇文章所述，Consumer 的核心逻辑部分主要在其 poll 模型。而其源码的实现上，主要的逻辑实现也是在 <code>pollOnce</code> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 一次 poll 过程</span></div><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;</div><div class="line">    coordinator.poll(time.milliseconds());<span class="comment">//NOTE： 获取 GroupCoordinator 并连接、加入 Group、Group 进行 rebalance 并获取 assignment</span></div><div class="line"></div><div class="line">    <span class="comment">// fetch positions if we have partitions we're subscribed to that we</span></div><div class="line">    <span class="comment">// don't know the offset for</span></div><div class="line">    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())<span class="comment">//<span class="doctag">NOTE:</span> 更新 offset</span></div><div class="line">        updateFetchPositions(<span class="keyword">this</span>.subscriptions.missingFetchPositions());</div><div class="line"></div><div class="line">    <span class="comment">// if data is available already, return it immediately</span></div><div class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">    <span class="comment">//NOTE： 根据最大限制拉取数据（按 partition 拉取,这个 partition 数据拉取完之后,拉取下一个 partition）</span></div><div class="line">    <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">        <span class="keyword">return</span> records;</div><div class="line">    <span class="comment">//<span class="doctag">NOTE:</span> 说明上次 fetch 到是的数据已经全部拉取了,需要再次发送 fetch 请求,从 broker 拉取数据</span></div><div class="line"></div><div class="line">    <span class="comment">// send any new fetches (won't resend pending fetches)</span></div><div class="line">    fetcher.sendFetches();<span class="comment">//<span class="doctag">NOTE:</span> 向订阅的所有 partition 发送 fetch 请求,会从多个 partition 拉取数据</span></div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> pollTimeout = Math.min(coordinator.timeToNextPoll(now), timeout);</div><div class="line"></div><div class="line">    client.poll(pollTimeout, now, <span class="keyword">new</span> PollCondition() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></div><div class="line">            <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></div><div class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// after the long poll, we should check whether the group needs to rebalance</span></div><div class="line">    <span class="comment">// prior to returning data so that the group can stabilize faster</span></div><div class="line">    <span class="keyword">if</span> (coordinator.needRejoin())</div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与 Server 进行交互，尤其初始化 Group 这一部分，主要是在 <code>coordinator.poll()</code> 方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    invokeCompletedOffsetCommitCallbacks();<span class="comment">//<span class="doctag">NOTE:</span> 触发回调函数</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned() &amp;&amp; coordinatorUnknown()) &#123;</div><div class="line">        <span class="comment">//<span class="doctag">NOTE:</span> 通过 subscribe() 方法订阅 topic,并且 coordinator 未知</span></div><div class="line">        ensureCoordinatorReady();<span class="comment">//<span class="doctag">NOTE:</span> 获取 GroupCoordinator 地址,并且建立连接</span></div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needRejoin()) &#123;<span class="comment">//<span class="doctag">NOTE:</span> 判断是否需要重新加入 group,如果订阅的 partition 变化或则分配的 partition 变化时,需要 rejoin</span></div><div class="line">        <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></div><div class="line">        <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></div><div class="line">        <span class="comment">// that we have matched the pattern against the cluster's topics at least once before joining.</span></div><div class="line">        <span class="keyword">if</span> (subscriptions.hasPatternSubscription())</div><div class="line">            client.ensureFreshMetadata();</div><div class="line"></div><div class="line">        ensureActiveGroup();</div><div class="line">        <span class="comment">//<span class="doctag">NOTE:</span> 确保 group 是 active;加入 group;分配订阅的 partition</span></div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pollHeartbeat(now);<span class="comment">//<span class="doctag">NOTE:</span> 检查心跳线程运行是否正常,如果心跳线程失败,则抛出异常,反之更新 poll 调用的时间</span></div><div class="line">    maybeAutoCommitOffsetsAsync(now);<span class="comment">//<span class="doctag">NOTE:</span> 自动 commit 时,当定时达到时,进行自动 commit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ensureCoordinatorReady()</code> 方法是获取该 group 对应的 GroupCoordinator 地址，并建立连接，然后再进行判断，如果当前的这个 Consumer Client 需要加入一个 group，将进行以下操作（向 Server 端发送 join-group 请求以加入 group，然后再发送 sync-group 请求，获取 client 的 assignment）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 确保 Group 是 active,并且加入该 group</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureActiveGroup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// always ensure that the coordinator is ready because we may have been disconnected</span></div><div class="line">    <span class="comment">// when sending heartbeats and does not necessarily require us to rejoin the group.</span></div><div class="line">    ensureCoordinatorReady();<span class="comment">//<span class="doctag">NOTE:</span> 确保 GroupCoordinator 已经连接</span></div><div class="line">    startHeartbeatThreadIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 启动心跳发送线程（并不一定发送心跳,满足条件后才会发送心跳）</span></div><div class="line">    joinGroupIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 请求,并对返回的信息进行处理，还包括了发送 sync-group 请求并进行相应处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Consumer-初始化时-group-状态变化"><a href="#Consumer-初始化时-group-状态变化" class="headerlink" title="Consumer 初始化时 group 状态变化"></a>Consumer 初始化时 group 状态变化</h2><p>这里详述一下 Client 进行以上操作时，Server 端 Group 状态的变化情况。当 Consumer Client 首次进行拉取数据，如果该其所属 Group 并不存在时，Group 的状态变化过程如下：</p>
<ol>
<li>Consumer Client 发送 join-group 请求，如果 Group 不存在，创建该 Group，Group 的状态为 <strong>Empty</strong>；</li>
<li>由于 Group 的 member 为空，将该 member 加入到 Group 中，并将当前 member （client）设置为 Group 的 leader，进行 rebalance 操作，Group 的状态变为 <strong>preparingRebalance</strong>，等待 <code>rebalance.timeout.ms</code> 之后（为了等待其他 member 重新发送 join-group，如果 Group 的状态变为 <code>preparingRebalance</code>，Consumer Client 在进行 poll 操作时，<code>needRejoin()</code> 方法结果就会返回 true，也就意味着当前 Consumer Client 需要重新加入 Group），Group 的 member 更新已经完成，此时 Group 的状态变为 <strong>AwaitingSync</strong>，并向 Group 的所有 member 返回 join-group 响应；</li>
<li>client 在收到 join-group 结果之后，如果发现自己的角色是 Group 的 leader，就进行 assignment，该 leader 将 assignment 的结果通过 sync-group 请求发送给 GroupCoordinator，而 follower 也会向 GroupCoordinator 发送一个 sync-group 请求（只不过对应的字段为空）；</li>
<li>当 GroupCoordinator 收到这个 Group leader 的请求之后，获取 assignment 的结果，将各个 member 对应的 assignment 发送给各个 member，而如果该 Client 是 follower 的话就不做任何处理，此时 group 的状态变为 <strong>Stable</strong>（也就是说，只有当收到的 Leader 的请求之后，才会向所有 member 返回 sync-group 的结果，这个是只发送一次的，由 leader 请求来触发）。</li>
</ol>
<h2 id="Consumer-Rebalance"><a href="#Consumer-Rebalance" class="headerlink" title="Consumer Rebalance"></a>Consumer Rebalance</h2><p>根据上图，当 group 在 Empty、AwaitSync 或 Stable 状态时，group 可能会进行 rebalance；<br>rebalance 的过程就是：等待所有 member 发送 join-group（上述过程的第2步），然后设置 Group 的 leader，进行 reassignment，各个 client 发送 sync-group 来同步 server 的 assignment 结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间看一下 Kafka 的部分源码（0.10.1.0 版），对一些地方做了一些相应的总结。本文主要就 Kafka Group 方面的内容做一下详细的讲述，重点讲述 Consumer Client 如何进行初始化、Server 端对应的 Consumer Group 状态
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>别人向上，我们却在向下</title>
    <link href="http://matt33.com/2017/01/08/book/"/>
    <id>http://matt33.com/2017/01/08/book/</id>
    <published>2017-01-08T08:11:14.000Z</published>
    <updated>2017-01-08T15:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>花了两周多的时间把钱穆老先生这部神作读完了，读完之后的感觉是，书中有太多的观点让我有醍醐灌顶之感，钱老读史思考的深度远非常人所及，这本书非常值得拜读，豆瓣上也同样给出了9分以上评价，真的名不虚传（<a href="https://book.douban.com/subject/11229072/" target="_blank" rel="external">《中国历代政治得失》</a>）。因为这本书并不是一气看完，大部分是在上下班的班车上看的，每天看一部分，持续半个月之后才看完，所以书中一些感觉很不错的观点到现在可能已经忘了一部分，现在回忆起整本书，大概有三点让我印象非常深刻，下面也会就这三点讲述一下。</p>
<p>第一点印象最深的地方当然是<strong>制度</strong>这一部分了，全文几乎都是在围绕着历代的政治制度而讲述。好的制度可以让这个国家更简单、更高效地运转，中国自古有句俗话，叫做”打天下容易，坐天下难”，在打天下的时候，少则几年、多则十几年就能打下天下。但随着队伍、领地的扩大，很多问题会暴露出来，由于之前是战时，这些问题可以暂时不管，而一旦国家归于统一、社会稳定下来之后，这些问题就不能不管了，如何为政府选取人才、如何指定合理的徒土地政策、赋役政策以及军队政策等，这些问题哪一个处理不好，都可能会导致功亏一篑，所以说坐天下难。但是难也得干下去，正所谓在其位谋其政，历代政府都使出自己的浑身解数，制定了一套政策，让这个庞大的国家开始缓慢地运转，而有些政策因其非常重要可能会以明文记载作为制度来保证政策高效地运行，制度一旦形成，甚至就如信仰一般，无人敢违逆。每个朝代在开始时期，都会指定一套保证政府运转的制度（而有的朝代却攻于权术，想着各种手段维护自己的统治，而不是尽一个政府的职责），而这些制度一旦形成，随着发展，到后期可能会变得漏洞百出而成为一些利息集团的保护伞，正所谓此一时彼一时，时代在发展，历史上也没有一套制度可以高效地运作几千年或者几百年而不离其初心。而且一旦利息集团形成，后世的知识分子又如何去改变呢？有的知识分子虽然看到这些弊端，如王安石，他同样也身居高危开始变法，也有了皇帝的支持，可是最后依然没有成功，中国人老是讲一句”祖宗之法不能改”。这种观念反而束缚了后世，如果制度不用变，后世还要政治家干什么？这也导致一个朝代兴起之后，后来因慌于人事而逐渐走向下坡路。朝代初兴之时，一般会出现很多人才，也会有圣明的皇帝，这种情况下，一些制度是可以按照其初心正常运作，而几十年或者百年之后，如果人事不给力，谁来保证？多少朝代由于这而毁，这也就突出一个好制度的重要性。制度，名义上一种规章制度，是大家共同遵守的信仰，也是约束大家的法则，但制度又不能一成不变，中国有时候就非常认死理，制度竟然可以原封不动运行几百年，这到后面怎么可能不出问题？这时候如果说中国没有法制观念反而不合适，我们反观一下西方人，他们的制度或法律其实是不在不断变化的、或者是进入了一个不断完善的轨道，西方的一些政府人员是是由人民选举出来，所以必然会代表多数人的利益，要不然下次肯定会被选下去，所以他们的制度或者法律也是会必然代表多数人的利益，而多数人的利益在发展的过程中是在不断变化的、而不是一成不变的，这也是它们制度能够自我完善的一个原因。而历史中的我们，就很难做到这一点，如果皇帝大臣是圣人君子还好，如果不是，受苦的只能是老百姓，这就说明，我们虽然有制度，但是并没有好的制度来保证这个国家的长久运转。</p>
<p>第二点说一下利益集团，或者是权力集团，钱老提出的这点观点还是很令我感到新奇的。西方社会刚开始的权力是把握在教会手中，后来又到了贵族手中，从来没有开放给全社会，这也是西方民众对主权、对权力的非常看重的原因，而我们则不一样，可以说从秦朝开始权力就已经开放给全社会或者很大一部分开放给全社会了，除了皇室，其他的职位到后来已经没有世袭，只要你有能力有才华而且又能证明自己，即使你出身低贱也能走向巅峰，如商鞅、韩信等。后来到了唐朝之后，就开始形成了科举制度，读书人科举成功即可入朝为官，可以说从此之后，中国社会的权力集团就是这些知识分子，他们才是保证这个国家运转的核心。虽说中国是皇权社会，但是皇帝只是一个人，不可能管理整个国家，皇帝的背后必然会有一群体支持着皇帝，帮着皇帝去管理整个国家。有了科举制度之后，整个国家的运转就靠着这些选举出来的人才来管理，而那些朝廷大员又非世袭，很多丞相或者内个大学士都出身贫苦，国家靠着这些读书人管理着整个国家，所以可以说中国是一个”仕人社会”，只不过到了元朝和清朝就变成了”部族社会”，这就另说了。</p>
<p>第三点读完之后的感受就是在两千年的历史（从汉到清）中，能明确感受到以下几点：1.中央政府在不断地集权、而地方政府的权力在衰落，地方政府的地位也在降低，尤其是那些真正管理百姓的县长，到后来职位是越来越低，甚至与中央通话都要隔着三四级，他们上要讨好上级，下要管理百姓，其实也是着实为难；2.政府为了防止百姓造反采取了很多的政策，比如在内部分裂知识分子以及普通民众，这也导致国人越发得不团结，不团结也就没有力量，甚至国人开始慢慢变得异常窝里斗，我们民族的这些糟粕都是有其缘由的；3.中国官本位也是有其原因的，自古以来优秀人才都被引入到了仕途，读书人心中也形成了一种观点——“学而优则仕”，而且政府到后来反而在不断地抑商，一是人才不断涌向政府，政府又用不了这么人，造成政府人事不断臃肿，二是其他行业需要人才反而又得不到人才，导致发展缓慢；4.民众的自由程度在不断压缩，甚至到了清朝为了防止汉人反清还实行了一些政策，取消了言论自由、结社自由和出版自由，这些在清朝之前都是很正常的东西，后来就慢慢给禁止了，而随后大家竟然慢慢习惯了，这也是因为个人力量非常薄弱，而大家又很难团结一起。这些不断形成的东西，站在民族长远的角度来看，对我们中华民族是非常有害的、不利的。</p>
<p>读完之后，尤其是与西方的历史对比，心中总是少不了些许疼痛，曾经引领世界的、有着全世界最优秀制度的民族，到最后竟然轮到没有自由的部族政治，清朝之害，远重于崖山。</p>
<hr>
<blockquote>
<p>汉光武自身是一好皇帝，明帝，章帝都好，然而只是人事好，没有立下好制度。因此皇帝好，事情也做得好。皇帝坏了，而政治上并不曾有管束皇帝的制度，这是东汉政治制度上的一个大问题。也是将来中国政治制度史上一个大问题。——钱穆, 中国历代政治得失, loc. 414-416</p>
</blockquote>
<p>Notes: 1) 缺少一种好的制度来防止其他情况的出现。</p>
<blockquote>
<p>但日子久了，那制度就变坏了。这不只是汉代选举制度如是，我们可以说，古今中外一切制度，都必如是。否则一项好制度，若能永远好下去，便将使政治窒息，再不需后代人来努力政治了。——钱穆, 中国历代政治得失, loc. 448-450</p>
</blockquote>
<p>Notes: 1) 任何政策都有其漏洞,时间越久,漏洞也就越多</p>
<blockquote>
<p>《唐六典》的，仍不应仅当它是一部历史书，为记载唐代现实制度的书，而应同时当它是一部理论和思想的书看。因唐代人对政治上的种种理论和思想，都已在此书中大部具体化制度化了。制度的背后，都应有理论和思想。一切制度，决不会凭空无端地产生。若我们忽略了中国以往现实的政治制度，而来空谈中国人以往的政治思想，也决无是处。——钱穆, 中国历代政治得失, loc. 568-571</p>
</blockquote>
<p>Notes: 1) 唐代的巨大进步</p>
<blockquote>
<p>总之中国是一个广土众民的大国家，必需得统一，而实不宜于过分的中央集权。这在中国的政治课题上，是一道值得谨慎应付的大题目。现在专说唐代，似乎其中央行政比汉进步，而地方行政则不如汉。中央的监察官变成了地方行政官，这是一大缺点。而由军队首领来充地方行政首长，则更是大毛病。唐室之崩溃，也可说即崩溃在此一制度上。——钱穆, 中国历代政治得失, loc. 609-612</p>
</blockquote>
<p>Notes: 1) 节度使既掌握军事又掌管地方事务,很危险</p>
<blockquote>
<p>从此可知，政治制度是现实的，每一制度，必须针对现实，时时刻刻求其能变动适应。任何制度，断无二三十年而不变的，更无二三百年而不变的。但无论如何变，一项制度背后的本原精神所在，即此制度之用意的主要处则仍可不变。于是每一项制度，便可循其正常轨道而发展。此即是此一项制度之自然生长。——钱穆, 中国历代政治得失, loc. 639-642</p>
</blockquote>
<p>Notes: 1) 制度因时因地而异.</p>
<blockquote>
<p>理论是此制度之精神生命，现实是此制度之血液营养，二者缺一不可。——钱穆, 中国历代政治得失, loc. 643-644</p>
</blockquote>
<p>Notes: 1) 理论是理想的,现实是不断完善理论,两则相辅相成。</p>
<blockquote>
<p>其实革命的本质，应该是推翻制度来迁就现实的，绝非是推翻现实来迁就制度的。我们此刻，一面既否定了传统制度背后的一切理论根据，一面又忽略了现实环境里面的一切真实要求。——钱穆, 中国历代政治得失, loc. 646-648</p>
</blockquote>
<p>Notes: 1) 制度为解决现实问题而生。</p>
<blockquote>
<p>当知任何一种制度之建立，傥是仅由一二人之私意便能实现了，这便无制度可讲。若谓此乃皇帝欺骗民众，而且凭此欺骗，便能专制几百年，古今中外，绝无此理。若民众如此易欺易骗，我们也无理由再来提倡民主政治。凭事实讲，科举制度显然在开放政权，这始是科举制度之内在意义与精神生命。汉代的选举，是由封建贵族中开放政权的一条路。唐代的公开竞选，是由门第特殊阶级中开放政权的一条路。——钱穆, 中国历代政治得失, loc. 673-677</p>
</blockquote>
<p>Notes: 1) 制度产生之历史背景,有其合理的地方,不能一言以蔽之。</p>
<blockquote>
<p>而中国则自唐以下，便已犯了政权开放之流毒。以水救水，以火救火，不仅是药不对病，而且会症上加症。若要解决中国社会之积弊，则当使知识分子不再集中到政治一途，便该奖励工商业，使聪明才智转趋此道。然结果又很易变成资本主义。在西方是先有了中产社会，先有了新兴工商资本，然后再来打开仕途，预闻政治。而中国则不然，可说自两汉以来，早已把政权开放给全国各地，不断奖励知识分子加入仕途，而同时又压抑工商资本。只鼓舞人为大学者，当大官，却不奖励人为大商人，发大财。节制资本，平均地权，大体上是中国历史上的传统政策。政治措施，存心在引导民间聪明才智，不许其为私家财力打算无限制的发展。——钱穆, 中国历代政治得失, loc. 683-689</p>
</blockquote>
<p>Notes: 1) 知识分子都涌入政治,造成官员庸肿不堪,直到今天依然如此,一个局长会有近十个副局长。 政治无法消化所有的优秀人才,应该将人才引入其他该需要的地方,以发挥最大的价值。</p>
<blockquote>
<p>即就账籍制度言，可见每一项制度之推行与继续，也必待有一种与之相当的道德意志与服务忠诚之贯注。否则徒法不能以自行，纵然法良意美，终是徒然。而且任何一制度，也必与其他制度发生交互影响。故凡一制度之成立，也绝非此制度可以单独成立的。——钱穆, 中国历代政治得失, loc. 717-720</p>
</blockquote>
<p>Notes: 1) 并不完全依靠法治,对道德水准有一定要求。</p>
<blockquote>
<p>好像汉代是在社会上层节制资本，而下层则没有力量管；唐代注意社会下层，由国家来计划分配，而让上层的富民能自由发展。这一情形，似乎唐代人更要高明些。他可以许你过富，却不让你过穷。——钱穆, 中国历代政治得失, loc. 774-776</p>
</blockquote>
<p>Notes: 1) 汉唐经济思想之精髓</p>
<blockquote>
<p>不过事情隔久了，这事情演变之本原意义忘失了，后人便只见得皇帝之尊严与宰相之卑微了。——钱穆, 中国历代政治得失, loc. 893-893</p>
</blockquote>
<p>Notes: 1) 一个制度的确立有其原因,但随着时间其原意慢慢被抛到脑后,久而久之也就为人所不知了。</p>
<blockquote>
<p>宋代制度之缺点，在散，在弱，不在专与暴。直到南宋宁宗时，已快亡国，皇帝时时下手条，当时称为御札，还激起朝臣愤慨，说事不出中书，是为乱政。可见宋代相权，还有它传统客观的地位。我们此刻只根据历史来说宋不如唐，所谓宋代宰相失职，一切仍是制度问题。并不是只有皇帝专制，更不要制度。——钱穆, 中国历代政治得失, loc. 916-919</p>
</blockquote>
<p>Notes: 1) 制度中的问题看似只是一条命令,实则影响巨大,制度要有自我完善机制</p>
<blockquote>
<p>无制度的政府，哪能有好施为，哪能有好结——钱穆, 中国历代政治得失, loc. 964-964</p>
</blockquote>
<p>Notes: 1) 制度的确立是有其缘由的,要明白背后的原因才能更好地让制度用在正途。</p>
<blockquote>
<p>宋代则把财富兵力都集中到中央，不留一点在地方上，所以中央一失败，全国土崩瓦解，再也没办法。——钱穆, 中国历代政治得失, loc. 985-986</p>
</blockquote>
<p>Notes: 1) 越往后,君权越大,中央集权越严重。</p>
<blockquote>
<p>任何一省都如此。给你这一半，割去你那一半。好使全国各省，都成支离破碎。既不能统一反抗，而任何一区域也很难单独反抗。这是行省制的内在精神。——钱穆, 中国历代政治得失, loc. 1321-1322</p>
</blockquote>
<p>Notes: 1) 背后的原因</p>
<blockquote>
<p>举人以下就没有做大官的份，如是则科举场中也分了流品。进士及第是清流，浮在上面直向前，秀才举人则变成了浊流，沉淀在下面，永远不超升。鼎——钱穆, 中国历代政治得失, loc. 1428-1430</p>
</blockquote>
<p>Notes: 1) 此思想毒害后代</p>
<blockquote>
<p>而且纵使存心公正善良的人，其所创制度，也可有偏弊，有流害。我们必如是想，才能对政治制度有深一层之研讨与警惕。——钱穆, 中国历代政治得失, loc. 1459-1460</p>
</blockquote>
<p>Notes: 1) 制度逐渐演化,已经在慢慢背离初衷。</p>
<blockquote>
<p>制度指政而言，法术只是些事情或手段；不好说是政治。大抵制度是出之于公的，在公的用心下形成的一些度量分寸是制度。而法术则出之于私，因此没有一定恰好的节限。所谓方法与权术，二者之间，当然又不能仔细分。——钱穆, 中国历代政治得失, loc. 1548-1550</p>
</blockquote>
<p>Notes: 1) 一个有度,一个没有</p>
<blockquote>
<p>论汉代，西汉可说是制度，东汉则多半出于光武的私心。论唐代，确实可说在建立制度，而宋代则有许多只算是一种法术。明代，有许多只能说它是一些事，不能说它是一些制。尤其是清代，可说全没有制度。它所有的制度，都是根据着明代，而在明代的制度里，再加上他们许多的私心。这种私心，可说是一种“部族政权”的私心。一切有满洲部族的私心处罚，所以全只有法术，更不见制度。——钱穆, 中国历代政治得失, loc. 1553-1557</p>
</blockquote>
<p>Notes: 1) 崖山之后无中国。并不准确。</p>
<blockquote>
<p>可是我们中国历史从汉代起，就不能叫皇权，因皇帝一个人不可能掌握一个国家的大权。也不能说它是贵族政权，因自汉代起，已没有显然的贵族。说是军人政权吗？我们也看不出汉政府以下，是由军人掌握的。说是资产阶级的政权吗？中国一向没有资产阶级。所以若说政权，则中国应该是一种士人政权，政府大权都掌握在士——读书人手里，从汉到明都如此。——钱穆, 中国历代政治得失, loc. 1569-1573</p>
</blockquote>
<p>Notes: 1) 这点分析得很好,利益总是被这些少数群体把握着。</p>
<blockquote>
<p>美国人尽管看重东方的商业，但他只可想旁的方法，不能派一总督来管理菲律宾，而把他们开国以来全部历史精神推翻了。所以今天苏维埃说美国帝国主义，其实是名实不相符。但若说英国对香港是一种帝国主义，这是百辩难逃的。因他把全国家分成了两部分，一部是本国，一部是征服地。这才始得叫帝国。清代有所谓本部十八省，外边又有藩属，故说它像西方的帝国，但细辩又不同。因清人待蒙古，比待中国本部的人还要好，蒙古人得封亲王，中国人是没有的。英国人断不能待香港人比待他本国的人好，可见就算清代也是帝国，还是东西巧妙不同的。——钱穆, 中国历代政治得失, loc. 1765-1770</p>
</blockquote>
<p>Notes: 1) 如果这样来看,确实如此,清朝也可以认为与英国一样。</p>
<blockquote>
<p>我们现在的毛病，就在喜欢随便使用别人家的现成名词，而这些名词的确实解释，我们又多不了解。——钱穆, 中国历代政治得失, loc. 1770-1771</p>
</blockquote>
<p>Notes: 1) 不明缘由</p>
<blockquote>
<p>当时的洪杨，并不是推不翻满清，但他们同时又要推翻中国全部历史，所以他们只可有失败。——钱穆, 中国历代政治得失, loc. 1811-1811</p>
</blockquote>
<p>Notes: 1) 缺少刘伯闻这样的谋士,这种谋士要上通天文,下知地理,也就是熟悉中国历史。</p>
<blockquote>
<p>但康有为只知道皇帝无害于立宪，却不知道满清皇帝的后面是一个部族政权在撑腰。部族政权是决不容有所谓立宪的。孙中山先生主张革命，一定要推翻皇帝，康有为的变法就变成了保皇，似乎又像非要皇帝不可了。康有为实在没有看清楚，他以为只要光绪皇帝听他话，变法就变得成，这是他的大错误。这个错误也就是错误在他没有像西洋人般懂得政治上的所谓主权的观念。他不懂得当时的中国政治，是满洲部族主权的政治。掌握主权的是满洲人，哪里是像他所谓的皇帝专制呢？他误认为中国传统政治只是皇帝专制，故而以为只要皇帝听我话，便可由皇帝专制一变而为皇帝立宪。——钱穆, 中国历代政治得失, loc. 1817-1822</p>
</blockquote>
<p>Notes: 1) 争论到最后变成了是否要保皇,已经失其初心。而且清帝国并非只是皇帝一人专制,后面利益何其复杂。</p>
<blockquote>
<p>至于中国历史上的传统政权，无论汉、唐、宋、明，却并无私权力，私立场，私背景，它的立场背景便是全国人民，便是全社会。所以遇到政治腐败，只要换一批人，把制度腐败了的略略修改，就仍可继续下。——钱穆, 中国历代政治得失, loc. 1828-1830</p>
</blockquote>
<p>Notes: 1) 两千年历史没有革命。 2) 两千年历史没有革命,变得很少。</p>
<blockquote>
<p>中国政治，实在一向是偏重于法治的，即制度化的，而西方近代政治，则比较偏重在人治在事实化。何以呢？因为他们一切政制，均决定于选举，选举出来的多数党，就可决定一切了。法制随多数意见而决定，而变动，故说它重人、重事实。我们的传统政治，往往一个制度经历几百年老不变，这当然只说是法治，是制度化。法治之下，人才就受束缚了。所以明末的黄梨洲要慨然说：“有治人，无治法。”这因一向制度太繁密，故使他太不看重法，太看重人，而要提出此主张。——钱穆, 中国历代政治得失, loc. 1905-1909</p>
</blockquote>
<p>Notes: 1) 这样的解释醍醐灌顶之感,我们一般认为中国缺少法治基因,而实际并非如此。</p>
<blockquote>
<p>孙先生不是读死书的人，他这几句话，并不由任何西方抄袭来，他真是深识远虑，确有他所见。政府是该属于民众的，但不是，也不能，定要全体民众直接来掌握此政权。理论上，国家政权当然在民众，该以民众大家的意见为意见。但民众意见，终是句空话。如何来表达出此民众的意见呢？今天中国多数民众，尚依赖政府来注意教和领导，他们哪有办法来过问政治？然而一个国家总要有一个不可动摇的中心，即如目前的日本，他们把历史上的传统中心皇帝尊严摇动了，急切间社会也会发生摇动的，他们拿什么东西来填补，来维系？这在他们也将成为一问题。中国也会碰到这问题的，而且早已碰到了。——钱穆, 中国历代政治得失, loc. 1924-1929</p>
</blockquote>
<p>Notes: 1) 孙中山先生有其擅长的地方,也有其不擅长的地方。</p>
<blockquote>
<p>历史终是客观事实，历史没有不对的，不对的是在我们不注重历史，不把历史作参考。至少我们讲人文科学方面的一切，是不该不懂历史的。政治也是人文科学中一门，我们回头把以前历史经过，再看一道，总还不是要不得。——钱穆, 中国历代政治得失, loc. 1948-1950</p>
</blockquote>
<p>Notes: 1) 历史是宝贵的财富,也是文化传统,焉能一笔抹杀</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了两周多的时间把钱穆老先生这部神作读完了，读完之后的感觉是，书中有太多的观点让我有醍醐灌顶之感，钱老读史思考的深度远非常人所及，这本书非常值得拜读，豆瓣上也同样给出了9分以上评价，真的名不虚传（&lt;a href=&quot;https://book.douban.com/subjec
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结</title>
    <link href="http://matt33.com/2016/12/31/2016-summary/"/>
    <id>http://matt33.com/2016/12/31/2016-summary/</id>
    <published>2016-12-31T05:14:44.000Z</published>
    <updated>2017-07-23T07:01:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天凌晨2点吃完饭回来之后，真是辗转反侧，不知为何，一直难以入眠，或许因为过了睡点，又或许因为昨晚的年会玩得太嗨，也可能是感觉对过去的一年有些许遗憾……</p>
<p>昨晚参加了最后一次实验室的年会，前两年中的都是三等奖（100块钱），没想到昨晚运气大爆发了，中了特等奖（Kindle Voyage），也算是2016年一个比较好的收官。然而，晚上睡觉时内心却是如何也无法平静下来，脑海中一直不断闪烁着过去一年、甚至过去两三年发生的一些事，不管怎样，时间就是这样，过去的就是过去了，并不以我们的意志为转移。</p>
<p>孟子说“吾日三省吾身”，这句话我们上小学时都学过，可是大多数人并没有去认真践行过，可能是现在这个社会给人压力大得已经很少有时间去思考、去反思。但是很多人却都有年终总结的习惯，总结一下过去一年做了什么事，是否完成了去年年终总结定的计划，再做一下未来一年的计划。有计划的人生总是会好一点，至少会给未来一年指引方向，甚至可以通过一些量化的指标来屏蔽一些重要的问题：我要想什么样的人生，我想要什么样的生活。这两个问题真的很难去回答，其实我们每个人也只是在不断地去摸索，因为我们原本就没有一个很清晰的目标。即使有了清晰的目标也很难在未来一年的时间里去完成，而我们又都是如此地急功近利，如果一件事情要花费自己三五年的时间、甚至十年时间的话，很多人可能都会选择放弃，去选择一些易于在短期内实现的目标。如果一个人没有一个清晰的长远目标，或者没有这个概念的话，那么年度目标其实也就是督促自己做点事而已。对于我们这种即将毕业或者刚步入职场的人来说，虽然并不一定有一个非常清晰的长远目标，但是至少是要有一个这样的概念。选取一个或者多个对你非常重要、或者能给你带来很大的提高、而短期无法实现的长远目标，把这个分割到每一年里慢慢去实现，但有一点要明确的是长远目标的制定依然是为了那两个问题而设置的，那两个问题肯定会在未来十年甚至二十年的时间不断地困扰我们，我们能做的，也只是不断地尝试，不断地去追寻内心（以上只是个人感慨，下面开始流水账）。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>从今年开始也算是正式迈入了职场，毕竟也在公司实习了半年多了，今年最重要的事情就是找工作这件事了，人生的第一份工作，好在最后去的部门、做的事情是自己想要的（找工作的感想可以参考<a href="http://matt33.com/2016/11/15/job-summary/">校招找工作小记</a>）。</p>
<p>除了正式工作，另一件非常重要的事就是毕业这件事了。记得去年下半年一直在绞尽脑汁，憋了好久才写了一篇小论文的大概，没写出多少，今年年初来了之后就边找实习边写小论文，最后也很幸运地成功水了一个会议。小论文之后又是大论文，纸老虎打了一个总是还会再出现一个，在实习前火急火燎地完成了初稿，后来又花了半个多月改了一下，到目前为止还没出现什么问题，祈祷盲审不中，明年顺利毕业。</p>
<p>关于明年，希望自己在工作上能有所建树，自己在公司未来的方向就是 Kafka 平台的开发和运维，希望自己能实现以下几个小目标：</p>
<ol>
<li>经过这半年对 Kafka 源码的学习和理解，希望明年把源码方面的东西都总结一下，对源码的核心设计了然于胸，多向社区提交一些 pr，成为 Kafka 领域较有权威的 contributor；</li>
<li>同事在公司经常会说<code>三分技术，七分做事</code>，虽然并不完全认同，但至少也得四分或五分做事，明年好好制定和完成自己的 KPI，认认真真做事，答应的事情要能按时按质搞定，做一个技术上靠谱的人，养成这样的习惯；</li>
<li>希望明年下半年晋升到P2.1，对小组、部门和公司业务有更深入的了解；</li>
<li>多与同事、业界交流技术经验，希望自己明年的 Github Contribute 更饱满；</li>
<li>好好运营自己的博客网站，每个月保持两篇技术文章输出（一篇 Kafka 相关）；</li>
<li>明年也应该补充一下自己的计算机基础知识，希望能够把《算法 第4版》、《深入理解计算机系统》和《计算机程序语言的构造与解释》这三本好好深入学习一下，前两本看了两年了才各自看了一半，真是惭愧，希望明年执行力强一些，把这三本坚持啃下来，并做一些相关的笔记；</li>
<li>对于其他的技术，要达到会用的效果，能够实现自己想要的功能，利用幂次法则用20%的时间达到80%的效果，选择三个方面：前端（Django、Boostrap使用）、spark（使用以及内部框架有较深入的了解）、机器学习（把周志华《机器学习》学习一下，找几个小项目做一下）；</li>
<li>每个月看一篇大数据方向的领域的相关论文，今年计划看12篇；</li>
<li>还有一个明年要做的也是很重要的是英语，先从听力开始，通过老友记去学习，要听到听懂每个句子未知，然后可以借鉴《技巧》里的不断加强难度练习的方式进行练习，一定要坚持下去，英语对于未来的发展还是至关重要的。</li>
</ol>
<p>上面的小目标也都不是很难，希望自己能够完成。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年貌似生活很平平淡淡，没有太大变化，只有几个微小的变化：</p>
<ul>
<li>之前和女朋友说了几年的云南自由行终于实现了，云南也确如网上所言，风景很好，我们整个旅途总体玩得也很开心，唯一不好的地方就是在香格里拉遇到了那些借着宗教、善意骗人的当地藏民，影响自己的心情，对那些地区多了一些偏见；</li>
<li>今年总共回家了三次，过春节一次，年中表弟结婚一次，十一回去一次，8月的时候老妈跟老弟来北京，带着他们在北京玩了三四天，老爸老妈随着年龄的增大，皱纹白发已经开始增多，自己纵有太多心酸也无可奈，只希望自己能早些立住脚，让父母过得舒适一些，年初春节的时候跟老爸老妈商量为了老弟的学习，就在学校附近租了房子专门让老妈去做饭，可是投入这么多，却没有任何收获，老弟反而更加肆无忌惮、更加贪玩，成绩也成了倒数，唉，少年不知愁滋味，只希望老弟早些长大；</li>
<li>今年自己开始买了一些装备玩户外，不过都是一些很成熟的入门级路线，不过开始总是好的，发现自己还是挺喜欢这些运动的；</li>
<li>年中的时候买了单反，开始玩起了摄影，不过目前技术依然很渣，虽然把 Lightroom 学得差不多了，但是却发现自己的硬伤是审美，并不很清楚什么样的照片才是美的照片，也并不知道在拍照时如何告诉拍照人摆 pose 以拍出最好的效果；</li>
<li>一个月前买了一个 Kindle，今年抽空确实看了不少书（<a href="https://github.com/wangzzu/awesome/blob/master/book-list.md" target="_blank" rel="external">2016个人书单</a>），大概有11本左右，因为之前看的书少，所以看的都是一些评分较高的书，其中也发现了几本好书，有两本准备寒假回去再看一遍，写几篇读书笔记，在以后的工作生活中按照书中介绍一些方法论去实验一下；</li>
<li>今年也算是坚持锻炼了身体，估计跑步跑了三百公里左右，上半年也经常去游泳，到公司实习后，回学校游泳不太方便，就经常去参加一些羽毛球活动，虽然没有把腹肌撕裂者坚持下去练出几块肌肉，但总体体重跟去年一样，并没有走样；</li>
<li>其他的都是一些琐碎之事，见了一些老朋友，很多都是几年未见的，在中学的时候感觉这些好哥们应该会一直在一起玩耍，现在却发现一年见上一面都很难，也由于各自在不同的环境下、不同的行业里大家慢慢渐行渐远，总之，感慨良多，要好好珍惜身边的好哥们，真如大土豆所言，能一直深交的好哥们人生有二三可能就已足矣。</li>
</ul>
<p>人生的时间，可能除了工作，其他基本上就属于生活了吧。中国讲<code>日子要越过越红火</code>，生活也是应该计划计划，未来一年希望能把下面的几件事搞定：</p>
<ul>
<li>走了近六年的爱情长跑，也总该有个结果了，希望明年能搞一个难忘的求婚仪式，结婚是明年还是后年可以再定，准备明年领证；</li>
<li>谈到了求婚，就不得不说到买房，希望明年户口迁杭州顺利，并把房子搞定，这个是明年重中之重，明年估计有一个月的工资就要交给铁总了；</li>
<li>希望老弟明年能进步，要不然在河南这样的高考大省，可能连上高中的机会都没有了，跟爸妈春节好好交交心，让他们少干点活，有些事情能不做的就不做了，到了这个年龄，健健康康才是最重要的；</li>
<li>坚持锻炼身体，在公司健身房多跑步（明年保持300km 以上），学习一下标准的羽毛球动作，提高球技（希望能在公司的高手场过上几招），冬天的时候跟公司的俱乐部学习一下滑雪，特别是单板（学会单板的滑行、刹车拐弯，冲一次高级场），也准备参加一些户外活动（爬山、穿越明年还是不能少），希望明年能体验一下蹦极，明年年初的毕业旅行计划去东南亚玩一趟，明年年终的时候，希望有时间和机会跟女友去日本或台湾一趟；</li>
<li>多读些书，非技术类的书籍明年计划读20本，好的书要做一下读书笔记；</li>
<li>明年就要出去租房子住了，希望合租的人能够好相处一些，明年打算练一下自己的厨艺，自己做饭还是要比外面干净很多，外面的东西越来越不放心了。</li>
<li>还有就是单反，学习审美，多拍多练习。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>人是越长大越孤单，小的时候每当我们做错事、有什么需要改正的缺点，父母都会去提醒我们，而长大之后，如果影响不到别人，别人可能根本不会搭理你，这也有可能是因为长大之后，大家性格思维都在固化，很难去纠正，别人也就懒得去管了。而对于我们个人的发展来说，这是非常不利的，找不到或发现不了自己的缺点，那提升自己就变得很难。所以，作为一个人，还是要有自知之明，正视自己的缺点，有的时候可能是从别人身上看到我们自己的影子（通过看别人来反思自己），有的时候可能朋友会对我们一些善意的提醒，对于这样的朋友，我们应该去珍惜。记得今年去华为面试的时候在公交上遇到了一个基督徒，人挺不错，他帮助我准备面试，并帮我指出一些问题，他指出的一个问题是我说话时语速太快，之前关于这个问题我真是一点都没有意识到，后来我刻意听了一下给别人发的微信语音，确实有这个问题，如果是平时聊天还好，而如果是做一些技术交流的话，就会出问题，对于一个问题因为自己比较熟悉、快速说出来并没有问题，而别人对这个问题如果不熟悉，自己的语句就应该放慢一些给别人足够的思考时间，这才是一种有效的交流方式，希望明年在这方面能有所改进。还有一个问题，发现身边有些同学，平时交流、出去玩都还可以，但是为人却很不大气，可能会需要一些成本才能感受出来，不过这个成本也值得，能够让自己对别人了解更深入些，以后交往有所顾忌，从这件事情上，其实也能够看出自己的一些影子，对于自己来说，需要做的是，与比较豪爽的人交往自己也应该豪爽，而与一些不大气或者小气的人交往时，就应该有所注意，当然也不能让被人的缺点阻挡自己的眼睛，还是要多发现别人的优点，毕竟人无完人。也希望自己明年能对一些事情看开一下，努力学习苏公<code>一蓑烟雨任平生</code>的人生态度。</p>
<p>总之，希望明年事事顺心，家人身体健康。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天凌晨2点吃完饭回来之后，真是辗转反侧，不知为何，一直难以入眠，或许因为过了睡点，又或许因为昨晚的年会玩得太嗨，也可能是感觉对过去的一年有些许遗憾……&lt;/p&gt;
&lt;p&gt;昨晚参加了最后一次实验室的年会，前两年中的都是三等奖（100块钱），没想到昨晚运气大爆发了，中了特等奖（K
    
    </summary>
    
      <category term="随笔" scheme="http://matt33.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://matt33.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Java 的 Checked 和 Unchecked Exception【译】</title>
    <link href="http://matt33.com/2016/12/13/java-exception/"/>
    <id>http://matt33.com/2016/12/13/java-exception/</id>
    <published>2016-12-12T16:04:26.000Z</published>
    <updated>2016-12-12T16:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果在 Java 应用中对 Exception 能够正确处理，那么将会使你的程序更具有健壮性。但是很多人对 Exception 中的 <strong>Checked Exception</strong> 和 <strong>Unchecked Exception</strong> 并不理解，并且 Exception 又常常被被分为 JVM Exception 和程序 Exception，这就让一些开发者显得更加困惑了，本文就这几个概念详细讲述一下。（本文翻译自<a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="external">Checked and Unchecked Exceptions in Java</a>）</p>
<h1 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h1><p>Checked Exception 是必须在代码中进行恰当处理的 Exception，而且编译器会强制开发者对其进行处理，否则编译会不通过。你可以使用 <code>catch</code> 语句捕获这些 Exception 或者在方法声明处使用 <code>throws</code> 语句抛出该异常。</p>
<p>一般来说，Checked Exception 的发生主要是由于一些特殊情况没有考虑到，比如如果网络连接失败会抛出 IOException，但是我们的程序应该能够提前预料到这些可能发生的异常，并对其进行处理，这样程序在运行过程中才不会崩掉，这也是编译器强制开发者对 Checked Exception 进行处理的原因。假设在文件传输的过程中网络出现中断，这时候程序应该能够捕获到这种异常并进行处理（重新尝试传输文件）。</p>
<h1 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h1><p>Unchecked Exception 的发生有一些是由于开发者代码逻辑错误造成的，比如：NullPointerException 这种异常可以通过检查一个引用是否为 null 来进行避免。</p>
<p>但是也有一些 Unchecked Exception 出现并不是因为开发者程序的问题，这些 Exception 是 <code>java.lang.Error</code> 的子类。就像 OutOfMemoryError 可能发生在任意一个示例对象创建时，但我们不可能在每个对象实例创建时都使用 <code>catch</code> 块去捕获异常。因此，我们也就不可能预料这些异常的发生，编译器在编译时也无法检测到这些异常。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面这个例子，由于没有对 Checked Exception 进行处理而导致编译失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使上面的代码可以正确编译，我们可以在 <code>try/catch</code> 块中捕获相应的异常或者是使用 <code>throws</code> 在 main 方法声明处抛出异常。</p>
<p>但是如果在 main 方法<strong>内部</strong>抛出一个 Unchecked Exception，依然可以正常编译，下面的例子就可以正确编译。正如前面所述，Unchecked Exception 在编译期间是无法提前检测，因此，不对其进行处理也不会影响到正常编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Exception-类层次结构"><a href="#Exception-类层次结构" class="headerlink" title="Exception 类层次结构"></a>Exception 类层次结构</h1><p><code>java.lang.Throwable</code> 类是一个 Checked Exception，Java 的 API 定义了 Throwable 的两个子类——<code>java.lang.Exception</code> 和 <code>java.lang.Error</code>， Error 类是 Unchecked Exception 类，而 Exception 则是 Checked Exception类。</p>
<p>Exception 类有一个 Unchecked Exception 子类——<code>java.lang.RuntimeException</code>，NullPointerException 和 ClassCastException 都是 RuntimeException 的子类。RuntimeException 和 Error 的所有子类都是 Unchecked Exception，其他的  Exception 则都是 Checked Exception，如下图所示。</p>
<p><img src="/images/java/Checked-and-Unchecked-Exceptions-in-Java.png" alt="Exception Hierarchy"></p>
<p>如果创建一个自定义的异常类，它是 Checked Exception 还是 Unchecked Exception 则依赖其父类的类型。如果它继承于一个 Unchecked Exception 类，那么它就是一个 Unchecked Exception，反之依然。</p>
<p>在对 Checked Exception 进行 <code>catch</code> 操作时，也需要遵循一定的规则：在 catch 块中捕获的异常，必须在 try 块中有出现这种异常的可能性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.out.println(<span class="string">"..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子就不能成功编译，因为在 try 块中永远都不会抛出 IOException，所以你也不能去捕获这种异常。但是如果你捕获的是一个 Unchecked Exception，那么就不会有这种问题。</p>
<p>Exception 和 Throwable 这两个类有些特殊，虽然它们都是 Checked Exception 类，但你依然可以捕获它们即使在 try 块中没有抛出该异常的可能性，因此，下面的代码的就可以正确编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.out.println(<span class="string">"..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面所说的规则对于 Exception 和 Throwable 这两个类并不是完全适用，这是因为对 Exception 和 Throwable 这两个类都有 Unchecked Exception 类型的子类，所以编译器允许你捕获它们（编译器认为你是在捕获一个 Unchecked Exception）。要清楚一点，<strong>编译器并不会检查 Unchecked Exception</strong>，RuntimeException 是 Exception 的子类，Error 是 Throwable的子类, 而 RuntimeException 和 Error 都是 Unchecked Exception 类。因此，上面的代码是可以正确编译的，编译允许这样做的原因就是因为这种方式是可以捕获到 Unchecked Exception 的。</p>
<h1 id="JVM-和程序异常"><a href="#JVM-和程序异常" class="headerlink" title="JVM 和程序异常"></a>JVM 和程序异常</h1><p>JVM Exception 是由 JVM 自己抛出的异常，比如：如果调用的方法使用一个 null 引用，然后 JVM 就会抛出 NullPointerException，或者如果在程序中出现10除以0的情况，JVM 会抛出一个 ArithmeticException。这些异常都是自动地由 JVM 抛出。</p>
<p>除了 JVM Exception 外，其他所有的异常都是由程序引起的异常。程序中，我们可以显式地使用 <code>throw</code> 语句抛出异常，这里以 NumberFormatException 为例。NumberFormatException 可能被方法 <code>Integer.parseInt</code> 或 <code>Float.parseFloat</code> 抛出，都是程序中可能出现的异常。在 <code>Integer</code> 类方法 <code>parseInt</code> 的实现中，可以找到如下的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 JVM 不会抛出这种类型的异常，这些异常是使用 <code>throw</code> 语句显式地程序中抛出。当然也可以如下所示在程序中抛出 JVM Exception。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"I told you s shouldn't be null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是一般情况下，JVM Exception 是不会被开发者抛出的（JVM 自己抛出的），所有的 JVM Exception 都是 unchecked，而程序中的异常则可能是 checked 的或者 unchecked 的。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/specs/#44121" target="_blank" rel="external">Chapter11 Exception</a></li>
<li><a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="external">Checked and Unchecked Exceptions in Java</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果在 Java 应用中对 Exception 能够正确处理，那么将会使你的程序更具有健壮性。但是很多人对 Exception 中的 &lt;strong&gt;Checked Exception&lt;/strong&gt; 和 &lt;strong&gt;Unchecked Exception&lt;/stro
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://matt33.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键总结</title>
    <link href="http://matt33.com/2016/12/06/vim-basic/"/>
    <id>http://matt33.com/2016/12/06/vim-basic/</id>
    <published>2016-12-06T14:02:51.000Z</published>
    <updated>2016-12-13T02:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 到目前位置也用了将近两年，但是很多的快捷键每次要用到的时候还是会 Google 一下，只能记住很少的命令，查的过程其实还是会浪费很多时间，这里总结一下一些常用的 Vim 命令，以便以后查看。</p>
<h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>h,j,k,l</td>
<td>h表示往左，j表示往下，k表示往上，l表示往右</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>上一页</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>下一页</td>
</tr>
<tr>
<td>w, e, W, E</td>
<td>跳到单词的后面，小写包括标点</td>
</tr>
<tr>
<td>b, B</td>
<td>以单词为单位往前跳动光标，小写包含标点</td>
</tr>
<tr>
<td>0</td>
<td>跳到本行的头部</td>
</tr>
<tr>
<td>O</td>
<td>开启新的一行</td>
</tr>
<tr>
<td>^</td>
<td>一行的开始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结尾</td>
</tr>
<tr>
<td>gg</td>
<td>文档的第一行</td>
</tr>
<tr>
<td>[N]G</td>
<td>文档的第N行（G 是最后一行），如：27+shift+g</td>
</tr>
</tbody>
</table>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>插入到光标前面</td>
</tr>
<tr>
<td>I</td>
<td>插入到行的开始位置</td>
</tr>
<tr>
<td>a</td>
<td>插入到光标的后面</td>
</tr>
<tr>
<td>A</td>
<td>插入到行的最后位置</td>
</tr>
<tr>
<td>o</td>
<td>在当前光标的下方插入新一行</td>
</tr>
<tr>
<td>O(Shift+o)</td>
<td>在当前光标的上方插入新一行</td>
</tr>
<tr>
<td>Esc</td>
<td>关闭插入模式</td>
</tr>
</tbody>
</table>
<h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>在插入模式替换光标所在的一个字符</td>
</tr>
<tr>
<td>J</td>
<td>合并下一行到上一行</td>
</tr>
<tr>
<td>s</td>
<td>删除光标所在的一个字符, 光标还在当行</td>
</tr>
<tr>
<td>S</td>
<td>删除光标所在的一行，光标还在当行，不同于dd</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步操作</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>恢复上一步操作</td>
</tr>
<tr>
<td>.</td>
<td>重复最后一个命令</td>
</tr>
<tr>
<td>~</td>
<td>变换为大写</td>
</tr>
<tr>
<td>[N]&gt;&gt;</td>
<td>一行或N行往右移动一个tab</td>
</tr>
<tr>
<td>[N]&lt;&lt;</td>
<td>一行或N行往左移动一个tab</td>
</tr>
</tbody>
</table>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:wq,:x</td>
<td>保存并关闭</td>
</tr>
<tr>
<td>:q</td>
<td>关闭（已保存）</td>
</tr>
<tr>
<td>:q!</td>
<td>强制关，不保存</td>
</tr>
</tbody>
</table>
<h1 id="查找和搜索"><a href="#查找和搜索" class="headerlink" title="查找和搜索"></a>查找和搜索</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/pattern</td>
<td>搜索（非插入模式) ，支持正则</td>
</tr>
<tr>
<td>?pattern</td>
<td>往后搜索</td>
</tr>
<tr>
<td>n</td>
<td>光标到达搜索结果的前一个目标</td>
</tr>
<tr>
<td>N</td>
<td>光标到达搜索结果的后一个目标</td>
</tr>
<tr>
<td>r+p</td>
<td>将光标之后的字符替换为字母p</td>
</tr>
<tr>
<td>:s/word/replace</td>
<td>光标所在行的第一个 word 替换为replace。</td>
</tr>
<tr>
<td>:%s/word/replace/</td>
<td>全文查找 word 并替换为 replace</td>
</tr>
<tr>
<td>:1,50s/word/replace/</td>
<td>在第1行和第50行之间（含）进行搜索和替换</td>
</tr>
<tr>
<td>:45s/word/replace/</td>
<td>表示仅仅在第45行进行搜索和替换。而 1,$ 行号范围和 % 是等价的</td>
</tr>
</tbody>
</table>
<h1 id="剪切、复制与粘贴"><a href="#剪切、复制与粘贴" class="headerlink" title="剪切、复制与粘贴"></a>剪切、复制与粘贴</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>dd</td>
<td>删除一行，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>de</td>
<td>删除光标后的单词内容，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>dw</td>
<td>删除光标后的单词内容以及之后的空格，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词</td>
</tr>
<tr>
<td>[N]dd</td>
<td>删除以当前行开始的n行</td>
</tr>
<tr>
<td>x</td>
<td>删除后一个字符</td>
</tr>
<tr>
<td>X</td>
<td>删除前一个字符</td>
</tr>
<tr>
<td>D</td>
<td>删除一行最后一个字符</td>
</tr>
<tr>
<td>[N]yy</td>
<td>复制一行或者N行</td>
</tr>
<tr>
<td>yw</td>
<td>复制一个单词</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
</tbody>
</table>
<h1 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>:split</td>
<td>水平方向分割出一个窗口</td>
</tr>
<tr>
<td>:vsplit</td>
<td>垂直方向分割出一个窗口</td>
</tr>
<tr>
<td>:close</td>
<td>关闭窗口</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口</td>
</tr>
</tbody>
</table>
<h1 id="文字版"><a href="#文字版" class="headerlink" title="文字版"></a>文字版</h1><p>这里有一个别人总结的文字版<a href="http://tnerual.eriogerg.free.fr/vimqrc.pdf" target="_blank" rel="external">图片链接</a>。</p>
<p><img src="/images/linux/vim-text.png" alt="vim-text"></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html" target="_blank" rel="external">Vim 使用笔记</a></li>
<li><a href="http://cenalulu.github.io/linux/all-vim-cheatsheat/" target="_blank" rel="external">史上最全Vim快捷键键位图 – 入门到进阶</a></li>
<li><a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="external">简明 Vim 练级攻略</a></li>
<li><a href="http://www.jianshu.com/p/c23136f68d2f" target="_blank" rel="external">Vim快捷键整理</a></li>
<li><a href="http://lxs647.iteye.com/blog/1245948" target="_blank" rel="external">vi/vim 删除以及其它命令</a></li>
<li><a href="http://pizn.github.io/2012/03/03/vim-commonly-used-command.html" target="_blank" rel="external">Vim 命令总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim 到目前位置也用了将近两年，但是很多的快捷键每次要用到的时候还是会 Google 一下，只能记住很少的命令，查的过程其实还是会浪费很多时间，这里总结一下一些常用的 Vim 命令，以便以后查看。&lt;/p&gt;
&lt;h1 id=&quot;光标移动&quot;&gt;&lt;a href=&quot;#光标移动&quot; cla
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>技巧，其实并没有什么技巧，只不过多了些毅力罢了</title>
    <link href="http://matt33.com/2016/11/29/book/"/>
    <id>http://matt33.com/2016/11/29/book/</id>
    <published>2016-11-29T14:14:26.000Z</published>
    <updated>2016-11-29T15:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于<a href="https://book.douban.com/subject/26874593/" target="_blank" rel="external">技巧</a>这本书的读书笔记。这本书是作者根据自己的生活学习经历悟出的一些方法论，满满的正能力，但有不同于一般的鸡汤文，书中提到的那些<strong>技巧</strong>，其实每个人都可以做到，但实际上却很少有人做到，正如作者所说<code>因为别人都睡着，你醒着那么你就是杰出的</code>。方法其实还是那种最简单的方法，简要来说就是<strong>行动+坚持</strong>，这也是最难的方法，因为坚持是最难的。用这种方法达到自己想要效果的人就认为这种方法非常有用，就如作者学习英语一样，而对于大多数那些坚持不下去的人来说，他们感觉这就是在扯犊子，正所谓方法因人而异。如果一味地去追求 XX 天精通 XX，其实最后的结果只会是<strong>从入门到放弃</strong>。</p>
<p>写着写着突然想讨论一下关于<strong>读书</strong>这个问题，在自己的印象中，自己第一次真正意义上、主动去读书应该是在中考结束的那个暑假，我现在已经忘了当时是什么原因让自己在那个暑假里读了好几本书，记得当时读了《三国演义》，在读完《三国演义》时觉得这本书应该是四大名著里写得最好的了，搞不懂为啥是《红楼梦》。而《红楼梦》这本书当时是强迫自己看下去的，这点还是有印象的，但当看到三十回之后，就被深深吸引住了，一发不可收拾，当时基本上晚上睡觉前都在读。当然，现在对于其中很多的细节都已经想不起来了，书中很多的故事也忘得差不多了，当年背了很久的《葬花词》也记不起几句了。我现在唯一有印象的，可能就是当时那段时光每天都在看书的场景（虽然是小说 :joy:），回忆起来还是很怀念的。再后来，上了高中之后，基本上就没有自己自主支配的时间，也就再也没有怎么看过书（非学科类的书）了。这就是在大学之前我与书的故事，很简单，但事实上，对于那个时候的我，并不知道怎么去读书，也不知道读这些书对自己有什么用，只是被书中的故事吸引而已，当然也就没有像红学研究者那样去思考这本书后面的故事。</p>
<p>到了大学之后，自己看的书也不是很多，其实是很少，这是我关于大学的遗憾之一，并没有在看书上花太多时间，大学四年自己看的书应该不会超过二十本。忘了是大二还是大三的时候，当时室友买了一本<a href="https://book.douban.com/subject/1013208/" target="_blank" rel="external">《如何阅读一本书》</a>，当时我在看到这本书的名字，对他不屑一顾地嘲笑了一番，当时感觉看书还需要学习、还需要让一本书来教你？看书不是每个人都会的吗？当时还没有开始接触豆瓣，并不知道在豆瓣上评分8.5的书意味着什么。</p>
<p>再后来，到研究生之后，记得在研一的时候，因为看了陈志武的《金融的逻辑》，对书中提出的观点感觉感觉很新颖，就把陈老师其他的几本书都看了一下，之后又看了一些小说以及吴军老师的书。前段时间在微博上看到有两本书突然很火，一本就是本文所说的《技巧》，另一本是《精进》。自己也就买了这两本书开始看，刚开始看的是《精进》，但是由于精进太偏方法论，理论更多些，感觉是需要在很安静的环境下看才比较好，所以到现在也就只看了一半，而《技巧》这本书都是以小故事的形式呈现，在宿舍或者公司读起来都很适合，所以虽然先看的《精进》，结果还是先把《技巧》看完了。《技巧》的作者 Tinyfool 是一个看过很多书的人，在书中也讲了很多看书的方法，而恰巧《精进》这本书的作者也讲了很多关于读书这一块的内容，告诉我们应该如何去读书、如何读懂一本书，在这一块，这两本书是解决了我的一些困惑。之前，我曾经想过，每看一本书，就做一个思维导图，到最后发现我做的思维导图压根没有别人做得那么好看，自己反而花了太多时间在思维导图的表达和形式上，开始觉得这并不是看书的一个好方式。</p>
<p>现在慢慢觉得关于读书这件事，第一步应该是选书，并不是评分高的书我们就应该去读，选书应该因人而异，读一本书我们是需要知道这本书解决我们哪方面的困惑，带着问题去读书，比如一些哲学类的东西在现实中可能无法找到解决方法，我们只有去借鉴前人的经验，但是也要明白一点：任何一个作者也是有其时代和历史局限性的，书中的答案并不定是正确的答案、并不一定可以解决自己的困惑。在选书上要选对自己有帮助的书，读书肯定是为了让自己收获一些东西，有些书可以解答自己的心理困惑，有些书可以讲述一些技术，也有一些书可以教给我们一些方法。但最关键的是自己要去思考和应用，对于提供书经验方法的书，我们可以学以致用；对于能解决一些困惑的书，我们要去思考这本书如何解决这个问题、从哪个角度出发以及中间论证的逻辑性等，这样才是真正的读书。现在回想起来，大学那时候的想法其实是很幼稚的，其实现在也不敢说自己就已经明白了读书的真谛，很多东西还是需要慢慢体会、慢慢积累、不断完善。</p>
<p>下面是《精进》作者采铜发的一段微博。</p>
<blockquote>
<p>很多人读完一本书的时候，喜欢画一个思维导图还原书中的主要观点。还有人会写一个书评，去分析和评价作者的观点对还是错。可是，作者的体系是他的体系，你无法直接受用；而观点的对错，对，是他对了，错，也是他错了，跟你什么关系呢？为什么一定要评个所以然出来呢？读书时，你更应着眼的是，这本书对你自己的意义。具体来讲，就是从“我”的需要出发，像一个探险家／考古学家／盗墓者／松鼠一样从各种书里探测、挖掘三种东西：原则、方法、素材。原则：书里有什么做事的原则是我可以借鉴的。方法：书里提供了什么做某事的方法。素材：书里提供了什么故事案例可以用来填充我的框架。这三样东西有些是在字面上，作者写明的，更多的，是深埋在文本之下，需要由你用你的洞察力去找出来。你读到的书是一整体，而你需要把它打散，找出你所需要的碎片，或原则，或方法，或素材，然后在你脑中拼接成型。——采铜微博。</p>
</blockquote>
<hr>
<p>下面的内容是自己在看书时，做的一些笔记，主要摘抄的书作者的观点以及个人的一些读后感。</p>
<h1 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h1><p>让人恐惧的不是死亡，而是希望。</p>
<ul>
<li>前妻的故事<ol>
<li>虽然学历低、家庭背景差，但是却有着一颗改变命令的心（这点很多人都有）；</li>
<li>她之所以从一个理发学徒变成一个年薪40w 的程序员（这个工资目前在程序员中并不算很高），但却很努力，而且不怕嘲笑，不懂的东西会虚心请教，最重要的是她能一直坚持下去了；</li>
<li>改变命运的心大部分人都有，但是一直把努力和不懂就问的品行坚持下去的人却很少。</li>
</ol>
</li>
<li>Sycx 的故事<br>-在互联网大潮之下潜行的成功创业者<ol>
<li>有一些互联网企业并不直接服务于用户，而是服务于产业，让互联网与一些具体的实体产业结合，这种商业模式可能不太好理解，但确实是互联网创业比较容易成功的地方。</li>
</ol>
</li>
<li>冯大辉的故事<ol>
<li>我不想做一辈子咸鱼，我构建我的个人品牌是希望积蓄力量，帮助我未来做事情；</li>
<li>无论加入的平台多么牛逼，只有自己踏踏实实做事情才能获得真正的成长。</li>
</ol>
</li>
<li>机会总是留给哪些不精明的人<ol>
<li>作者用一个身边人的例子（一位腾讯的早期员工）告诉读者一个道理：有时候人太过于精明，反而会忽略一些其他东西，从长远来看并不见得对自己有益（当然这个人的经历有很大运气的成分，但有一点可以确定的是，这个人并不甘于平庸，而且可以为了自己喜欢的东西放弃稳定的工作）。</li>
<li>作为一名普普通通的人，应该少一些浮想和幻想，多关注关注自己真正关注的东西，改变自己的心态。</li>
</ol>
</li>
<li>每个人都不完美<ol>
<li>对他人要宽容：要用发展的眼光看他人，人无完人；</li>
<li>对自己宽容：不要急躁，先承认现状，然后慢慢改进，才能平静地追求持续稳定的改进。</li>
</ol>
</li>
<li>我们能给世界留下什么<ol>
<li>作者简述乔布斯的故事，根据自己的经历做了一些思考，每个人在人生中都会经历各种起落，任何人都有烦恼，关键在于自己有没有 faith，有没有 calling，遇到困难时，有没有选择 fight。</li>
</ol>
</li>
<li>年轻是什么<ol>
<li>年轻是永远的积极向上、挑战自己、对世界继续充满好奇，希望每一天都过得有意义、充实，同时充满新鲜感，而老则相反，我们自己永远有选择的权利；</li>
<li>学习任何一个东西哪怕需要3-5年，但因为我们至少有几十年的时间可以去学习，所以去学习任何一个我们有兴趣的点都是完全可以的。</li>
</ol>
</li>
<li>身上的赘肉和自己的困境一样<ol>
<li>困境同样也不是一天之内降临的，也是慢慢积累的，找到解决办法，沿着一个既定的方向，慢慢来；</li>
<li>对于每个人来说，也许你们不胖，但是人生本是逆水行舟，当你停止前进的时候，你就老了，你就死了。</li>
</ol>
</li>
<li>疼痛有时候也是一种成长<ol>
<li>《异类》中谈论的一万个小时理论，并不是普普通通的一万个小时，而是不断冲破舒适区的一万个小时；</li>
<li>成长是由疼痛感的，就像爬楼梯，如果你可以轻轻松松爬5层，那么爬6层楼也许你会开始喘粗气，7层楼也许就会累了。那么5层就是你的舒适区，你每天都爬5层楼的话，就是坚持，而每天都试图<strong>多爬一层，这就是成长</strong>；</li>
<li>爱上成长，就是爱上那种疼痛的感觉，爱上那种感觉，就觉得自己一往无前、不可阻挡…..</li>
</ol>
</li>
<li>坚持本心，但不要拒绝任何改变<ol>
<li>我们在成长的过程中，都是一边追寻着改变而一边又畏惧着改变的；</li>
<li>这个时代变化太快，我觉得更幸福的模式不是找到一个好工作安稳一生，而是学会不停地改善自己，挑战自己的方法，然后用前进迎接这个世界一切的改变，永远站在风口浪尖上，直面前行。</li>
</ol>
</li>
<li>劫后<ol>
<li>有些东西无法预料，重要的是活好每一天。</li>
</ol>
</li>
<li>尽可能活成你想要的样子<ol>
<li>如果你发现自己不会背单词、不会游泳，那就是自己得到的欲望不够强烈；</li>
<li>The world is a playground. You know that when you are a kid but somewhere along the way, everyone forget it.</li>
</ol>
</li>
</ul>
<ol>
<li>这个世界对每个人都一样，但有些人活得很快乐，而有些人却很疼苦。</li>
</ol>
<h1 id="我们的伟业，是次序不断地改变自己"><a href="#我们的伟业，是次序不断地改变自己" class="headerlink" title="我们的伟业，是次序不断地改变自己"></a>我们的伟业，是次序不断地改变自己</h1><ul>
<li>作者学习英语的历程，很有借鉴意义<ol>
<li>作者并不是一个语言天赋很好的人，英文底子也不是很好，但最后却可以在两年内达到听说读写与外国人交流都没问题，这是很值得我们学习的，作者的技巧也就两点：循环渐进+坚持（过程很痛苦，但是回忆起来却很快乐），中间最喜欢作者说的一句话：<strong>当你感觉痛苦时，这时候就是成长</strong>；</li>
<li>虽然作者使用的是<strong>硬学</strong>，但要注意循环渐进，要由浅入深，而且不要急躁，作者看美剧突破无字幕用了半年，听 Postcast 突破也用了一个月；</li>
<li>在学习的时候，要给自己定下目标，然后去努力达到这个目标，这样才有方向性；</li>
<li>一切痛苦都不是痛苦，一切辛苦也都是快乐。</li>
</ol>
</li>
<li>掌握”学习曲线”，终身学习<ol>
<li>在任何环境中，我们都可以观察到，即使是一个不断变化的环境中，终身学习者也只占很少一部分，如果你是终身学习者，你可以秒杀一个领域里的你的同侪，终身学习是没有极限的；</li>
<li>学习曲线，当开始比较平，但是当你对一个东西了解以后，后面就是一个加速度过程，在开始的学习中，要设定合适的基准，不要控制太狠。</li>
</ol>
</li>
<li>锻炼你的大脑<ol>
<li>人有两个大脑，一个深思熟虑、功能非常强大；另一个比较像远古的动物，不太懂事，但它非常快，有点像反射，我们应该远离远古的大脑；</li>
<li>当你觉得难受时，你的大脑就在进化，无论在任何时候你觉得轻松，你都在使用你的习惯；</li>
</ol>
</li>
<li>二手知识的问题<ol>
<li>对于二手的知识的建议：一定要自己去看书，去看一手的东西，因为信息在传播的过程中会出现失真；</li>
<li>书读多了，读傻了，这是因为根本没有读懂书；</li>
<li>读一本书是要了解它的精髓，明白作者的心思，明白为什么这么写，学会一些思维方式、方法论或者一种思想感情，而不是会背几个段落。在读书的时候，如果你加入了自己的一些思考，用思维或者实践践行了书里面的理念，那么这本书，你就真的读懂了。</li>
</ol>
</li>
<li>学思关系<ol>
<li>学习的过程中，最重要的是要进行<strong>思考</strong>，比如，在看经济学的书的时候，学着利用学到的理论去分析现实生活中遇到的问题，去旅行去见世面，去了解不同的风土人情，跟书上的描写做对照，这也是思考；</li>
<li>看一本书，去吸收消化它，将它变成自己的理论，去验证它。</li>
</ol>
</li>
<li>阅读中的模型和数据<ol>
<li>一般来说，读书会给我们两种情形的收获：一是改造我们的思维方式，给我们展现一个新的思维模型，另一个是在现有的思维模型下，给我们数据，让我们对现有模型更精通、更确信。</li>
</ol>
</li>
<li>理性地设定目标<ol>
<li>再设定目标时，要设定一个长期目标，这个目标要有一定难度，让它指引着自己前进，当达到之后，再设定一个更大的目标；但近期目标一定要是可以达到的，每次完成一件事，成功了然后就会获得成就感，这会激励我们努力去做下一件事，这样才会进入一个<strong>正向循环</strong>之中；</li>
<li>人的学习曲线是一个二次函数，刚开始设置的短期目标比较低，然后慢慢提高，慢慢提高，追求在整个提升过程中，始终保持每一个短期目标都可达成，从而进入长效的正向循环之中，追求”乐学”和先慢后快的加速度运动过程之中。</li>
</ol>
</li>
<li>追求积累的力量<ol>
<li>我一直思考为什么需要终身学习、自主学习，以及我们应该怎么终身学习和自主学习。但是，扔需要强调的是，这里不会有任何捷径，我不知道任何捷径，我也不相信任何捷径；</li>
<li>年轻的时候，我以为成功是一个结果，是一个我们可以用毕生追求的目标。然而，这几年，我才慢慢明白，成功只是完善自己道路上的一个过程，没有尽头，爬上了一座高山，还有另外一座高山在等你。每一次你获得成功之前，都无不重要，获得之后，无非就是一个廉价的会议而已，你要追求的是自己的不断完善，这才是无尽的旅程。</li>
</ol>
</li>
<li>读书的时候我们在读什么<ol>
<li>人和动物的一个最大区别就是，人会思考，会将知识进行传承；</li>
<li>应试教育只是学习一种方式而已，并不是学校教育学习的东西就够我们使用了，毕业了之后就不需要学习了，实际上，在学校教育结束，我们还应该更加努力地去学习和看书，因为，在这个时代，大学毕业，竞争才刚刚开始；</li>
<li>对于任何一本好书，它的价值都远远大于它账面上的价格，在这样的情况下，迅速获取一本好书，获取其中的知识，从而提升自己的价值，这才是更合理的决策；</li>
<li>在书读太少的前提下谈优劣是一个笑话，在读得太少的前提下谈选择又是另外一个笑话，我们需要在阅读中不断的认识自己。</li>
</ol>
</li>
<li>时间和节奏的力量<ol>
<li>每个人的时间都很紧张，但是核心的问题不是时间本身，而是你能不能把握到节约时间的工作方法，简单来说，就是做事有规律有计划；</li>
<li>你可以试一下，学会每天都花固定的时间做一点点改进自己的事情，一年时间，你的改进就非常惊人，而你同时也会明白这样的人生才不会荒废。</li>
</ol>
</li>
<li>不要被你受的教育束缚<ol>
<li>不要相信某某东西很难，只有研究生博士才能学会这样的鬼话。实践才是学习的最好方法，我们要摆脱应试教育对自己的影响，从自身出发，从终身学习出发，仔细思考，自己的人该怎么渡过。</li>
</ol>
</li>
</ul>
<h1 id="前行的力量"><a href="#前行的力量" class="headerlink" title="前行的力量"></a>前行的力量</h1><p>我可以接收我自己沉沦一天、两天、三天，我决不能接收自己一直沉沦，我还没有死，所以，我不会停止前进，你们呢？</p>
<ul>
<li>比你聪明的人大多数也比你勤奋，你看不到的东西不代表没有发生过<ol>
<li>个人发展上，虽然个人的出身、家世背景对个人有一定影响，但是如果你足够努力，不断地去提高自己，在这个社会上，你完全可以过得很好。</li>
</ol>
</li>
<li>工作如何和个人成长相协调，写到刚毕业的大学生和毕业不足五年的朋友们<ol>
<li>工作无聊，不是个人无聊的原因，有些人是可以把无聊的工作，做的有声有色，甚至脱颖而出的；</li>
<li>对于校招的学生，当你在找到一个满意的工作之后，你必须要明白，你学历的价值在慢慢消退，慢慢地大家就会用一个对社会人的要求来要求你。</li>
</ol>
</li>
<li>工作方法篇：任务分解<ol>
<li>任务分解，尤其对于复杂问题，非常重要；</li>
<li>任务分解的过程，其实也就是对这个复杂问题思考的过程，只要经过深入的思考，你才能对这个任务进行分解。</li>
</ol>
</li>
<li>为什么有些人用一年时间获得了你十年的工作经验？<ol>
<li>优秀的人不但有极强的学习能力，而且他们的学习方法和对待事情的认真态度是不可阻挡的；</li>
<li>你是有十年工作经验？还是把一年工作经验用了十年？《异类》的理论是只有当你刻意去学习，不停地从自己舒适区跳出来，忍受一种痛苦和煎熬，改变自己之后，这样你付出的时间才算数；</li>
<li>如果当你在工作处理工作时，感觉很轻松，其实这时更应该有种危机感，因为这个时候其实你并没有在成长，只是在利用自己过去的经验而已。这个时候有两个办法可以去提高自己：一是找一份更有挑战性的工作，二是做一个副项目提高自己。</li>
</ol>
</li>
<li>改进自己从学会如何正确认识自己开始<ol>
<li>总之一句话，吾日三省吾身；</li>
<li>并不是所有人都可以做到，也并不是每个人都可以一直坚持下去，更应该通过外力的辅助让自己坚持一下。</li>
</ol>
</li>
<li>这是一个协作的世界<ol>
<li>在协作的世界里，很多你想做的事情更容易完成。</li>
</ol>
</li>
<li>字是一个一个写出的，路是一步一步走的<ol>
<li>走到天竺，分三步。第一步，开始走；第二步，走；第三步，到了；</li>
<li>实现自己计划的路上有多少辛苦。有多少磨难，你如果不上路，恐怕永远无法知道。</li>
</ol>
</li>
<li>急与快的区别<ol>
<li>欲速则不达，最好的方法，就不疾不徐，认真回到内心去思考，自己想要什么，自己可以做什么，什么是自己可以一步一个脚印解决问题的方法。</li>
</ol>
</li>
<li>什么是沟通？沟通的目的是什么？<ol>
<li>沟通是因为我们不同的人有不同的价值观，对事物有不同的看法，有不同的利益、不同的想法，但是我们要生活在一起，要在一起做事情，所以我们要相互交换意见；</li>
<li>沟通的目的并不是要战胜别人、说服别人，而是要说出自己的想法、自己的观点，就事论事，大家再一起寻找其中的平衡点。</li>
</ol>
</li>
<li>接触微博你节约了时间，然而并没有什么卵用<ol>
<li>耽误不耽误时间关键个人的计划，一定要保证事情优先，娱乐在后的原则，在保证自己计划、事情完成的情况，娱乐并不是坏的影响。</li>
</ol>
</li>
<li>理清头绪，找到节奏<ol>
<li>很多时候，当我们面对很多问题，很多压力，有时候甚至解决一个问题，又接着出现更多的问题，陷入一个恶性循环。当出现这种情况的时候，我们是需要思考、反思的，因为我们可能一直都没有直面真正的问题，做事情没有头绪，没有节奏，没有方法，当我们认为自己在辛苦工作，但却有从不思考为什么会一直做不好？</li>
<li>我们不应该在泥潭里坚持，而应该去积累，积累改进，积累思考跳出泥潭，去掌控自己的工作和生活。</li>
</ol>
</li>
<li>哪里真有什么信息过剩，你过省吸收的是垃圾，你需要的信息你根本没有获取够<ol>
<li>明白一点，信息从来没有过剩，我们只是沉迷在噪声里；</li>
<li>在合适的时间掌握稀缺的信息，是非常重要的，比如，当微信的小程序刚刚出来，在第一时间去学习、去应用，顺便写一些文章、做一些实用的东西；</li>
<li>深度挖掘信息的价值，如比看一本书，应该从中学会新的思维方法，将书中的方法论应用到自己的学习生活中，这样才是读懂了这本书；</li>
<li>什么信息才是自己需要的信息，要根据自己的需求出发，从自己<strong>成长的角度</strong>去考虑。</li>
</ol>
</li>
</ul>
<h1 id="我们都生活在生活之中"><a href="#我们都生活在生活之中" class="headerlink" title="我们都生活在生活之中"></a>我们都生活在生活之中</h1><ul>
<li>这世界上有无数的路，你走你的好了，别人怎么走跟你无关<ol>
<li>看完这篇文章，想起了一句话，在人生的过程中，每个人只能陪你走过一段距离。确实是这样，初中、高中时要好的朋友，等到工作了还有多少依然保持不错的联系？每个人的选择都不一样，最后的结果也只能是大家会渐行渐远；</li>
<li>这个世界上有无数条路，有很多路可以通向成功、幸福和快乐，关键是要找到自己的路，别人走什么路，其实跟我们关系并不大。</li>
</ol>
</li>
<li>自信心要如何培养？<ol>
<li>第一，要相信一点，其实大家都一样，我并不比大多数人聪明，同时也不比大多数人傻；第二，一次次的正反馈会增大我们的自信心；</li>
<li>要平时所有优秀的人，不要认为他们有什么天赋，学习优秀的人的做事方法，让自己也变得优秀，这才是进步。</li>
</ol>
</li>
<li>所有人都伤害不了你，伤害你的总是你自己<ol>
<li>这个世界有各种各样的人，有各种各样的评价标准，不管你多厉害，你也不可能取悦所有的人。关键在于找到自己真正在乎的人，找到自己真正在乎的标准。</li>
</ol>
</li>
<li>这世间并没有一种东西叫做拖延症<ol>
<li>拖延症这个概念确实是有害的，我们每个人的拖延都有无数的原因，如果我们不去分析拖延的具体原因，只是以拖延症来自我安慰，那么拖延症永远都无法得到解决。</li>
<li>拖延症，有一些情况是因为心理原因，有一些情况是因为自己把计划定得太死太严，不太合理。</li>
</ol>
</li>
<li>笨鸟先飞，但聪明的鸟飞得更快怎么办？<ol>
<li>笨鸟先飞，只是为了比自己昨天早到，要注意这里比较的对象是昨天的自己，而不是别人，如果选错了比较对象，只是自寻烦恼而已；</li>
<li>人活着，只是为了吃饱穿暖吗？如果只是这样，会不会太容易了？其实动物园里的猴子也可以吃饱穿暖，但是，这有什么意思？人活着总要有点念想，有点目标，要不人生岂不太无聊。</li>
</ol>
</li>
<li>梦想总是那么美好的，奈何你总是死在路口<ol>
<li>不去出发、不去努力，你怎么知道梦想不会实现。</li>
</ol>
</li>
<li>到底有没有寒门上升的阶梯？我们有没有希望？<ol>
<li>社会发展到现在，阶级在一定程度上确实在固化，但是这并不能否定个人努力的重要性，我们需要做的，其实就是一步一步地提升自己。</li>
</ol>
</li>
<li>成功并非只有一个标准<ol>
<li>对于人生来说，对于个人的成功来说，作者认为持续成长和内心平静。持续成长就是不断地去提升自己、越过一个又一个的高峰。内心平静就是 follow your heart，寻找内心的快乐。</li>
</ol>
</li>
<li>环境和你个人的关系，君子反求诸己<ol>
<li>环境对人的影响，其实也是非常重要的，这一点是毋庸置疑的，但是从另一角度想，如果一个和马云有同样生活经历的人，是不是也能有马云一样的成就呢？恐怕正常人都会觉得不太可能，同样也可以看出在人生中个人的影响力。对于我们大多数人来说，自己的之前的生活环境已经是无法改变了，现在能改变的只是自己了。如果只与自己做比较，影响自己发展的，只有自己个人；</li>
<li>对于我们很多人来说，由于我们的起点都不是很高，我们稍微努力一些成果就会很惊人，就跟在学校里提高学习成绩一样，差生稍微努力一下，效果会非常惊人的；</li>
<li>在现在这个社会里，能真正沉下心去做事的人并不多，只要稍微努力努力，我们就可以脱颖而出。换句话说，大多数在睡觉，你醒着你就是杰出的。</li>
</ol>
</li>
<li>《细节决定成败》的贡献和流毒<ol>
<li>与其一味地追求细节，更重要的是应该分清主次。</li>
</ol>
</li>
<li>改变不会在一夜降临，有耐心的人才能看到花开<ol>
<li>这世界上所有的变化和成长都是非常缓慢的，也只有这些缓慢的变化和成长才能慢慢积累，慢慢积累成翻天覆地的变化。</li>
</ol>
</li>
<li>外部条件解决后，你会发现最大的阻碍永远是你的内心<ol>
<li>如果外部条件解决之后，其实到最后你发现你没成功的原因并不是外部的条件，而是自己的内心。举个例子，在以前，如果你考不上耶鲁那你就上不了耶鲁的课，但是后来 MOOC 出现之后，你可以免费地去学很多名校的课，但是你最后发现你并没有坚持下去，这是因为你并没有那么想去上。记得在大二的时候，我第一次听说公开课这个概念，第一个看的是那个哲学课《死亡》，很明显我并没有坚持下去，直到现在，已经到研三了，也没有一门公开课坚持看完过。But now，我发现再不能这样下去了，那些对自己很有帮助的课，需要给自己定了一个计划，督促自己坚持下去。</li>
</ol>
</li>
<li>寻找和突破心障<ol>
<li>当你想做一件事，当时并没有去做，而且阻挡你的并不是金钱这些外部条件，那这是什么？可以称之为心障；</li>
<li>很多东西都可以算作是一种心障，比如学习成本的问题、不追求美好的生活。关于学习成本的问题，假如说学习一门语言或技术需要花费2年，但是我们可以用五年，甚至十年，那这合算吗？聪明人都知道，这怎么算都是合算的，更何况如果一门外语，尤其是英语，是可以用一辈子的，那这就更划算了，或者更详细算一下，英语熟练之后给你带来的好处，这就可以成为你学习的动力。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于&lt;a href=&quot;https://book.douban.com/subject/26874593/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;技巧&lt;/a&gt;这本书的读书笔记。这本书是作者根据自己的生活学习经历悟出的一些方法论，满满的正能力，但
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>观念在变化、在成长</title>
    <link href="http://matt33.com/2016/11/25/book/"/>
    <id>http://matt33.com/2016/11/25/book/</id>
    <published>2016-11-25T14:22:30.000Z</published>
    <updated>2016-11-25T16:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前公司推送了一位大神的推荐书单，当中推荐了这本<a href="https://book.douban.com/subject/20463108/" target="_blank" rel="external">《观念的水位》</a>，那是第一次看到这本书，记得当时看到这本书的名字，瞬间就吸引了我的兴趣，然后就在豆瓣上搜索了一下，看到评价还不错，就加到了自己的书单里。再后来，回到学校就在网上找到这本书的电子版，下载到手机里就开始看了起来，中间大概花了半个月的时间把这本书看完，那段时间基本上每天在公司上下班的班车和地铁上都在看这本书。在看的过程中，根据每篇文章看后的感想，做了一部分的笔记，在文章的后面会列出来。</p>
<p>在刚开始读的时候，就感觉这本书写得很深刻，披露得也很现实，甚至有点怀疑这本书是不是在大陆出版的。从书的整体上来看，感觉这本书，可以分为三大部分，第一部分是作者根据身边的实事写的一些思考和感悟，主要是以作者在英国的生活经历为主；第二部分，确切的是说应该是作者对于一些名著（或小说）的读后感；第三部分，是作者对电影的一些感悟。因为作者主要是研究历史、政治经济学（确切应该是政治学）这一块，当然其中也有关于人性和心理学的内容，作者根据身边的实事、电影以及小说，对宪政、人性进入了很多深入的分析，其中很多的地方都是我从来没想过的点（书读得少，没办法）。最令自己的敬佩的是，作者每读一本书，都会写一篇文章，看一些好电影也是这样，作者都会去深入地思考，这些都是自己应该去学习的地方。</p>
<p>当然，这本书在豆瓣能达到8分以上，证明书的内容也不会差到哪去。在读这本书的过程中，有种当时读《野火集》的感觉，感觉我们国家相比于欧美发达国家而言，政治文明、法制文明、宪政制度真的相差很远，而且我们国家在发展的过程中，还出现了各种各样的问题，这些问题都影响着我们每一个人。我们都知道法制的重要性，可是一个没有独立司法环境的社会，如何保障法制社会的建立、如何保障公民权利，一个人既当球员又当裁判，该如何保障另一球队的公平性？</p>
<p>但是，这本书给我带来的希望的地方是，随着我们国家经济的发展，当人们吃饱肚子、衣食住行得到保证之后，人们就会有一些其他更高的追求（精神上），随着这部分人的人数在增加，也推动了全民观念的水位在上升。当然由于最近一年房价的疯涨，一线城市及强二线城市基本上都已经翻倍了，这种情况的发生，突然将中国中产阶级迅速打压下去，也导致了中国中产阶级都成了名副其实的负翁。</p>
<p>就在写的时候，突然想到一点，想到了宋朝，记得历史课上学过，在宋朝，由于经济非常发达（宋朝是一个并不是由于农民起义而灭掉的王朝），在当时诞生了资产阶级的萌芽，假设，如果历史可以假设，那么如果当时蒙古没有崛起，宋朝的经济肯定还会接着发展，宋朝当时的科技好像也在世界处于领先地位，如果能这样一直发展下去，中国会不会诞生现代文明？现在我们已经无法推断，我们知道的结果是，由于蒙古的崛起，宋朝灭亡了，中国资本主义的萌芽被消灭掉了，蒙古打到地中海，其实也是间接地促使欧洲的文艺复兴（这一点暂不讨论）。中国最初的资本主义萌芽被消灭掉之后，后来再也没有恢复起来，之后明朝也没有达到宋朝当时的经济水平，中国也就慢慢沦落为二流国家。在现代，西方人经常说一句话，一个国家的中产阶级是这个国家最宝贵的财富。反看我们国家，在房价暴涨之前，随着经济的发展，中国的中产阶级人数是在慢慢扩大的，但是后来由于房价暴涨，带动了生活成本的迅速上升，我们国家的中产阶级被房价压得喘不过气，不知道是不是与一千年前的宋朝有些相似之处。本来看到的希望，突然又被现实击破。</p>
<p>当然，在历史的发展过程中，即使对于那些老牌发达国家来说，他们也是慢慢地一步一步走到现在的，而且也不能说他们现在的制度就是最好制度。尤其是近段欧洲的难民问题、美国当选的新总统特朗普感觉像是由于美国民粹主义被煽动而当选的。世界变化实在是太快，我们也不知道未来会怎样发展，我们国家是不是能走出中等收入国家陷进，尤其在出现：由于房价上涨导致制造业成本上涨，很多制造业开始外流，向东南亚发展这情况下，我们知道，制造业和服务业目前是最能解决就业的，我们国家如果在服务业还没有发展到一定程度时制造业就开始下滑，那么结果可想而知，有多少人会失业？这些问题应该怎么去解决，我现在其实是有一些悲观的，我并不知道出路在哪，感觉祖国任重道远。</p>
<hr>
<p>对书中一些小节的读后感</p>
<blockquote>
<p>认定自由、民主“只适合西方”的看法是一种变相的种族主义，而种族主义是一种过于懒惰的世界观。——自序：春天里</p>
</blockquote>
<p>近百年来，中华民族都在为了自由、民主而努力，虽然现在我们国家的经济、政治、法制相比与以前已经进步很多了，可依然跟马克思描述的社会主义有很大距离，甚至有些地方离西方发达国家也有很多的差距，而我们却总是各种借口去推卸责任。</p>
<blockquote>
<p>追求快乐的本性使每个人都成为潜在的革命者，而一个远离快乐的制度也许可以依靠信息控制维持很久，但在信息控制越来越不可能的世界，一条缝会渐渐变成一扇门。</p>
</blockquote>
<p>人性到底是善还是恶，不同的人、不同的宗教会有不同的理解，但是人追求幸福、快乐的本性是一样的，由此可见，有些人去追求财富、一些人选择移民，这都是在追求自己认为的那种快乐生活，有些人会感觉金钱会让自己有安全感、可以为自己的快乐提供基础，有些人认为移民到发达国家，享受更好的医疗制度、教育制度，会让自己更快乐。</p>
<blockquote>
<p>经济基础、社会结构和国际环境的变化已经为新的制度变迁创造基础，这种看法用学术语言来说叫“结构主义”</p>
</blockquote>
<p>说到经济，不得不让人想到邓小平，这里其他的不谈，小平提出的发展才是硬道理，对大陆确实带来了很大的贡献。经济的发展，首先会让人民生活条件提高，当大部分的人经济水平上去之后，人们才会有时间、有精力去思考、追逐自己的内心所求。一旦当有一些东西阻挡了大部分追求自己想要东西的时候，这些人都会成为一个潜在的革命者。</p>
<blockquote>
<p>我当然不相信制度的改革可以一夜之间改变文化，但是制度的变革至少可以打开一个公共生活的空间，而公民素养的培养首先需要一个公共空间，就象学会跑步需要首先解开脚镣。——素什么质</p>
</blockquote>
<p>罗马不是一天建成的，同样，欧美现在的政治、法制、精神等文明也不是突然就冒出来的，美国也曾经有过一段非常腐败的时期，美国也是这样一步步过来的。同样，中国要想崛起也需要时间，但中国崛起的前提是制度不能成为发展的绊脚石，改革需要深入、需要彻底、需要适应我们国家的发展。</p>
<blockquote>
<p>鉴定民意的真伪，标准不在于民众选择的那一刻是不是真诚，而在于他们在形成意见时讨论是否自由、观念可否多元、信息是否充分。——民意与伪民意</p>
</blockquote>
<p>如果人民一直被洗脑，没有独立思考精神，民主很多时候会成为被民粹主义利用的工具，这也是为什么一直说中产阶级是一个国家宝贵的财富的原因，当然这里中产阶级指的是有独立思考意识的中产阶级。</p>
<blockquote>
<p>制度也许可以一夜之间改写，但是企业家精神、商业头脑、市场意识，只有通过漫长的学习才能形成。——给理想一点时间</p>
</blockquote>
<p>再次证明了时间、过程的重要性，对于个人也是如此，没有人可以在一夜之间学会这学会那，只有持续不断的学习、不断地去积累才会达到自己想要的效果。</p>
<blockquote>
<p>一个人“看到”一个事物并不等于他能“看见”它，人们往往需要穿过重重意识形态才能看见自己所看到的东西。——不知道与宁可不知道</p>
</blockquote>
<p>看到不等于看见，对于大多数人，都会不自觉地选择性地过滤掉一些信息，因为不知道这些信息反而让他感觉到一切都很美好，而知道这些信息，会让他看到自己的无知。</p>
<blockquote>
<p>斯坦福大学心理学家津巴多曾经做过一个著名的“斯坦福监狱实验”。24名学生随机抽签，一半当“狱卒”，一半当“犯人”。结果在一周的角色扮演过程中，演狱卒的学生越来越残暴，演犯人的则越来越卑怯。短短一星期，哪怕是一个实验的环境，角色感就可以改造人性，这事想想真叫人不寒而栗：现实中，有多少人经年累月地藏身于各种制度化的角色中，而其人性又在角色不断内化的过程中被劫持到了哪一个星球？——恶之平庸</p>
</blockquote>
<p>环境对人的影响非常大，这个让我深有感触，就像这次香格里拉之行，以导游为例，他是一个藏族人，同时也是藏传佛教的信徒，按理说，应该是很虔诚的，待人应该以善为本，可是他入了导游这一行，这个行业有太多的潜规则，强制游客购物，甚至不惜用道德绑架、人身威胁来强迫购物，很明显这些东西他都会拿提成的，难道他不知道这是不对的吗？但是在那些藏民眼中，他却是带动当地经济发展的好人，这个导游还资助当地藏区的贫困学生，难道他是坏人吗？明显也不是，他甚至在家人、藏民眼中还是善良的佛教徒。那这是什么原因？我现在能想到的只能是环境因素，或许他会用这个行业就是这样、大家都这样来安慰自己，来减少或消除内心的不安。</p>
<blockquote>
<p>愤怒之所以令人上瘾，大约是因为愤怒是通向正义感的捷径。——迷人的愤怒</p>
</blockquote>
<p>愤怒并没有错，但是要理性愤怒，要独立思考，不能人云亦云。</p>
<blockquote>
<p>中国近当代知识分子里我最爱的还是胡适和顾准，因为在一个几千年陶醉于“意境美”的文化里，他俩一个讲实证精神，一个讲经验主义。——告别印象主义</p>
</blockquote>
<p>实证精神确实是中国人欠缺的一种精神，实事求是的口号我们也喊了几十年了，但是依然没有成为我们的民族精神，反而假大空依然横行，就比如学术这一领域，无论是教授还是学生都以这个东西能不能写成论文发表为目的，而不是这个东西能不能用或者能不能改进现有的一些技术环境。</p>
<blockquote>
<p>试图绕过程序正义，依靠“宣传”“维稳”来寻求民众合作，在一个民众理性能力和权利意识逐渐强大的时代，只会越来越捉襟见肘，甚至会陷入政府“怎么做都是错”的可悲境地。——怎样推销糖果</p>
</blockquote>
<p>依靠强权让别人去接受一些想法或事实的做法已经满足不了现在的实际情况，应该邀请对方一起商讨、共同做一个决定，包括对孩子的教育也是这样。</p>
<blockquote>
<p>在非黑即白之外还有很多思想的灰色地带，而这个地带往往最考验思想的精细，通过将他人的观点极端 化取消其意义，恰恰是公共讨论中的避重就轻。——标签战</p>
</blockquote>
<p>在与人争论中，应该用事实和逻辑分析说话，而不是简单的片面的理解，就给人贴一个标签。很多东西并不能简单地说对与错。</p>
<blockquote>
<p>除非你意识到中国不仅仅存在于都市的“五环”。在海水的深处，阳光未曾照耀之处，还有韩颖雷金模们，并且每一个已知的韩颖雷金模们，很可能还对应无数我们尚未知晓也无从知晓的韩颖雷金模们。在苍苍莽莽的雪地里，要保持对那个被遮蔽世界的知觉，你得不断提醒自己不要睡着不要睡着不要睡着。——没来的请举手</p>
</blockquote>
<p>作为国人，对这个问题比较痛心，这个社会中有太多无助的人，他们是为了大多数人利益而牺牲的少数人。尤其是近几年，房价的暴涨，导致大陆的贫富差距迅速扩大，贫富差距之大，令人咋舌，这实际上是对中下层人民财富的一次间接剥削，是一次很不公平的财富转移。</p>
<blockquote>
<p>社会跟政府讲道理，政府就跟社会耍流氓；社会跟政府耍流氓，政府就跟社会讲道理。——法治何以可能</p>
</blockquote>
<p>民主对于法制的维护着实重要，民主实际上就是对权利者权利的制衡，它可以在普通公民利益与权利者利息之间达到一个平衡。</p>
<blockquote>
<p>当然博爱的起点是自爱。自爱加上同理心，才成为博爱。——他也可以是我</p>
</blockquote>
<p>权利的重要与权力的可怕，大家都深有体会，把权力关进笼子，赋予公民应有的权利，这样这个社会才能健康的发展，这也是近百年来，国人一直的追求，虽然我们离这个理想还有很远的距离，但不能阻挡我们追求的脚步。</p>
<blockquote>
<p>西谚云：不要让“最好”成为“更好”的敌人。意思是80分不完美，60分也不完美，但不要因为80分不是100分而否认从60分进步到80分的意义。不过中谚却说：五十步怎么可以笑百步?要我说，五十步怎么不可以笑百步，九十九步都可以笑百步。人类文明的进步靠的就是点点滴滴的努力，大的进步值得大的肯定，小进步值得小肯定。——合同异</p>
</blockquote>
<p>一味的合同异就否认了变量之间的差异，也就否认了这些点滴的进步，而不急会不无以至千里，人类的进步就是靠着这些点滴实现的。</p>
<blockquote>
<p>纯洁固然美好，但是它对世界丰富性和复杂性的敌视，它天然的非黑即白世界观，本身就为专制提供了最好的精神土壤。——权力的道德捆绑</p>
</blockquote>
<p>这就好比人不能说是绝对的好与坏，而中国从古至今都是依靠人治，法制观念淡薄，依靠人治的最明显的就是民间对包青天和海瑞的推崇，人治对于国家来说是危险的，法制才是把权力关进笼子，这样公民的权利才有保障。</p>
<blockquote>
<p>我心中理想的社会变革应是一个“水涨船高”的过程：政治制度的变革源于公众政治观念的变化，而政治观念的变化又植根于人们生活观念的变化。——观念的水位</p>
</blockquote>
<p>社会观念确实在变化，尤其是当越来越多的中产阶级走出国门，看到欧美国家人民的生活时，公民的权利意识在觉醒，但是有一点要注意的是中国中产阶级毕竟是少数，中国还有基数很大的农民阶级，他们的经济条件和公民意识还需要慢慢提高，所以感觉这也是中国深度改革还需要一点火候的原因。</p>
<blockquote>
<p>英国的报销门事件得以解决，政府信息公开是一个关键因素，但是信息公开本身，又依赖媒体自由、政党角逐、权力制衡等机制。仅仅依靠领导人的“决心”，信息公开很可能流于形式，甚至成为政治作秀。一般来说，谁也不会搬起石头砸自己的脚，要想根治浪费公款，只有把“搬起石头”的权力交给别人。——倒霉的英国议员</p>
</blockquote>
<p>一个人既当裁判又当球员显然是不合理，这样只会导致很多政策流于形式。</p>
<blockquote>
<p>其实诚恳地反思过去，核心意义并不是“秋后算账”，而恰恰是在直面历史的基础上实现真正的和解与稳定。——过去的怎样让它过去</p>
</blockquote>
<p>人需要反思，需要思考，国家同样也一样，如果不反思，悲剧只会不断重演。</p>
<blockquote>
<p>政府作为公共服务机构，其不作为和胡作非为一样可怕。——沉默罪</p>
</blockquote>
<p>政府作为唯一的合法暴力机构，如果默认他人胡作非为跟自己胡作非为没什么区别。</p>
<blockquote>
<p>对具体清晰的逃避也就是对批评的封闭。——大家一起来算账</p>
</blockquote>
<p>讲述问题或辩论时应该实事求是，而不是一味地扣高帽子，说一些比较虚的事情，更多地应该讲述具体的实事，做人做事都该如此。</p>
<blockquote>
<p>俾斯麦说“政治是一种可能性的艺术”，那么我们能敲开人性中哪种可能性，说到底还是取决于我们在缔造什么样的政治。——敲开最好的可能</p>
</blockquote>
<p>人性都是一样，如果哪个国家人民的素质有高低，那也只是后天环境影响的。一个好的政治制度应该激发公民心中的善、保护公民心中的善。</p>
<blockquote>
<p>政府本质上不过是个公共服务机构，而不是什么高高在上的官府。——让政治变得家常</p>
</blockquote>
<p>一个国家的政治制度和政府性质，对于一个民族的影响很大，好的制度会估计民族向善的方向发展，不好的反之。</p>
<blockquote>
<p>在一定意义上，与其说浩浩荡荡的游行队伍体现了人们对经济危机的一团怒火，不如说体现了欧美高度发达公民社 会的组织资源。——绞死银行家</p>
</blockquote>
<p>公民有言论自由、有充分表达自己意愿的渠道，这种制度才会让一个国家更稳定、人民生活更幸福。</p>
<blockquote>
<p>在言论自由和政治平等之间，如何实现平衡？——民主的裤衩</p>
</blockquote>
<p>自由与平等是人类一直在追逐的东西，但两者在某些情况下也会有冲突，如何进行平衡，这种事情一般由最高法院来裁决，美国的司法充分保证了司法的裁决不受政治的影响，</p>
<blockquote>
<p>多元的观点带来充分的政策辩论，而充分的辩论不但给民众一个从不同角度理解这个法案的机会，也督促辩论两党给其主张提供坚实的论据基础。——吵吵更健康</p>
</blockquote>
<p>美帝的很多政策就是多方互相妥协的结果，美帝充斥各种利益集团，国家要想稳定要想发展，必须平衡各方利益，谈判妥协几乎可以说是美帝的基因所在。相反，我们民族，从古至今都是忍受，再忍受，直至没有活路，然后革命，接着再进入循环。我们民族一直都在想突破这个兴亡迭代的循环，能不能突破还要看我们这几代人的努力。</p>
<blockquote>
<p>分析各国改革速度和改革成效关系的话，反而发现改得快的未必发展慢，改得慢的发展未必快。结论很可能是，相比改革公正性、法治化、政策合理性，变革速度可能本来就不是个核心问题。——苏东巨变：20年之后</p>
</blockquote>
<p>这种感觉可以归结于具体的国情，估计作者又该说了应该拿出具体事实，而不是简单的国情了事，什么是国情，国情这种东西很模糊，天天说国情的人都不一定能搞明白啥是国情。我个人的理解是：政治、法制的改革如果能走在经济发展的前面，那么就能快速促进经济的发展，一旦落后于经济，就会抑制经济的发展。</p>
<blockquote>
<p>人类花了28年等待有形柏林墙的倒塌，无形柏林墙的消除，也许要更漫长地等待。——俄罗斯的徘徊</p>
</blockquote>
<p>自由、民主是需要时间、需要代价的。</p>
<blockquote>
<p>民主制度并不是选民投下一张选票然后翘起二郎腿等待政治家给我们端茶倒水的“懒人”体制，而需要民众对政治经年累月地“巡逻”促成点滴改良及至水滴石穿。——当“革命”成为家常便饭</p>
</blockquote>
<p>罗马不是一日建成的，一个自由、民主的社会也是如此。并不是说有了选举制度，就可以实现民主，俄罗斯可是不单单有选举制度，还是多党制，但我们并不认为俄罗斯是民主国家。自由、民主需要时间、需要代价，观念的上升才能更好地促使社会的变更。</p>
<blockquote>
<p>制度大于出身，这才是民主的要义。——“亚洲特色”的民主</p>
</blockquote>
<p>记得大陆官方当时发表声明嘲笑日本是政治世袭，国内当时可真是一片骂声，原因很清晰，日本还是世袭？那中国、朝鲜是什么？简直呵呵了。看一个社会、一个国家、一个民族，不去学习别人好的部分，老是揪住人家一些小污点不放，感觉很没有大国的胸襟。</p>
<blockquote>
<p>我认为，在经济政策上要允许试错，但藐视程序正义则是破坏现代政治的根基。——当民主缺失中产阶级</p>
</blockquote>
<p>最典型的例子就是美帝当面禁酒令，虽然执行禁酒令的时间只有13年，但确使美国经济倒退了不止20年，但是，这也丝毫没有成为阻挡美国后来崛起的绊脚石。美国现在的文明就是这样一点一点试错中成长的，什么东西都不是一蹴而就的。</p>
<blockquote>
<p>百万人涌现街头，其实并不突然。追求更多自由、更真实民主的暗流一直在伊朗“螺旋型”前进。——历史螺旋式终结</p>
</blockquote>
<p>自由民主可以说是这个世界的普世价值，每个国家和民族都在不余遗力地追求，正如前面所言，这并不是一触而就的，每个国家在走向这的过程都是曲折的，就像我们中华民族，虽然已经努力了一百多年，但与我们的理想还相差甚远。</p>
<blockquote>
<p>能够有制度性制衡来推动不同机构和利益集团之间的协商互动。一个只注重垂直呼应民意而忽视水平制衡的政府，也许合法性很高，但是合理性很低。——选举式独裁</p>
</blockquote>
<p>从美国的经验来看，权力之间的制衡以及利益集团间的相互妥协（在美国，各个协会组织或公会组织都是代表其协会成员的利息的利息集团）才是西方民主的真谛</p>
<blockquote>
<p>面对全球化，值得思考的不是它是否带来挑战，而是挑战与机遇是否对称。——我们在输出什么</p>
</blockquote>
<p>经济全球化确实带了很多问题，但是肯定是机遇与挑战并存的，问题当然很复杂，也不能一概而论。</p>
<blockquote>
<p>虽然美国收入差距在拉大，但社会仍具有相当的流动性。——有多少资本主义可以重来</p>
</blockquote>
<p>这也是美国价值观风靡全球的原因之一，一个相信个人奋斗的国家，是更容易吸引全球的人才，尤其是那些出身并不是很优秀的家庭。</p>
<blockquote>
<p>根据奥尔森集体行动的逻辑，当一个政策的受益或者受损对象比较集中，他们组织起来行动的可能性也更大。——从更人道的到更霸道的</p>
</blockquote>
<p>他们之间有明确的公共利息，不但利息明确，而且很少有分歧。</p>
<blockquote>
<p>量入为出本是最朴素的道理，但是将福利视为集体权利而不是个体责任的文化已使很多人失去了这种朴实。对于这些人来说，胖子的问题不是暴饮暴食，而是医生的减肥食谱。</p>
</blockquote>
<p>高额的福利必须会有高额的税收，福利不是从天上掉下来的，可惜的是我们国家欧洲的税收非洲的福利。</p>
<blockquote>
<p>一想到在那样无望的时代，曾国藩还奋发图强，对他的钦佩不禁如滔滔江水。转而又想到，即使是以他的奋发图强，也只能哀叹“天命”之不可违，却从未抬头观望天窗外的璀璨星空，又觉得个人面对历史，还真是胳膊拧不过大腿。——成圣又如何</p>
</blockquote>
<p>方向是错的，再努力又有何用？可是应该如何分辨自己的方向是否正确呢？曾国藩当时是没有这个条件去感受西方政治制度，自然也无法看到天窗外的星空。西方政治制度最大的特点就是不相信人性，他们用制度、用规则去管理，而不是人治、德治。</p>
<blockquote>
<p>这也是戈尔巴乔夫始料不及之处。他以为他可以放开管制同时强化专政，但多元社会和权力垄断不相容。他必须做出选择，是继续支撑这个空心帝国，还是捅破那层纸。最后他说，如果不是我们，是谁？如果不在此刻，又待何时？——那个搬起石头砸自己脚的人</p>
</blockquote>
<p>戈尔巴乔夫在来临的这个时刻做出了他应该做的决定，他选择戳破这个纸老虎，选择放弃专制，但历史并没有按照他预期的想象发展，现在俄罗斯也并不是自由民主的代表，改革的道路一片艰辛。</p>
<blockquote>
<p>摘下有色眼镜观察他国并不容易，因为我们脑子里充满了各种“想当然”。也许问题的关键并不在于我们怎么看待他国，而是怎么看待自己。——超越那些“想当然”</p>
</blockquote>
<p>在改革时，当然不能完全照抄某种经济改革，但也不能因为某些经济政策导致了一些不好后果，就把把它全盘否定。突然感觉我对这本书的一些见解好像都是在某些课上学到了，看来有些课有些书至少理论上还是很不错的，只是执行的过程中出了一些偏差。</p>
<blockquote>
<p>正是这种矛盾使其从一开始就不可能是一个逻辑上自洽的帝国：你不可能一边宣扬天赋人权，一边心安理得地铐住黑人送到加勒比海的甘蔗地。——当自由遭遇一丝微风</p>
<p>获得民众的信任并非一劳永逸之事。如果最高法院在其判决中背叛了美国宪法的最基本价值观，没有对这些价值观进行与时俱进的适应性诠释，或者在宪法所追求的不同价值观之间没有实现微妙的平衡，民众的信任和服从很可能随风而去。这大约是美国法官们工作的艰难之处：他们永远在如履薄冰，永远在风口浪尖。——法治的“秘密”</p>
</blockquote>
<p>美国法院的主要是目的就是维护宪法赋予公民的个人权利神圣不可侵犯，在历次判决中，都是以这个作为原则，这也是高等法院受公民信任的原因。</p>
<blockquote>
<p>从这个意义上来说，王彩玲这个角色比Howard更有意义：如果对个体意志的赞叹并不依赖于它是否引向“成功”，那么兰德分配给Howard的最后成功命运就是个多余的情节。不但多余，甚至是误导性的，它给人造成“功夫不负有心人”的错觉：不，功夫常常是会负有心人的；功夫负不负有心人本该没有那么重要的；“有心”的价值是不能用“负与不负”来衡量的。——你比你想象得更自由</p>
</blockquote>
<p>如果坚持初心，坚持个人的信念，成不成功又有什么不同，都只是外界的看法而已。</p>
<blockquote>
<p>犹豫不是为了逃避选择，但是它令选择之后的制度设计更加审慎和包容。——诸善之间</p>
</blockquote>
<p>当面临选择时，每一种选择都有其合理性，其实都是一种对哲学的思考，人类更多的时候是在多种选择中达成一种妥协。</p>
<blockquote>
<p>今天，权力的巩固仍然借助于对历史的改写与屏蔽。历史一层层被擦掉，或者被涂抹，失忆的人群也因此成为价值的木偶。——像一滴水一样</p>
</blockquote>
<p>正如驴得水中所说，过去的如果就让它过去，未来只会更糟。东亚民族自古以来都有改写历史的习惯，直到今天也是这样，花了那么多代价、交了那么多学费，就这样为了“政治正确”而被改写，我们可能又不得不重新去探索，这只会让未来变得更糟糕。</p>
<blockquote>
<p>所以我现在读书并不指望醍醐灌顶，更不觉得书架上会有什么“神明”，仅仅希望每一本书能推进一小点知识或者带来一个小启发。正如政治上不存在什么“救世主”，智识上也不存在什么“救世主”。真正的好书，都向证伪敞开，而不是给你一个一劳永逸的启示录让你枕着它睡大觉。振聋发聩的东西，我一向觉得可疑。——从经典到经验</p>
</blockquote>
<p>读书并不一定要去读那些深奥的经典之作，更多的应该根据自己的问题，这本书能给自己一些启发、带来一些思考、解决一些困惑，更能体现这本书的价值。</p>
<blockquote>
<p>真的，他们是怎么说服自己的？这事首先令人困惑，其次才令人沮丧。他们怎么能够在窃听骚扰跟踪袭击迫害诚实正直的人之后，一转身，对自己的孩子说：孩子，你要做一个好人。——没有你们就没有他们</p>
</blockquote>
<p>这种事情就像我们对一个幼女强奸犯说，你怎么能这样对待这个小姑娘，这个小姑娘也是别人的女儿，如果别人这样对待你的女儿你会怎么样？有时候我也搞不懂他们是怎么说服自己的，这个可能需要对人性进行更深层次的深挖。</p>
<blockquote>
<p>一切专制者都试图控制人的思想，但警察无法进驻人的大脑，于是只能控制思想的表达。语言因此必须被消毒、被驯化。一些词被妖魔化，另一些词被扎上蝴蝶结，一些词被灌入硫酸，另一些词则被喷上了香水。多年的教育之后，一提起“农民起义”，我就想起了“可歌可泣”，一说到“国民党”，就想起“三座大山”……成年以后我知道历史并非如此非黑即白，但这些被“加工”过的词汇在意识深处留下的情绪反射却经久不去。以条件反射代替思考，使每一个词语在展开其内容之前散发出某种“气味”，正是此类教育的成功之处。——语言的贫困</p>
</blockquote>
<p>这是多么的真实啊，记得小时候不知从何时开始，脑海里一出现欧美资本主义国家，就会想到万恶的资本主义、剥削压迫无产阶级，可是长大之后，我慢慢知道这个世界实际上很复杂，好与坏都是相伴而生的，而我们因为意识形态的问题边只看到某些国家好的地方或者坏的地方，又因为媒体是被完全限制的，所以我们接受的只是他们想让我们接受的，不过互联网确实是在慢慢打破这种限制，让我知道了做一个人是应该独立思考的，而不是等着别人去喂食，这也是我现在对外面的世界充满很大的好奇心，也是现在努力的原因，因为我想要自己去探索一些东西，而不是被强行灌输。作者后面这十几篇文章都是通过电影慢慢感受的，而自己在看电影时只是简单地看一下剧情，并没有深入思考，这也是我应该向作者学习的地方之一。</p>
<blockquote>
<p>影片最后，中年迈克问老年汉娜是否会想起那些犹太人，汉娜冷冷地答：“我怎么想无关紧要，反正死的人都死了。”“我以为你学到了更多的东西。”“我学到了，我学会了阅读。”汉娜学会了阅读，也仅仅是阅读而已。——爱是</p>
</blockquote>
<p>感觉已经超出了我理解范围，我也很难明白为什么人会这么复杂，有那么多面，即使这很多面实际上是有矛盾的。</p>
<blockquote>
<p>说到底，谁都终将被扔回时间的海底，在那里与其它鱼虾贝壳一同聆听无边寂静，而在这之前，我们能指望的，大约只是心灵成长，祈祷生的优雅可以抚慰它的渺小。——记得当年草上飞</p>
</blockquote>
<p>成长的道路各有不同，个人的环境、遭遇各有不同，最后每个人的最后每个人的结果当然也并不会按照自己所想的那样发展。但在命运的手上也有漏网之鱼，虽然并不多，但还是有的，这也是这个世界的美妙之处。</p>
<blockquote>
<p>抑与解放，但是刘天昭不。她写一个小女孩擦玻璃的神情，写帆布椅子上坐着的一个无所事事的老太太，写窗外三三两两的人群，写前任房客掉到床底下的储蓄本，写一只灰喜鹊在天空中划过的轨迹，写夜半大街的光线……总之她写一切貌似轻微、无关和混沌的时刻和人物。她简直是故意通过描写这些“无关紧要”的事物来暗暗颠覆这个世界的权力结构和等级秩序。谁说政治局委员的命运就比远亲里某个“破鞋”的命运更惊心动魄？又或者，凭什么一个“破鞋”的命运一定比窗前一只乌鸦起落的声音更值得书写？在被时间击败、被时间席卷、被时间吞噬方面，万物皆平等，因而都值得在颤抖中被文字拥抱。——诗的世界在每一个角落等待</p>
</blockquote>
<p>她那本书的厉害在于与别人切入点的不同吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前公司推送了一位大神的推荐书单，当中推荐了这本&lt;a href=&quot;https://book.douban.com/subject/20463108/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《观念的水位》&lt;/a&gt;，那是第一次看到这本书，记得当时看到这
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
