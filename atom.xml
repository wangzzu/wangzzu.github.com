<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matt&#39;s Blog</title>
  <subtitle>wangzzu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://matt33.com/"/>
  <updated>2017-11-11T03:04:33.000Z</updated>
  <id>http://matt33.com/</id>
  
  <author>
    <name>Matt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka 源码解析之 Consumer Poll 模型（七）</title>
    <link href="http://matt33.com/2017/11/11/consumer-pollonce/"/>
    <id>http://matt33.com/2017/11/11/consumer-pollonce/</id>
    <published>2017-11-11T03:04:45.000Z</published>
    <updated>2017-11-11T03:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇问文章中已经介绍一个 Consumer 实例如何加入到一个 group 中，它是 Consumer Poll 模型第一步要做的事件，本文会完整讲述一个 Consumer 实例在 poll 模型过程中会做哪些事情，只有理解了 poll 模型才能更好地理解 Consumer 端的处理逻辑。</p>
<h2 id="Consumer-示例"><a href="#Consumer-示例" class="headerlink" title="Consumer 示例"></a>Consumer 示例</h2><p>这里以一个 Consumer 的实例代码作为开始，一个比较常见的 Consumer 示例代码如下所示，其主要包含一下几个步骤：</p>
<ol>
<li>构造 Propertity，进行 consumer 相关的配置；</li>
<li>创建 KafkaConsumer 的对象 consumer；</li>
<li>订阅相应的 topic 列表；</li>
<li>调用 consumer 的 poll 方法拉取订阅的消息。</li>
</ol>
<p>前面两步在 Consumer 底层上只是创建了一个 consumer 对象，第三步只有记录一下订阅的 topic 信息，consumer 实际的操作都是第四步，也就是在 <code>poll</code> 方法中实现的，这也是 poll 模型对于理解 consumer 设计非常重要的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自动 commit 的情况</div><div class="line"> * Created by matt on 16/7/14.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAutoOffsetCommit</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String topic;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String group;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        topic=args[<span class="number">0</span>];</div><div class="line">        group=args[<span class="number">1</span>]; <span class="comment">// auto-offset-commit</span></div><div class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"XXX:9092,XXX:9092"</span>);</div><div class="line">        props.put(<span class="string">"group.id"</span>, group);</div><div class="line">        props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>); <span class="comment">// 自动commit</span></div><div class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>); <span class="comment">// 自动commit的间隔</span></div><div class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">        consumer.subscribe(Arrays.asList(topic)); <span class="comment">// 可消费多个topic,组成一个list</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">                System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Poll-模型综述"><a href="#Poll-模型综述" class="headerlink" title="Poll 模型综述"></a>Poll 模型综述</h2><p>当一个 consumer 对象创建之后，只有 poll 方法调用时，consumer 才会真正去连接 kafka 集群，进行相关的操作，其 poll 方法具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//timeout(ms): buffer 中的数据未就绪情况下，等待的最长时间，如果设置为0，立即返回 buffer 中已经就绪的数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</div><div class="line">    acquire();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Timeout must not be negative"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Consumer is not subscribed to any topics or assigned any partitions"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// poll for new data until the timeout expires</span></div><div class="line">        <span class="keyword">long</span> start = time.milliseconds();</div><div class="line">        <span class="keyword">long</span> remaining = timeout;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollOnce(remaining);</div><div class="line">            <span class="comment">//note: 从订阅的 partition 中拉取数据,pollOnce() 才是对 Consumer 客户端拉取数据的核心实现</span></div><div class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</div><div class="line">                <span class="comment">// 在返回数据之前，发送下次的 fetch 请求，避免用户在下次获取数据时线程 block</span></div><div class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.pendingRequestCount() &gt; <span class="number">0</span>)</div><div class="line">                    client.pollNoWakeup();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConsumerRecords&lt;&gt;(records);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> elapsed = time.milliseconds() - start;</div><div class="line">            remaining = timeout - elapsed;</div><div class="line">        &#125; <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        release();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>consumer <code>poll</code> 方法主要做了以下几件事情：</p>
<ol>
<li>检查这个 consumer 是否订阅的相应的 topic-partition；</li>
<li>调用 <code>pollOnce()</code> 方法获取相应的 records；</li>
<li>在返回获取的 records 前，发送下一次的 fetch 请求，避免用户在下次请求时线程 block 在 <code>pollOnce()</code> 方法中；</li>
<li>如果在给定的时间（timeout）内获取不到可用的 records，返回空数据。</li>
</ol>
<p>这里可以看出，poll 方法的真正实现是在 pollOnce 方法中，poll 方法通过 pollOnce 方法获取可用的数据。</p>
<h3 id="pollOnce-方法"><a href="#pollOnce-方法" class="headerlink" title="pollOnce 方法"></a>pollOnce 方法</h3><p>这里看下 pollOnce 方法主要做了哪些事情，其具体实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// note: 一次 poll 过程，除了获取新数据外，还会做一些必要的 offset-commit 核 reset-offset  的操作</span></div><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;</div><div class="line">    <span class="comment">// note： 1. 获取 GroupCoordinator 地址并连接、加入 Group、sync Group、自动 commit, join 及 sync 期间 group 会进行 rebalance</span></div><div class="line">    coordinator.poll(time.milliseconds());</div><div class="line">    <span class="comment">// note: 2. 更新订阅的 topic-partition 的 offset（如果订阅的 topic-partition list 没有有效的 offset 的情况下）</span></div><div class="line">    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())</div><div class="line">        updateFetchPositions(<span class="keyword">this</span>.subscriptions.missingFetchPositions());</div><div class="line"></div><div class="line">    <span class="comment">// note: 3. 获取 fetcher 已经拉取到的数据</span></div><div class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">    <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">        <span class="keyword">return</span> records;</div><div class="line">    <span class="comment">// note: 说明上次 fetch 到是的数据已经全部拉取了,需要再次发送 fetch 请求,从 broker 拉取数据</span></div><div class="line"></div><div class="line">    <span class="comment">// note: 4. 发送 fetch 请求,会从多个 topic-partition 拉取数据（只要对应的 topic-partition 没有未完成的请求）</span></div><div class="line">    fetcher.sendFetches();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> pollTimeout = Math.min(coordinator.timeToNextPoll(now), timeout);</div><div class="line"></div><div class="line">    <span class="comment">//note: 5. 调用 poll 方法发送请求（底层发送请求的接口）</span></div><div class="line">    client.poll(pollTimeout, now, <span class="keyword">new</span> PollCondition() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();<span class="comment">//note: 有完成的 fetcher 请求的话,这里就不会 block,但是 block 也是有最大时间限制</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//note: 6. 如果 group 需要 rebalance,直接返回空数据,这样更快地让 group 进行稳定状态</span></div><div class="line">    <span class="keyword">if</span> (coordinator.needRejoin())</div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pollOnce 可以简单分为6步来看，其作用分别如下：</p>
<ol>
<li><code>coordinator.poll()</code>：获取 GroupCoordinator 的地址，并建立相应 tcp 连接，发送 join-group、sync-group，之后才真正加入到了一个 group 中，这时会获取其要消费的 topic-partition 列表，如果设置了自动 commit，也会在这一步进行 commit，具体可见 <a href="http://matt33.com/2017/10/22/consumer-join-group/">Kafka 源码解析之 Consumer 如何加入一个 Group（六）</a>，总之，对于一个新建的 group，group 状态将会从 <strong>Empty –&gt; PreparingRebalance –&gt; AwaiSync –&gt; Stable</strong>；</li>
<li><code>updateFetchPositions()</code>： 在上一步中已经获取到了这个 consumer 实例要订阅的 topic-partition list，这一步更新其 fetch-position offset，以便进行拉取；</li>
<li><code>fetcher.sendFetches()</code>：返回其 fetched records，并更新其 fetch-position offset，只有在 offset-commit 时（自动 commit 时，是在第一步实现的），才会更新其 committed offset；</li>
<li><code>fetcher.sendFetches()</code>：只要订阅的 topic-partition list 没有未处理的 fetch 请求，就发送对这个 topic-partition 的 fetch 请求，在真正发送时，还是会按 node 级别去发送，leader 是同一个 node 的 topic-partition 会合成一个请求去发送；</li>
<li><code>client.poll()</code>：调用底层 NetworkClient 提供的接口去发送相应的请求；</li>
<li><code>coordinator.needRejoin()</code>：如果当前实例分配的 topic-partition 列表发送了变化，那么这个 consumer group 就需要进行 rebalance。</li>
</ol>
<h3 id="PollOnce-整体流程"><a href="#PollOnce-整体流程" class="headerlink" title="PollOnce 整体流程"></a>PollOnce 整体流程</h3><p>通过上面一节的介绍，pollOnce 方法做的事情现在已经有了一个比较清晰的认识，PollOnce 其详细流程图如下所示：</p>
<p><img src="/images/kafka/pollonce_only.png" alt="pollOnce 总体流程"></p>
<p>从上图可以看出，Consumer 在实现上，其调用还是比较复杂，不过复杂的地方都封装在底层了，Consumer 的网络模型如下图所示：</p>
<p><img src="/images/kafka/consumer-network.png" alt="Consumer 网络模型"></p>
<p>上面这张图，主要介绍了 KafkaConsumer 的封装模型。</p>
<h2 id="PollOnce-模型详解"><a href="#PollOnce-模型详解" class="headerlink" title="PollOnce 模型详解"></a>PollOnce 模型详解</h2><p>这一节详细讲述一下 PollOnce 模型的实现，主要讲述其前4步，最后的两步比较简单（跟之前也有重复），这里就不再细讲了。</p>
<h3 id="coordinator-poll"><a href="#coordinator-poll" class="headerlink" title="coordinator.poll()"></a><code>coordinator.poll()</code></h3><p>这部分的内容还是挺多的，其详细内部见：<a href="http://matt33.com/2017/10/22/consumer-join-group/">Kafka 源码解析之 Consumer 如何加入一个 Group（六）</a>，一个 consumer 实例在这一步实现的内容是：</p>
<ol>
<li>获取 GroupCoordinator 的地址，并建立相应 tcp 连接；</li>
<li>发送 join-group 请求，然后 group 将会进行 rebalance；</li>
<li>发送 sync-group 请求，之后才正在加入到了一个 group 中，这时会通过请求获取其要消费的 topic-partition 列表；</li>
<li>如果设置了自动 commit，也会在这一步进行 commit offset。</li>
</ol>
<p>通过前面的 pollOnce 流程图也能清楚地看到各个部分是在哪个方法中实现的。</p>
<h3 id="updateFetchPositions"><a href="#updateFetchPositions" class="headerlink" title="updateFetchPositions()"></a><code>updateFetchPositions()</code></h3><p>这个方法主要是用来更新这个 consumer 实例订阅的 topic-partition 列表的 fetch-offset 信息。</p>
<p>在 Fetcher 中，这个 consumer 实例订阅的每个 topic-partition 都会有一个对应的 TopicPartitionState 对象，在这个对象中会记录以下这些内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 记录 tp 的一些 offset 信息</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartitionState</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Long position; <span class="comment">// last consumed position</span></div><div class="line">    <span class="keyword">private</span> Long highWatermark; <span class="comment">// the high watermark from last fetch</span></div><div class="line">    <span class="keyword">private</span> OffsetAndMetadata committed;  <span class="comment">// last committed position</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> paused;  <span class="comment">// whether this partition has been paused by the user</span></div><div class="line">    <span class="keyword">private</span> OffsetResetStrategy resetStrategy;  <span class="comment">// the strategy to use if the offset needs resetting</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中需要关注的几个属性是：</p>
<ol>
<li>position：Fetcher 下次去拉取时的 offset，Fecher 在拉取时需要知道这个值；</li>
<li>committed：consumer 已经处理完的最新一条消息的 offset，consumer 主动调用 offset-commit 时会更新这个值；</li>
<li>resetStrategy：这 topic-partition offset 重置的策略，重置之后，这个策略就会改为 null，防止再次操作。</li>
</ol>
<p><code>updateFetchPositions()</code> 这个方法的目的就是为了获取其订阅的每个 topic-partition 对应的 position，这样 Fetcher 才知道从哪个 offset 开始去拉取这个 topic-partition 的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将 the fetch position 设置为 the committed position（如果有 committed offset 的话），否则就使用配置的重置策略去设置 offset</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFetchPositions</span><span class="params">(Set&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">    <span class="comment">//note: 先重置那些调用 seekToBegin 和 seekToEnd 的 offset 的 tp,设置其  the fetch position 的 offset</span></div><div class="line">    fetcher.resetOffsetsIfNeeded(partitions);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions(partitions)) &#123;</div><div class="line">        <span class="comment">//note: 获取所有分配 tp 的 offset, 即 committed offset, 更新到 TopicPartitionState 中的 committed offset 中</span></div><div class="line">        coordinator.refreshCommittedOffsetsIfNeeded();</div><div class="line"></div><div class="line">        <span class="comment">//note: 如果 the fetch position 值无效,则将上步获取的 committed offset 设置为 the fetch position</span></div><div class="line">        fetcher.updateFetchPositions(partitions);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述过程主要分为三步，可以结合前面的流程来看，这里就不再详细去介绍其下面几层调用的实现了：</p>
<ol>
<li><code>fetcher.resetOffsetsIfNeeded()</code>：处理那些 resetStrategy 不为 null 的 topic-partition（一般是使用了 <code>seekToBegin()</code> 和 <code>seekToEnd()</code> 方法的 topic-partition），Fetcher 会发送 list-offset 请求去获取相应的 offset，实际上在获取时，是根据时间戳（earliest：-2， latest：-1）去查找的相应的 offset，因为从 0.10.2 之后系统在保存 topic 数据时，会保存相应的 timestrap 信息；</li>
<li><code>coordinator.refreshCommittedOffsetsIfNeeded()</code>：发送 offset-fetch 请求获取其所订阅的所有 topic-partition 的 commited offset，如果这个 group 没有关于这个 topic-partition 的 offset 就会根据其默认的 <code>auto.offset.reset</code> 信息返回 -1或-2，并将获取到的信息更新到 committed offset 中；</li>
<li><code>fetcher.updateFetchPositions()</code>：如果 the fetch position 还没有有效值（第一步处理的那些 topic-partition 已经有了有效值），那么就将 the fetch position 设置为 committed offset。</li>
</ol>
<p>到这一步，这个 consumer 订阅的 topic-partition list 都有了相应的 the fetch position，Fetcher 在发送 fetch 请求就知道应该从哪个 offset 开始去拉取这个 topic-partition，自此，发送 fetch 请求前的准备都已经完成。</p>
<h3 id="fetcher-sendFetches"><a href="#fetcher-sendFetches" class="headerlink" title="fetcher.sendFetches()"></a><code>fetcher.sendFetches()</code></h3><p>这个虽然是 pollOnce 的第四步，但我们这里放在第三步来讲，只有在发送 fetch 请求后，才能调用 <code>fetcher.fetchedRecords()</code> 获取到其拉取的数据，所以这里先介绍这个方法，其具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 向订阅的所有 partition （只要该 leader 暂时没有拉取请求）所在 leader 发送 fetch 请求</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//note: 1 创建 Fetch Request</span></div><div class="line">    Map&lt;Node, FetchRequest.Builder&gt; fetchRequestMap = createFetchRequests();</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchRequest.Builder&gt; fetchEntry : fetchRequestMap.entrySet()) &#123;</div><div class="line">        <span class="keyword">final</span> FetchRequest.Builder request = fetchEntry.getValue();</div><div class="line">        <span class="keyword">final</span> Node fetchTarget = fetchEntry.getKey();</div><div class="line"></div><div class="line">        log.debug(<span class="string">"Sending fetch for partitions &#123;&#125; to broker &#123;&#125;"</span>, request.fetchData().keySet(), fetchTarget);</div><div class="line">        <span class="comment">//note: 2 发送 Fetch Request</span></div><div class="line">        client.send(fetchTarget, request)</div><div class="line">                .addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;</div><div class="line">                        FetchResponse response = (FetchResponse) resp.responseBody();</div><div class="line">                        <span class="keyword">if</span> (!matchesRequestedPartitions(request, response)) &#123;</div><div class="line">                            <span class="comment">// obviously we expect the broker to always send us valid responses, so this check</span></div><div class="line">                            <span class="comment">// is mainly for test cases where mock fetch responses must be manually crafted.</span></div><div class="line">                            log.warn(<span class="string">"Ignoring fetch response containing partitions &#123;&#125; since it does not match "</span> +</div><div class="line">                                    <span class="string">"the requested partitions &#123;&#125;"</span>, response.responseData().keySet(),</div><div class="line">                                    request.fetchData().keySet());</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</div><div class="line">                        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</div><div class="line"></div><div class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&gt; entry : response.responseData().entrySet()) &#123;</div><div class="line">                            TopicPartition partition = entry.getKey();</div><div class="line">                            <span class="keyword">long</span> fetchOffset = request.fetchData().get(partition).offset;</div><div class="line">                            FetchResponse.PartitionData fetchData = entry.getValue();</div><div class="line">                            completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, fetchOffset, fetchData, metricAggregator,</div><div class="line">                                    request.version()));<span class="comment">//note: 成功后加入 CompletedFetch</span></div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        sensors.fetchLatency.record(resp.requestLatencyMs());</div><div class="line">                        sensors.fetchThrottleTimeSensor.record(response.getThrottleTime());</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</div><div class="line">                        log.debug(<span class="string">"Fetch request to &#123;&#125; for partitions &#123;&#125; failed"</span>, fetchTarget, request.fetchData().keySet(), e);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fetchRequestMap.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在发送的 fetch 的过程中，总共分为以下两步：</p>
<ol>
<li><code>createFetchRequests()</code>：为订阅的所有 topic-partition list 创建 fetch 请求（只要该topic-partition 没有还在处理的请求），创建的 fetch 请求依然是按照 node 级别创建的；</li>
<li><code>client.send()</code>：发送 fetch 请求，并设置相应的 Listener，请求处理成功的话，就加入到 completedFetches 中，在加入这个 completedFetches 集合时，是按照 topic-partition 级别去加入，这样也就方便了后续的处理。</li>
</ol>
<p>从这里可以看出，在每次发送 fetch 请求时，都会向所有可发送的 topic-partition 发送 fetch 请求，调用一次 <code>fetcher.sendFetches</code>，拉取到的数据，可需要多次 pollOnce 循环才能处理完，因为 Fetcher 线程是在后台运行，这也保证了尽可能少地阻塞用户的处理线程，因为如果 Fetcher 中没有可处理的数据，用户的线程是会阻塞在 poll 方法中的。</p>
<h3 id="fetcher-fetchedRecords"><a href="#fetcher-fetchedRecords" class="headerlink" title="fetcher.fetchedRecords()"></a><code>fetcher.fetchedRecords()</code></h3><p>这个方法的作用就获取已经从 Server 拉取到的 Records，其源码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回获取到的 the fetched records， 并更新 the consumed position</span></div><div class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;</div><div class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; drained = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> recordsRemaining = maxPollRecords;<span class="comment">//<span class="doctag">NOTE:</span> 在 max.poll.records 中设置单词最大的拉取条数</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (nextInLineRecords == <span class="keyword">null</span> || nextInLineRecords.isDrained()) &#123; <span class="comment">//note: nextInLineRecords 为空时</span></div><div class="line">            CompletedFetch completedFetch = completedFetches.poll();<span class="comment">//note: 当一个 nextInLineRecords 处理完,就从 completedFetches 处理下一个完成的 Fetch 请求</span></div><div class="line">            <span class="keyword">if</span> (completedFetch == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            nextInLineRecords = parseCompletedFetch(completedFetch);<span class="comment">//note: 获取下一个要处理的 nextInLineRecords</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            TopicPartition partition = nextInLineRecords.partition;</div><div class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = drainRecords(nextInLineRecords, recordsRemaining);<span class="comment">//note:拉取records,更新 position</span></div><div class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;</div><div class="line">                List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = drained.get(partition);</div><div class="line">                <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123; <span class="comment">//note: 正常情况下,一个 node 只会发送一个 request,一般只会有一个</span></div><div class="line">                    drained.put(partition, records);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());</div><div class="line">                    newRecords.addAll(currentRecords);</div><div class="line">                    newRecords.addAll(records);</div><div class="line">                    drained.put(partition, newRecords);</div><div class="line">                &#125;</div><div class="line">                recordsRemaining -= records.size();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> drained;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; drainRecords(PartitionRecords&lt;K, V&gt; partitionRecords, <span class="keyword">int</span> maxRecords) &#123;</div><div class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(partitionRecords.partition)) &#123;</div><div class="line">        <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer's poll call</span></div><div class="line">        log.debug(<span class="string">"Not returning fetched records for partition &#123;&#125; since it is no longer assigned"</span>, partitionRecords.partition);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// note that the consumed position should always be available as long as the partition is still assigned</span></div><div class="line">        <span class="keyword">long</span> position = subscriptions.position(partitionRecords.partition);</div><div class="line">        <span class="keyword">if</span> (!subscriptions.isFetchable(partitionRecords.partition)) &#123;<span class="comment">//note: 这个 tp 不能来消费了,比如调用 pause</span></div><div class="line">            log.debug(<span class="string">"Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable"</span>, partitionRecords.partition);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitionRecords.fetchOffset == position) &#123;<span class="comment">//note: offset 对的上,也就是拉取是按顺序拉的</span></div><div class="line">            <span class="comment">//note: 获取该 tp 对应的records,并更新 partitionRecords 的 fetchOffset（用于判断是否顺序）</span></div><div class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = partitionRecords.drainRecords(maxRecords);</div><div class="line">            <span class="keyword">if</span> (!partRecords.isEmpty()) &#123;</div><div class="line">                <span class="keyword">long</span> nextOffset = partRecords.get(partRecords.size() - <span class="number">1</span>).offset() + <span class="number">1</span>;</div><div class="line">                log.trace(<span class="string">"Returning fetched records at offset &#123;&#125; for assigned partition &#123;&#125; and update "</span> +</div><div class="line">                        <span class="string">"position to &#123;&#125;"</span>, position, partitionRecords.partition, nextOffset);</div><div class="line"></div><div class="line">                subscriptions.position(partitionRecords.partition, nextOffset);<span class="comment">//note: 更新消费的到 offset（ the fetch position）</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//note: 获取 Lag（即 position与 hw 之间差值）,hw 为 null 时,才返回 null</span></div><div class="line">            Long partitionLag = subscriptions.partitionLag(partitionRecords.partition);</div><div class="line">            <span class="keyword">if</span> (partitionLag != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">this</span>.sensors.recordPartitionLag(partitionRecords.partition, partitionLag);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> partRecords;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// these records aren't next in line based on the last consumed position, ignore them</span></div><div class="line">            <span class="comment">// they must be from an obsolete request</span></div><div class="line">            log.debug(<span class="string">"Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;"</span>,</div><div class="line">                    partitionRecords.partition, partitionRecords.fetchOffset, position);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    partitionRecords.drain();</div><div class="line">    <span class="keyword">return</span> Collections.emptyList();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PartitionRecords 是 <code>parseCompletedFetch()</code> 处理后的类型，其成员变量如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionRecords</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fetchOffset;</div><div class="line">    <span class="keyword">private</span> TopicPartition partition;</div><div class="line">    <span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; records;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>consumer 的 Fetcher 处理从 server 获取的 fetch response 大致分为以下几个过程：</p>
<ol>
<li>通过 <code>completedFetches.poll()</code> 获取已经成功的 fetch response（在 <code>sendFetches()</code> 方法中会把成功的结果放在这个集合中，是拆分为 topic-partition 的粒度放进去的）；</li>
<li><code>parseCompletedFetch()</code> 处理上面获取的 completedFetch，构造成 PartitionRecords 类型；</li>
<li>通过 <code>drainRecords()</code> 方法处理 PartitionRecords 对象，在这个里面会去验证 fetchOffset 是否能对得上，只有 fetchOffset 是一致的情况下才会去处理相应的数据，并更新 the fetch offset 的信息，如果 fetchOffset 不一致，这里就不会处理，the fetch offset 就不会更新，下次 fetch 请求时是会接着 the fetch offset 的位置去请求相应的数据。</li>
<li>返回相应的 Records 数据。</li>
</ol>
<p>自此，consumer 的 poll 模型处理的逻辑就已经基本上讲完了，下篇博客会讲述下面三点内容：</p>
<ol>
<li>consumer 的两种订阅模型；</li>
<li>consumer 的同步 commit 和异步 commit；</li>
<li>consumer 提供的两种 <code>partition.assignment.strategy</code>。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇问文章中已经介绍一个 Consumer 实例如何加入到一个 group 中，它是 Consumer Poll 模型第一步要做的事件，本文会完整讲述一个 Consumer 实例在 poll 模型过程中会做哪些事情，只有理解了 poll 模型才能更好地理解 Consum
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码解析之 Consumer 如何加入一个 Group（六）</title>
    <link href="http://matt33.com/2017/10/22/consumer-join-group/"/>
    <id>http://matt33.com/2017/10/22/consumer-join-group/</id>
    <published>2017-10-22T13:19:23.000Z</published>
    <updated>2017-10-22T16:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一篇博客（2017-09-10），到现在已经过去一个多月了，理论上这篇文章在上个月就应该写完，无奈拖延症又犯了，一直以这部分过于复杂为借口拖了好久，这两天逼了自己一把，先整理出其中的一篇，后续要加把劲，要不然今年的年度计划（年底前把这个系列写完）就完不成了，废话到此为止，下面步入正文。在 Kafka 中，Consumer 的复杂度要比 producer 高出很多，对于 Producer 而言，没有 producer 组的概念的、也不需要 care offset 等问题，而 Consumer 就不一样了，它需要关注的内容很多，需要考虑分布式消费（Consumer Group），为了防止重复消费或者部分数据未消费需要考虑 offset，这些都对 Consumer 的设计以及 Server 对其处理提出了很高的要求。本来计划是先进行综述，然后再分别介绍各个模块，现在打算反过来，先介绍各个模块，最后再进行综述，本篇为 Consumer 源码分析开篇，先从一个 Consumer 实例如何加入一个 Consumer Group 讲起。</p>
<p>这里的分析是以 0.10.2 为准，在 0.10.2 版的 KafkaConsumer 中，相比于老版的 KafkaConsumer（0.9以前的），新版从0.9开始做了很大改进，总结起来，其优势有以下两点：</p>
<ul>
<li>实现了 High Level 与 Simple Level Consumer API 的统一，极大地简化了实现的复杂度；</li>
<li>增加了 GroupCoordinator 角色，它作用是：<code>GroupCoordinator handles general group membership and offset management</code>；</li>
</ul>
<p>接下来会按照下面这个流程来讲述：</p>
<ol>
<li>GroupCoordinator 简单介绍；</li>
<li>Consumer poll 模型：join-group 是 poll 模型的第一步，其他部分后续再讲；</li>
<li>Consumer join-group 的详细过程以及在这个过程中 group 状态的变化。</li>
</ol>
<h2 id="GroupCoordinator-简介"><a href="#GroupCoordinator-简介" class="headerlink" title="GroupCoordinator 简介"></a>GroupCoordinator 简介</h2><p>这里先简单介绍一下 GroupCoordinator 这个角色，后续有一篇文章进行专门讲述，GroupCoordinator 是运行在 Kafka Broker 上的一个服务，每台 Broker 在运行时都会启动一个这样的服务，但一个 consumer 具体与哪个 Broker 上这个服务交互，就需要先介绍一下 <code>__consumer_offsets</code> 这个 topic。</p>
<h3 id="consumer-offsets-topic"><a href="#consumer-offsets-topic" class="headerlink" title="__consumer_offsets topic"></a><code>__consumer_offsets</code> topic</h3><p><code>__consumer_offsets</code> 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有50个 partition，每个 partition 三副本，如下图所示（只列出了30 个 partition）：</p>
<p><img src="/images/kafka/consumer_offsets.png" alt="__consumer_offsets topic"></p>
<h3 id="GroupCoordinator"><a href="#GroupCoordinator" class="headerlink" title="GroupCoordinator"></a>GroupCoordinator</h3><p>GroupCoordinator 是负责 consumer group member 管理以及 offset 管理。</p>
<p>每个 Consumer Group 都有其对应的 GroupCoordinator，但具体是由哪个 GroupCoordinator 负责与 group.id 的 hash 值有关，通过这个 <strong>abs(GroupId.hashCode()) % NumPartitions</strong> 来计算出一个值（其中，NumPartitions 是 <code>__consumer_offsets</code> 的 partition 数，默认是50个），这个值代表了 <code>__consumer_offsets</code> 的一个 partition，而这个 partition 的 leader 即为这个 Group 要交互的 GroupCoordinator 所在的节点。</p>
<h2 id="Consumer-poll-模型"><a href="#Consumer-poll-模型" class="headerlink" title="Consumer poll 模型"></a>Consumer poll 模型</h2><p>Consumer poll 方法的真正实现是在 <code>pollOnce()</code> 方法中，这里直接看下其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Do one round of polling. In addition to checking for new data, this does any needed offset commits</div><div class="line"> * (if auto-commit is enabled), and offset resets (if an offset reset policy is defined).</div><div class="line"> * <span class="doctag">@param</span> timeout The maximum time to block in the underlying call to &#123;<span class="doctag">@link</span> ConsumerNetworkClient#poll(long)&#125;.</div><div class="line"> * <span class="doctag">@return</span> The fetched records (may be empty)</div><div class="line"> */</div><div class="line"><span class="comment">// note: 一次 poll 过程,包括检查新的数据、做一些必要的 commit 以及 offset  重置操作</span></div><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;</div><div class="line">    <span class="comment">// note： 1. 获取 GroupCoordinator 并连接、加入 Group、sync Group, 期间 group 会进行 rebalance 并获取</span></div><div class="line">    coordinator.poll(time.milliseconds());</div><div class="line">    <span class="comment">// assignment</span></div><div class="line"></div><div class="line">    <span class="comment">// fetch positions if we have partitions we're subscribed to that we</span></div><div class="line">    <span class="comment">// don't know the offset for</span></div><div class="line">    <span class="comment">// note: 2. 更新要拉取 partition 的 offset（如果需要更新的话）</span></div><div class="line">    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())</div><div class="line">        updateFetchPositions(<span class="keyword">this</span>.subscriptions.missingFetchPositions());</div><div class="line"></div><div class="line">    <span class="comment">// if data is available already, return it immediately</span></div><div class="line">    <span class="comment">// note: 3. 获取 fetcher 已经拉取到的数据</span></div><div class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">    <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">        <span class="keyword">return</span> records;</div><div class="line">    <span class="comment">// note: 说明上次 fetch 到是的数据已经全部拉取了,需要再次发送 fetch 请求,从 broker 拉取数据</span></div><div class="line"></div><div class="line">    <span class="comment">// send any new fetches (won't resend pending fetches)</span></div><div class="line">    <span class="comment">// note: 4. 向订阅的所有 partition 发送 fetch 请求,会从多个 partition 拉取数据</span></div><div class="line">    fetcher.sendFetches();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> pollTimeout = Math.min(coordinator.timeToNextPoll(now), timeout);</div><div class="line"></div><div class="line">    <span class="comment">//note: 5. 调用 poll 方法发送数据</span></div><div class="line">    client.poll(pollTimeout, now, <span class="keyword">new</span> PollCondition() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></div><div class="line">            <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></div><div class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// after the long poll, we should check whether the group needs to rebalance</span></div><div class="line">    <span class="comment">// prior to returning data so that the group can stabilize faster</span></div><div class="line">    <span class="comment">//note: 6. 如果 group 需要 rebalance, 直接返回空数据,这样更快地让 group 进行稳定状态</span></div><div class="line">    <span class="keyword">if</span> (coordinator.needRejoin())</div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们把一个 pollOnce 模型分为6个部分，这里简单介绍一下：</p>
<ol>
<li>连接 GroupCoordinator，并发送 join-group、sync-group 请求，加入 group 成功，并获取其分配的 tp 列表；</li>
<li>更新这些分配的 tp 列表的 the last committed offset（没有的话，根据其设置进行获取 offset）；</li>
<li>调用 Fetcher 获取拉取的数据，如果有数据，立马返回，没有的话就进行下面的操作；</li>
<li>调用 Fetcher 发送 fetch 请求（只是加入队列，并未真正发送）；</li>
<li>调用 poll() 方法发送请求；</li>
<li>如果 group 之前是需要 rebalacne 的，直接返回空集合，这样可以便于 group 尽快达到一个稳定的状态。</li>
</ol>
<p>一个 Consumer 实例消费数据的前提是能够加入一个 group 成功，并获取其要订阅的 tp（topic-partition）列表，这都是在第一步中完成的，如果这个 group 是一个新的 group，那么 group 的状态将会由 <strong>Empty –&gt; PreparingRebalance –&gt; AwaitSync –&gt; Stable</strong> 的变化过程，下面将会详细介绍。</p>
<h2 id="Consumer-join-group-详解"><a href="#Consumer-join-group-详解" class="headerlink" title="Consumer join-group 详解"></a>Consumer join-group 详解</h2><p>通过上面，我们知道，poll 模型的第一步是在 <code>ConsumerCoordinator.poll()</code> 中实现的，其整体过程如下所示。</p>
<p><img src="/images/kafka/join-group.png" alt="Consumer 加入一个 group 的整体流程"></p>
<blockquote>
<p>其实，主要观察图中左边的部分即可，也就是 ConsumerCoordinator 和 AbstractCoordinator 中的方法。</p>
</blockquote>
<p>对于一个 Consumer Group，其状态变化图下图所示（后面会讲到）。</p>
<p><img src="/images/kafka/group.png" alt="Group 状态变化图"></p>
<h3 id="ConsumerCoordinator-poll"><a href="#ConsumerCoordinator-poll" class="headerlink" title="ConsumerCoordinator.poll()"></a><code>ConsumerCoordinator.poll()</code></h3><p>先看一下 <code>ConsumerCoordinator.poll()</code> 的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// note: 它确保了这个 group 的 coordinator 是已知的,并且这个 consumer 是已经加入到了 group 中,也用于 offset 周期性的 commit</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    invokeCompletedOffsetCommitCallbacks();<span class="comment">// note: 用于测试</span></div><div class="line"></div><div class="line">    <span class="comment">// note: Step1 通过 subscribe() 方法订阅 topic,并且 coordinator 未知,初始化 Consumer Coordinator</span></div><div class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned() &amp;&amp; coordinatorUnknown()) &#123;</div><div class="line">        <span class="comment">// note: 获取 GroupCoordinator 地址,并且建立连接</span></div><div class="line">        ensureCoordinatorReady();</div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// note: Step2 判断是否需要重新加入 group,如果订阅的 partition 变化或则分配的 partition 变化时,需要 rejoin</span></div><div class="line">    <span class="keyword">if</span> (needRejoin()) &#123;</div><div class="line">        <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></div><div class="line">        <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></div><div class="line">        <span class="comment">// that we have matched the pattern against the cluster's topics at least once before joining.</span></div><div class="line">        <span class="comment">// note: rejoin group 之前先刷新一下 metadata（对于 AUTO_PATTERN 而言）</span></div><div class="line">        <span class="keyword">if</span> (subscriptions.hasPatternSubscription())</div><div class="line">            client.ensureFreshMetadata();</div><div class="line"></div><div class="line">        <span class="comment">// note: 确保 group 是 active; 加入 group; 分配订阅的 partition</span></div><div class="line">        ensureActiveGroup();</div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// note: Step3 检查心跳线程运行是否正常,如果心跳线程失败,则抛出异常,反之更新 poll 调用的时间</span></div><div class="line">    pollHeartbeat(now);</div><div class="line">    <span class="comment">// note: Step4 自动 commit 时,当定时达到时,进行自动 commit</span></div><div class="line">    maybeAutoCommitOffsetsAsync(now);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 poll 方法中，具体实现，可以分为以下三步：</p>
<ol>
<li>通过 <code>subscribe()</code> 方法订阅 topic, 并且 coordinator 未知，就初始化 Consumer Coordinator（在 <code>ensureCoordinatorReady()</code> 中实现，主要的作用是发送 GroupCoordinator 请求，并建立连接）；</li>
<li>判断是否需要重新加入 group，如果订阅的 partition 变化或则分配的 partition 变化时，需要 rejoin，通过 <code>ensureActiveGroup()</code> 发送 join-group、sync-group 请求，加入 group 并获取其 assign 的 tp list；</li>
<li>检测心跳线程运行是否正常（需要定时向 GroupCoordinator 发送心跳线程，长时间未发送的话 group就会认为该实例已经挂了）；</li>
<li>如果设置的是自动 commit，如果定时达到自动 commit。</li>
</ol>
<p>这其中，有两个地方需要详细介绍，那就是第一步中的 <code>ensureCoordinatorReady()</code> 方法和第二步中的 <code>ensureActiveGroup()</code> 方法。</p>
<h3 id="ensureCoordinatorReady"><a href="#ensureCoordinatorReady" class="headerlink" title="ensureCoordinatorReady()"></a><code>ensureCoordinatorReady()</code></h3><p>这个方法的作用是：选择一个连接数最小的 broker，向其发送 GroupCoordinator 请求，并建立相应的 TCP 连接。</p>
<ul>
<li>其方法的调用如前面的流程图所示：ensureCoordinatorReady() –&gt; lookupCoordinator() –&gt; sendGroupCoordinatorRequest()。</li>
<li>如果 client 获取到 Server response，那么就会与 GroupCoordinator 建立连接；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// note: 确保 coordinator 已经 ready（已经连接,并可以发送请求）</span></div><div class="line"><span class="comment">// note: 如果 coordinator 已经 ready 返回 true,否则返回 flase。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">long</span> startTimeMs, <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> remainingMs = timeoutMs;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (coordinatorUnknown()) &#123;</div><div class="line">        <span class="comment">// note:  获取 GroupCoordinator,并建立连接</span></div><div class="line">        RequestFuture&lt;Void&gt; future = lookupCoordinator();</div><div class="line">        client.poll(future, remainingMs);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (future.failed()) &#123;<span class="comment">// note: 如果获取的过程中失败了</span></div><div class="line">            <span class="keyword">if</span> (future.isRetriable()) &#123;</div><div class="line">                remainingMs = timeoutMs - (time.milliseconds() - startTimeMs);</div><div class="line">                <span class="keyword">if</span> (remainingMs &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                log.debug(<span class="string">"Coordinator discovery failed for group &#123;&#125;, refreshing metadata"</span>, groupId);</div><div class="line">                client.awaitMetadataUpdate(remainingMs);</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                <span class="keyword">throw</span> future.exception();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; client.connectionFailed(coordinator)) &#123;</div><div class="line">            <span class="comment">// we found the coordinator, but the connection has failed, so mark</span></div><div class="line">            <span class="comment">// it dead and backoff before retrying discovery</span></div><div class="line">            coordinatorDead();</div><div class="line">            time.sleep(retryBackoffMs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        remainingMs = timeoutMs - (time.milliseconds() - startTimeMs);</div><div class="line">        <span class="keyword">if</span> (remainingMs &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> !coordinatorUnknown();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// note: 选择一个连接最小的节点,发送 groupCoordinator 请求</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// find a node to ask about the coordinator</span></div><div class="line">        Node node = <span class="keyword">this</span>.client.leastLoadedNode();<span class="comment">//<span class="doctag">NOTE:</span> 找一个节点,发送 groupCoordinator 的请求</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> If there are no brokers left, perhaps we should use the bootstrap set</span></div><div class="line">            <span class="comment">// from configuration?</span></div><div class="line">            log.debug(<span class="string">"No broker available to send GroupCoordinator request for group &#123;&#125;"</span>, groupId);</div><div class="line">            <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            findCoordinatorFuture = sendGroupCoordinatorRequest(node);<span class="comment">//<span class="doctag">NOTE:</span> 发送请求，并对 response 进行处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> findCoordinatorFuture;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 发送 GroupCoordinator 的请求</span></div><div class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;Void&gt; <span class="title">sendGroupCoordinatorRequest</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">// initiate the group metadata request</span></div><div class="line">    log.debug(<span class="string">"Sending GroupCoordinator request for group &#123;&#125; to broker &#123;&#125;"</span>, groupId, node);</div><div class="line">    GroupCoordinatorRequest.Builder requestBuilder =</div><div class="line">            <span class="keyword">new</span> GroupCoordinatorRequest.Builder(<span class="keyword">this</span>.groupId);</div><div class="line">    <span class="keyword">return</span> client.send(node, requestBuilder)</div><div class="line">                 .compose(<span class="keyword">new</span> GroupCoordinatorResponseHandler());</div><div class="line">    <span class="comment">//<span class="doctag">NOTE:</span> compose 的作用是将 GroupCoordinatorResponseHandler 类转换为 RequestFuture</span></div><div class="line">    <span class="comment">//<span class="doctag">NOTE:</span> 实际上就是为返回的 Future 类重置 onSuccess() 和 onFailure() 方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 对 GroupCoordinator 的 response 进行处理,回调</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCoordinatorResponseHandler</span> <span class="keyword">extends</span> <span class="title">RequestFutureAdapter</span>&lt;<span class="title">ClientResponse</span>, <span class="title">Void</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</div><div class="line">        log.debug(<span class="string">"Received GroupCoordinator response &#123;&#125; for group &#123;&#125;"</span>, resp, groupId);</div><div class="line"></div><div class="line">        GroupCoordinatorResponse groupCoordinatorResponse = (GroupCoordinatorResponse) resp.responseBody();</div><div class="line">        <span class="comment">// use MAX_VALUE - node.id as the coordinator id to mimic separate connections</span></div><div class="line">        <span class="comment">// for the coordinator in the underlying network client layer</span></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> this needs to be better handled in KAFKA-1935</span></div><div class="line">        Errors error = Errors.forCode(groupCoordinatorResponse.errorCode());</div><div class="line">        clearFindCoordinatorFuture();</div><div class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</div><div class="line">            <span class="comment">// note: 如果正确获取 GroupCoordinator 时, 建立连接,并更新心跳时间</span></div><div class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</div><div class="line">                AbstractCoordinator.<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> Node(</div><div class="line">                        Integer.MAX_VALUE - groupCoordinatorResponse.node().id(),</div><div class="line">                        groupCoordinatorResponse.node().host(),</div><div class="line">                        groupCoordinatorResponse.node().port());</div><div class="line">                log.info(<span class="string">"Discovered coordinator &#123;&#125; for group &#123;&#125;."</span>, coordinator, groupId);</div><div class="line">                client.tryConnect(coordinator);<span class="comment">//note: 初始化 tcp 连接</span></div><div class="line">                heartbeat.resetTimeouts(time.milliseconds());<span class="comment">//note: 更新心跳时间</span></div><div class="line">            &#125;</div><div class="line">            future.complete(<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</div><div class="line">            future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.debug(<span class="string">"Group coordinator lookup for group &#123;&#125; failed: &#123;&#125;"</span>, groupId, error.message());</div><div class="line">            future.raise(error);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</div><div class="line">        clearFindCoordinatorFuture();</div><div class="line">        <span class="keyword">super</span>.onFailure(e, future);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ensureActiveGroup"><a href="#ensureActiveGroup" class="headerlink" title="ensureActiveGroup()"></a><code>ensureActiveGroup()</code></h3><p>这个方法的作用是：向 GroupCoordinator 发送 join-group、sync-group 请求，获取 assign 的 tp list。</p>
<ul>
<li>如前面图中所示，ensureActiveGroup 方法的调用过程：ensureActiveGroup() –&gt; ensureCoordinatorReady() –&gt; startHeartbeatThreadIfNeeded() –&gt; joinGroupIfNeeded()；</li>
<li><code>joinGroupIfNeeded()</code> 方法中最重要的方法是 <code>initiateJoinGroup()</code>，其方法的调用过程为：initiateJoinGroup() –&gt; sendJoinGroupRequest() –&gt; JoinGroupResponseHandler.handle().succeed –&gt; onJoinLeader()/onJoinFollower() –&gt; sendSyncGroupRequest() –&gt; SyncGroupResponseHandler。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 确保 Group 是 active,并且加入该 group</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureActiveGroup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// always ensure that the coordinator is ready because we may have been disconnected</span></div><div class="line">    <span class="comment">// when sending heartbeats and does not necessarily require us to rejoin the group.</span></div><div class="line">    ensureCoordinatorReady();<span class="comment">//<span class="doctag">NOTE:</span> 确保 GroupCoordinator 已经连接</span></div><div class="line">    startHeartbeatThreadIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 启动心跳发送线程（并不一定发送心跳,满足条件后才会发送心跳）</span></div><div class="line">    joinGroupIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 请求,并对返回的信息进行处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>join-group 的请求是在 <code>joinGroupIfNeeded()</code> 中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// note: join group</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joinGroupIfNeeded</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (needRejoin() || rejoinIncomplete()) &#123;</div><div class="line">        ensureCoordinatorReady();</div><div class="line">        <span class="comment">// call onJoinPrepare if needed. We set a flag to make sure that we do not call it a second</span></div><div class="line">        <span class="comment">// time if the client is woken up before a pending rebalance completes. This must be called</span></div><div class="line">        <span class="comment">// on each iteration of the loop because an event requiring a rebalance (such as a metadata</span></div><div class="line">        <span class="comment">// refresh which changes the matched subscription set) can occur while another rebalance is</span></div><div class="line">        <span class="comment">// still in progress.</span></div><div class="line">        <span class="comment">//note: 触发 onJoinPrepare, 包括 offset commit 和 rebalance listener</span></div><div class="line">        <span class="keyword">if</span> (needsJoinPrepare) &#123;</div><div class="line">            onJoinPrepare(generation.generationId, generation.memberId);</div><div class="line">            needsJoinPrepare = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// note: 初始化 JoinGroup 请求,并发送该请求</span></div><div class="line">        RequestFuture&lt;ByteBuffer&gt; future = initiateJoinGroup();</div><div class="line">        client.poll(future);</div><div class="line">        resetJoinGroupFuture();<span class="comment">//<span class="doctag">NOTE:</span> 重置 joinFuture 为空</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (future.succeeded()) &#123;<span class="comment">//note: join succeed,这一步时,时间上 sync-group 已经成功了</span></div><div class="line">            needsJoinPrepare = <span class="keyword">true</span>;</div><div class="line">            onJoinComplete(generation.generationId, generation.memberId, generation.protocol, future.value());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            RuntimeException exception = future.exception();</div><div class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UnknownMemberIdException ||</div><div class="line">                    exception <span class="keyword">instanceof</span> RebalanceInProgressException ||</div><div class="line">                    exception <span class="keyword">instanceof</span> IllegalGenerationException)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!future.isRetriable())</div><div class="line">                <span class="keyword">throw</span> exception;</div><div class="line">            time.sleep(retryBackoffMs);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sendJoinGroupRequest()</code> 方法是由 <code>initiateJoinGroup()</code> 方法来调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 的请求, 并添加 listener</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">initiateJoinGroup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// we store the join future in case we are woken up by the user after beginning the</span></div><div class="line">    <span class="comment">// rebalance in the call to poll below. This ensures that we do not mistakenly attempt</span></div><div class="line">    <span class="comment">// to rejoin before the pending rebalance has completed.</span></div><div class="line">    <span class="keyword">if</span> (joinFuture == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// fence off the heartbeat thread explicitly so that it cannot interfere with the join group.</span></div><div class="line">        <span class="comment">// Note that this must come after the call to onJoinPrepare since we must be able to continue</span></div><div class="line">        <span class="comment">// sending heartbeats if that callback takes some time.</span></div><div class="line">        <span class="comment">// note: rebalance 期间,心跳线程停止</span></div><div class="line">        disableHeartbeatThread();</div><div class="line"></div><div class="line">        state = MemberState.REBALANCING;<span class="comment">//<span class="doctag">NOTE:</span> 标记为 rebalance</span></div><div class="line">        joinFuture = sendJoinGroupRequest();<span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 请求</span></div><div class="line">        joinFuture.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ByteBuffer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ByteBuffer value)</span> </span>&#123;</div><div class="line">                <span class="comment">// handle join completion in the callback so that the callback will be invoked</span></div><div class="line">                <span class="comment">// even if the consumer is woken up before finishing the rebalance</span></div><div class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</div><div class="line">                    log.info(<span class="string">"Successfully joined group &#123;&#125; with generation &#123;&#125;"</span>, groupId, generation.generationId);</div><div class="line">                    state = MemberState.STABLE;<span class="comment">//<span class="doctag">NOTE:</span> 标记 Consumer 为 stable</span></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (heartbeatThread != <span class="keyword">null</span>)</div><div class="line">                        heartbeatThread.enable();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</div><div class="line">                <span class="comment">// we handle failures below after the request finishes. if the join completes</span></div><div class="line">                <span class="comment">// after having been woken up, the exception is ignored and we will rejoin</span></div><div class="line">                <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</div><div class="line">                    state = MemberState.UNJOINED;<span class="comment">//<span class="doctag">NOTE:</span> 标记 Consumer 为 Unjoined</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> joinFuture;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sendJoinGroupRequest() 及其处理如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Join the group and return the assignment for the next generation. This function handles both</div><div class="line"> * JoinGroup and SyncGroup, delegating to &#123;<span class="doctag">@link</span> #performAssignment(String, String, Map)&#125; if</div><div class="line"> * elected leader by the coordinator.</div><div class="line"> * <span class="doctag">@return</span> A request future which wraps the assignment returned from the group leader</div><div class="line"> */</div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 请求并返回 the assignment for the next generation（这个是在 JoinGroupResponseHandler 中做的）</span></div><div class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">sendJoinGroupRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (coordinatorUnknown())</div><div class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</div><div class="line"></div><div class="line">    <span class="comment">// send a join group request to the coordinator</span></div><div class="line">    log.info(<span class="string">"(Re-)joining group &#123;&#125;"</span>, groupId);</div><div class="line">    JoinGroupRequest.Builder requestBuilder = <span class="keyword">new</span> JoinGroupRequest.Builder(</div><div class="line">            groupId,</div><div class="line">            <span class="keyword">this</span>.sessionTimeoutMs,</div><div class="line">            <span class="keyword">this</span>.generation.memberId,</div><div class="line">            protocolType(),</div><div class="line">            metadata()).setRebalanceTimeout(<span class="keyword">this</span>.rebalanceTimeoutMs);</div><div class="line"></div><div class="line">    log.debug(<span class="string">"Sending JoinGroup (&#123;&#125;) to coordinator &#123;&#125;"</span>, requestBuilder, <span class="keyword">this</span>.coordinator);</div><div class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder)</div><div class="line">            .compose(<span class="keyword">new</span> JoinGroupResponseHandler());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 处理 JoinGroup response 的 handler（同步 group 信息）</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">JoinGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(JoinGroupResponse joinResponse, RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</div><div class="line">        Errors error = Errors.forCode(joinResponse.errorCode());</div><div class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;</div><div class="line">            log.debug(<span class="string">"Received successful JoinGroup response for group &#123;&#125;: &#123;&#125;"</span>, groupId, joinResponse);</div><div class="line">            sensors.joinLatency.record(response.requestLatencyMs());</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (state != MemberState.REBALANCING) &#123;<span class="comment">//<span class="doctag">NOTE:</span> 如果此时 Consumer 的状态不是 rebalacing,就引起异常</span></div><div class="line">                    <span class="comment">// if the consumer was woken up before a rebalance completes, we may have already left</span></div><div class="line">                    <span class="comment">// the group. In this case, we do not want to continue with the sync group.</span></div><div class="line">                    future.raise(<span class="keyword">new</span> UnjoinedGroupException());</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(joinResponse.generationId(),</div><div class="line">                            joinResponse.memberId(), joinResponse.groupProtocol());</div><div class="line">                    AbstractCoordinator.<span class="keyword">this</span>.rejoinNeeded = <span class="keyword">false</span>;</div><div class="line">                    <span class="comment">//<span class="doctag">NOTE:</span> join group 成功,下面需要进行 sync-group,获取分配的 tp 列表。</span></div><div class="line">                    <span class="keyword">if</span> (joinResponse.isLeader()) &#123;</div><div class="line">                        onJoinLeader(joinResponse).chain(future);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        onJoinFollower().chain(future);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_LOAD_IN_PROGRESS) &#123;</div><div class="line">            log.debug(<span class="string">"Attempt to join group &#123;&#125; rejected since coordinator &#123;&#125; is loading the group."</span>, groupId,</div><div class="line">                    coordinator());</div><div class="line">            <span class="comment">// backoff and retry</span></div><div class="line">            future.raise(error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID) &#123;</div><div class="line">            <span class="comment">// reset the member id and retry immediately</span></div><div class="line">            resetGeneration();</div><div class="line">            log.debug(<span class="string">"Attempt to join group &#123;&#125; failed due to unknown member id."</span>, groupId);</div><div class="line">            future.raise(Errors.UNKNOWN_MEMBER_ID);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_COORDINATOR_NOT_AVAILABLE</div><div class="line">                || error == Errors.NOT_COORDINATOR_FOR_GROUP) &#123;</div><div class="line">            <span class="comment">// re-discover the coordinator and retry with backoff</span></div><div class="line">            coordinatorDead();</div><div class="line">            log.debug(<span class="string">"Attempt to join group &#123;&#125; failed due to obsolete coordinator information: &#123;&#125;"</span>, groupId, error.message());</div><div class="line">            future.raise(error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.INCONSISTENT_GROUP_PROTOCOL</div><div class="line">                || error == Errors.INVALID_SESSION_TIMEOUT</div><div class="line">                || error == Errors.INVALID_GROUP_ID) &#123;</div><div class="line">            <span class="comment">// log the error and re-throw the exception</span></div><div class="line">            log.error(<span class="string">"Attempt to join group &#123;&#125; failed due to fatal error: &#123;&#125;"</span>, groupId, error.message());</div><div class="line">            future.raise(error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</div><div class="line">            future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// unexpected error, throw the exception</span></div><div class="line">            future.raise(<span class="keyword">new</span> KafkaException(<span class="string">"Unexpected error in join group response: "</span> + error.message()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sendJoinGroupRequest()：向 GroupCoordinator 发送 join-group 请求</p>
<ol>
<li>如果 group 是新的 group.id，那么此时 group 初始化的状态为 <strong>Empty</strong>；</li>
<li>当 GroupCoordinator 接收到 consumer 的 join-group 请求后，由于此时这个 group 的 member 列表还是空（group 是新建的，每个 consumer 实例被称为这个 group 的一个 member），第一个加入的 member 将被选为 leader，也就是说，对于一个新的 consumer group 而言，当第一个 consumer 实例加入后将会被选为 leader；</li>
<li>如果 GroupCoordinator 接收到 leader 发送 join-group 请求，将会触发 rebalance，group 的状态变为 <strong>PreparingRebalance</strong>；</li>
<li>此时，GroupCoordinator 将会等待一定的时间，如果在一定时间内，接收到 join-group 请求的 consumer 将被认为是依然存活的，此时 group 会变为 <strong>AwaitSync</strong> 状态，并且 GroupCoordinator 会向这个 group 的所有 member 返回其 response；</li>
<li>consumer 在接收到 GroupCoordinator 的 response 后，如果这个 consumer 是 group 的 leader，那么这个 consumer 将会负责为整个 group assign partition 订阅安排（默认是按 range 的策略，目前也可选 roundrobin），然后 leader 将分配后的信息以 <code>sendSyncGroupRequest()</code> 请求的方式发给 GroupCoordinator，而作为 follower 的 consumer 实例会发送一个空列表；</li>
<li>GroupCoordinator 在接收到 leader 发来的请求后，会将 assign 的结果返回给所有已经发送 sync-group 请求的 consumer 实例，并且 group 的状态将会转变为 <strong>Stable</strong>，如果后续再收到 sync-group 请求，由于 group 的状态已经是 Stable，将会直接返回其分配结果。</li>
</ol>
<p>sync-group 请求的发送及其实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 consumer 为 follower 时,从 GroupCoordinator 拉取分配结果</span></div><div class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinFollower</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// send follower's sync group with an empty assignment</span></div><div class="line">    SyncGroupRequest.Builder requestBuilder =</div><div class="line">            <span class="keyword">new</span> SyncGroupRequest.Builder(groupId, generation.generationId, generation.memberId,</div><div class="line">                    Collections.&lt;String, ByteBuffer&gt;emptyMap());</div><div class="line">    log.debug(<span class="string">"Sending follower SyncGroup for group &#123;&#125; to coordinator &#123;&#125;: &#123;&#125;"</span>, groupId, <span class="keyword">this</span>.coordinator,</div><div class="line">            requestBuilder);</div><div class="line">    <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//note: 当 consumer 客户端为 leader 时,对 group 下的所有实例进行分配,将 assign 的结果发送到 GroupCoordinator</span></div><div class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">onJoinLeader</span><span class="params">(JoinGroupResponse joinResponse)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// perform the leader synchronization and send back the assignment for the group</span></div><div class="line">        Map&lt;String, ByteBuffer&gt; groupAssignment = performAssignment(joinResponse.leaderId(), joinResponse.groupProtocol(),</div><div class="line">                joinResponse.members());<span class="comment">//<span class="doctag">NOTE:</span> 进行 assign 操作</span></div><div class="line"></div><div class="line">        SyncGroupRequest.Builder requestBuilder =</div><div class="line">                <span class="keyword">new</span> SyncGroupRequest.Builder(groupId, generation.generationId, generation.memberId, groupAssignment);</div><div class="line">        log.debug(<span class="string">"Sending leader SyncGroup for group &#123;&#125; to coordinator &#123;&#125;: &#123;&#125;"</span>,</div><div class="line">                groupId, <span class="keyword">this</span>.coordinator, requestBuilder);</div><div class="line">        <span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);<span class="comment">//<span class="doctag">NOTE:</span> 发送 sync-group 请求</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">        <span class="keyword">return</span> RequestFuture.failure(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 发送 SyncGroup 请求,获取对 partition 分配的安排</span></div><div class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">sendSyncGroupRequest</span><span class="params">(SyncGroupRequest.Builder requestBuilder)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (coordinatorUnknown())</div><div class="line">        <span class="keyword">return</span> RequestFuture.coordinatorNotAvailable();</div><div class="line">    <span class="keyword">return</span> client.send(coordinator, requestBuilder)</div><div class="line">            .compose(<span class="keyword">new</span> SyncGroupResponseHandler());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">SyncGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SyncGroupResponse syncResponse,</span></span></div><div class="line">                       RequestFuture&lt;ByteBuffer&gt; future) &#123;</div><div class="line">        Errors error = Errors.forCode(syncResponse.errorCode());</div><div class="line">        <span class="keyword">if</span> (error == Errors.NONE) &#123;<span class="comment">//note: 同步成功</span></div><div class="line">            sensors.syncLatency.record(response.requestLatencyMs());</div><div class="line">            future.complete(syncResponse.memberAssignment());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            requestRejoin();<span class="comment">//note: join 的标志位设置为 true</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (error == Errors.GROUP_AUTHORIZATION_FAILED) &#123;</div><div class="line">                future.raise(<span class="keyword">new</span> GroupAuthorizationException(groupId));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.REBALANCE_IN_PROGRESS) &#123;<span class="comment">//<span class="doctag">NOTE:</span> group 正在进行 rebalance,任务失败</span></div><div class="line">                log.debug(<span class="string">"SyncGroup for group &#123;&#125; failed due to coordinator rebalance"</span>, groupId);</div><div class="line">                future.raise(error);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_MEMBER_ID</div><div class="line">                    || error == Errors.ILLEGAL_GENERATION) &#123;</div><div class="line">                log.debug(<span class="string">"SyncGroup for group &#123;&#125; failed due to &#123;&#125;"</span>, groupId, error);</div><div class="line">                resetGeneration();</div><div class="line">                future.raise(error);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.GROUP_COORDINATOR_NOT_AVAILABLE</div><div class="line">                    || error == Errors.NOT_COORDINATOR_FOR_GROUP) &#123;</div><div class="line">                log.debug(<span class="string">"SyncGroup for group &#123;&#125; failed due to &#123;&#125;"</span>, groupId, error);</div><div class="line">                coordinatorDead();</div><div class="line">                future.raise(error);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                future.raise(<span class="keyword">new</span> KafkaException(<span class="string">"Unexpected error from SyncGroup: "</span> + error.message()));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="onJoinComplete"><a href="#onJoinComplete" class="headerlink" title="onJoinComplete()"></a><code>onJoinComplete()</code></h3><p>经过上面的步骤，一个 consumer 实例就已经加入 group 成功了，加入 group 成功后，将会触发ConsumerCoordinator 的 <code>onJoinComplete()</code> 方法，其作用就是：更新订阅的 tp 列表、更新其对应的 metadata 及触发注册的 listener。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// note: 加入 group 成功</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onJoinComplete</span><span class="params">(<span class="keyword">int</span> generation,</span></span></div><div class="line">                              String memberId,</div><div class="line">                              String assignmentStrategy,</div><div class="line">                              ByteBuffer assignmentBuffer) &#123;</div><div class="line">    <span class="comment">// only the leader is responsible for monitoring for metadata changes (i.e. partition changes)</span></div><div class="line">    <span class="keyword">if</span> (!isLeader)</div><div class="line">        assignmentSnapshot = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    PartitionAssignor assignor = lookupAssignor(assignmentStrategy);</div><div class="line">    <span class="keyword">if</span> (assignor == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Coordinator selected invalid assignment protocol: "</span> + assignmentStrategy);</div><div class="line"></div><div class="line">    Assignment assignment = ConsumerProtocol.deserializeAssignment(assignmentBuffer);</div><div class="line"></div><div class="line">    <span class="comment">// set the flag to refresh last committed offsets</span></div><div class="line">    <span class="comment">//note: 设置是否需要拉取 last committed offsets 为 true</span></div><div class="line">    subscriptions.needRefreshCommits();</div><div class="line"></div><div class="line">    <span class="comment">// update partition assignment</span></div><div class="line">    <span class="comment">//note: 更新订阅的 tp list</span></div><div class="line">    subscriptions.assignFromSubscribed(assignment.partitions());</div><div class="line"></div><div class="line">    <span class="comment">// check if the assignment contains some topics that were not in the original</span></div><div class="line">    <span class="comment">// subscription, if yes we will obey what leader has decided and add these topics</span></div><div class="line">    <span class="comment">// into the subscriptions as long as they still match the subscribed pattern</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// TODO this part of the logic should be removed once we allow regex on leader assign</span></div><div class="line">    Set&lt;String&gt; addedTopics = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (TopicPartition tp : subscriptions.assignedPartitions()) &#123;</div><div class="line">        <span class="keyword">if</span> (!joinedSubscription.contains(tp.topic()))</div><div class="line">            addedTopics.add(tp.topic());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addedTopics.isEmpty()) &#123;</div><div class="line">        Set&lt;String&gt; newSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(subscriptions.subscription());</div><div class="line">        Set&lt;String&gt; newJoinedSubscription = <span class="keyword">new</span> HashSet&lt;&gt;(joinedSubscription);</div><div class="line">        newSubscription.addAll(addedTopics);</div><div class="line">        newJoinedSubscription.addAll(addedTopics);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.subscriptions.subscribeFromPattern(newSubscription);</div><div class="line">        <span class="keyword">this</span>.joinedSubscription = newJoinedSubscription;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// update the metadata and enforce a refresh to make sure the fetcher can start</span></div><div class="line">    <span class="comment">// fetching data in the next iteration</span></div><div class="line">    <span class="comment">//note: 更新 metadata,确保在下一次循环中可以拉取</span></div><div class="line">    <span class="keyword">this</span>.metadata.setTopics(subscriptions.groupSubscription());</div><div class="line">    client.ensureFreshMetadata();</div><div class="line"></div><div class="line">    <span class="comment">// give the assignor a chance to update internal state based on the received assignment</span></div><div class="line">    assignor.onAssignment(assignment);</div><div class="line"></div><div class="line">    <span class="comment">// reschedule the auto commit starting from now</span></div><div class="line">    <span class="keyword">this</span>.nextAutoCommitDeadline = time.milliseconds() + autoCommitIntervalMs;</div><div class="line"></div><div class="line">    <span class="comment">// execute the user's callback after rebalance</span></div><div class="line">    <span class="comment">//note: 执行 listener</span></div><div class="line">    ConsumerRebalanceListener listener = subscriptions.listener();</div><div class="line">    log.info(<span class="string">"Setting newly assigned partitions &#123;&#125; for group &#123;&#125;"</span>, subscriptions.assignedPartitions(), groupId);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Set&lt;TopicPartition&gt; assigned = <span class="keyword">new</span> HashSet&lt;&gt;(subscriptions.assignedPartitions());</div><div class="line">        listener.onPartitionsAssigned(assigned);</div><div class="line">    &#125; <span class="keyword">catch</span> (WakeupException | InterruptException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        log.error(<span class="string">"User provided listener &#123;&#125; for group &#123;&#125; failed on partition assignment"</span>,</div><div class="line">                listener.getClass().getName(), groupId, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，一个 consumer 实例算是真正上意义上加入 group 成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上一篇博客（2017-09-10），到现在已经过去一个多月了，理论上这篇文章在上个月就应该写完，无奈拖延症又犯了，一直以这部分过于复杂为借口拖了好久，这两天逼了自己一把，先整理出其中的一篇，后续要加把劲，要不然今年的年度计划（年底前把这个系列写完）就完不成了，废话到此为
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码解析之 Producer 单 Partition 顺序性实现及配置说明（五）</title>
    <link href="http://matt33.com/2017/09/10/produccer-end/"/>
    <id>http://matt33.com/2017/09/10/produccer-end/</id>
    <published>2017-09-10T15:39:01.000Z</published>
    <updated>2017-09-10T16:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天把 Kafka Producer 最后一部分给讲述一下，Producer 大部分内容都已经在前面几篇文章介绍过了，这里简单做个收尾，但并不是对前面的总结，本文从两块来讲述：RecordAccumulator 类的实现、Kafka Producer 如何保证其顺序性以及 Kafka Producer 的配置说明，每个 Producer 线程都会有一个 RecordAccumulator 对象，它负责缓存要发送 RecordBatch、记录发送的状态并且进行相应的处理，这里会详细讲述 Kafka Producer 如何保证单 Partition 的有序性。最后，简单介绍一下 Producer 的参数配置说明，只有正确地理解 Producer 相关的配置参数，才能更好地使用 Producer，发挥其相应的作用。</p>
<h2 id="RecordAccumulator"><a href="#RecordAccumulator" class="headerlink" title="RecordAccumulator"></a>RecordAccumulator</h2><p>这里再看一下 RecordAccumulator 的数据结构，如下图所示，每个 topic-partition 都有一个对应的 deque，deque 中存储的是 RecordBatch，它是发送的基本单位，只有这个 topic-partition 的 RecordBatch 达到大小或时间要求才会触发发送操作（但并不是只有达到这两个条件之一才会被发送，这点要理解清楚）。</p>
<p><img src="/images/kafka/recordbatch.png" alt="RecordAccumulator 模型"></p>
<p>再看一下 RecordAccumulator 类的主要方法介绍，如下图所示。</p>
<p><img src="/images/kafka/RecordAccumulator.png" alt="RecordAccumulator 主要方法及其说明"></p>
<p>这张图基本上涵盖了 RecordAccumulator 的主要方法，下面会选择其中几个方法详细讲述，会围绕着 Kafka Producer 如何实现单 Partition 顺序性这个主题来讲述。</p>
<h3 id="mutePartition-与-unmutePartition"><a href="#mutePartition-与-unmutePartition" class="headerlink" title="mutePartition() 与 unmutePartition()"></a>mutePartition() 与 unmutePartition()</h3><p>先看下 <code>mutePartition()</code> 与 <code>unmutePartition()</code> 这两个方法，它们是保证有序性关键之一，其主要做用就是将指定的 topic-partition 从 muted 集合中加入或删除，后面会看到它们的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TopicPartition&gt; muted;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mutePartition</span><span class="params">(TopicPartition tp)</span> </span>&#123;</div><div class="line">    muted.add(tp);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unmutePartition</span><span class="params">(TopicPartition tp)</span> </span>&#123;</div><div class="line">    muted.remove(tp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里先说一下这两个方法调用的条件，这样的话，下面在介绍其他方法时才会更容易理解：</p>
<ul>
<li><code>mutePartition()</code>：如果要求保证顺序性，那么这个 tp 对应的 RecordBatch 如果要开始发送，就将这个 tp 加入到 <code>muted</code> 集合中；</li>
<li><code>unmutePartition()</code>：如果 tp 对应的 RecordBatch 发送完成，tp 将会从 <code>muted</code> 集合中移除。</li>
</ul>
<p>也就是说，<code>muted</code> 是用来记录这个 tp 是否有还有未完成的 RecordBatch。</p>
<h3 id="ready"><a href="#ready" class="headerlink" title="ready()"></a>ready()</h3><p><code>ready()</code> 是在 Sender 线程中调用的，其作用选择那些可以发送的 node，也就是说，如果这个 tp 对应的 batch 可以发送（达到时间或大小要求），就把 tp 对应的 leader 选出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ReadyCheckResult <span class="title">ready</span><span class="params">(Cluster cluster, <span class="keyword">long</span> nowMs)</span> </span>&#123;</div><div class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">    <span class="keyword">long</span> nextReadyCheckDelayMs = Long.MAX_VALUE;</div><div class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> exhausted = <span class="keyword">this</span>.free.queued() &gt; <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; entry : <span class="keyword">this</span>.batches.entrySet()) &#123;</div><div class="line">        TopicPartition part = entry.getKey();</div><div class="line">        Deque&lt;RecordBatch&gt; deque = entry.getValue();</div><div class="line"></div><div class="line">        Node leader = cluster.leaderFor(part);</div><div class="line">        <span class="keyword">synchronized</span> (deque) &#123;</div><div class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; !deque.isEmpty()) &#123;</div><div class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></div><div class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></div><div class="line">                unknownLeaderTopics.add(part.topic());</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !muted.contains(part)) &#123;<span class="comment">//note: part 如果 mute 就不会遍历</span></div><div class="line">                RecordBatch batch = deque.peekFirst();</div><div class="line">                <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">boolean</span> backingOff = batch.attempts &gt; <span class="number">0</span> &amp;&amp; batch.lastAttemptMs + retryBackoffMs &gt; nowMs;</div><div class="line">                    <span class="comment">//note: 是否是在重试</span></div><div class="line">                    <span class="keyword">long</span> waitedTimeMs = nowMs - batch.lastAttemptMs;</div><div class="line">                    <span class="keyword">long</span> timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;</div><div class="line">                    <span class="keyword">long</span> timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</div><div class="line">                    <span class="keyword">boolean</span> full = deque.size() &gt; <span class="number">1</span> || batch.isFull(); <span class="comment">//note: batch 满了</span></div><div class="line">                    <span class="keyword">boolean</span> expired = waitedTimeMs &gt;= timeToWaitMs; <span class="comment">//note: batch 超时</span></div><div class="line">                    <span class="keyword">boolean</span> sendable = full || expired || exhausted || closed || flushInProgress();</div><div class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;</div><div class="line">                        readyNodes.add(leader);<span class="comment">// note: 将可以发送的 leader 添加到集合中</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></div><div class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></div><div class="line">                        <span class="comment">// since we'll just wake up and then sleep again for the remaining time.</span></div><div class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这一行 <code>(!readyNodes.contains(leader) &amp;&amp; !muted.contains(part))</code>，如果 <code>muted</code> 集合包含这个 tp，那么在遍历时将不会处理它对应的 deque，也就是说，如果一个 tp 加入了 <code>muted</code> 集合中，即使它对应的 RecordBatch 可以发送了，也不会触发引起其对应的 leader 被选择出来。</p>
<h3 id="drain"><a href="#drain" class="headerlink" title="drain()"></a>drain()</h3><p><code>drain()</code> 是用来遍历可发送请求的 node，然后再遍历在这个 node 上所有 tp，如果 tp 对应的 deque 有数据，将会被选择出来直到超过一个请求的最大长度（<code>max.request.size</code>）为止，也就说说即使 RecordBatch 没有达到条件，但为了保证每个 request 尽快多地发送数据提高发送效率，这个 RecordBatch 依然会被提前选出来并进行发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 返回该 node 对应的可以发送的 RecordBatch 的 batches,并从 queue 中移除（最大的大小为maxSize,超过的话,下次再发送）</span></div><div class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;RecordBatch&gt;&gt; drain(Cluster cluster,</div><div class="line">                                             Set&lt;Node&gt; nodes,</div><div class="line">                                             <span class="keyword">int</span> maxSize,</div><div class="line">                                             <span class="keyword">long</span> now) &#123;</div><div class="line">    <span class="keyword">if</span> (nodes.isEmpty())</div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line"></div><div class="line">    Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Node node : nodes) &#123;</div><div class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">        List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());</div><div class="line">        List&lt;RecordBatch&gt; ready = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">/* to make starvation less likely this loop doesn't start at 0 */</span></div><div class="line">        <span class="keyword">int</span> start = drainIndex = drainIndex % parts.size();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            PartitionInfo part = parts.get(drainIndex);</div><div class="line">            TopicPartition tp = <span class="keyword">new</span> TopicPartition(part.topic(), part.partition());</div><div class="line">            <span class="comment">// Only proceed if the partition has no in-flight batches.</span></div><div class="line">            <span class="keyword">if</span> (!muted.contains(tp)) &#123;<span class="comment">//note: 被 mute 的 tp 依然不会被遍历</span></div><div class="line">                Deque&lt;RecordBatch&gt; deque = getDeque(<span class="keyword">new</span> TopicPartition(part.topic(), part.partition()));</div><div class="line">                <span class="keyword">if</span> (deque != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (deque) &#123;</div><div class="line">                        RecordBatch first = deque.peekFirst();</div><div class="line">                        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="keyword">boolean</span> backoff = first.attempts &gt; <span class="number">0</span> &amp;&amp; first.lastAttemptMs + retryBackoffMs &gt; now;</div><div class="line">                            <span class="comment">// Only drain the batch if it is not during backoff period.</span></div><div class="line">                            <span class="keyword">if</span> (!backoff) &#123;</div><div class="line">                                <span class="keyword">if</span> (size + first.sizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;</div><div class="line">                                    <span class="comment">// there is a rare case that a single batch size is larger than the request size due</span></div><div class="line">                                    <span class="comment">// to compression; in this case we will still eventually send this batch in a single</span></div><div class="line">                                    <span class="comment">// request</span></div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    RecordBatch batch = deque.pollFirst();</div><div class="line">                                    batch.close();</div><div class="line">                                    size += batch.sizeInBytes();</div><div class="line">                                    ready.add(batch);</div><div class="line">                                    batch.drainedMs = now;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.drainIndex = (<span class="keyword">this</span>.drainIndex + <span class="number">1</span>) % parts.size();</div><div class="line">        &#125; <span class="keyword">while</span> (start != drainIndex);</div><div class="line">        batches.put(node.id(), ready);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> batches;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在遍历 node 的所有 tp 时，可以看到是有条件的 —— <code>!muted.contains(tp)</code>，如果这个 tp 被添加到 <code>muted</code> 集合中，那么它将不会被遍历，也就不会作为 request 一部分被发送出去，这也就保证了 tp 如果还有未完成的 RecordBatch，那么其对应 deque 中其他 RecordBatch 即使达到条件也不会被发送，就保证了 tp 在任何时刻只有一个 RecordBatch 在发送。</p>
<h3 id="顺序性如何保证？"><a href="#顺序性如何保证？" class="headerlink" title="顺序性如何保证？"></a>顺序性如何保证？</h3><p>是否保证顺序性，还是在 Sender 线程中实现的，<code>mutePartition()</code> 与 <code>unmutePartition()</code> 也都是在 Sender 中调用的，这里看一下 KafkaProducer 是如何初始化一个 Sender 对象的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// from KafkaProducer</span></div><div class="line"><span class="keyword">this</span>.sender = <span class="keyword">new</span> Sender(client,</div><div class="line">                         <span class="keyword">this</span>.metadata,</div><div class="line">                         his.accumulator,</div><div class="line">                         config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION) == <span class="number">1</span>,</div><div class="line">                         config.getInt(ProducerConfig.MAX_REQUEST_SIZE_CONFIG),</div><div class="line">                         (<span class="keyword">short</span>) parseAcks(config.getString(ProducerConfig.ACKS_CONFIG)),</div><div class="line">                         config.getInt(ProducerConfig.RETRIES_CONFIG),</div><div class="line">                         <span class="keyword">this</span>.metrics,</div><div class="line">                         Time.SYSTEM,</div><div class="line">                         <span class="keyword">this</span>.requestTimeoutMs);<span class="comment">//<span class="doctag">NOTE:</span> Sender 实例,发送请求的后台线程</span></div><div class="line"></div><div class="line"><span class="comment">// from Sender</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sender</span><span class="params">(KafkaClient client,</span></span></div><div class="line">              Metadata metadata,</div><div class="line">              RecordAccumulator accumulator,</div><div class="line">              <span class="keyword">boolean</span> guaranteeMessageOrder,</div><div class="line">              <span class="keyword">int</span> maxRequestSize,</div><div class="line">              <span class="keyword">short</span> acks,</div><div class="line">              <span class="keyword">int</span> retries,</div><div class="line">              Metrics metrics,</div><div class="line">              Time time,</div><div class="line">              <span class="keyword">int</span> requestTimeout) &#123;</div><div class="line">        <span class="keyword">this</span>.client = client;</div><div class="line">        <span class="keyword">this</span>.accumulator = accumulator;</div><div class="line">        <span class="keyword">this</span>.metadata = metadata;</div><div class="line">        <span class="keyword">this</span>.guaranteeMessageOrder = guaranteeMessageOrder;</div><div class="line">        <span class="keyword">this</span>.maxRequestSize = maxRequestSize;</div><div class="line">        <span class="keyword">this</span>.running = <span class="keyword">true</span>; <span class="comment">//note: 默认为 true</span></div><div class="line">        <span class="keyword">this</span>.acks = acks;</div><div class="line">        <span class="keyword">this</span>.retries = retries;</div><div class="line">        <span class="keyword">this</span>.time = time;</div><div class="line">        <span class="keyword">this</span>.sensors = <span class="keyword">new</span> SenderMetrics(metrics);</div><div class="line">        <span class="keyword">this</span>.requestTimeout = requestTimeout;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上述过程可以这样进行解读</p>
<p><code>this.guaranteeMessageOrder = (config.getInt(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION) == 1)</code></p>
<p>如果 KafkaProducer 的 <code>max.in.flight.requests.per.connection</code> 设置为1，那么就可以保证其顺序性，否则的话，就不保证顺序性，从下面这段代码也可以看出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//from Sender</span></div><div class="line"><span class="comment">//note: max.in.flight.requests.per.connection 设置为1时会保证</span></div><div class="line"><span class="keyword">if</span> (guaranteeMessageOrder) &#123;</div><div class="line">    <span class="comment">// Mute all the partitions draine</span></div><div class="line">    <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</div><div class="line">         <span class="keyword">for</span> (RecordBatch batch : batchList)</div><div class="line">             <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，如果要保证单 Partition 的顺序性，需要在 Producer 中配置 <code>max.in.flight.requests.per.connection=1</code>，而其实现机制则是在 RecordAccumulator 中实现的。</p>
<h2 id="Producer-Configs"><a href="#Producer-Configs" class="headerlink" title="Producer Configs"></a>Producer Configs</h2><p>这里是关于 Kafka Producer 一些配置的说明，内容来自官方文档<a href="http://kafka.apache.org/0102/documentation.html#producerconfigs" target="_blank" rel="external">Producer Configs</a>以及自己的一些个人理解，这里以官方文档保持一致，按其重要性分为三个级别进行讲述（涉及到权限方面的参数，这里先不介绍）。</p>
<h3 id="high-importance"><a href="#high-importance" class="headerlink" title="high importance"></a>high importance</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>bootstrap.servers</td>
<td>Kafka Broker 的一个列表，不用包含所有的 Broker，它用于初始化连接时，通过这几个 broker 来获取集群的信息，比如：<code>127.0.0.1：9092,127.0.0.2：9092,127.0.0.3：9092</code></td>
<td>-</td>
</tr>
<tr>
<td>key.serializer</td>
<td>对 key 进行序列化的 class，一般使用<code>StringSerializer</code></td>
<td>-</td>
</tr>
<tr>
<td>value.serializer</td>
<td>对 value 进行序列化的 class，一般使用 <code>StringDeserializer</code></td>
<td>-</td>
</tr>
<tr>
<td>acks</td>
<td>用于设置在什么情况一条才被认为已经发送成功了。acks=0：msg 只要被 producer 发送出去就认为已经发送完成了；acks=1：如果 leader 接收到消息并发送 ack （不会等会该 msg 是否同步到其他副本）就认为 msg 发送成功了； acks=all或者-1：leader 接收到 msg 并从所有 isr 接收到 ack 后再向 producer 发送 ack，这样才认为 msg 发送成功了，这是最高级别的可靠性保证。</td>
<td>1</td>
</tr>
<tr>
<td>buffer.memory</td>
<td>producer 可以使用的最大内存，如果超过这个值，producer 将会 block <code>max.block.ms</code> 之后抛出异常。</td>
<td>33554432（32MB）</td>
</tr>
<tr>
<td>compression.type</td>
<td>Producer 数据的压缩格式，可以选择 none、gzip、snappy、lz4</td>
<td>none</td>
</tr>
<tr>
<td>retries</td>
<td>msg 发送失败后重试的次数，允许重试，如果 <code>max.in.flight.requests.per.connection</code> 设置不为1，可能会导致乱序</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="medium-importance"><a href="#medium-importance" class="headerlink" title="medium importance"></a>medium importance</h3><p>下面的这些参数虽然被描述为 medium，但实际上对 Producer 的吞吐量等影响也同样很大，在实践中跟 high 参数的重要性基本一样。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch.size</td>
<td>producer 向 partition 发送数据时，是以 batch 形式的发送数据，当 batch 的大小超过 <code>batch.size</code> 或者时间达到 <code>linger.ms</code> 就会发送 batch，根据经验，设置为1MB 吞吐会更高，太小的话吞吐小，太大的话导致内存浪费进而影响吞吐量</td>
<td>16384（16KB）</td>
</tr>
<tr>
<td>linger.ms</td>
<td>在一个 batch 达不到 <code>batch.size</code> 时，这个 batch 最多将会等待 <code>linger.ms</code> 时间，超过这个时间这个 batch 就会被发送，但也会带来相应的延迟，可以根据具体的场景进行设置</td>
<td>0</td>
</tr>
<tr>
<td>client.id</td>
<td>client 的 id，主要用于追踪 request 的来源</td>
<td>null</td>
</tr>
<tr>
<td>connections.max.idle.ms</td>
<td>如果 connection 连续空闲时间超过了这个值，将会被关闭，主要使用 Selector 的 <code>maybeCloseOldestConnection</code> 方法</td>
<td>540000（9min）</td>
</tr>
<tr>
<td>max.block.ms</td>
<td>控制 <code>KafkaProducer.send()</code> 和 <code>KafkaProducer.partitionsFor()</code> block 的最大时间，block 的原因是 buffer 满了或者 metadata 不可用导致。</td>
<td>60000</td>
</tr>
<tr>
<td>max.request.size</td>
<td>一个请求的最大长度</td>
<td>1048576（1MB）</td>
</tr>
<tr>
<td>partitioner.class</td>
<td>获取 topic 分区的 class</td>
<td>org.apache.kafka.clients.producer.internals.DefaultPartitioner</td>
</tr>
<tr>
<td>receive.buffer.bytes</td>
<td>在读取数据时 TCP receive buffer （SO_RCVBUF）的大小</td>
<td>32768（32KB）</td>
</tr>
<tr>
<td>request.timeout.ms</td>
<td>如果 producer 超过这么长时间没有收到 response，将会再次发送请求</td>
<td>30000</td>
</tr>
<tr>
<td>timeout.ms</td>
<td>用于配置 leader 等待 isr 返回 ack 的最大时间，如果超过了这个时间，将会返回给 producer 一个错误。</td>
<td>30000</td>
</tr>
</tbody>
</table>
<h3 id="low-importance"><a href="#low-importance" class="headerlink" title="low importance"></a>low importance</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>block.on.buffer.full</td>
<td>当 Producer 使用 buffer 达到最大设置时，如果设置为 false，将会 block <code>max.block.ms</code> 后然后抛出 <code>TimeoutException</code> 异常，如果设置为 true，将会把 <code>max.block.ms</code> 设置为 <code>Long.MAX_VALUE</code>。</td>
<td>false</td>
</tr>
<tr>
<td>interceptor.classes</td>
<td>使用拦截器，实现这个 <code>ProducerInterceptor</code> 接口，可以对 topic 进行简单的处理。</td>
<td>null</td>
</tr>
<tr>
<td>max.in.flight.requests.per.connection</td>
<td>对一个 connection，同时发送最大请求数，不为1时，不能保证顺序性。</td>
<td>5</td>
</tr>
<tr>
<td>metadata.fetch.timeout.ms</td>
<td>获取 metadata 时的超时时间</td>
<td>60000</td>
</tr>
<tr>
<td>metadata.max.age.ms</td>
<td>强制 metadata 定时刷新的间隔</td>
<td>300000（5min）</td>
</tr>
<tr>
<td>metric.reporters</td>
<td>A list of classes to use as metrics reporters. Implementing the MetricReporter interface，JmxReporter 是默认被添加的。</td>
<td>“”</td>
</tr>
<tr>
<td>metrics.num.samples</td>
<td>统计 metrics 时采样的次数</td>
<td>2</td>
</tr>
<tr>
<td>metrics.sample.window.ms</td>
<td>metrics 采样计算的时间窗口</td>
<td>30000</td>
</tr>
<tr>
<td>reconnect.backoff.ms</td>
<td>重新建立建立连接的间隔</td>
<td>50</td>
</tr>
<tr>
<td>retry.backoff.ms</td>
<td>发送重试的间隔</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>对于不同的场景，合理配置相应的 Kafka Producer 参数。</p>
<p>至此，Kafka Producer 部分的源码分析已经结束，从下周开始将开始对 Kafka Consumer 部分进行分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天把 Kafka Producer 最后一部分给讲述一下，Producer 大部分内容都已经在前面几篇文章介绍过了，这里简单做个收尾，但并不是对前面的总结，本文从两块来讲述：RecordAccumulator 类的实现、Kafka Producer 如何保证其顺序性以及 
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 最佳实践【译】</title>
    <link href="http://matt33.com/2017/09/04/kafka-best-pratice/"/>
    <id>http://matt33.com/2017/09/04/kafka-best-pratice/</id>
    <published>2017-09-04T14:07:58.000Z</published>
    <updated>2017-09-05T00:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里翻译一篇关于 Kafka 实践的文章，内容来自 DataWorks Summit/Hadoop Summit（<a href="https://dataworkssummit.com/munich-2017/sessions/apache-kafka-best-practices/" target="_blank" rel="external">Hadoop Summit</a>）上一篇分享，PPT 见<a href="https://www.slideshare.net/HadoopSummit/apache-kafka-best-practices" target="_blank" rel="external">Apache Kafka Best Pratices</a>，里面讲述了很多关于 Kafka 配置、监控、优化的内容，绝对是在实践中总结出的精华，有很大的借鉴参考意义，本文主要是根据 PPT 的内容进行翻译及适当补充。</p>
<p>Kafka 的架构这里就不多做介绍了，直接不如正题。</p>
<h2 id="Kafka-基本配置及性能优化"><a href="#Kafka-基本配置及性能优化" class="headerlink" title="Kafka 基本配置及性能优化"></a>Kafka 基本配置及性能优化</h2><p>这里主要是 Kafka 集群基本配置的相关内容。</p>
<h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><p>Kafka 集群基本硬件的保证</p>
<table>
<thead>
<tr>
<th></th>
<th>集群规模</th>
<th>内存</th>
<th>CPU</th>
<th>存储</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kafka Brokers</td>
<td>3+</td>
<td>24GB+（小规模）；64GB+（大规模）</td>
<td>多核（12CPU+），并允许超线程</td>
<td>6+ 1TB 的专属磁盘（RAID 或 JBOD）</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>3（小规模）；5（大规模）</td>
<td>8GB+（小规模）；24GB+（大规模）</td>
<td>2核+</td>
<td>SSD 用于中间的日志传输</td>
</tr>
</tbody>
</table>
<h3 id="OS-调优"><a href="#OS-调优" class="headerlink" title="OS 调优"></a>OS 调优</h3><ul>
<li>OS page cache：应当可以缓存所有活跃的 Segment（Kafka 中最基本的数据存储单位）；</li>
<li>fd 限制：100k+；</li>
<li>禁用 swapping：简单来说，swap 作用是当内存的使用达到一个临界值时就会将内存中的数据移动到 swap 交换空间，但是此时，内存可能还有很多空余资源，swap 走的是磁盘 IO，对于内存读写很在意的系统，最好禁止使用 swap 分区（参考<a href="https://www.quora.com/What-is-swapping-in-an-OS" target="_blank" rel="external">What is swapping in an OS?</a>）；</li>
<li>TCP 调优；</li>
<li>JVM 配置<ol>
<li>JDK 8 并且使用 G1 垃圾收集器；</li>
<li>至少要分配 6-8 GB 的堆内存。</li>
</ol>
</li>
</ul>
<h3 id="Kafka-磁盘存储"><a href="#Kafka-磁盘存储" class="headerlink" title="Kafka 磁盘存储"></a>Kafka 磁盘存储</h3><ul>
<li>使用多块磁盘，并配置为 Kafka 专用的磁盘；</li>
<li>JBOD vs RAID10；</li>
<li>JBOD（Just a Bunch of Disks，简单来说它表示一个没有控制软件提供协调控制的磁盘集合，它将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘，数据是按序存储，它的性能与单块磁盘类似）</li>
<li>JBOD 的一些缺陷：<ul>
<li>任何磁盘的损坏都会导致异常关闭，并且需要较长的时间恢复；</li>
<li>数据不保证一致性；</li>
<li>多级目录；</li>
</ul>
</li>
<li>社区也正在解决这么问题，可以关注 KIP 112、113：<ul>
<li>必要的工具用于管理 JBOD；</li>
<li>自动化的分区管理；</li>
<li>磁盘损坏时，Broker 可以将 replicas 迁移到好的磁盘上；</li>
<li>在同一个 Broker 的磁盘间 reassign replicas；</li>
</ul>
</li>
<li>RAID 10 的特点：<ul>
<li>可以允许单磁盘的损坏；</li>
<li>性能和保护；</li>
<li>不同磁盘间的负载均衡；</li>
<li>高命中来减少 space；</li>
<li>单一的 mount point；</li>
</ul>
</li>
<li>文件系统：<ul>
<li>使用 EXT 或 XFS；</li>
<li>SSD；</li>
</ul>
</li>
</ul>
<h3 id="基本的监控"><a href="#基本的监控" class="headerlink" title="基本的监控"></a>基本的监控</h3><p>Kafka 集群需要监控的一些指标，这些指标反应了集群的健康度。</p>
<ul>
<li>CPU 负载；</li>
<li>Network Metrics；</li>
<li>File Handle 使用；</li>
<li>磁盘空间；</li>
<li>磁盘 IO 性能；</li>
<li>GC 信息；</li>
<li>ZooKeeper 监控。</li>
</ul>
<h2 id="Kafka-replica-相关配置及监控"><a href="#Kafka-replica-相关配置及监控" class="headerlink" title="Kafka replica 相关配置及监控"></a>Kafka replica 相关配置及监控</h2><h3 id="Kafka-Replication"><a href="#Kafka-Replication" class="headerlink" title="Kafka Replication"></a>Kafka Replication</h3><ul>
<li>Partition 有两种副本：Leader，Follower；</li>
<li>Leader 负责维护 in-sync-replicas(ISR)<ul>
<li><code>replica.lag.time.max.ms</code>：默认为10000，如果 follower 落后于 leader 的消息数超过这个数值时，leader 就将 follower 从 isr 列表中移除；</li>
<li><code>num.replica.fetchers</code>，默认为1，用于从 leader 同步数据的 fetcher 线程数；</li>
<li><code>min.insync.replica</code>：Producer 端使用来用于保证 Durability（持久性）；</li>
</ul>
</li>
</ul>
<h3 id="Under-Replicated-Partitions"><a href="#Under-Replicated-Partitions" class="headerlink" title="Under Replicated Partitions"></a>Under Replicated Partitions</h3><p>当发现 replica 的配置与集群的不同时，一般情况都是集群上的 replica 少于配置数时，可以从以下几个角度来排查问题：</p>
<ul>
<li>JMX 监控项：kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions；</li>
<li>可能的原因：<ul>
<li>Broker 挂了？</li>
<li>Controller 的问题？</li>
<li>ZooKeeper 的问题？</li>
<li>Network 的问题？</li>
</ul>
</li>
<li>解决办法：<ul>
<li>调整 ISR 的设置；</li>
<li>Broker 扩容。</li>
</ul>
</li>
</ul>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>负责管理 partition 生命周期；</li>
<li>避免 Controller’s ZK 会话超时：<ul>
<li>ISR 抖动；</li>
<li>ZK Server 性能问题；</li>
<li>Broker 长时间的 GC；</li>
<li>网络 IO 问题；</li>
</ul>
</li>
<li>监控：<ul>
<li>kafka.controller:type=KafkaController,name=ActiveControllerCount，应该为1；</li>
<li>LeaderElectionRate。</li>
</ul>
</li>
</ul>
<h3 id="Unclean-leader-选举"><a href="#Unclean-leader-选举" class="headerlink" title="Unclean leader 选举"></a>Unclean leader 选举</h3><p>允许不在 isr 中 replica 被选举为 leader。</p>
<ul>
<li>这是 Availability 和 Correctness 之间选择，Kafka 默认选择了可用性；</li>
<li><code>unclean.leader.election.enable</code>：默认为 true，即允许不在 isr 中 replica 选为 leader，这个配置可以全局配置，也可以在 topic 级别配置；</li>
<li>监控：kafka.controller:type=ControllerStats,name=UncleanLeaderElectionsPerSec。</li>
</ul>
<h2 id="Broker-配置"><a href="#Broker-配置" class="headerlink" title="Broker 配置"></a>Broker 配置</h2><p>Broker 级别有几个比较重要的配置，一般需要根据实际情况进行相应配置的：</p>
<ul>
<li><code>log.retention.{ms, minutes, hours}</code> , <code>log.retention.bytes</code>：数据保存时间；</li>
<li><code>message.max.bytes</code>, <code>replica.fetch.max.bytes</code>；</li>
<li><code>delete.topic.enable</code>：默认为 false，是否允许通过 admin tool 来删除 topic；</li>
<li><code>unclean.leader.election.enable</code> = false，参见上面；</li>
<li><code>min.insync.replicas</code> = 2：当 Producer 的 acks 设置为 all 或 -1 时，<code>min.insync.replicas</code> 代表了必须进行确认的最小 replica 数，如果不够的话 Producer 将会报 <code>NotEnoughReplicas</code> 或 <code>NotEnoughReplicasAfterAppend</code> 异常；</li>
<li><code>replica.lag.time.max.ms</code>（超过这个时间没有发送请求的话，follower 将从 isr 中移除）, num.replica.fetchers；</li>
<li><code>replica.fetch.response.max.bytes</code>；</li>
<li><code>zookeeper.session.timeout.ms</code> = 30s；</li>
<li><code>num.io.threads</code>：默认为8，KafkaRequestHandlerPool 的大小。</li>
</ul>
<h2 id="Kafka-相关资源的评估"><a href="#Kafka-相关资源的评估" class="headerlink" title="Kafka 相关资源的评估"></a>Kafka 相关资源的评估</h2><h3 id="集群评估"><a href="#集群评估" class="headerlink" title="集群评估"></a>集群评估</h3><ul>
<li>Broker 评估<ul>
<li>每个 Broker 的 Partition 数不应该超过2k；</li>
<li>控制 partition 大小（不要超过25GB）；</li>
</ul>
</li>
<li>集群评估（Broker 的数量根据以下条件配置）<ul>
<li>数据保留时间；</li>
<li>集群的流量大小；</li>
</ul>
</li>
<li>集群扩容：<ul>
<li>磁盘使用率应该在 60% 以下；</li>
<li>网络使用率应该在 75% 以下；</li>
</ul>
</li>
<li>集群监控<ul>
<li>保持负载均衡；</li>
<li>确保 topic 的 partition 均匀分布在所有 Broker 上；</li>
<li>确保集群的阶段没有耗尽磁盘或带宽。</li>
</ul>
</li>
</ul>
<h3 id="Broker-监控"><a href="#Broker-监控" class="headerlink" title="Broker 监控"></a>Broker 监控</h3><ul>
<li>Partition 数：kafka.server:type=ReplicaManager,name=PartitionCount；</li>
<li>Leader 副本数：kafka.server:type=ReplicaManager,name=LeaderCount；</li>
<li>ISR 扩容/缩容率：kafka.server:type=ReplicaManager,name=IsrExpandsPerSec；</li>
<li>读写速率：Message in rate/Byte in rate/Byte out rate；</li>
<li>网络请求的平均空闲率：NetworkProcessorAvgIdlePercent；</li>
<li>请求处理平均空闲率：RequestHandlerAvgIdlePercent。</li>
</ul>
<h3 id="Topic-评估"><a href="#Topic-评估" class="headerlink" title="Topic 评估"></a>Topic 评估</h3><ul>
<li>partition 数<ul>
<li>Partition 数应该至少与最大 consumer group 中 consumer 线程数一致；</li>
<li>对于使用频繁的 topic，应该设置更多的 partition；</li>
<li>控制 partition 的大小（25GB 左右）；</li>
<li>考虑应用未来的增长（可以使用一种机制进行自动扩容）；</li>
</ul>
</li>
<li>使用带 key 的 topic；</li>
<li>partition 扩容：当 partition 的数据量超过一个阈值时应该自动扩容（实际上还应该考虑网络流量）。</li>
</ul>
<h3 id="合理地设置-partition"><a href="#合理地设置-partition" class="headerlink" title="合理地设置 partition"></a>合理地设置 partition</h3><ul>
<li>根据吞吐量的要求设置 partition 数：<ul>
<li>假设 Producer 单 partition 的吞吐量为 P；</li>
<li>consumer 消费一个 partition 的吞吐量为 C；</li>
<li>而要求的吞吐量为 T；</li>
<li>那么 partition 数至少应该大于 T/P、T/c 的最大值；</li>
</ul>
</li>
<li>更多的 partition，意味着：<ul>
<li>更多的 fd；</li>
<li>可能增加 Unavailability（可能会增加不可用的时间）；</li>
<li>可能增加端到端的延迟；</li>
<li>client 端将会使用更多的内存。</li>
</ul>
</li>
</ul>
<p>关于 Partition 的设置可以参考这篇文章<a href="https://www.confluent.io/blog/how-to-choose-the-number-of-topicspartitions-in-a-kafka-cluster/" target="_blank" rel="external">How to choose the number of topics/partitions in a Kafka cluster?</a>，这里简单讲述一下，Partition 的增加将会带来以下几个优点和缺点：</p>
<ol>
<li>增加吞吐量：对于 consumer 来说，一个 partition 只能被一个 consumer 线程所消费，适当增加 partition 数，可以增加 consumer 的并发，进而增加系统的吞吐量；</li>
<li>需要更多的 fd：对于每一个 segment，在 broker 都会有一个对应的 index 和实际数据文件，而对于 Kafka Broker，它将会对于每个 segment 每个 index 和数据文件都会打开相应的 file handle（可以理解为 fd），因此，partition 越多，将会带来更多的 fd；</li>
<li>可能会增加数据不可用性（主要是指增加不可用时间）：主要是指 broker 宕机的情况，越多的 partition 将会意味着越多的 partition 需要 leader 选举（leader 在宕机这台 broker 的 partition 需要重新选举），特别是如果刚好 controller 宕机，重新选举的 controller 将会首先读取所有 partition 的 metadata，然后才进行相应的 leader 选举，这将会带来更大不可用时间；</li>
<li>可能增加 End-to-end 延迟：一条消息只有其被同步到 isr 的所有 broker 上后，才能被消费，partition 越多，不同节点之间同步就越多，这可能会带来毫秒级甚至数十毫秒级的延迟；</li>
<li>Client 将会需要更多的内存：Producer 和 Consumer 都会按照 partition 去缓存数据，每个 partition 都会带来数十 KB 的消耗，partition 越多, Client 将会占用更多的内存。</li>
</ol>
<h2 id="Producer-的相关配置、性能调优及监控"><a href="#Producer-的相关配置、性能调优及监控" class="headerlink" title="Producer 的相关配置、性能调优及监控"></a>Producer 的相关配置、性能调优及监控</h2><h3 id="Quotas"><a href="#Quotas" class="headerlink" title="Quotas"></a>Quotas</h3><ul>
<li>避免被恶意 Client 攻击，保证 SLA；</li>
<li>设置 produce 和 fetch 请求的字节速率阈值；</li>
<li>可以应用在 user、client-id、或者 user 和 client-id groups；</li>
<li>Broker 端的 metrics 监控：throttle-rate、byte-rate；</li>
<li><code>replica.fetch.response.max.bytes</code>：用于限制 replica 拉取请求的内存使用；</li>
<li>进行数据迁移时限制贷款的使用，<code>kafka-reassign-partitions.sh -- -throttle option</code>。</li>
</ul>
<h3 id="Kafka-Producer"><a href="#Kafka-Producer" class="headerlink" title="Kafka Producer"></a>Kafka Producer</h3><ul>
<li>使用 Java 版的 Client；</li>
<li>使用 <code>kafka-producer-perf-test.sh</code> 测试你的环境；</li>
<li>设置内存、CPU、batch 压缩；<ul>
<li>batch.size：该值设置越大，吞吐越大，但延迟也会越大；</li>
<li>linger.ms：表示 batch 的超时时间，该值越大，吞吐越大、但延迟也会越大；</li>
<li><code>max.in.flight.requests.per.connection</code>：默认为5，表示 client 在 blocking 之前向单个连接（broker）发送的未确认请求的最大数，超过1时，将会影响数据的顺序性；</li>
<li><code>compression.type</code>：压缩设置，会提高吞吐量；</li>
<li><code>acks</code>：数据 durability 的设置；</li>
</ul>
</li>
<li>避免大消息<ul>
<li>会使用更多的内存；</li>
<li>降低 Broker 的处理速度；</li>
</ul>
</li>
</ul>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><ul>
<li>如果吞吐量小于网络带宽<ul>
<li>增加线程；</li>
<li>提高 batch.size；</li>
<li>增加更多 producer 实例；</li>
<li>增加 partition 数；</li>
</ul>
</li>
<li>设置 acks=-1 时，如果延迟增大：可以增大 <code>num.replica.fetchers</code>（follower 同步数据的线程数）来调解；</li>
<li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li>
</ul>
<h3 id="Prodcuer-监控"><a href="#Prodcuer-监控" class="headerlink" title="Prodcuer 监控"></a>Prodcuer 监控</h3><ul>
<li>batch-size-avg</li>
<li>compression-rate-avg</li>
<li>waiting-threads</li>
<li>buffer-available-bytes</li>
<li>record-queue-time-max</li>
<li>record-send-rate</li>
<li>records-per-request-avg</li>
</ul>
<h2 id="Kafka-Consumer-配置、性能调优及监控"><a href="#Kafka-Consumer-配置、性能调优及监控" class="headerlink" title="Kafka Consumer 配置、性能调优及监控"></a>Kafka Consumer 配置、性能调优及监控</h2><h3 id="Kafka-Consumer"><a href="#Kafka-Consumer" class="headerlink" title="Kafka Consumer"></a>Kafka Consumer</h3><ul>
<li>使用 <code>kafka-consumer-perf-test.sh</code> 测试环境；</li>
<li>吞吐量问题：<ul>
<li>partition 数太少；</li>
<li>OS page cache：分配足够的内存来缓存数据；</li>
<li>应用的处理逻辑；</li>
</ul>
</li>
<li>offset topic（<code>__consumer_offsets</code>）<ul>
<li><code>offsets.topic.replication.factor</code>：默认为3；</li>
<li><code>offsets.retention.minutes</code>：默认为1440，即 1day；<br>– MonitorISR，topicsize；</li>
</ul>
</li>
<li>offset commit较慢：异步 commit 或 手动 commit。</li>
</ul>
<h3 id="Consumer-配置"><a href="#Consumer-配置" class="headerlink" title="Consumer 配置"></a>Consumer 配置</h3><ul>
<li><code>fetch.min.bytes</code> 、<code>fetch.max.wait.ms</code>；</li>
<li><code>max.poll.interval.ms</code>：调用 <code>poll()</code> 之后延迟的最大时间，超过这个时间没有调用 <code>poll()</code> 的话，就会认为这个 consumer 挂掉了，将会进行 rebalance；</li>
<li><code>max.poll.records</code>：当调用 <code>poll()</code> 之后返回最大的 record 数，默认为500；</li>
<li><code>session.timeout.ms</code>；</li>
<li>Consumer Rebalance<br>– check timeouts<br>– check processing times/logic<br>– GC Issues</li>
<li>网络配置；</li>
</ul>
<h3 id="Consumer-监控"><a href="#Consumer-监控" class="headerlink" title="Consumer 监控"></a>Consumer 监控</h3><p>consumer 是否跟得上数据的发送速度。</p>
<ul>
<li>Consumer Lag：consumer offset 与 the end of log（partition 可以消费的最大 offset） 的差值；</li>
<li>监控<ul>
<li>metric 监控：records-lag-max；</li>
<li>通过 <code>bin/kafka-consumer-groups.sh</code> 查看；</li>
<li>用于 consumer 监控的 LinkedIn’s Burrow；</li>
</ul>
</li>
<li>减少 Lag<ul>
<li>分析 consumer：是 GC 问题还是 Consumer hang 住了；</li>
<li>增加 Consumer 的线程；</li>
<li>增加分区数和 consumer 线程；</li>
</ul>
</li>
</ul>
<h2 id="如何保证数据不丢"><a href="#如何保证数据不丢" class="headerlink" title="如何保证数据不丢"></a>如何保证数据不丢</h2><p>这个是常用的配置，这里截了 PPT 中的内容</p>
<p><img src="/images/kafka/not-data-less.png" alt="Kafka 数据不丢配置"></p>
<ul>
<li><code>block.on.buffer.full</code>：默认设置为 false，当达到内存设置时，可能通过 block 停止接受新的 record 或者抛出一些错误，默认情况下，Producer 将不会抛出  BufferExhaustException，而是当达到 <code>max.block.ms</code> 这个时间后直接抛出 TimeoutException。设置为 true 的意义就是将 <code>max.block.ms</code> 设置为 Long.MAX_VALUE，未来版本中这个设置将被遗弃，推荐设置 <code>max.block.ms</code>。</li>
</ul>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://www.slideshare.net/HadoopSummit/apache-kafka-best-practices" target="_blank" rel="external">Apache Kafka Best Pratices</a>；</li>
<li>胡夕-<a href="http://www.cnblogs.com/huxi2b/p/6720292.html" target="_blank" rel="external">【译】Kafka最佳实践 / Kafka Best Practices</a>；</li>
<li><a href="https://www.confluent.io/blog/how-to-choose-the-number-of-topicspartitions-in-a-kafka-cluster/" target="_blank" rel="external">How to choose the number of topics/partitions in a Kafka cluster?</a>；</li>
<li><a href="https://www.zhihu.com/question/20131784" target="_blank" rel="external">raid有哪几种有什么区别？希望讲通俗点</a>；</li>
<li><a href="https://stackoverflow.com/questions/33536061/file-descriptors-and-file-handles-and-c#" target="_blank" rel="external">File Descriptors and File Handles (and C)</a>.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里翻译一篇关于 Kafka 实践的文章，内容来自 DataWorks Summit/Hadoop Summit（&lt;a href=&quot;https://dataworkssummit.com/munich-2017/sessions/apache-kafka-best-prac
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 Producer NIO 网络模型（四）</title>
    <link href="http://matt33.com/2017/08/22/producer-nio/"/>
    <id>http://matt33.com/2017/08/22/producer-nio/</id>
    <published>2017-08-22T13:58:25.000Z</published>
    <updated>2017-08-25T09:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 Kafka 源码解析的第四篇，在写这篇文章之前，专门看了一下 Java NIO 相关的内容，只有理解了 Java NIO 模型才能更好地理解 NIO 在 Kafka 中是如何应用的以及 Producer 如何利用 Java NIO 构建其网络模型（不了解的，可以先看一下上一篇文章：<a href="http://matt33.com/2017/08/12/java-nio/">谈一谈 Java IO 模型</a>），同时，本文也是对 Producer 整个流程的一个总结，主要讲述以下两个问题：</p>
<ol>
<li>Producer 的大概网络模型，与 Java NIO 模型之间关系；</li>
<li>Producer 整体流程及其整体流程详解。</li>
</ol>
<h1 id="Producer-的网络模型"><a href="#Producer-的网络模型" class="headerlink" title="Producer 的网络模型"></a>Producer 的网络模型</h1><p>KafkaProducer 通过 Sender 进行相应的 IO 操作，而 Sender 又调用 NetworkClient 来进行 IO 操作，NetworkClient 底层是对 Java NIO 进行相应的封装，其网络模型如下图所示（该图参考：<a href="http://blog.csdn.net/chunlongyu/article/details/52636762" target="_blank" rel="external">Kafka源码深度解析－序列3 －Producer －Java NIO</a>，在其基础上增加一个 KafkaProducer 成员变量的图形）。</p>
<p><img src="/images/kafka/producer-network.png" alt="Prodcuer 网络模型"></p>
<p>从图中可以看出，Sender 为最上层的接口，即调用层，Sender 调用 NetworkClient，NetworkClient 调用 Selector，而 Selector 底层封装了 Java NIO 的相关接口，从右边的图也可以看出它们之间的关系。</p>
<h1 id="Producer-整体流程"><a href="#Producer-整体流程" class="headerlink" title="Producer 整体流程"></a>Producer 整体流程</h1><p>有了对 Producer 网络模型的大概框架认识之后，下面再深入进去，看一下它们之间的调用关系以及 Producer 是如何调用 Java NIO 的相关接口，Producer 端的整体流程如下图所示。</p>
<p><img src="/images/kafka/producer-nio-flow.png" alt="Producer 整体流程"></p>
<p>这里涉及到的主要方法是：</p>
<ul>
<li><code>KafkaProducer.dosend()</code>；</li>
<li><code>Sender.run()</code>；</li>
<li><code>NetworkClient.poll()</code>（<code>NetworkClient.dosend()</code>）；</li>
<li><code>Selector.poll()</code>；</li>
</ul>
<p>下面会结合上图，对这几个方法做详细的讲解，本文下面的内容都是结合上图进行讲解。</p>
<h2 id="KafkaProducer-dosend"><a href="#KafkaProducer-dosend" class="headerlink" title="KafkaProducer.dosend()"></a>KafkaProducer.dosend()</h2><p><code>dosend()</code> 方法是读懂 Producer 的入口，具体可以参考 <a href="http://matt33.com/2017/06/25/kafka-producer-send-module/#Producer-的-doSend-实现">dosend()</a>，<code>dosend()</code> 主要做了两个事情：</p>
<ol>
<li><code>waitOnMetadata()</code>：请求更新 tp（topic-partition） meta，中间会调用 <code>sender.wakeup()</code>；</li>
<li><code>accumulator.append()</code>：将 msg 写入到其 tp 对应的 deque 中，如果该 tp 对应的 deque 新建了一个 Batch，最后也会调用 <code>sender.wakeup()</code>。</li>
</ol>
<p>这里主要关注的是 <code>sender.wakeup()</code> 方法，它的作用是将 Sender 线程从阻塞中唤醒。</p>
<h3 id="sender-wakeup-方法"><a href="#sender-wakeup-方法" class="headerlink" title="sender.wakeup() 方法"></a><code>sender.wakeup()</code> 方法</h3><p>这里来看一下 <code>sender.wakeup()</code> 具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// org.apache.kafka.clients.producer.internals.Sender</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* Wake up the selector associated with this send thread</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.client.wakeup();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// org.apache.kafka.clients.NetworkClient</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* Interrupt the client if it is blocked waiting on I/O.</div><div class="line">*/</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.selector.wakeup();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// org.apache.kafka.common.network.Selector</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* Interrupt the nioSelector if it is blocked waiting to do I/O.</div><div class="line">*/</div><div class="line"><span class="comment">//note: 如果 selector 是阻塞的话,就唤醒</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.nioSelector.wakeup();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法很简单，但也很有意思，其调用过程是下面这个样子：</p>
<ul>
<li>Sender -&gt; NetworkClient -&gt; Selector(Kafka 封装的) -&gt; Selector(Java NIO)</li>
</ul>
<p>跟上面两张图中 KafkaProducer 的总体调用过程大概一致，它的作用就是将 Sender 线程从 <code>select()</code> 方法的阻塞中唤醒，<code>select()</code> 方法的作用是轮询注册在多路复用器上的 Channel，它会一直阻塞在这个方法上，除非满足下面条件中的一个：</p>
<ul>
<li>at least one channel is selected;</li>
<li>this selector’s {@link #wakeup wakeup} method is invoked;</li>
<li>the current thread is interrupted;</li>
<li>the given timeout period expires.</li>
</ul>
<p>否则 <code>select()</code> 将会一直轮询，阻塞在这个地方，直到条件满足。</p>
<p>分析到这里，KafkaProducer 中 <code>dosend()</code> 方法调用 <code>sender.wakeup()</code> 方法作用就很明显的，作用就是：当有新的 RecordBatch 创建后，旧的 RecordBatch 就可以发送了（或者此时有 Metadata 请求需要发送），如果线程阻塞在 <code>select()</code> 方法中，就将其唤醒，Sender 重新开始运行 <code>run()</code> 方法，在这个方法中，旧的 RecordBatch （或相应的 Metadata 请求）将会被选中，进而可以及时将这些请求发送出去。</p>
<h2 id="Sender-run"><a href="#Sender-run" class="headerlink" title="Sender.run()"></a>Sender.run()</h2><p>每次循环都是从 Sender 的 <code>run()</code> 方法开始，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: Sender 线程每次循环具体执行的地方</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        Cluster cluster = metadata.fetch();</div><div class="line">        <span class="comment">//note: Step1 获取那些已经可以发送的 RecordBatch 对应的 nodes</span></div><div class="line">        RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</div><div class="line"></div><div class="line">        <span class="comment">//note: Step2  如果有 topic-partition 的 leader 是未知的,就强制 metadata 更新</span></div><div class="line">        <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</div><div class="line">            <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</div><div class="line">                <span class="keyword">this</span>.metadata.add(topic);</div><div class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//note: 如果与node 没有连接（如果可以连接,会初始化该连接）,暂时先移除该 node</span></div><div class="line">        Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</div><div class="line">        <span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Node node = iter.next();</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;<span class="comment">//note: 没有建立连接的 broker,这里会与其建立连接</span></div><div class="line">                iter.remove();</div><div class="line">                notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.connectionDelay(node, now));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//note: Step3  返回该 node 对应的所有可以发送的 RecordBatch 组成的 batches（key 是 node.id,这些 batches 将会在一个 request 中发送）</span></div><div class="line">        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster,</div><div class="line">                                                                         result.readyNodes,</div><div class="line">                                                                         <span class="keyword">this</span>.maxRequestSize,</div><div class="line">                                                                         now);</div><div class="line">        <span class="comment">//note: 保证一个 tp 只有一个 RecordBatch 在发送,保证有序性</span></div><div class="line">        <span class="comment">//note: max.in.flight.requests.per.connection 设置为1时会保证</span></div><div class="line">        <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</div><div class="line">            <span class="comment">// Mute all the partitions draine</span></div><div class="line">            <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</div><div class="line">                <span class="keyword">for</span> (RecordBatch batch : batchList)</div><div class="line">                    <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//note: 将由于元数据不可用而导致发送超时的 RecordBatch 移除</span></div><div class="line">        List&lt;RecordBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.abortExpiredBatches(<span class="keyword">this</span>.requestTimeout, now);</div><div class="line">        <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</div><div class="line">            <span class="keyword">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</div><div class="line"></div><div class="line">        sensors.updateProduceRequestMetrics(batches);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</div><div class="line">        <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</div><div class="line">            log.trace(<span class="string">"Nodes with data ready to send: &#123;&#125;"</span>, result.readyNodes);</div><div class="line">            pollTimeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//note: Step4 发送 RecordBatch</span></div><div class="line">        sendProduceRequests(batches, now);</div><div class="line"></div><div class="line">        <span class="comment">//note: 如果有 partition 可以立马发送数据,那么 pollTimeout 为0.</span></div><div class="line">        <span class="comment">//note: Step5 关于 socket 的一些实际的读写操作</span></div><div class="line">        <span class="keyword">this</span>.client.poll(pollTimeout, now);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>Sender.run()</code> 的大概流程总共有以下五步：</p>
<ol>
<li><code>accumulator.ready()</code>：遍历所有的 tp（topic-partition），如果其对应的 RecordBatch 可以发送（大小达到 <code>batch.size</code> 大小或时间达到 <code>linger.ms</code>），就将其对应的 leader 选出来，最后会返回一个可以发送 Produce request 的 <code>Set&lt;Node&gt;</code>（实际返回的是 <code>ReadyCheckResult</code> 实例，不过 <code>Set&lt;Node&gt;</code> 是最主要的成员变量）；</li>
<li>如果发现有 tp 没有 leader，那么这里就调用 <code>requestUpdate()</code> 方法更新 metadata，实际上还是在第一步对 tp 的遍历中，遇到没有 leader 的 tp 就将其加入到一个叫做  <code>unknownLeaderTopics</code> 的 set 中，然后会请求这个 tp 的 meta（meta 的更新策略可以参考之前的一篇博客 <a href="http://matt33.com/2017/07/08/kafka-producer-metadata/#Producer-Metadata-的更新策略">Producer Metadata 的更新策略</a>）；</li>
<li><code>accumulator.drain()</code>：遍历每个 leader （第一步中选出）上的所有 tp，如果该 tp 对应的 RecordBatch 不在 backoff 期间（没有重试过，或者重试了但是间隔已经达到了 retryBackoffMs ），并且加上这个 RecordBatch 其大小不超过 maxSize（一个 request 的最大限制，默认为 1MB），那么就把这个 RecordBatch 添加 list 中，最终返回的类型为 <code>Map&lt;Integer, List&lt;RecordBatch&gt;&gt;</code>，key 为 leader.id，value 为要发送的 RecordBatch 的列表；</li>
<li><code>sendProduceRequests()</code>：发送 Produce 请求，从图中，可以看出，这个方法会调用 <code>NetworkClient.send()</code> 来发送 clientRequest；</li>
<li><code>NetworkClient.poll()</code>：关于 socket 的 IO 操作都是在这个方法进行的，它还是调用 Selector 进行的相应操作，而 Selector 底层则是封装的 Java NIO 的相关接口，这个下面会详细讲述。</li>
</ol>
<p>在第三步中，可以看到，如果要向一个 leader 发送 Produce 请求，那么这 leader 对应 tp，如果其 RecordBatch 没有达到要求（<code>batch.size</code> 或 <code>linger.ms</code> 都没达到）还是可能会发送，这样做的好处是：可以减少 request 的频率，有利于提供发送效率。</p>
<h2 id="NetworkClient-poll"><a href="#NetworkClient-poll" class="headerlink" title="NetworkClient.poll()"></a>NetworkClient.poll()</h2><p>这个方法也是一个非常重要的方法，其作用简单来说有三点：</p>
<ul>
<li>如果需要更新 Metadata，那么就发送 Metadata 请求；</li>
<li>调用 Selector 进行相应的 IO 操作；</li>
<li>处理 Server 端的 response 及一些其他的操作。</li>
</ul>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="comment">//note: Step1 判断是否需要更新 meta,如果需要就更新（请求更新 metadata 的地方）</span></div><div class="line">        <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);</div><div class="line">        <span class="comment">//note: Step2 调用 Selector.poll() 进行 socket 相关的 IO 操作</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"Unexpected error during I/O"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//note: Step3 处理完成后的操作</span></div><div class="line">        <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</div><div class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        handleAbortedSends(responses);</div><div class="line">        <span class="comment">//note: 处理已经完成的 send（不需要 response 的 request,如 send）</span></div><div class="line">        handleCompletedSends(responses, updatedNow);<span class="comment">//note: 通过 selector 中获取 Server 端的 response</span></div><div class="line">        <span class="comment">//note: 处理从 server 端接收到 Receive（如 Metadata 请求）</span></div><div class="line">        handleCompletedReceives(responses, updatedNow);<span class="comment">//note: 在返回的 handler 中，会处理 metadata 的更新</span></div><div class="line">        <span class="comment">//note: 处理连接失败那些连接,重新请求 meta</span></div><div class="line">        handleDisconnections(responses, updatedNow);</div><div class="line">        <span class="comment">//note: 处理新建立的那些连接（还不能发送请求,比如:还未认证）</span></div><div class="line">        handleConnections();</div><div class="line">        handleInitiateApiVersionRequests(updatedNow);</div><div class="line">        handleTimedOutRequests(responses, updatedNow);</div><div class="line"></div><div class="line">        <span class="comment">// invoke callbacks</span></div><div class="line">        <span class="keyword">for</span> (ClientResponse response : responses) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response.onComplete();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                log.error(<span class="string">"Uncaught error in request completion:"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> responses;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法大致分为三步，这里详述讲述一下：</p>
<ol>
<li><code>metadataUpdater.maybeUpdate()</code>：如果 Metadata 需要更新，那么就选择连接数最小的 node，发送 Metadata 请求，详细流程可以参考之前那篇博客<a href="http://matt33.com/2017/07/08/kafka-producer-metadata/#Producer-的-Metadata-更新流程">Producer 的 Metadata 更新流程</a>；</li>
<li><code>selector.poll()</code>：进行 socket IO 相关的操作，下面会详细讲述；</li>
<li>process completed actions：在一个 <code>select()</code> 过程之后的相关处理。<ul>
<li><code>handleAbortedSends(responses)</code>：处理那么在发送过程出现 <code>UnsupportedVersionException</code> 异常的 request；</li>
<li><code>handleCompletedSends(responses, updatedNow)</code>：处理那些已经完成的 request，如果是那些不需要 response 的 request 的话，这里直接调用 <code>request.completed()</code>，标志着这个 request 发送处理完成；</li>
<li><code>handleCompletedReceives(responses, updatedNow)</code>：处理那些从 Server 端接收的 Receive，metadata 更新就是在这里处理的（以及 <code>ApiVersionsResponse</code>）；</li>
<li><code>handleDisconnections(responses, updatedNow)</code>：处理连接失败那些连接,重新请求 metadata；</li>
<li><code>handleConnections()</code>：处理新建立的那些连接（还不能发送请求,比如:还未认证）；</li>
<li><code>handleInitiateApiVersionRequests(updatedNow)</code>：对那些新建立的连接，发送 apiVersionRequest（默认情况：第一次建立连接时，需要向 Broker 发送 ApiVersionRequest 请求）；</li>
<li><code>handleTimedOutRequests(responses, updatedNow)</code>：处理 timeout 的连接，关闭该连接，并刷新 Metadata。</li>
</ul>
</li>
</ol>
<h2 id="Selector-poll"><a href="#Selector-poll" class="headerlink" title="Selector.poll()"></a>Selector.poll()</h2><p> Selector 类是 Kafka 对 Java NIO 相关接口的封装，socket IO 相关的操作都是这个类中完成的，这里先看一下 <code>poll()</code> 方法，主要的操作都是这个方法中调用的，其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout should be &gt;= 0"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//note: Step1 清除相关记录</span></div><div class="line">        clear();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())</div><div class="line">            timeout = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* check ready keys */</span></div><div class="line">        <span class="comment">//note: Step2 获取就绪事件的数</span></div><div class="line">        <span class="keyword">long</span> startSelect = time.nanoseconds();</div><div class="line">        <span class="keyword">int</span> readyKeys = select(timeout);</div><div class="line">        <span class="keyword">long</span> endSelect = time.nanoseconds();</div><div class="line">        <span class="keyword">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</div><div class="line"></div><div class="line">        <span class="comment">//note: Step3 处理 io 操作</span></div><div class="line">        <span class="keyword">if</span> (readyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty()) &#123;</div><div class="line">            pollSelectionKeys(<span class="keyword">this</span>.nioSelector.selectedKeys(), <span class="keyword">false</span>, endSelect);</div><div class="line">            pollSelectionKeys(immediatelyConnectedKeys, <span class="keyword">true</span>, endSelect);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//note: Step4 将处理得到的 stagedReceives 添加到 completedReceives 中</span></div><div class="line">        addToCompletedReceives();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endIo = time.nanoseconds();</div><div class="line">        <span class="keyword">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</div><div class="line"></div><div class="line">        <span class="comment">// we use the time at the end of select to ensure that we don't close any connections that</span></div><div class="line">        <span class="comment">// have just been processed in pollSelectionKeys</span></div><div class="line">        <span class="comment">//note: 每次 poll 之后会调用一次</span></div><div class="line">        <span class="comment">//<span class="doctag">TODO:</span> 连接虽然关闭了,但是 Client 端的缓存依然存在</span></div><div class="line">        maybeCloseOldestConnection(endSelect);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>Selector.poll()</code> 方法会进行四步操作，这里分别来介绍一些。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p><code>clear()</code> 方法是在每次 <code>poll()</code> 执行的第一步，它作用的就是清理上一次 poll 过程产生的部分缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 每次 poll 调用前都会清除以下缓存</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.completedSends.clear();</div><div class="line">    <span class="keyword">this</span>.completedReceives.clear();</div><div class="line">    <span class="keyword">this</span>.connected.clear();</div><div class="line">    <span class="keyword">this</span>.disconnected.clear();</div><div class="line">    <span class="comment">// Remove closed channels after all their staged receives have been processed or if a send was requested</span></div><div class="line">    <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, KafkaChannel&gt;&gt; it = closingChannels.entrySet().iterator(); it.hasNext(); ) &#123;</div><div class="line">        KafkaChannel channel = it.next().getValue();</div><div class="line">        Deque&lt;NetworkReceive&gt; deque = <span class="keyword">this</span>.stagedReceives.get(channel);</div><div class="line">        <span class="keyword">boolean</span> sendFailed = failedSends.remove(channel.id());</div><div class="line">        <span class="keyword">if</span> (deque == <span class="keyword">null</span> || deque.isEmpty() || sendFailed) &#123;</div><div class="line">            doClose(channel, <span class="keyword">true</span>);</div><div class="line">            it.remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.disconnected.addAll(<span class="keyword">this</span>.failedSends);</div><div class="line">    <span class="keyword">this</span>.failedSends.clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><p>Selector 的 <code>select()</code> 方法在实现上底层还是调用 Java NIO 原生的接口，这里的 <code>nioSelector</code> 其实就是 <code>java.nio.channels.Selector</code> 的实例对象，这个方法最坏情况下，会阻塞 ms 的时间，如果在一次轮询，只要有一个 Channel 的事件就绪，它就会立马返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> ms)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ms &lt; <span class="number">0L</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout should be &gt;= 0"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ms == <span class="number">0L</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nioSelector.selectNow();</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nioSelector.select(ms);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="pollSelectionKeys"><a href="#pollSelectionKeys" class="headerlink" title="pollSelectionKeys()"></a>pollSelectionKeys()</h3><p>这部分是 socket IO 的主要部分，发送 Send 及接收 Receive 都是在这里完成的，在 <code>poll()</code> 方法中，这个方法会调用两次：</p>
<ol>
<li>第一次调用的目的是：处理已经就绪的事件，进行相应的 IO 操作；</li>
<li>第二次调用的目的是：处理新建立的那些连接，添加缓存及传输层（Kafka 又封装了一次，这里后续文章会讲述）的握手与认证。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pollSelectionKeys</span><span class="params">(Iterable&lt;SelectionKey&gt; selectionKeys,</span></span></div><div class="line">                                   <span class="keyword">boolean</span> isImmediatelyConnected,</div><div class="line">                                   <span class="keyword">long</span> currentTimeNanos) &#123;</div><div class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            SelectionKey key = iterator.next();</div><div class="line">            iterator.remove();</div><div class="line">            KafkaChannel channel = channel(key);</div><div class="line"></div><div class="line">            <span class="comment">// register all per-connection metrics at once</span></div><div class="line">            sensors.maybeRegisterConnectionMetrics(channel.id());</div><div class="line">            <span class="keyword">if</span> (idleExpiryManager != <span class="keyword">null</span>)</div><div class="line">                idleExpiryManager.update(channel.id(), currentTimeNanos);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                <span class="comment">/* complete any connections that have finished their handshake (either normally or immediately) */</span></div><div class="line">                <span class="comment">//note: 处理一些刚建立 tcp 连接的 channel</span></div><div class="line">                <span class="keyword">if</span> (isImmediatelyConnected || key.isConnectable()) &#123;</div><div class="line">                    <span class="keyword">if</span> (channel.finishConnect()) &#123;<span class="comment">//note: 连接已经建立</span></div><div class="line">                        <span class="keyword">this</span>.connected.add(channel.id());</div><div class="line">                        <span class="keyword">this</span>.sensors.connectionCreated.record();</div><div class="line">                        SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">                        log.debug(<span class="string">"Created socket with SO_RCVBUF = &#123;&#125;, SO_SNDBUF = &#123;&#125;, SO_TIMEOUT = &#123;&#125; to node &#123;&#125;"</span>,</div><div class="line">                                socketChannel.socket().getReceiveBufferSize(),</div><div class="line">                                socketChannel.socket().getSendBufferSize(),</div><div class="line">                                socketChannel.socket().getSoTimeout(),</div><div class="line">                                channel.id());</div><div class="line">                    &#125; <span class="keyword">else</span></div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/* if channel is not ready finish prepare */</span></div><div class="line">                <span class="comment">//note: 处理 tcp 连接还未完成的连接,进行传输层的握手及认证</span></div><div class="line">                <span class="keyword">if</span> (channel.isConnected() &amp;&amp; !channel.ready())</div><div class="line">                    channel.prepare();</div><div class="line"></div><div class="line">                <span class="comment">/* if channel is ready read from any connections that have readable data */</span></div><div class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;</div><div class="line">                    NetworkReceive networkReceive;</div><div class="line">                    <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="keyword">null</span>)<span class="comment">//note: 知道读取一个完整的 Receive,才添加到集合中</span></div><div class="line">                        addToStagedReceives(channel, networkReceive);<span class="comment">//note: 读取数据</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/* if channel is ready write to any sockets that have space in their buffer and for which we have data */</span></div><div class="line">                <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</div><div class="line">                    Send send = channel.write();</div><div class="line">                    <span class="keyword">if</span> (send != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">this</span>.completedSends.add(send);<span class="comment">//note: 将完成的 send 添加到 list 中</span></div><div class="line">                        <span class="keyword">this</span>.sensors.recordBytesSent(channel.id(), send.size());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/* cancel any defunct sockets */</span></div><div class="line">                <span class="comment">//note: 关闭断开的连接</span></div><div class="line">                <span class="keyword">if</span> (!key.isValid())</div><div class="line">                    close(channel, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                String desc = channel.socketDescription();</div><div class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException)</div><div class="line">                    log.debug(<span class="string">"Connection with &#123;&#125; disconnected"</span>, desc, e);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    log.warn(<span class="string">"Unexpected error from &#123;&#125;; closing connection"</span>, desc, e);</div><div class="line">                close(channel, <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="addToCompletedReceives"><a href="#addToCompletedReceives" class="headerlink" title="addToCompletedReceives()"></a>addToCompletedReceives()</h3><p>这个方法的目的是处理接收到的 Receive，由于 Selector 这个类在 Client 和 Server 端都会调用，这里分两种情况讲述一下：</p>
<ol>
<li>应用在 Server 端时，后续文章会详细介绍，这里简单说一下，Server 为了保证消息的时序性，在 Selector 中提供了两个方法：<code>mute(String id)</code> 和 <code>unmute(String id)</code>，对该 KafkaChannel 做标记来保证同时只能处理这个 Channel 的一个 request（可以理解为排它锁）。当 Server 端接收到 request 后，先将其放入 <code>stagedReceives</code> 集合中，此时该 Channel 还未 mute，这个 Receive 会被放入 <code>completedReceives</code> 集合中。Server 在对 <code>completedReceives</code> 集合中的 request 进行处理时，会先对该 Channel mute，处理后的 response 发送完成后再对该 Channel unmute，然后才能处理该 Channel 其他的请求；</li>
<li>应用在 Client 端时，Client 并不会调用 Selector 的 <code>mute()</code> 和 <code>unmute()</code> 方法，client 的时序性而是通过 <code>InFlightRequests</code> 和 RecordAccumulator 的 <code>mutePartition</code> 来保证的（下篇文章会讲述），因此对于 Client 端而言，这里接收到的所有 Receive 都会被放入到 <code>completedReceives</code> 的集合中等待后续处理。</li>
</ol>
<p>这个方法只有配合 Server 端的调用才能看明白其作用，它统一 Client 和 Server 调用的 api，使得都可以使用 Selector 这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * checks if there are any staged receives and adds to completedReceives</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToCompletedReceives</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stagedReceives.isEmpty()) &#123;<span class="comment">//note: 处理 stagedReceives</span></div><div class="line">        Iterator&lt;Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt;&gt; iter = <span class="keyword">this</span>.stagedReceives.entrySet().iterator();</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; entry = iter.next();</div><div class="line">            KafkaChannel channel = entry.getKey();</div><div class="line">            <span class="keyword">if</span> (!channel.isMute()) &#123;</div><div class="line">                Deque&lt;NetworkReceive&gt; deque = entry.getValue();</div><div class="line">                addToCompletedReceives(channel, deque);</div><div class="line">                <span class="keyword">if</span> (deque.isEmpty())</div><div class="line">                    iter.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToCompletedReceives</span><span class="params">(KafkaChannel channel, Deque&lt;NetworkReceive&gt; stagedDeque)</span> </span>&#123;</div><div class="line">    NetworkReceive networkReceive = stagedDeque.poll();</div><div class="line">    <span class="keyword">this</span>.completedReceives.add(networkReceive); <span class="comment">//note: 添加到 completedReceives 中</span></div><div class="line">    <span class="keyword">this</span>.sensors.recordBytesReceived(channel.id(), networkReceive.payload().limit());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Network-send-方法"><a href="#Network-send-方法" class="headerlink" title="Network.send() 方法"></a>Network.send() 方法</h2><p>至此，文章的主要内容已经讲述得差不多了，第二张图中最上面的那个调用关系已经讲述完，下面讲述一下另外一个小分支，也就是从 <code>Sender.run()</code> 调用 <code>NetworkClient.send()</code> 开始的那部分，其调用过程如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sender.run()</div><div class="line">Sender.sendProduceRequests()</div><div class="line">NetworkClient.send()</div><div class="line">NetworkClient.dosend()</div><div class="line">Selector.send()</div><div class="line">KafkaChannel.setSend()</div></pre></td></tr></table></figure>
<h3 id="NetworkClient-dosend"><a href="#NetworkClient-dosend" class="headerlink" title="NetworkClient.dosend()"></a>NetworkClient.dosend()</h3><p>Producer 端的请求都是通过 <code>NetworkClient.dosend()</code> 来发送的，其作用就是：</p>
<ul>
<li>检查版本信息，并根据 <code>apiKey()</code> 构建 Request；</li>
<li>创建 <code>NetworkSend</code> 实例；</li>
<li>调用 <code>Selector.send</code> 发送该 Send。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 发送请求</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSend</span><span class="params">(ClientRequest clientRequest, <span class="keyword">boolean</span> isInternalRequest, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        String nodeId = clientRequest.destination();</div><div class="line">        <span class="keyword">if</span> (!isInternalRequest) &#123;</div><div class="line">            <span class="comment">// If this request came from outside the NetworkClient, validate</span></div><div class="line">            <span class="comment">// that we can send data.  If the request is internal, we trust</span></div><div class="line">            <span class="comment">// that that internal code has done this validation.  Validation</span></div><div class="line">            <span class="comment">// will be slightly different for some internal requests (for</span></div><div class="line">            <span class="comment">// example, ApiVersionsRequests can be sent prior to being in</span></div><div class="line">            <span class="comment">// READY state.)</span></div><div class="line">            <span class="keyword">if</span> (!canSendRequest(nodeId))</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Attempt to send a request to node "</span> + nodeId + <span class="string">" which is not ready."</span>);</div><div class="line">        &#125;</div><div class="line">        AbstractRequest request = <span class="keyword">null</span>;</div><div class="line">        AbstractRequest.Builder&lt;?&gt; builder = clientRequest.requestBuilder();</div><div class="line">        <span class="comment">//note: 构建 AbstractRequest, 检查其版本信息</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            NodeApiVersions versionInfo = nodeApiVersions.get(nodeId);</div><div class="line">            <span class="comment">// Note: if versionInfo is null, we have no server version information. This would be</span></div><div class="line">            <span class="comment">// the case when sending the initial ApiVersionRequest which fetches the version</span></div><div class="line">            <span class="comment">// information itself.  It is also the case when discoverBrokerVersions is set to false.</span></div><div class="line">            <span class="keyword">if</span> (versionInfo == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (discoverBrokerVersions &amp;&amp; log.isTraceEnabled())</div><div class="line">                    log.trace(<span class="string">"No version information found when sending message of type &#123;&#125; to node &#123;&#125;. "</span> +</div><div class="line">                            <span class="string">"Assuming version &#123;&#125;."</span>, clientRequest.apiKey(), nodeId, builder.version());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">short</span> version = versionInfo.usableVersion(clientRequest.apiKey());</div><div class="line">                builder.setVersion(version);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// The call to build may also throw UnsupportedVersionException, if there are essential</span></div><div class="line">            <span class="comment">// fields that cannot be represented in the chosen version.</span></div><div class="line">            request = builder.build();<span class="comment">//note: 当为 Produce 请求时,转化为 ProduceRequest,Metadata 请求时,转化为 Metadata 请求</span></div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedVersionException e) &#123;</div><div class="line">            <span class="comment">// If the version is not supported, skip sending the request over the wire.</span></div><div class="line">            <span class="comment">// Instead, simply add it to the local queue of aborted requests.</span></div><div class="line">            log.debug(<span class="string">"Version mismatch when attempting to send &#123;&#125; to &#123;&#125;"</span>,</div><div class="line">                    clientRequest.toString(), clientRequest.destination(), e);</div><div class="line">            ClientResponse clientResponse = <span class="keyword">new</span> ClientResponse(clientRequest.makeHeader(),</div><div class="line">                    clientRequest.callback(), clientRequest.destination(), now, now,</div><div class="line">                    <span class="keyword">false</span>, e, <span class="keyword">null</span>);</div><div class="line">            abortedSends.add(clientResponse);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        RequestHeader header = clientRequest.makeHeader();</div><div class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">int</span> latestClientVersion = ProtoUtils.latestVersion(clientRequest.apiKey().id);</div><div class="line">            <span class="keyword">if</span> (header.apiVersion() == latestClientVersion) &#123;</div><div class="line">                log.trace(<span class="string">"Sending &#123;&#125; to node &#123;&#125;."</span>, request, nodeId);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                log.debug(<span class="string">"Using older server API v&#123;&#125; to send &#123;&#125; to node &#123;&#125;."</span>,</div><div class="line">                    header.apiVersion(), request, nodeId);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//note: Send是一个接口，这里返回的是 NetworkSend，而 NetworkSend 继承 ByteBufferSend</span></div><div class="line">        Send send = request.toSend(nodeId, header);</div><div class="line">        InFlightRequest inFlightRequest = <span class="keyword">new</span> InFlightRequest(</div><div class="line">                header,</div><div class="line">                clientRequest.createdTimeMs(),</div><div class="line">                clientRequest.destination(),</div><div class="line">                clientRequest.callback(),</div><div class="line">                clientRequest.expectResponse(),</div><div class="line">                isInternalRequest,</div><div class="line">                send,</div><div class="line">                now);</div><div class="line">        <span class="keyword">this</span>.inFlightRequests.add(inFlightRequest);</div><div class="line">        <span class="comment">//note: 将 send 和对应 kafkaChannel 绑定起来，并开启该 kafkaChannel 底层 socket 的写事件</span></div><div class="line">        selector.send(inFlightRequest.send);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Selector-send"><a href="#Selector-send" class="headerlink" title="Selector.send()"></a>Selector.send()</h3><p>这个方法就比较容易理解了，它的作用就是获取该 Send 对应的 KafkaChannel，调用 <code>setSend()</code> 向 KafkaChannel 注册一个 <code>Write</code> 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 发送请求</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Send send)</span> </span>&#123;</div><div class="line">    String connectionId = send.destination();</div><div class="line">    <span class="keyword">if</span> (closingChannels.containsKey(connectionId))</div><div class="line">        <span class="keyword">this</span>.failedSends.add(connectionId);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        KafkaChannel channel = channelOrFail(connectionId, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            channel.setSend(send);</div><div class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</div><div class="line">            <span class="keyword">this</span>.failedSends.add(connectionId);</div><div class="line">            close(channel, <span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="KafkaChannel-setSend"><a href="#KafkaChannel-setSend" class="headerlink" title="KafkaChannel.setSend()"></a>KafkaChannel.setSend()</h3><p><code>setSend()</code> 方法需要配合 <code>write()</code>（该方法是在 <code>Selector.poll()</code> 中调用的） 方法一起来看</p>
<ul>
<li><code>setSend()</code>：将当前 KafkaChannel 的 Send 赋值为要发送的 Send，并注册一个 <code>OP_WRITE</code> 事件；</li>
<li><code>write()</code>：发送当前的 Send，发送完后删除注册的 <code>OP_WRITE</code> 事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 每次调用时都会注册一个 OP_WRITE 事件</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSend</span><span class="params">(Send send)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.send != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Attempt to begin a send operation with prior send operation still in progress."</span>);</div><div class="line">    <span class="keyword">this</span>.send = send;</div><div class="line">    <span class="keyword">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//note: 调用 send() 发送 Send</span></div><div class="line"><span class="function"><span class="keyword">public</span> Send <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Send result = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (send != <span class="keyword">null</span> &amp;&amp; send(send)) &#123;</div><div class="line">        result = send;</div><div class="line">        send = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//note: 发送完成后,就删除这个 WRITE 事件</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">(Send send)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    send.writeTo(transportLayer);</div><div class="line">    <span class="keyword">if</span> (send.completed())</div><div class="line">        transportLayer.removeInterestOps(SelectionKey.OP_WRITE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> send.completed();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，简单总结一下，可以回过头再看一下第一张图，对于 KafkaProducer 而言，其直接调用是 Sender，而 Sender 底层调用的是 NetworkClient，NetworkClient 则是通过 Selector 实现，Selector 则是对 Java NIO 原生接口的封装。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52636762" target="_blank" rel="external">Kafka源码深度解析－序列3 －Producer －Java NIO</a></li>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52651960" target="_blank" rel="external"> Kafka源码深度解析－序列4 －Producer －network层核心原理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 Kafka 源码解析的第四篇，在写这篇文章之前，专门看了一下 Java NIO 相关的内容，只有理解了 Java NIO 模型才能更好地理解 NIO 在 Kafka 中是如何应用的以及 Producer 如何利用 Java NIO 构建其网络模型（不了解的，可以先看
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈 Java IO 模型</title>
    <link href="http://matt33.com/2017/08/12/java-nio/"/>
    <id>http://matt33.com/2017/08/12/java-nio/</id>
    <published>2017-08-12T09:51:56.000Z</published>
    <updated>2017-08-18T14:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java IO 模型对于 Java 开发工程师来说，是日常工作中经常接触的内容，特别是随着分布式系统的兴起，IO 也显得越来越重要，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现，不熟悉这一部分内容的话，可以先看一下上篇文章<a href="http://matt33.com/2017/08/06/unix-io/">Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</a>，本文跟上篇的内容是紧密相连的，特别是本文的重点 —— Java NIO 部分，其底层原理就是 UNIX 的 IO 多路复用，IO 多路复用在上篇文章中讲述了很多。</p>
<p>这篇文章大概内容如下：</p>
<ol>
<li>Java IO 模型的简单介绍；</li>
<li>BIO 、NIO、AIO 模型的介绍，会详细介绍 NIO；</li>
<li>几种 IO 模型的对比。</li>
</ol>
<h1 id="Java-IO-模型介绍"><a href="#Java-IO-模型介绍" class="headerlink" title="Java IO 模型介绍"></a>Java IO 模型介绍</h1><p>在 JDK 推出 Java NIO 之前，基于 Java 的所有 Socket 通信都采用了同步阻塞模式（BIO），这种一对一的通信模型虽然简化了开发的难度，但在性能和可靠性方面却存在这巨大的瓶颈，特别是无法处理高并发的场景，使得 Java 在服务器端应用十分有限。</p>
<p>正是由于 Java 传统 BIO 的拙劣表现，使得 Java 不得不去开发新版的 IO 模型，最终，JDK1.4 提供了新的 NIO 类库，Java 可以支持非阻塞 IO；之后，JDK1.7 正式发布，不但对 NIO 进行了升级，还提供了 AIO 功能。本文就是在对 Java 这些 IO 模型学习后，总结的一篇笔记。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>网络编程的基本模型是 Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的 IP 地址和端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接成功，双方就可以通过网络套接字（socket）进行通信（可以参考<a href="http://localhost:8080/2016/08/30/http-protocol/" target="_blank" rel="external">TCP的三次握手和四次挥手</a>），下面先看一下两种对 IO 模型常见的分类方式。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>描述的是用户线程与内核的交互方式，与消息的通知机制有关：</p>
<ol>
<li>同步：当一个同步调用发出后，需要等待返回消息（用户线程不断去询问），才能继续进行；</li>
<li>异步：当一个异步调用发出后，调用者不能立即得到返回消息，完成后会通过状态、通知和回调来通知调用者。</li>
</ol>
<p>简单来说就是：</p>
<ol>
<li>同步：同步等待消息通知，消息返回才能继续进行；</li>
<li>异步：异步等待消息通知，完成后被调系统通过回调等来通过调用者。</li>
</ol>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞指的是不能立刻得到结果之前，会不会阻塞当前线程。</p>
<ol>
<li>阻塞：当前线程会被挂起，直到结果返回；</li>
<li>非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（会导致线程切换的增加）。</li>
</ol>
<p>举个栗子说明：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>示例</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td>在银行排队，不干别的事情</td>
<td>效率最低</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>排队时，边打电话边抬头看是否到自己了</td>
<td>效率低下</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>在银行领一个号后，在银行里等，不能做别的事情</td>
<td></td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>领完号后，在忙着自己的事情，直到柜台通知</td>
<td>效率较高</td>
</tr>
</tbody>
</table>
<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>BIO 模型是 Java IO 最开始提供的一种 IO 模型，BIO 又可以细分为两种模型，一是传统的同步阻塞模型，二是在对传统 BIO 模型的基本上进行的优化，又称为伪异步 IO 模型。</p>
<h2 id="传统的-BIO-模型"><a href="#传统的-BIO-模型" class="headerlink" title="传统的 BIO 模型"></a>传统的 BIO 模型</h2><p>传统 BIO 中，ServerSocket 负责绑定 IP 地址，启动监听端口；Socket 负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞通信。采用 BIO 通信模型的 Server，通常由一个独立的 Acceptor 线程负责监听 Client 端的连接，它接受到 Client 端连接请求后为每个 Client 创建一个新的线程进行处理，处理完之后，通过输出流返回给 Client 端，线程销毁，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="/images/java/BIO.png" alt="传统 Java BIO 模型"></p>
<p>这个模型最大的问题是：</p>
<ul>
<li>缺乏扩展性，不能处理高性能、高并发场景，线程是 JVM 中非常宝贵的资源，当线程数膨胀后，系统的性能就会急剧下降，随着并发访问量的继续增大，系统就会出现线程堆栈溢出、创建新线程失败等问题，导致 Server 不能对外提供服务。</li>
</ul>
<p>示例代码参考 <a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/bio/" target="_blank" rel="external">Java BIO 示例</a>。</p>
<h2 id="伪异步-IO-模型"><a href="#伪异步-IO-模型" class="headerlink" title="伪异步 IO 模型"></a>伪异步 IO 模型</h2><p>为了改进这种一对一的连接模型，后来又演进出了一种通过线程池或者消息队列实现 1 个或者多个线程处理所有 Client 请求的模型，由于它底层依然是同步阻塞 IO，所以被称为【伪异步 IO 模型】。相比于传统 BIO 后端不断创建新的线程处理 Client 请求，它在后端使用一个<strong>线程池</strong>来代替，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程资源耗尽，过程如下图所示（图来自《Netty 权威指南》）。</p>
<p><img src="/images/java/BIO2.png" alt="伪异步 IO 模型"></p>
<p>看似这个模型解决了 BIO 面对的问题，实际上，由于它是面向数据流的模型，底层依然是同步阻塞模型，在处理一个 socket 输入流，它会一直阻塞下去，除非：有数据可读、可用数据读取完毕、有异常，否则会一直一直阻塞下去。这个模型最大的问题是：</p>
<ul>
<li>阻塞的时间取决于对应 IO 线程的处理速度和网络 IO 的传输速度，处理效率不可控。</li>
</ul>
<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><p>Java NIO 是 Java IO 模型中最重要的 IO 模型，也是本文主要讲述的内容，正式由于 NIO 的出现，Java 才能在服务端获得跟 C 和 C++ 一样的运行效率，NIO 是 New IO（或者 Non-block IO）的简称。</p>
<p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同套接字通道的实现，它们都支持阻塞和非阻塞两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞 IO 以降低复杂度，但是高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在 NIO 中有三种非常重要的概念：</p>
<ul>
<li>缓冲区（buffer）：本质上是一个数组，它包含一些要读写的数据；</li>
<li>通道（channel）：是一个通道，通过它读写数据，类似于自来水管；</li>
<li>多路复用器（selector）：用于选择已经就绪的任务，selector 会轮询注册在其上的 channel，选出已经就绪的 channel。</li>
</ul>
<p><img src="/images/java/NIO.png" alt="NIO 的简单模型"></p>
<p>三者之间的关系如上图所示，这里先简单概括一下：</p>
<ul>
<li>Buffer：是缓冲区，任何时候访问 NIO 数据，都是通过 Buffer 进行；</li>
<li>Channel：通过它读写 Buffer 中的数据，可以用于读、写或同时读写；</li>
<li>Selector：多路复用器，Selector 不断轮询注册在其上的 Channel，如果某个 Channel 有新的 TCP 链接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮组出来，然后通过<code>SelectionKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</li>
</ul>
<p>下面详细介绍一下这三个概念。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 是全双工的，可以比流更好地映射底层操作系统的 API，与流也非常相似，有以下几点区别：</p>
<ul>
<li>Channel 可以读也可以写，但流（InputStream 或 OutputStream）是单向的；</li>
<li>通道可以异步读写；</li>
<li>它是基于缓冲区（Buffer）进行读写；</li>
</ul>
<p>在 Java 中提供以下几种 Channel：</p>
<ol>
<li>FileChannel：用于文件的读写；</li>
<li>DatagramChannel：用于 UDP 数据读写；</li>
<li>SocketChannel：用于 Socket 数据读写；</li>
<li>ServerSocketChannel：监听 TCP 连接请求。</li>
</ol>
<p>这些 Channel 类之间的继承关系如下图所示</p>
<p><img src="/images/java/channel.png" alt="Channel 之间的继承关系"></p>
<p>从上图中，可以看出，Channel 可以分为两大类：用于网络读写的 <code>SelectableChannel</code> 和用于文件操作的 <code>FileChannel</code>。</p>
<p>其中，FileChannel 只能在阻塞模式下工作，具体可以参考<a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-filechannel.html" target="_blank" rel="external">Java NIO FileChannel文件通道</a>。</p>
<h4 id="NIO-Scatter-Gather"><a href="#NIO-Scatter-Gather" class="headerlink" title="NIO Scatter/Gather"></a>NIO Scatter/Gather</h4><p>Java NIO 发布时内置了对 scatter/gather的支持：</p>
<ul>
<li>Scattering read 指的是从通道读取的操作能把数据写入多个 Buffer，也就是 sctters 代表了数据从一个 Channel 到多个 Buffer的过程。</li>
<li>Gathering write 则正好相反，表示的是从多个 Buffer 把数据写入到一个 Channel中。</li>
</ul>
<p><img src="/images/java/scatter-gather.png" alt="Channel 之间的继承关系"></p>
<p>示例如下，具体参考 <a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-scatter-gather.html" target="_blank" rel="external">Java NIO Scatter / Gather</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Scattering read</span></div><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line">channel.read(bufferArray);</div><div class="line"></div><div class="line"><span class="comment">// Gathering write</span></div><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line">channel.write(bufferArray);</div></pre></td></tr></table></figure>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer，本质上是一块内存区，可以用来读写数据，它包含一些要写入或者要读出的数据。在 NIO 中，所有数据都是通过 Buffer 处理的，读取数据时，它是直接读到缓冲区中，写入数据时，写入到缓冲区。</p>
<p>最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组，除了 ByteBuffer，还有其他的一些 Buffer，如：CharBuffer、IntBuffer 等，它们之间的关系如下图所示。</p>
<p><img src="/images/java/buffer.png" alt="Buffer 之间的继承关系"></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Buffer 基本用法（读写数据过程）：</p>
<ol>
<li>把数据写入 Buffer；</li>
<li>调用 <code>flip()</code>，Buffer 由写模式变为读模式；</li>
<li>Buffer 中读取数据；</li>
<li>调用 <code>clear()</code> 清空 buffer，等待下次写入。</li>
</ol>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] req = <span class="string">"QUERY TIME ORDER"</span>.getBytes();</div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(req.length);</div><div class="line">byteBuffer.put(req);</div><div class="line">byteBuffer.flip();</div><div class="line"><span class="keyword">while</span> (byteBuffer.hasRemaining())&#123;</div><div class="line">     System.out.println((<span class="keyword">char</span>) byteBuffer.get());</div><div class="line">&#125;</div><div class="line">byteBuffer.clear();</div></pre></td></tr></table></figure>
<h4 id="Buffer-位置信息"><a href="#Buffer-位置信息" class="headerlink" title="Buffer 位置信息"></a>Buffer 位置信息</h4><p>Buffer 实质上就是一块内存，用于读写数据，这块内存被 NIO Buffer 管理，一个 Buffer 有三个属性是必须掌握的，分别是：</p>
<ul>
<li>capacity：容量；</li>
<li>position：位置；</li>
<li>limit：限制；</li>
</ul>
<p>其中，position 和 limit 的具体含义取决于当前 buffer 的模式，capacity 在两种模式下都表示容量，Buffer 读模式和写模式如下图所示。</p>
<p><img src="/images/java/buffer-position.png" alt="Buffer 的位置信息"></p>
<ol>
<li>容量（capacity）<ul>
<li>Buffer 有一块固定的内存，其大小就是 capacity，一旦 Buffer 写满，就需要清空已读数据以便下次继续写入新的数据；</li>
</ul>
</li>
<li>位置（Position）<ul>
<li>写模式时，当写入数据到 Buffer 的时候从一个确定的位置开始，初始化时这个位置 position 为0，写入数据后，position 的值就会指向数据之后的单元，position 最大的值可以达到 <code>capacity-1</code>；</li>
<li>读模式时，也需要从一个确定的位置开始，Buffer 从写模式变为读模式时，position 会归零，每次读取后，position 向后移动；</li>
</ul>
</li>
<li>上限（limit）<ul>
<li>写模式时，limit 就是能写入的最大数据量，等同于 Buffer 的容量；</li>
<li>读模式时，limit 代表我们能读取的最大容量，它的值等同于写模式下 position 位置。</li>
</ul>
</li>
</ol>
<h4 id="Buffer-常用方法"><a href="#Buffer-常用方法" class="headerlink" title="Buffer 常用方法"></a>Buffer 常用方法</h4><ul>
<li><code>flip()</code>：把 buffer 从模式调整为读模式，在读模式下，可以读取所有已经写入的数据；</li>
<li><code>clear()</code>：清空整个 buffer；</li>
<li><code>compact()</code>：只清空已读取的数据，未被读取的数据会被移动到 buffer 的开始位置，写入位置则紧跟着未读数据之后；</li>
<li><code>rewind()</code>：将 position 置为0，这样我们可以重复读取 Buffer 中的数据，limit 保持不变；</li>
<li><code>mark()</code>和<code>reset()</code>：通过mark方法可以标记当前的position，通过reset来恢复mark的位置</li>
<li><code>equals()</code>：判断两个 Buffer 是否相等，需满足：类型相同、Buffer 中剩余字节数相同、所有剩余字节相等；</li>
<li><code>compareTo()</code>：compareTo 比较 Buffer 中的剩余元素，只不过这个方法适用于比较排序的。</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector 是 Java NIO 核心部分，简单来说，它的作用就是：Selector 不断轮询注册在其上的 Channel，如果某个 Channel 上面有新的 TCP 连接、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 <code>SelectorKey()</code> 可以获取就绪 Channel 的集合，进行后续的 IO 操作。</p>
<p>一个 Selector 可以轮询多个 Channel，由于 JDK 底层使用了 <code>epoll()</code> 实现，它并没有最大连接句柄 1024/2048 的限制，这就意味着只需要一个线程负责 Selector 的轮询，就可以连接上千上万的 Client。</p>
<h4 id="注册-Channel"><a href="#注册-Channel" class="headerlink" title="注册 Channel"></a>注册 Channel</h4><p>举一个栗子，简单介绍 <code>Selector</code> 的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 Selector</span></div><div class="line">Selector selector = Selector.open();</div><div class="line"><span class="comment">// 将一个 Channel 注册到 Selector 上</span></div><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</div></pre></td></tr></table></figure>
<p><code>register()</code> 的第二个参数代表的是 selector 监听的事件类型，Selector 可以监听事件类型总共有以下四种：</p>
<ol>
<li>SelectionKey.OP_CONNECT：只会注册一次，成功之后（TCP 连接建立之后），这个监听事件就取消了；</li>
<li>SelectionKey.OP_ACCEPT：主要用于服务端，就是监听是否有新的连接请求；</li>
<li>SelectionKey.OP_READ：注册之后不会取消，监听是否数据到来；</li>
<li>SelectionKey.OP_WRITE：最好的使用方法是每当发送数据时，就注册一次，然后再取消，否则每次 select 轮询时，注册 OP_WRITE 事件的 Channel 都是 ready 的，除非 socket send buffer 满了（参考 <a href="https://stackoverflow.com/questions/23136079/communicating-between-nio-op-read-and-op-write-operations" target="_blank" rel="external">Communicating between nio OP_READ and OP_WRITE operations</a>）。</li>
</ol>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p><code>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</code> 返回的是已经就绪的 Channel 集合，<code>SelectionKey</code> 对象的详细属性如下图所示。</p>
<p><img src="/images/java/SelectionKey.png" alt="SelectionKey 的详情"></p>
<h2 id="NIO-原理"><a href="#NIO-原理" class="headerlink" title="NIO 原理"></a>NIO 原理</h2><p>Java NIO 实现的关键是 IO 多路复用（具体可以参考上篇文章：<a href="http://matt33.com/2017/08/06/unix-io/#Linux-的-IO-多路复用模型">Linux 的 IO 多路复用模型</a>），在 Linux 平台，Java NIO 是基于 epoll（2.6以上，之前是 Select） 来实现的。</p>
<p>Linux 的 select/epoll  使用的是 Reactor 网络 IO 模式。网络编程中，有两种常用的设计模式，它们都是基于事件驱动：</p>
<ul>
<li>Reactor 模式：主动模式，应用程序不断去轮询，问操作系统 IO 是否就绪，实际的 IO 操作还是由应用实现（IO 多路复用采用的模式）；</li>
<li>Proactor 模式：被动模式，操作系统把 IO 完成后通知应用程序，此时数据已经就绪。</li>
</ul>
<p>这两种模式详细内容可以参考<a href="http://daoluan.net/linux/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2013/08/20/two-high-performance-io-design-patterns.html" target="_blank" rel="external">两种高性能 I/O 设计模式 Reactor 和 Proactor</a>一文。</p>
<h2 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h2><p>关于 Java NIO，有两种最常见的使用方式：</p>
<ul>
<li>使用原生的 Java NIO（如 Kafka）；</li>
<li>使用 Netty（Hadoop 的 RPC 框架 Avro 底层使用 Netty 做通信框架）。</li>
</ul>
<p>在实际使用中，推荐第二种，使用 Netty 将会大大提高开发效率，后续会写篇关于 Netty 的文章，介绍一下 Netty 的具体内容，这里使用一个基于 Java 原生 NIO API 的小示例，讲述一下 NIO 的使用方法。</p>
<h3 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h3><p>NIO Client 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="/images/java/nio-client.png" alt="NIO Client 端序列图"></p>
<p>具体的代码及注释参考：<a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/client/" target="_blank" rel="external">NIO Client 端代码</a>。</p>
<h3 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h3><p>NIO Server 创建序列图如下图所示（图片来自《Netty 权威指南》）。</p>
<p><img src="/images/java/nio-server.png" alt="NIO Server 端序列图"></p>
<p>具体的代码及注释参考：<a href="https://github.com/wangzzu/ProgramlLearn/tree/aab89008091660f1f231763660eb329eb5928bde/java_learn/java_socket/src/main/java/nio/server/" target="_blank" rel="external">NIO Server 端代码</a>。</p>
<h1 id="IO-模型对比"><a href="#IO-模型对比" class="headerlink" title="IO 模型对比"></a>IO 模型对比</h1><p>在对比之前，先简单介绍 Java AIO 模型，这里就不再进行相应的展开了。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>NIO 2.0 中引入异步通道的概念，并提供了异步文件通道和异步套接字导通的实现，它是真正的异步非阻塞I IO，底层是利用事件驱动（AIO）实现，不需要多路复用器（Selector）对注册的通道进行轮组操作即可实现异步读写。</p>
<p>可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/" target="_blank" rel="external">在 Java 7 中体会 NIO.2 异步执行的快乐</a></p>
<h2 id="几种-IO-模型功能和特性对比"><a href="#几种-IO-模型功能和特性对比" class="headerlink" title="几种 IO 模型功能和特性对比"></a>几种 IO 模型功能和特性对比</h2><table>
<thead>
<tr>
<th></th>
<th>传统 BIO</th>
<th>伪异步 IO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>client 数：IO 线程数</td>
<td>1：1</td>
<td>M：N（M 可以大于 N）</td>
<td>M：1</td>
<td>M：0（不需要额外的线程，被动回调）</td>
</tr>
<tr>
<td>IO 类型（阻塞）</td>
<td>阻塞IO</td>
<td>阻塞IO</td>
<td>非阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>IO 类型（同步）</td>
<td>同步 IO</td>
<td>同步 IO</td>
<td>同步 IO（IO 多路复用）</td>
<td>异步 IO</td>
</tr>
<tr>
<td>可靠性</td>
<td>非常差</td>
<td>差</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>本文主要是对 Java IO 模型总结，特别是对 NIO 模型的总结。</p>
<hr>
<p>参考</p>
<ul>
<li>《Netty 权威指南》；</li>
<li>Java NIO <a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="external">英文版</a>，<a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">中文版</a>；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java IO 模型对于 Java 开发工程师来说，是日常工作中经常接触的内容，特别是随着分布式系统的兴起，IO 也显得越来越重要，Java 的 IO 模型本质上还是利用操作系统提供的接口来实现，不熟悉这一部分内容的话，可以先看一下上篇文章&lt;a href=&quot;http://m
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Unix 网络 IO 模型及 Linux 的 IO 多路复用模型</title>
    <link href="http://matt33.com/2017/08/06/unix-io/"/>
    <id>http://matt33.com/2017/08/06/unix-io/</id>
    <published>2017-08-06T14:19:56.000Z</published>
    <updated>2017-08-06T14:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段在看 Kafka 的网络模型时，遇到了很多 Java NIO 的内容，在学习 Java NIO 的过程中，发现需要把 UNIX 的这几种网络 IO 模型以及 Linux 的 IO 多路复用理解清楚，才能更好地理解 Java NIO，本文就是在学习 UNIX 的五种网络 IO 模型以及 Linux IO 多路复用模型后，做的一篇总结。</p>
<p>本文主要探讨的问题有以下两个：</p>
<ol>
<li>Unix 中的五种网络 IO 模型；</li>
<li>Linux 中 IO 多路复用的实现。</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在介绍网络模型之前，先简单介绍一些基本概念。</p>
<h3 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h3><p>文件描述符（file descriptor，简称 fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p>在 Linux 中，内核将所有的外部设备都当做一个文件来进行操作，而对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd，对一个 socket 的读写也会有相应的描述符，称为 socketfd（socket 描述符），实际上描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性）。</p>
<h3 id="用户空间与内核空间、内核态与用户态"><a href="#用户空间与内核空间、内核态与用户态" class="headerlink" title="用户空间与内核空间、内核态与用户态"></a>用户空间与内核空间、内核态与用户态</h3><p>这个是经常提到的概念，具体含义可以参考这篇文章<a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间，进程上下文与中断上下文【总结】</a>，大概内容如下：</p>
<p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 linux 操作系统而言（以32位操作系统为例）</p>
<ul>
<li>将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间；</li>
<li>将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</li>
</ul>
<p>每个进程可以通过系统调用进入内核，因此，Linux 内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<ul>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（<strong>内核态</strong>）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈；</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（<strong>用户态</strong>）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当一个进程在执行时，CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。</p>
<p>当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在 Linux 中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。</p>
<h2 id="UNIX-的网络-IO-模型"><a href="#UNIX-的网络-IO-模型" class="headerlink" title="UNIX 的网络 IO 模型"></a>UNIX 的网络 IO 模型</h2><p>根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了以下 5 种 IO 模型。</p>
<h3 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h3><p>最常用的 IO 模型就是阻塞 IO 模型，在缺省条件下，所有文件操作都是阻塞的，以 socket 读为例来介绍一下此模型，如下图所示。</p>
<p><img src="/images/linux/BIO.png" alt="阻塞 IO 模型"></p>
<p>在用户空间调用 <code>recvfrom</code>，系统调用直到数据包达到且被复制到应用进程的缓冲区中或中间发生异常返回，在这个期间进程会一直等待。进程从调用 <code>recvfrom</code> 开始到它返回的整段时间内都是被阻塞的，因此，被称为阻塞 IO 模型。</p>
<h3 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h3><p><code>recvfrom</code> 从应用到内核的时，如果该缓冲区没有数据，就会直接返回 <code>EWOULDBLOCK</code> 错误，一般都对非阻塞 IO 模型进行轮询检查这个状态，看看内核是不是有数据到来，流程如下图所示。</p>
<p><img src="/images/linux/N-BIO.png" alt="非阻塞 IO 模型"></p>
<p>也就是说非阻塞的 <code>recvform</code> 系统调用调用之后，进程并没有被阻塞，内核马上返回给进程。</p>
<ul>
<li>如果数据还没准备好，此时会返回一个 error。进程在返回之后，可以干点别的事情，然后再发起 <code>recvform</code> 系统调用。重复上面的过程，循环往复的进行 <code>recvform</code> 系统调用，这个过程通常被称之为<strong>轮询</strong>。</li>
</ul>
<p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<p>在 Linux 下，可以通过设置 socket 使其变为 non-blocking。</p>
<h3 id="IO-多路复用模型"><a href="#IO-多路复用模型" class="headerlink" title="IO 多路复用模型"></a>IO 多路复用模型</h3><p>Linux 提供 select、poll、epoll，进程通过讲一个或者多个 fd 传递给 select、poll、epoll 系统调用，阻塞在 select 操作（这个是内核级别的调用）上，这样的话，可以同时监听多个 fd 是否处于就绪状态。其中，</p>
<ul>
<li>select/poll 是顺序扫描 fd 是否就绪，而且支持的 fd 数量有限；</li>
<li>epoll 是基于事件驱动方式代替顺序扫描性能更高。</li>
</ul>
<p>这个后面详细讲述，具体流程如下图所示。</p>
<p><img src="/images/linux/Multi-IO.png" alt="IO 多路复用模型"></p>
<p>多路复用的特点是通过一种机制一个进程能同时等待 IO 文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll 函数就可以返回，它最大的优势就是可以同时处理多个连接。</p>
<h3 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h3><p>首先需要开启 socket 信号驱动 IO 功能，并通过系统调用 <code>sigaction</code> 执行一个信号处理函数（非阻塞，立即返回）。当数据就绪时，会为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 <code>recvfrom</code> 来读取数据，并通知主循环喊出处理数据，流程如下图所示。</p>
<p><img src="/images/linux/single-IO.png" alt="信号驱动 IO 模型"></p>
<h3 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h3><p>告知内核启动某个事件，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通过我们，流程如下图所示。</p>
<p><img src="/images/linux/AIO.png" alt="异步 IO 模型"></p>
<p>与信号驱动模式的主要区别是：</p>
<ul>
<li>信号驱动 IO 由内核通知我们何时可以开始一个 IO 操作；</li>
<li>异步 IO 操作由内核通知我们 IO 何时完成。</li>
</ul>
<p>内核是通过向应用程序发送 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉用户 read 操作已经完成，在 Linux 中，通知的方式是信号：</p>
<ol>
<li>当进程正处于用户态时，应用需要立马进行处理，一般情况下，是先将事件登记一下，放进一个队列中；</li>
<li>当进程正处于内核态时，比如正在以同步阻塞模式读磁盘，那么只能先把这个通知挂起来，等内核态的事情完成之后，再触发信号通知；</li>
<li>如果这个进程现在被挂起来了，比如 sleep，那就把这个进程唤醒，等 CPU 空闲时，就会调度这个进程，触发信号通知。</li>
</ol>
<h3 id="几种-IO-模型比较"><a href="#几种-IO-模型比较" class="headerlink" title="几种 IO 模型比较"></a>几种 IO 模型比较</h3><p><img src="/images/linux/IO-compact.png" alt="几种模型的比较"></p>
<h2 id="Linux-的-IO-多路复用模型"><a href="#Linux-的-IO-多路复用模型" class="headerlink" title="Linux 的 IO 多路复用模型"></a>Linux 的 IO 多路复用模型</h2><p>IO 多路复用通过把多个 IO 阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下，可以同时处理多个 client 请求，与传统的多线程/多进程模型相比，IO 多路复用的最大优势是系统开销小，系统不需要创建新的额外的进程或线程，也不需要维护这些进程和线程的运行，节省了系统资源，IO 多路复用的主要场景如下：</p>
<ol>
<li>Server 需要同时处理多个处于监听状态或者连接状态的 socket；</li>
<li>Server 需要同时处理多种网络协议的 socket。</li>
</ol>
<p>IO 多路复用实际上就是通过一种机制，一个进程可以监视多个描 fd，一旦某个 fd 就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，目前支持 IO 多路复用的系统有 select、pselect、poll、epoll，但它们本质上都是同步 IO。</p>
<p>在 Linux 网络编程中，最初是选用 select 做轮询和网络事件通知，然而 select 的一些固有缺陷导致了它的应用受到了很大的限制，最终 Linux 选择 epoll。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 函数监视的 fd 分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后select 函数会阻塞，直到有 fd 就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当select函数返回后，可以通过遍历 fdset，来找到就绪的 fd。</p>
<p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一个最大的缺陷就是单个进程对打开的 fd 是有一定限制的，它由 <code>FD_SETSIZE</code> 限制，默认值是1024，如果修改的话，就需要重新编译内核，不过这会带来网络效率的下降。</p>
<p>select 和 poll 另一个缺陷就是随着 fd 数目的增加，可能只有很少一部分 socket 是活跃的，但是 select/poll 每次调用时都会线性扫描全部的集合，导致效率呈现线性的下降。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有 fd 后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历 fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样以下两个缺点：</p>
<ol>
<li>大量的 fd 的数组被整体复制于用户态和内核地址空间之间；</li>
<li>poll 还有一个特点是【水平触发】，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd；</li>
<li>fd 增加时，线性扫描导致性能下降。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些 fd 变为就绪态，并且只会通知一次。还有一个特点是，epoll 使用【事件】的就绪通知方式，通过 <code>epoll_ctl</code> 注册 fd，一旦该 fd 就绪，内核就会采用类似 callback 的回调机制来激活该 fd，<code>epoll_wait</code> 便可以收到通知。</p>
<p>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，它支持的 fd 上限受操作系统最大文件句柄数；</li>
<li>效率提升，不是轮询的方式，不会随着 fd 数目的增加效率下降。epoll 只会对【活跃】的 socket 进行操作，这是因为在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的，只有【活跃】的 socket 才会主动的去调用 callback 函数，其他 idle 状态的 socket 则不会。epoll 的性能不会受 fd 总数的限制。</li>
<li>select/poll 都需要内核把 fd 消息通知给用户空间，而 epoll 是通过内核和用户空间 <code>mmap</code> 同一块内存实现。</li>
</ol>
<p>epoll 对 fd 的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT 模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件，下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件；</li>
<li>ET 模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件，如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h3 id="三种模型的区别"><a href="#三种模型的区别" class="headerlink" title="三种模型的区别"></a>三种模型的区别</h3><table>
<thead>
<tr>
<th>类别</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持的最大连接数</td>
<td>由 <code>FD_SETSIZE</code> 限制</td>
<td>基于链表存储，没有限制</td>
<td>受系统最大句柄数限制</td>
</tr>
<tr>
<td>fd 剧增的影响</td>
<td>线性扫描 fd 导致性能很低</td>
<td>同 select</td>
<td>基于 fd 上 callback 实现，没有性能下降的问题</td>
</tr>
<tr>
<td>消息传递机制</td>
<td>内核需要将消息传递到用户空间，需要内核拷贝</td>
<td>同 select</td>
<td>epoll 通过内核与用户空间共享内存来实现</td>
</tr>
</tbody>
</table>
<p>介绍完 IO 多路复用之后，后续我们看一下 Java 网络编程中的 NIO 模型及其背后的实现机制。</p>
<hr>
<p>参考</p>
<ul>
<li>《Netty 权威指南》</li>
<li><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间，进程上下文与中断上下文【总结】</a></li>
<li><a href="http://www.jianshu.com/p/486b0965c296" target="_blank" rel="external">聊聊 Linux 中的五种 IO 模型</a></li>
<li><a href="http://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="external">聊聊IO多路复用之select、poll、epoll详解</a></li>
<li><a href="http://www.jianshu.com/p/2461535c38f3" target="_blank" rel="external">高性能Server—Reactor模型</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段在看 Kafka 的网络模型时，遇到了很多 Java NIO 的内容，在学习 Java NIO 的过程中，发现需要把 UNIX 的这几种网络 IO 模型以及 Linux 的 IO 多路复用理解清楚，才能更好地理解 Java NIO，本文就是在学习 UNIX 的五种网络 
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 topic 创建过程（三）</title>
    <link href="http://matt33.com/2017/07/21/kafka-topic-create/"/>
    <id>http://matt33.com/2017/07/21/kafka-topic-create/</id>
    <published>2017-07-21T15:49:03.000Z</published>
    <updated>2017-11-04T04:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 Kafka 源码解析的第三篇，主要讲述一个 topic 的创建过程，从 topic 是如何创建到 topic 真正创建成功的中间详细过程，文章主要内容可以分为以下几个部分：</p>
<ol>
<li>topic 是如何创建的？<ul>
<li>命令行创建；</li>
<li>Producer 发送数据时，自动创建；</li>
</ul>
</li>
<li>topic 创建时，replicas 是如何分配的？<ul>
<li>指定 replicas 的分配；</li>
<li>自动 replicas 分配；</li>
</ul>
</li>
<li>replicas 更新到 zk 后，底层如何创建一个 topic？<ul>
<li>创建 Partition 对象及状态更新；</li>
<li>创建 Partition 的 replica 对象及状态更新。</li>
</ul>
</li>
</ol>
<p>一个 topic 的完整创建过程如下图所示（以 topic 的 replicas 自动创建，且 broker 没有机架感知为例）</p>
<p><img src="/images/kafka/create_topic.png" alt="Topic 完整创建过程"></p>
<p>上图只是列出一些主要的方法调用，具体内容下面会详细讲述（在看下面的内容时，最后配合上面这张图来看）。</p>
<h2 id="topic-介绍"><a href="#topic-介绍" class="headerlink" title="topic 介绍"></a>topic 介绍</h2><p>topic 是 Kafka 中的一个消息队列的标识，也可以认为是消息队列的一个 id，用于区分不同的消息队列，一个 topic 由多个 partition 组成，这些 partition 是通常是分布在不同的多台 Broker 上的，为了保证数据的可靠性，一个 partition 又会设置为多个副本（replica），通常会设置两副本或三副本。如下图所示，这个一个名为『topic』的 topic，它由三个 partition 组成，两副本，假设 Kafka 集群有三台 Broker（replica 0_1 代表 partition 0 的第一个副本）。</p>
<p><img src="/images/kafka/topic-replicas.png" alt="Kafka Topic 的组成"></p>
<p>在设置副本时，副本数是必须大于集群的 Broker 数的，副本只有设置在不同的机器上才有作用。</p>
<h2 id="topic-如何创建"><a href="#topic-如何创建" class="headerlink" title="topic 如何创建"></a>topic 如何创建</h2><p>topic 在创建时有两种方式：</p>
<ol>
<li>通过 <code>kafka-topics.sh</code> 创建一个 topic，可以设置相应的副本数让 Server 端自动进行 replica 分配，也可以直接指定手动 replica 的分配；</li>
<li>Server 端如果 <code>auto.create.topics.enable</code> 设置为 true 时，那么当 Producer 向一个不存在的 topic 发送数据时，该 topic 同样会被创建出来，此时，副本数默认是1。</li>
</ol>
<p>下面看一下这两种方式的底层实现。</p>
<h3 id="kafka-topics-sh-创建-topic"><a href="#kafka-topics-sh-创建-topic" class="headerlink" title="kafka-topics.sh 创建 topic"></a>kafka-topics.sh 创建 topic</h3><p>在 Kafka 的安装目录下，通过下面这条命令可以创建一个 partition 为3，replica 为2的 topic（test）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --partitions 3 --replication-factor 2</div></pre></td></tr></table></figure>
<p><code>kafka-topics.sh</code> 实际上是调用 <code>kafka.admin.TopicCommand</code> 的方法来创建 topic，其实现如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 创建 topic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>, opts: <span class="type">TopicCommandOptions</span>) &#123;</div><div class="line">  <span class="keyword">val</span> topic = opts.options.valueOf(opts.topicOpt)</div><div class="line">  <span class="keyword">val</span> configs = parseTopicConfigsToBeAdded(opts)</div><div class="line">  <span class="keyword">val</span> ifNotExists = opts.options.has(opts.ifNotExistsOpt)</div><div class="line">  <span class="keyword">if</span> (<span class="type">Topic</span>.hasCollisionChars(topic))</div><div class="line">    println(<span class="string">"WARNING: Due to limitations in metric names, topics with a period ('.') or underscore ('_') could collide. To avoid issues it is best to use either, but not both."</span>)</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (opts.options.has(opts.replicaAssignmentOpt)) &#123;<span class="comment">//note: 指定 replica 的分配,直接向 zk 更新即可</span></div><div class="line">      <span class="keyword">val</span> assignment = parseReplicaAssignment(opts.options.valueOf(opts.replicaAssignmentOpt))</div><div class="line">      <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, assignment, configs, update = <span class="literal">false</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//note: 未指定 replica 的分配,调用自动分配算法进行分配</span></div><div class="line">      <span class="type">CommandLineUtils</span>.checkRequiredArgs(opts.parser, opts.options, opts.partitionsOpt, opts.replicationFactorOpt)</div><div class="line">      <span class="keyword">val</span> partitions = opts.options.valueOf(opts.partitionsOpt).intValue</div><div class="line">      <span class="keyword">val</span> replicas = opts.options.valueOf(opts.replicationFactorOpt).intValue</div><div class="line">      <span class="keyword">val</span> rackAwareMode = <span class="keyword">if</span> (opts.options.has(opts.disableRackAware)) <span class="type">RackAwareMode</span>.<span class="type">Disabled</span></div><div class="line">                          <span class="keyword">else</span> <span class="type">RackAwareMode</span>.<span class="type">Enforced</span></div><div class="line">      <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, partitions, replicas, configs, rackAwareMode)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Created topic \"%s\"."</span>.format(topic))</div><div class="line">  &#125; <span class="keyword">catch</span>  &#123;</div><div class="line">    <span class="keyword">case</span> e: <span class="type">TopicExistsException</span> =&gt; <span class="keyword">if</span> (!ifNotExists) <span class="keyword">throw</span> e</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果指定了 partition 各个 replica 的分布，那么将 partition replicas 的结果验证之后直接更新到 zk 上，验证的 replicas 的代码是在 <code>parseReplicaAssignment</code> 中实现的，如下所示</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseReplicaAssignment</span></span>(replicaAssignmentList: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">  <span class="keyword">val</span> partitionList = replicaAssignmentList.split(<span class="string">","</span>)</div><div class="line">  <span class="keyword">val</span> ret = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]]()</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until partitionList.size) &#123;</div><div class="line">    <span class="keyword">val</span> brokerList = partitionList(i).split(<span class="string">":"</span>).map(s =&gt; s.trim().toInt)</div><div class="line">    <span class="keyword">val</span> duplicateBrokers = <span class="type">CoreUtils</span>.duplicates(brokerList)</div><div class="line">    <span class="keyword">if</span> (duplicateBrokers.nonEmpty)<span class="comment">//note: 同一个 partition 对应的 replica 是不能相同的</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminCommandFailedException</span>(<span class="string">"Partition replica lists may not contain duplicate entries: %s"</span>.format(duplicateBrokers.mkString(<span class="string">","</span>)))</div><div class="line">    ret.put(i, brokerList.toList)</div><div class="line">    <span class="keyword">if</span> (ret(i).size != ret(<span class="number">0</span>).size)<span class="comment">//note: 同一个 topic 的副本数必须相同</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Partition "</span> + i + <span class="string">" has different replication factor: "</span> + brokerList)</div><div class="line">  &#125;</div><div class="line">  ret.toMap</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有指定 parittion replicas 分配的话，将会调用 <code>AdminUtils.createTopic</code> 方法创建 topic，这个方法首先会检测当前的 Kafka 集群是否机架感知，如果有的话先获取 Broker 的机架信息，接着再使用 Replica 自动分配算法来分配 Partition 的 replica，最后就跟指定 replica 方式一样，将 replicas 的结果更新到 zk 中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>,</div><div class="line">                topic: <span class="type">String</span>,</div><div class="line">                partitions: <span class="type">Int</span>,</div><div class="line">                replicationFactor: <span class="type">Int</span>,</div><div class="line">                topicConfig: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>,</div><div class="line">                rackAwareMode: <span class="type">RackAwareMode</span> = <span class="type">RackAwareMode</span>.<span class="type">Enforced</span>) &#123;</div><div class="line">  <span class="keyword">val</span> brokerMetadatas = getBrokerMetadatas(zkUtils, rackAwareMode)<span class="comment">//note: 有机架感知的情况下,返回 Broker 与机架之间的信息</span></div><div class="line">  <span class="keyword">val</span> replicaAssignment = <span class="type">AdminUtils</span>.assignReplicasToBrokers(brokerMetadatas, partitions, replicationFactor)<span class="comment">//note: 获取 partiiton 的 replicas 分配</span></div><div class="line">  <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, replicaAssignment, topicConfig)<span class="comment">//note: 更新到 zk 上</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Producer-创建-topic"><a href="#Producer-创建-topic" class="headerlink" title="Producer 创建 topic"></a>Producer 创建 topic</h3><p>只有当 Server 端的 <code>auto.create.topics.enable</code> 设置为 true 时，Producer 向一个不存在的 topic 发送数据，该 topic 才会被自动创建。</p>
<p>当 Producer 在向一个 topic 发送 produce 请求前，会先通过发送 Metadata 请求来获取这个 topic 的 metadata。Server 端在处理 Metadata 请求时，如果发现要获取 metadata 的 topic 不存在但 Server 允许 producer 自动创建 topic 的话（如果开启权限时，要求 Producer 需要有相应权限：对 topic 有 Describe 权限，并且对当前集群有 Create 权限），那么 Server 将会自动创建该 topic.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 获取 topic 的 metadata 信息</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getTopicMetadata</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], listenerName: <span class="type">ListenerName</span>, errorUnavailableEndpoints: <span class="type">Boolean</span>): <span class="type">Seq</span>[<span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> topicResponses = metadataCache.getTopicMetadata(topics, listenerName, errorUnavailableEndpoints)</div><div class="line">  <span class="keyword">if</span> (topics.isEmpty || topicResponses.size == topics.size) &#123;</div><div class="line">    topicResponses</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> nonExistentTopics = topics -- topicResponses.map(_.topic).toSet<span class="comment">//note: 集群上暂时不存在的 topic 列表</span></div><div class="line">    <span class="keyword">val</span> responsesForNonExistentTopics = nonExistentTopics.map &#123; topic =&gt;</div><div class="line">      <span class="keyword">if</span> (topic == <span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>) &#123;</div><div class="line">        createGroupMetadataTopic()</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.autoCreateTopicsEnable) &#123;<span class="comment">//note: auto.create.topics.enable 为 true 时,即允许自动创建 topic</span></div><div class="line">        createTopic(topic, config.numPartitions, config.defaultReplicationFactor)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>, topic, <span class="literal">false</span>,</div><div class="line">          java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    topicResponses ++ responsesForNonExistentTopics</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>createTopic</code> 还是调用了 <code>AdminUtils.createTopic</code> 来创建 topic，与命令行创建的底层实现是一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(topic: <span class="type">String</span>,</div><div class="line">                        numPartitions: <span class="type">Int</span>,</div><div class="line">                        replicationFactor: <span class="type">Int</span>,</div><div class="line">                        properties: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>()): <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span> = &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//note: 还是调用 AdminUtils 命令创建 topic</span></div><div class="line">    <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, numPartitions, replicationFactor, properties, <span class="type">RackAwareMode</span>.<span class="type">Safe</span>)</div><div class="line">    info(<span class="string">"Auto creation of topic %s with %d partitions and replication factor %d is successful"</span></div><div class="line">      .format(topic, numPartitions, replicationFactor))</div><div class="line">    <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">      java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> _: <span class="type">TopicExistsException</span> =&gt; <span class="comment">// let it go, possibly another broker created this topic</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">    <span class="keyword">case</span> ex: <span class="type">Throwable</span>  =&gt; <span class="comment">// Catch all to prevent unhandled errors</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.forException(ex), topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="replica-如何分配"><a href="#replica-如何分配" class="headerlink" title="replica 如何分配"></a>replica 如何分配</h2><p>通过前面的内容，可以看到，无论使用哪种方式，最后都是通过 <code>AdminUtils.createOrUpdateTopicPartitionAssignmentPathInZK()</code> 将 topic 的 Partition replicas 的更新到 zk 上，这中间关键的一点在于：Partition 的 replicas 是如何分配的。在创建时，我们既可以指定相应 replicas 分配，也可以使用默认的算法自动分配。</p>
<h3 id="创建时指定-replicas-分配"><a href="#创建时指定-replicas-分配" class="headerlink" title="创建时指定 replicas 分配"></a>创建时指定 replicas 分配</h3><p>在创建 topic 时，可以通过以下形式直接指定 topic 的 replica</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --replica-assignment 1:2,3:4,5:6</div></pre></td></tr></table></figure>
<p>该 topic 有三个 partition，其中，partition 0 的 replica 分布在1和2上，partition 1 的 replica 分布在3和4上，partition 3 的 replica 分布在4和5上。</p>
<p>这样情况下，在创建 topic 时，Server 端会将该 replica 分布直接更新到 zk 上。</p>
<h3 id="replicas-自动分配算法"><a href="#replicas-自动分配算法" class="headerlink" title="replicas 自动分配算法"></a>replicas 自动分配算法</h3><p>在创建 topic 时，Server 通过 <code>AdminUtils.assignReplicasToBrokers()</code> 方法来获取该 topic partition 的 replicas 分配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 副本分配时,有三个原则:</div><div class="line">   * 1. 将副本平均分布在所有的 Broker 上;</div><div class="line">   * 2. partition 的多个副本应该分配在不同的 Broker 上;</div><div class="line">   * 3. 如果所有的 Broker 有机架信息的话, partition 的副本应该分配到不同的机架上。</div><div class="line">   *</div><div class="line">   * 为实现上面的目标,在没有机架感知的情况下，应该按照下面两个原则分配 replica:</div><div class="line">   * 1. 从 broker.list 随机选择一个 Broker,使用 round-robin 算法分配每个 partition 的第一个副本;</div><div class="line">   * 2. 对于这个 partition 的其他副本,逐渐增加 Broker.id 来选择 replica 的分配。</div><div class="line">   *</div><div class="line">   * @param brokerMetadatas</div><div class="line">   * @param nPartitions</div><div class="line">   * @param replicationFactor</div><div class="line">   * @param fixedStartIndex</div><div class="line">   * @param startPartitionId</div><div class="line">   * @return</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokers</span></span>(brokerMetadatas: <span class="type">Seq</span>[<span class="type">BrokerMetadata</span>],</div><div class="line">                             nPartitions: <span class="type">Int</span>,</div><div class="line">                             replicationFactor: <span class="type">Int</span>,</div><div class="line">                             fixedStartIndex: <span class="type">Int</span> = <span class="number">-1</span>,</div><div class="line">                             startPartitionId: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">if</span> (nPartitions &lt;= <span class="number">0</span>) <span class="comment">// note: 要增加的 partition 数需要大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidPartitionsException</span>(<span class="string">"number of partitions must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &lt;= <span class="number">0</span>) <span class="comment">//note: replicas 应该大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">"replication factor must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &gt; brokerMetadatas.size) <span class="comment">//note: replicas 超过了 broker 数</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">s"replication factor: <span class="subst">$replicationFactor</span> larger than available brokers: <span class="subst">$&#123;brokerMetadatas.size&#125;</span>"</span>)</div><div class="line">   <span class="keyword">if</span> (brokerMetadatas.forall(_.rack.isEmpty))<span class="comment">//note: 没有开启机架感知</span></div><div class="line">     assignReplicasToBrokersRackUnaware(nPartitions, replicationFactor, brokerMetadatas.map(_.id), fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   <span class="keyword">else</span> &#123; <span class="comment">//note: 机架感知的情况</span></div><div class="line">     <span class="keyword">if</span> (brokerMetadatas.exists(_.rack.isEmpty)) <span class="comment">//note: 并不是所有的机架都有机架感知</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Not all brokers have rack information for replica rack aware assignment"</span>)</div><div class="line">     assignReplicasToBrokersRackAware(nPartitions, replicationFactor, brokerMetadatas, fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里没有开启机架感知模式来介绍 topic partition replicas 的分配情况，其分配算法主要是 <code>assignReplicasToBrokersRackUnaware()</code> 方法中实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: partition 分配</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokersRackUnaware</span></span>(nPartitions: <span class="type">Int</span>,</div><div class="line">                                                replicationFactor: <span class="type">Int</span>,</div><div class="line">                                                brokerList: <span class="type">Seq</span>[<span class="type">Int</span>],</div><div class="line">                                                fixedStartIndex: <span class="type">Int</span>,</div><div class="line">                                                startPartitionId: <span class="type">Int</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">val</span> ret = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]]()</div><div class="line">   <span class="keyword">val</span> brokerArray = brokerList.toArray</div><div class="line">   <span class="keyword">val</span> startIndex = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length) <span class="comment">//note: 随机选择一个Broker</span></div><div class="line">   <span class="keyword">var</span> currentPartitionId = math.max(<span class="number">0</span>, startPartitionId) <span class="comment">//note: 开始增加的第一个 partition</span></div><div class="line">   <span class="keyword">var</span> nextReplicaShift = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length)</div><div class="line">   <span class="keyword">for</span> (_ &lt;- <span class="number">0</span> until nPartitions) &#123; <span class="comment">//note: 对每个 partition 进行分配</span></div><div class="line">     <span class="keyword">if</span> (currentPartitionId &gt; <span class="number">0</span> &amp;&amp; (currentPartitionId % brokerArray.length == <span class="number">0</span>))</div><div class="line">       nextReplicaShift += <span class="number">1</span> <span class="comment">//note: 防止 partition 过大时,其中某些 partition 的分配（leader、follower）完全一样</span></div><div class="line">     <span class="keyword">val</span> firstReplicaIndex = (currentPartitionId + startIndex) % brokerArray.length <span class="comment">//note: partition 的第一个 replica</span></div><div class="line">     <span class="keyword">val</span> replicaBuffer = mutable.<span class="type">ArrayBuffer</span>(brokerArray(firstReplicaIndex))</div><div class="line">     <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until replicationFactor - <span class="number">1</span>) <span class="comment">//note: 其他 replica 的分配</span></div><div class="line">       replicaBuffer += brokerArray(replicaIndex(firstReplicaIndex, nextReplicaShift, j, brokerArray.length))</div><div class="line">     ret.put(currentPartitionId, replicaBuffer)</div><div class="line">     currentPartitionId += <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   ret</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: 为 partition 设置完第一个 replica 后,其他 replica 分配的计算</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">replicaIndex</span></span>(firstReplicaIndex: <span class="type">Int</span>, secondReplicaShift: <span class="type">Int</span>, replicaIndex: <span class="type">Int</span>, nBrokers: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">   <span class="keyword">val</span> shift = <span class="number">1</span> + (secondReplicaShift + replicaIndex) % (nBrokers - <span class="number">1</span>)<span class="comment">//note: 在 secondReplicaShift 的基础上增加一个 replicaIndex</span></div><div class="line">   (firstReplicaIndex + shift) % nBrokers</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里举一个栗子，假设一个 Kafka 集群有5个节点，新建的 topic 有10个 partition，并且是三副本，假设最初随机选择的 <code>startIndex</code> 和 <code>nextReplicaShift</code> 节点均为0</p>
<ul>
<li>partition 为0时，那第一副本在 <code>(0+0)%5=0</code>，第二个副本在 <code>(0+(1+(0+0)%5)))%5=1</code>，第三副本在 <code>(0+(1+(0+1)%5)))%5=2</code>；</li>
<li>partition 为2时，那第一副本在 <code>(0+2)%5=2</code>，第二个副本在 <code>(2+(1+(0+0)%5)))%5=3</code>，第三副本在 <code>(2+(1+(0+1)%5)))%5=4</code>；</li>
<li>partition 为5时，那第一副本在 <code>(0+5)%5=0</code>，第二个副本在 <code>(0+(1+(1+0)%5)))%5=2</code>，第三副本在 <code>(0+(1+(1+1)%5)))%5=3</code>（partition 数是 Broker 数一倍时，<code>nextReplicaShift</code> 值会增加1）；</li>
<li>partition 为8时，那第一副本在 <code>(0+8)%5=3</code>，第二个副本在 <code>(3+(1+(1+0)%5)))%5=0</code>，第三副本在 <code>(3+(1+(1+1)%5)))%5=1</code>。</li>
</ul>
<p>分配如下表所示：</p>
<table>
<thead>
<tr>
<th>broker-0</th>
<th>broker-1</th>
<th>broker-2</th>
<th>broker-3</th>
<th>broker-4</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>p4</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p3</td>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>(3nd replica)</td>
</tr>
<tr>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>(3nd replica)</td>
</tr>
</tbody>
</table>
<h2 id="replicas-更新到-zk-后触发的操作"><a href="#replicas-更新到-zk-后触发的操作" class="headerlink" title="replicas 更新到 zk 后触发的操作"></a>replicas 更新到 zk 后触发的操作</h2><p>这一部分的内容是由 Kafka Controller 来控制的（Kafka Controller 将会在后续文章中讲解），当一个 topic 的 replicas 更新到 zk 上后，监控 zk 这个目录的方法会被触发（<code>TopicChangeListener.doHandleChildChange()</code>方法），可以配合文章第一张图来看。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 zk 上 topic 节点上有变更时,这个方法就会调用</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doHandleChildChange</span></span>(parentPath: <span class="type">String</span>, children: <span class="type">Seq</span>[<span class="type">String</span>]) &#123;</div><div class="line">      inLock(controllerContext.controllerLock) &#123;</div><div class="line">        <span class="keyword">if</span> (hasStarted.get) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">val</span> currentChildren = &#123;</div><div class="line">              debug(<span class="string">"Topic change listener fired for path %s with children %s"</span>.format(parentPath, children.mkString(<span class="string">","</span>)))</div><div class="line">              children.toSet</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">val</span> newTopics = currentChildren -- controllerContext.allTopics<span class="comment">//note: 新创建的 topic 列表</span></div><div class="line">            <span class="keyword">val</span> deletedTopics = controllerContext.allTopics -- currentChildren<span class="comment">//note: 已经删除的 topic 列表</span></div><div class="line">            controllerContext.allTopics = currentChildren</div><div class="line"></div><div class="line">            <span class="comment">//note: 新创建 topic 对应的 partition 列表</span></div><div class="line">            <span class="keyword">val</span> addedPartitionReplicaAssignment = zkUtils.getReplicaAssignmentForTopics(newTopics.toSeq)</div><div class="line">            controllerContext.partitionReplicaAssignment = controllerContext.partitionReplicaAssignment.filter(p =&gt;</div><div class="line">              !deletedTopics.contains(p._1.topic))<span class="comment">//note: 把已经删除 partition 过滤掉</span></div><div class="line">            controllerContext.partitionReplicaAssignment.++=(addedPartitionReplicaAssignment)<span class="comment">//note: 将新增的 tp-replicas 更新到缓存中</span></div><div class="line">            info(<span class="string">"New topics: [%s], deleted topics: [%s], new partition replica assignment [%s]"</span>.format(newTopics,</div><div class="line">              deletedTopics, addedPartitionReplicaAssignment))</div><div class="line">            <span class="keyword">if</span> (newTopics.nonEmpty)<span class="comment">//note: 处理新建的 topic</span></div><div class="line">              controller.onNewTopicCreation(newTopics, addedPartitionReplicaAssignment.keySet)</div><div class="line">          &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while handling new topic"</span>, e)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法主要做了以下内容：</p>
<ul>
<li>获取 zk 的 topic 变更信息，得到新创建的 topic 列表（<code>newTopics</code>）以及被删除的 topic 列表（<code>deletedTopics</code>）；</li>
<li>将 <code>deletedTopics</code> 的 replicas 从 controller 的缓存中删除，并将新增 topic 的 replicas 更新到 controller 的缓存中；</li>
<li>调用 KafkaController 的 <code>onNewTopicCreation()</code> 创建 partition 和 replica 对象。</li>
</ul>
<p>KafkaController 中 <code>onNewTopicCreation()</code> 方法先对这些 topic 注册 <code>PartitionChangeListener</code>，然后再调用 <code>onNewPartitionCreation()</code> 方法创建 partition 和 replicas 的实例对象，<strong>topic 创建的主要实现是在 KafkaController <code>onNewPartitionCreation()</code> 这个方法中</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition state machine 监控到有新 topic 或 partition 时,这个方法将会被调用</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">   * 1. 注册 partition change listener;</div><div class="line">   * 2. 触发 the new partition callback,也即是 onNewPartitionCreation()</div><div class="line">   * 3. 发送 metadata 请求给所有的 Broker</div><div class="line">   * @param topics</div><div class="line">   * @param newPartitions</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewTopicCreation</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New topic creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   <span class="comment">// subscribe to partition changes</span></div><div class="line">   topics.foreach(topic =&gt; partitionStateMachine.registerPartitionChangeListener(topic))</div><div class="line">   onNewPartitionCreation(newPartitions)</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: topic 变化时,这个方法将会被调用</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 partition 置为 NewPartition 状态; 2.从 NewPartition 改为 OnlinePartition 状态</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 Replica 置为 NewReplica 状态; 2.从 NewReplica 改为 OnlineReplica 状态</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewPartitionCreation</span></span>(newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New partition creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">NewPartition</span>)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">NewReplica</span>)</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">OnlinePartition</span>, offlinePartitionSelector)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">OnlineReplica</span>)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在详细介绍这四个方法的调用之前，先简单详述一下 Partition 和 Replica 状态机的变化。</p>
<h3 id="Partition-状态机"><a href="#Partition-状态机" class="headerlink" title="Partition 状态机"></a>Partition 状态机</h3><p>关于 Partition 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/PartitionStateMachine.scala" target="_blank" rel="external">PartitionStateMachine</a>，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/partition_stat.png" alt="Partition 状态机"></p>
<p>一个 Partition 对象有四种状态：</p>
<ol>
<li><code>NonExistentPartition</code>：这个 partition 不存在；</li>
<li><code>NewPartition</code>：这个 partition 刚创建，有对应的 replicas，但还没有 leader 和 isr；</li>
<li><code>OnlinePartition</code>：这个 partition 的 leader 已经选举出来了，处理正常的工作状态；</li>
<li><code>OfflinePartition</code>：partition 的 leader 挂了。</li>
</ol>
<p>partition 只有在 <code>OnlinePartition</code> 这个状态时，才是可用状态。</p>
<h3 id="Replica-状态机"><a href="#Replica-状态机" class="headerlink" title="Replica 状态机"></a>Replica 状态机</h3><p>关于 Replica 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/ReplicaStateMachine.scala" target="_blank" rel="external">ReplicaStateMachine</a>，，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/replica_stat.png" alt="Replica 状态机"></p>
<p>Replica 对象有七种状态，中文解释的比较难以理解，直接上原文对这几种状态的解释。</p>
<ol>
<li><code>NewReplica</code>：The controller can create new replicas during partition reassignment. In this state, a replica can only get become follower state change request.</li>
<li><code>OnlineReplica</code>：Once a replica is started and part of the assigned replicas for its partition, it is in this state. In this state, it can get either become leader or become follower state change requests.</li>
<li><code>OfflineReplica</code>：If a replica dies, it moves to this state. This happens when the broker hosting the replica is down.</li>
<li><code>ReplicaDeletionStarted</code>：If replica deletion starts, it is moved to this state.</li>
<li><code>ReplicaDeletionSuccessful</code>：If replica responds with no error code in response to a delete replica request, it is moved to this state.</li>
<li><code>ReplicaDeletionIneligible</code>：If replica deletion fails, it is moved to this state.</li>
<li><code>NonExistentReplica</code>：If a replica is deleted successfully, it is moved to this state.</li>
</ol>
<h3 id="onNewPartitionCreation-详解"><a href="#onNewPartitionCreation-详解" class="headerlink" title="onNewPartitionCreation() 详解"></a><code>onNewPartitionCreation()</code> 详解</h3><p>这个方法有以下四步操作：</p>
<ol>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, NewPartition)</code>： 创建 Partition 对象，并将其状态置为 <code>NewPartition</code> 状态</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), NewReplica)</code>：创建 Replica 对象，并将其状态置为 <code>NewReplica</code> 状态；</li>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, OnlinePartition, offlinePartitionSelector)</code>：将 partition 对象从 <code>NewPartition</code> 改为 <code>OnlinePartition</code> 状态；</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), OnlineReplica)</code>：将 Replica 对象从 <code>NewReplica</code> 改为 <code>OnlineReplica</code> 状态。</li>
</ol>
<h4 id="partitionStateMachine-gt-NewPartition"><a href="#partitionStateMachine-gt-NewPartition" class="headerlink" title="partitionStateMachine &gt; NewPartition"></a>partitionStateMachine &gt; NewPartition</h4><p>这部分的作用是，创建分区对象，并将其状态设置为 <code>NewPartition</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">  <span class="comment">//note: 新建一个 partition</span></div><div class="line">  assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NonExistentPartition</span>), <span class="type">NewPartition</span>)</div><div class="line">  partitionState.put(topicAndPartition, <span class="type">NewPartition</span>) <span class="comment">//note: 缓存 partition 的状态</span></div><div class="line">  <span class="keyword">val</span> assignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition).mkString(<span class="string">","</span>)</div><div class="line">  stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed partition %s state from %s to %s with assigned replicas %s"</span></div><div class="line">                            .format(controllerId, controller.epoch, topicAndPartition, currState, targetState,</div><div class="line">                                    assignedReplicas))</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-NewReplica"><a href="#replicaStateMachine-gt-NewReplica" class="headerlink" title="replicaStateMachine &gt; NewReplica"></a>replicaStateMachine &gt; NewReplica</h4><p>这部分是为每个 Partition 创建对应的 replica 对象，并将其状态设置为 <code>NewReplica</code>，参照状态机的变化图更好理解。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica, <span class="type">List</span>(<span class="type">NonExistentReplica</span>), targetState)  <span class="comment">//note: 验证</span></div><div class="line">          <span class="comment">// start replica as a follower to the current leader for its partition</span></div><div class="line">          <span class="keyword">val</span> leaderIsrAndControllerEpochOpt = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topic, partition)</div><div class="line">          leaderIsrAndControllerEpochOpt <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">Some</span>(leaderIsrAndControllerEpoch) =&gt;</div><div class="line">              <span class="keyword">if</span>(leaderIsrAndControllerEpoch.leaderAndIsr.leader == replicaId)<span class="comment">//note: 这个状态的 Replica 不能作为 leader</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(<span class="string">"Replica %d for partition %s cannot be moved to NewReplica"</span></div><div class="line">                  .format(replicaId, topicAndPartition) + <span class="string">"state as it is being requested to become leader"</span>)</div><div class="line">              <span class="comment">//note: 向所有 replicaId 发送 LeaderAndIsr 请求,这个方法同时也会向所有的 broker 发送 updateMeta 请求</span></div><div class="line">              brokerRequestBatch.addLeaderAndIsrRequestForBrokers(<span class="type">List</span>(replicaId),</div><div class="line">                                                                  topic, partition, leaderIsrAndControllerEpoch,</div><div class="line">                                                                  replicaAssignment)</div><div class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// new leader request will be sent to this replica when one gets elected</span></div></pre></td></tr></table></figure>
<h4 id="partitionStateMachine-gt-OnlinePartition"><a href="#partitionStateMachine-gt-OnlinePartition" class="headerlink" title="partitionStateMachine &gt; OnlinePartition"></a>partitionStateMachine &gt; OnlinePartition</h4><p>这个方法的主要的作用是将 partition 对象的状态由 <code>NewPartition</code> 设置为 <code>OnlinePartition</code>，从状态机图中可以看到，会有以下两步操作：</p>
<ol>
<li>初始化 leader 和 isr，replicas 中的第一个 replica 将作为 leader，所有 replica 作为 isr，并把 leader 和 isr 信息更新到 zk；</li>
<li>发送 LeaderAndIsr 请求给所有的 replica，发送 UpdateMetadata 给所有 Broker。</li>
</ol>
<p>具体操作如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// post: partition has been assigned replicas</span></div><div class="line">       <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt;</div><div class="line">         assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NewPartition</span>, <span class="type">OnlinePartition</span>, <span class="type">OfflinePartition</span>), <span class="type">OnlinePartition</span>)</div><div class="line">         partitionState(topicAndPartition) <span class="keyword">match</span> &#123;</div><div class="line">           <span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">             <span class="comment">// initialize leader and isr path for new partition</span></div><div class="line">             initializeLeaderAndIsrForPartition(topicAndPartition) <span class="comment">//note: 为新建的 partition 初始化 leader 和 isr</span></div><div class="line">           <span class="keyword">case</span> <span class="type">OfflinePartition</span> =&gt;</div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt; <span class="comment">// invoked when the leader needs to be re-elected</span></div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> _ =&gt; <span class="comment">// should never come here since illegal previous states are checked above</span></div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<p>实际的操作是在 <code>initializeLeaderAndIsrForPartition()</code> 方法中完成，这个方法是当 partition 对象的状态由 NewPartition 变为 OnlinePartition 时触发的，用来初始化该 partition 的 leader 和 isr。简单来说，就是选取 Replicas 中的第一个 Replica 作为 leader，所有的 Replica 作为 isr，最后调用 <code>brokerRequestBatch.addLeaderAndIsrRequestForBrokers</code> 向所有 replicaId 发送 LeaderAndIsr 请求以及向所有的 broker 发送 UpdateMetadata 请求（关于 Server 对 LeaderAndIsr 和 UpdateMetadata 请求的处理将会后续文章中讲述）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition 状态由 NewPartition 变为 OnlinePartition 时,将触发这一方法,用来初始化 partition 的 leader 和 isr</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initializeLeaderAndIsrForPartition</span></span>(topicAndPartition: <span class="type">TopicAndPartition</span>) &#123;</div><div class="line">   <span class="keyword">val</span> replicaAssignment = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">   <span class="keyword">val</span> liveAssignedReplicas = replicaAssignment.filter(r =&gt; controllerContext.liveBrokerIds.contains(r))</div><div class="line">   liveAssignedReplicas.size <span class="keyword">match</span> &#123;</div><div class="line">     <span class="keyword">case</span> <span class="number">0</span> =&gt;</div><div class="line">       <span class="keyword">val</span> failMsg = (<span class="string">"encountered error during state change of partition %s from New to Online, assigned replicas are [%s], "</span> +</div><div class="line">                      <span class="string">"live brokers are [%s]. No assigned replica is alive."</span>)</div><div class="line">                        .format(topicAndPartition, replicaAssignment.mkString(<span class="string">","</span>), controllerContext.liveBrokerIds)</div><div class="line">       stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">     <span class="keyword">case</span> _ =&gt;</div><div class="line">       debug(<span class="string">"Live assigned replicas for partition %s are: [%s]"</span>.format(topicAndPartition, liveAssignedReplicas))</div><div class="line">       <span class="comment">// make the first replica in the list of assigned replicas, the leader</span></div><div class="line">       <span class="keyword">val</span> leader = liveAssignedReplicas.head <span class="comment">//note: replicas 中的第一个 replica 选做 leader</span></div><div class="line">       <span class="keyword">val</span> leaderIsrAndControllerEpoch = <span class="keyword">new</span> <span class="type">LeaderIsrAndControllerEpoch</span>(<span class="keyword">new</span> <span class="type">LeaderAndIsr</span>(leader, liveAssignedReplicas.toList),</div><div class="line">         controller.epoch)</div><div class="line">       debug(<span class="string">"Initializing leader and isr for partition %s to %s"</span>.format(topicAndPartition, leaderIsrAndControllerEpoch))</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         zkUtils.createPersistentPath(</div><div class="line">           getTopicPartitionLeaderAndIsrPath(topicAndPartition.topic, topicAndPartition.partition),</div><div class="line">           zkUtils.leaderAndIsrZkData(leaderIsrAndControllerEpoch.leaderAndIsr, controller.epoch))<span class="comment">//note: zk 上初始化节点信息</span></div><div class="line">         <span class="comment">// <span class="doctag">NOTE:</span> the above write can fail only if the current controller lost its zk session and the new controller</span></div><div class="line">         <span class="comment">// took over and initialized this partition. This can happen if the current controller went into a long</span></div><div class="line">         <span class="comment">// GC pause</span></div><div class="line">         controllerContext.partitionLeadershipInfo.put(topicAndPartition, leaderIsrAndControllerEpoch)</div><div class="line">         brokerRequestBatch.addLeaderAndIsrRequestForBrokers(liveAssignedReplicas, topicAndPartition.topic,</div><div class="line">           topicAndPartition.partition, leaderIsrAndControllerEpoch, replicaAssignment)<span class="comment">//note: 向 live 的 Replica 发送  LeaderAndIsr 请求</span></div><div class="line">       &#125; <span class="keyword">catch</span> &#123;</div><div class="line">         <span class="keyword">case</span> _: <span class="type">ZkNodeExistsException</span> =&gt;</div><div class="line">           <span class="comment">// read the controller epoch</span></div><div class="line">           <span class="keyword">val</span> leaderIsrAndEpoch = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topicAndPartition.topic,</div><div class="line">             topicAndPartition.partition).get</div><div class="line">           <span class="keyword">val</span> failMsg = (<span class="string">"encountered error while changing partition %s's state from New to Online since LeaderAndIsr path already "</span> +</div><div class="line">                          <span class="string">"exists with value %s and controller epoch %d"</span>)</div><div class="line">                            .format(topicAndPartition, leaderIsrAndEpoch.leaderAndIsr.toString(), leaderIsrAndEpoch.controllerEpoch)</div><div class="line">           stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-OnlineReplica"><a href="#replicaStateMachine-gt-OnlineReplica" class="headerlink" title="replicaStateMachine &gt; OnlineReplica"></a>replicaStateMachine &gt; OnlineReplica</h4><p>这一步也就是最后一步，将 Replica 对象的状态由 <code>NewReplica</code> 更新为 <code>OnlineReplica</code> 状态，这些 Replica 才真正可用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">OnlineReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica,</div><div class="line">            <span class="type">List</span>(<span class="type">NewReplica</span>, <span class="type">OnlineReplica</span>, <span class="type">OfflineReplica</span>, <span class="type">ReplicaDeletionIneligible</span>), targetState)</div><div class="line">          replicaState(partitionAndReplica) <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">              <span class="comment">// add this replica to the assigned replicas list for its partition</span></div><div class="line">              <span class="comment">//note: 向 the assigned replicas list 添加这个 replica（正常情况下这些 replicas 已经更新到 list 中了）</span></div><div class="line">              <span class="keyword">val</span> currentAssignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">              <span class="keyword">if</span>(!currentAssignedReplicas.contains(replicaId))</div><div class="line">                controllerContext.partitionReplicaAssignment.put(topicAndPartition, currentAssignedReplicas :+ replicaId)</div><div class="line">              stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed state of replica %d for partition %s from %s to %s"</span></div><div class="line">                                        .format(controllerId, controller.epoch, replicaId, topicAndPartition, currState,</div><div class="line">                                                targetState))</div></pre></td></tr></table></figure>
<p>一直到这一步，一个 topic 就才算真正被创建完成。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/huxi2b/p/5923252.html" target="_blank" rel="external">Kafka如何创建topic？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 Kafka 源码解析的第三篇，主要讲述一个 topic 的创建过程，从 topic 是如何创建到 topic 真正创建成功的中间详细过程，文章主要内容可以分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;topic 是如何创建的？&lt;ul&gt;
&lt;li&gt;命令行创建；&lt;/li&gt;
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用的一些系统命令</title>
    <link href="http://matt33.com/2017/07/16/linux-system-cmd/"/>
    <id>http://matt33.com/2017/07/16/linux-system-cmd/</id>
    <published>2017-07-16T02:31:47.000Z</published>
    <updated>2017-09-04T07:17:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章的内容，基本来自<a href="http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">每日一个 linux 命令</a>，选取了几个在工作常用的命令，有：top、iostat、netstat 、free 和 ps，本文的主要目的是在学习这几条命令的过程中，简单做一些记录，便于日后工作中更加熟练地使用这些命令。</p>
<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>top 命令是 Linux 下面实时展示系统运行情况的一个命令，它也可以显示当前每个任务的系统信息。在对系统的性能进行分析，它是一个最常用的命令。</p>
<h2 id="命令常用参数"><a href="#命令常用参数" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><ol>
<li>命令格式：<ul>
<li>top [参数]</li>
</ul>
</li>
<li>命令功能：<ul>
<li>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</li>
</ul>
</li>
<li>命令参数：<ul>
<li><code>-b</code>: 批处理</li>
<li><code>-c</code>: 显示完整的治命令</li>
<li><code>-I</code>: 忽略失效过程</li>
<li><code>-s</code>: 保密模式</li>
<li><code>-S</code>: 累积模式</li>
<li><code>-i&lt;时间&gt;</code>: 设置间隔时间</li>
<li><code>-u&lt;用户名&gt;</code>: 指定用户名</li>
<li><code>-p&lt;进程号&gt;</code>: 指定进程</li>
<li><code>-n&lt;次数&gt;</code>: 循环显示的次数</li>
</ul>
</li>
</ol>
<h2 id="显示说明"><a href="#显示说明" class="headerlink" title="显示说明"></a>显示说明</h2><p>在命令行输入 <code>top</code> 命令，终端会展示当前系统的信息，如下所示</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ top</div><div class="line">top - 21:04:19 up 129 days, 20:31,  1 user,  load average: 58.32, 57.85, 57.50</div><div class="line">Tasks: 589 total,   1 running, 584 sleeping,   0 stopped,   4 zombie</div><div class="line">Cpu(s): 22.3%us, 11.8%sy,  0.0%ni, 63.2%id,  0.2%wa,  0.0%hi,  2.5%si,  0.0%st</div><div class="line">Mem:  132103752k total, 122070628k used, 10033124k free,    42940k buffers</div><div class="line">Swap:        0k total,        0k used,        0k free, 58734284k cached</div><div class="line"></div><div class="line">   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</div><div class="line"> 51179	matt   20   0 70.6g  24g  80m S 704.9 19.2  39244,38 java</div><div class="line">     1 root      20   0 1155m 1.1g  592 S  0.0  0.9   4020:57 init</div><div class="line">     2 root      20   0     0    0    0 S  0.0  0.0   0:00.01 kthreadd</div></pre></td></tr></table></figure>
<p>上面只是截取了部分的信息，这里介绍以下上面的一些信息的说明。上面的前五行是当前系统情况整体的统计信息区。</p>
<ol>
<li>任务的队列信息，同 uptime 命令的执行结果<ul>
<li><code>21:04:19</code>: 当前系统时间；</li>
<li><code>up 129 days, 20:31</code>: 系统已经运行了129天20小时31分钟（这期间系统没有重启）；</li>
<li><code>1 users</code>: 当前有1个用户登录系统；</li>
<li><code>load average: 58.32, 57.85, 57.50</code>: load average 后面的三个数分别是1分钟、5分钟、15分钟的负载情况（<strong>这个数除以逻辑 CPU 的数量，结果高于5的时候就表明系统在超负荷运转</strong>）</li>
</ul>
</li>
<li>Tasks — 任务（进程）的统计信息<ul>
<li>系统现在共有589个进程，其中处于运行中的有1个，584个在休眠（sleep），stoped 状态的有0个，zombie 状态（僵尸）的有4个；</li>
</ul>
</li>
<li>cpu 的状态信息<ul>
<li><code>22.3%us</code>: 用户空间占用 CPU 的百分比</li>
<li><code>11.8% sy</code>: 内核空间占用 CPU 的百分比</li>
<li><code>0.0% ni</code>: 改变过优先级的进程占用 CPU 的百分比</li>
<li><code>63.2% id</code>: 空闲 CPU 百分比</li>
<li><code>0.2% wa</code>: IO 等待占用 CPU 的百分比</li>
<li><code>0.0% hi</code>: 硬中断（Hardware IRQ）占用 CPU 的百分比</li>
<li><code>2.5% si</code>: 软中断（Software Interrupts）占用 CPU 的百分比</li>
<li><code>0.0% st</code>: 虚拟机占用的百分比</li>
</ul>
</li>
<li>内存的状态信息<ul>
<li><code>132103752k total</code>： 物理内存总量（128GB）</li>
<li><code>122070628k used</code>： 使用中的内存总量（118GB）</li>
<li><code>10033124k free</code>： 空闲内存总量（10GB）</li>
<li><code>42940k buffers</code>： 缓存的内存量 （42M）</li>
</ul>
</li>
<li>swap交换分区信息<ul>
<li><code>0k total</code>: 交换区总量（0K）</li>
<li><code>0k used</code>: 使用的交换区总量（0K）</li>
<li><code>0k free</code>: 空闲交换区总量（0K）</li>
<li><code>58734284k cached</code>: 缓冲的交换区总量（56GB）</li>
</ul>
</li>
<li>空行，作为系统信息与进程信息的分界线</li>
<li>各进程（任务）的状态监控<ul>
<li><code>PID</code>: 进程id</li>
<li><code>USER</code>: 进程所有者</li>
<li><code>PR</code>: 进程优先级</li>
<li><code>NI</code>: nice 值，负值表示高优先级，正值表示低优先级</li>
<li><code>VIRT</code>: 进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES</li>
<li><code>RES</code>: 进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA</li>
<li><code>SHR</code>: 共享内存大小，单位 kb</li>
<li><code>S</code>: 进程状态。D= 不可中断的睡眠状态 R= 运行 S= 睡眠 T= 跟踪/停止 Z= 僵尸进程</li>
<li><code>%CPU</code>: 上次更新到现在的CPU时间占用百分比</li>
<li><code>%MEM</code>: 进程使用的物理内存百分比</li>
<li><code>TIME+</code>: 进程使用的CPU时间总计，单位1/100秒</li>
<li><code>COMMAND</code>: 进程名称</li>
</ul>
</li>
</ol>
<p>其中，第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到 free 中去，因此在 linux 上 free 内存会越来越少，但不用为此担心。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>在工作中，常用的几个命令在 <a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a> 都已经介绍得比较全面了，这里，再简单重复一下。</p>
<h3 id="多-CPU-监控"><a href="#多-CPU-监控" class="headerlink" title="多 CPU 监控"></a>多 CPU 监控</h3><p>在 top 的基本视图中，按键盘数字<strong>1</strong>，可监控每个逻辑CPU的状况：</p>
<p><img src="/images/linux/top1.png" alt="TOP 多 CPU 监控"></p>
<h3 id="高亮显示当前进程"><a href="#高亮显示当前进程" class="headerlink" title="高亮显示当前进程"></a>高亮显示当前进程</h3><p>敲击键盘<strong>b</strong>（打开/关闭加亮效果），top 的视图变化如下（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top2.png" alt="TOP 高亮"></p>
<h3 id="进程字段排序"><a href="#进程字段排序" class="headerlink" title="进程字段排序"></a>进程字段排序</h3><p>默认进入 top 时，各进程是按照 CPU 的占用量来排序的，敲击键盘<strong>x</strong>（打开/关闭排序列的加亮效果），top 的视图变化如下所示，会将 CPU 占用量这行高亮（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top4.png" alt="TOP 按 CPU 占用量排序"></p>
<p>通过 <code>shift + &gt;</code>或<code>shift + &lt;</code>可以向右或左改变排序列，下图是按一次<code>shift + &gt;</code>的效果图，视图现在已经按照 <code>%MEM</code> 来排序（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top5.png" alt="TOP 按内存排序"></p>
<h3 id="显示进程完成命令"><a href="#显示进程完成命令" class="headerlink" title="显示进程完成命令"></a>显示进程完成命令</h3><p>敲击键盘<strong>c</strong>（打开/关闭进程完成命令），top 的视图变化如下（图来自<a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a>）。</p>
<p><img src="/images/linux/top6.png" alt="TOP 显示完整命令"></p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul>
<li><code>top -p 574</code>: 显示指定的进程信息</li>
<li><code>top -d 3</code>: 设置信息更新时间</li>
<li><code>top -n 2</code>: 设置信息更新次数</li>
<li><code>top -S</code>: 以累积模式显示程序信息</li>
<li><code>top -Hp 2050</code>：显示该进程所有线程的详细信息</li>
</ul>
<h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><p>iostat 也即 I/O statistics（输入/输出统计），iostat 会对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出 CPU 使用情况。但它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。</p>
<h2 id="命令常用参数-1"><a href="#命令常用参数-1" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><p>1．命令格式：</p>
<ul>
<li>iostat [参数][时间][次数]<br>2．命令功能：</li>
<li>通过 iostat 方便查看 CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况，负载信息。<br>3．命令参数：</li>
<li><code>-C</code>: 显示CPU使用情况</li>
<li><code>-d</code>: 显示磁盘使用情况</li>
<li><code>-k</code>: 以 KB 为单位显示</li>
<li><code>-m</code>: 以 M 为单位显示</li>
<li><code>-N</code>: 显示磁盘阵列(LVM) 信息</li>
<li><code>-n</code>: 显示NFS 使用情况</li>
<li><code>-p[磁盘]</code>: 显示磁盘和分区的情况</li>
<li><code>-t</code>: 显示终端和CPU的信息</li>
<li><code>-x</code>: 显示详细信息</li>
<li><code>-V</code>: 显示版本信息</li>
</ul>
<h2 id="显示说明-1"><a href="#显示说明-1" class="headerlink" title="显示说明"></a>显示说明</h2><p>使用 iostat 命令时，终端会显示很多很多的信息，这里介绍一下这些信息的含义。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ iostat</div><div class="line">Linux 2.6.32-431.20.3.el6.mt20150216.x86_64 (XXX) 	2017年07月16日 	_x86_64_	(32 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">          22.28    0.00   14.26    0.25    0.00   63.22</div><div class="line"></div><div class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</div><div class="line">sda              20.65       205.78       452.71 9429827972 20744862776</div></pre></td></tr></table></figure>
<ol>
<li>CPU 属性值说明：<ul>
<li><code>%user</code>：CPU 处在用户模式下的时间百分比</li>
<li><code>%nice</code>：CPU 处在带 NICE 值的用户模式下的时间百分比</li>
<li><code>%system</code>：CPU 处在系统模式下的时间百分比</li>
<li><code>%iowait</code>：CPU 等待输入输出完成时间的百分比</li>
<li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比</li>
<li><code>%idle</code>：CPU 空闲时间百分比</li>
</ul>
</li>
<li>disk 属性<ul>
<li><code>tps</code>：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。</li>
<li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li>
<li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li>
<li><code>kB_read</code>：读取的总数据量；</li>
<li><code>kB_wrtn</code>：写入的总数量数据量，这些单位都为Kilobytes。</li>
</ul>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ iostat -xm 3</div><div class="line">Linux 2.6.32-431.20.3.el6.mt20150216.x86_64 (XXX) 	2017年07月16日 	_x86_64_	(32 CPU)</div><div class="line"></div><div class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</div><div class="line">          22.28    0.00   14.26    0.25    0.00   63.21</div><div class="line"></div><div class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await  svctm  %util</div><div class="line">sda               0.50    42.34    6.47   14.18     0.10     0.22    31.90     0.02    1.20   0.44   0.90</div></pre></td></tr></table></figure>
<p>这里 disk 属性与上面的不太相同</p>
<ul>
<li><code>rrqm/s</code>: 每秒进行 merge 的读操作数目。即 rmerge/s</li>
<li><code>wrqm/s</code>: 每秒进行 merge 的写操作数目。即 wmerge/s</li>
<li><code>r/s</code>: 每秒完成的读 I/O 设备次数。即 rio/s</li>
<li><code>w/s</code>: 每秒完成的写 I/O 设备次数。即 wio/s</li>
<li><code>rsec/s</code>: 每秒读扇区数。即 rsect/s</li>
<li><code>wsec/s</code>: 每秒写扇区数。即 wsect/s</li>
<li><code>rkB/s</code>: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li>
<li><code>wkB/s</code>: 每秒写K字节数。是 wsect/s 的一半。</li>
<li><code>avgrq-sz</code>: 平均每次设备 I/O 操作的数据大小 (扇区)。</li>
<li><code>avgqu-sz</code>: 平均 I/O 队列长度。</li>
<li><code>await</code>: 平均每次设备 I/O 操作的等待时间 (毫秒)。</li>
<li><code>svctm</code>: 平均每次设备 I/O 操作的服务时间 (毫秒)。</li>
<li><code>%util</code>: 一秒中有百分之多少的时间用于 I/O 操作，即被 IO 消耗的 CPU 百分比。</li>
</ul>
<p>其中，下面是在实践中积累的一些经验</p>
<ol>
<li>如果 <code>%iowait</code> 的值过高，表示硬盘存在 I/O 瓶颈；</li>
<li><code>%idle</code> 值高，表示 CPU 较空闲，如果 <code>%idle</code> 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。<code>%idle</code> 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</li>
<li>如果 <code>%util</code> 接近 100%，说明产生的I/O请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈，其值大于 70% 时，磁盘的压力就很大了；</li>
<li>如果 <code>svctm</code> 比较接近 <code>await</code>，说明 I/O 几乎没有等待时间；如果 <code>await</code> 远大于 <code>svctm</code>，说明 I/O 队列太长，IO 响应太慢，则需要进行必要优化；</li>
<li>如果 <code>avgqu-sz</code> 比较大，也表示有当量 IO 在等待，它是 IO 调优时需要注意的地方，它是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小；</li>
<li>await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。</li>
</ol>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><ul>
<li><code>iostat 2 3</code>: 每隔 2 秒刷新显示，且显示 3 次；</li>
<li><code>iostat -d sda</code>: 显示指定磁盘信息；</li>
<li><code>iostat -t</code>: 显示 tty 和 CPU 信息；</li>
<li><code>iostat -m</code>: 以M为单位显示所有信息；</li>
<li><code>iostat -d -k 1 1</code>: 查看TPS和吞吐量信息；</li>
<li><code>iostat -c 1 3</code>: 查看cpu状态；</li>
</ul>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>ps —— 是 process status 的简称，它列出的是当前时刻那些进程的快照，如果想要动态的显示进程信息内容，可以使用 top 命令。</p>
<p>使用 ps 可以做以下事情：</p>
<ul>
<li>确定有哪些进程正在运行、查看运行的状态；</li>
<li>进程是否结束；</li>
<li>进程有没有僵死；</li>
<li>哪些进程占用了过多的资源等等。</li>
</ul>
<h2 id="Linux-进程的五种状态"><a href="#Linux-进程的五种状态" class="headerlink" title="Linux 进程的五种状态"></a>Linux 进程的五种状态</h2><p>在 Linux 上进程有5种状态，每种状态对应着不同的标识，如下表所示：</p>
<table>
<thead>
<tr>
<th>Linux 上状态</th>
<th>ps 的状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行（正在运行或在运行队列中等待）</td>
<td>R（running or on run queue）</td>
</tr>
<tr>
<td>中断（休眠中、受阻、在等待某个条件的形成和接收到信号）</td>
<td>S（sleeping）</td>
</tr>
<tr>
<td>不可中断（收到信号不唤醒和不可运行, 进程必须等待直到有中断发生）</td>
<td>D（uninterruptible sleep）</td>
</tr>
<tr>
<td>僵死（进程已终止，但进程描述符存在，直到父进程调用wait4()后才会释放）</td>
<td>Z（a defunct zombie process）</td>
</tr>
<tr>
<td>停止（进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行）</td>
<td>T（traced or stopped）</td>
</tr>
</tbody>
</table>
<h2 id="命令常用参数-2"><a href="#命令常用参数-2" class="headerlink" title="命令常用参数"></a>命令常用参数</h2><ol>
<li>命令格式<ul>
<li>ps [参数]</li>
</ul>
</li>
<li>命令参数<ul>
<li><code>a</code>：显示所有进程</li>
<li><code>-a</code>：显示同一终端下的所有程序</li>
<li><code>-A</code>：显示所有进程</li>
<li><code>c</code>：显示进程的真实名称</li>
<li><code>-N</code>：反向选择</li>
<li><code>e</code>：显示环境变量</li>
<li><code>f</code>：显示程序间的关系</li>
<li><code>-H</code>：显示树状结构</li>
<li><code>r</code>：显示当前终端的进程</li>
<li><code>T</code>：显示当前终端的所有程序</li>
<li><code>u</code>：指定用户的所有进程</li>
<li><code>-au</code>：显示较详细的资讯</li>
<li><code>-aux</code>：显示所有包含其他使用者的行程</li>
<li><code>-C&lt;命令&gt;</code>：列出指定命令的状况</li>
<li><code>--lines&lt;行数&gt;</code>：每页显示的行数</li>
<li><code>--width&lt;字符数&gt;</code>：每页显示的字符数</li>
<li><code>--help</code>：显示帮助信息</li>
<li><code>--version</code>：显示版本显示</li>
</ul>
</li>
</ol>
<h2 id="显示说明-2"><a href="#显示说明-2" class="headerlink" title="显示说明"></a>显示说明</h2><h3 id="将当前这次登入的-PID-与相关信息列示出来"><a href="#将当前这次登入的-PID-与相关信息列示出来" class="headerlink" title="将当前这次登入的 PID 与相关信息列示出来"></a>将当前这次登入的 PID 与相关信息列示出来</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ ps <span class="_">-l</span></div><div class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S   10 120177 120176  0  80   0 - 27078 <span class="built_in">wait</span>   pts/0    00:00:00 bash</div><div class="line">0 R   10 137912 120177  0  80   0 - 27031 -      pts/0    00:00:00 ps</div></pre></td></tr></table></figure>
<p>上面各个参数的含义：</p>
<ul>
<li><code>F</code>: 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>
<li><code>S</code>: 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</li>
<li><code>UID</code>: 程序被该 UID 所拥有</li>
<li><code>PID</code>: 就是这个程序的 ID</li>
<li><code>PPID</code>: 则是其上级父程序的ID</li>
<li><code>C</code>: CPU 使用的资源百分比</li>
<li><code>PRI</code>: 这个是 Priority (优先执行序) 的缩写</li>
<li><code>NI</code>: 这个是 Nice 值</li>
<li><code>ADDR</code>: 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>
<li><code>SZ</code>: 使用掉的内存大小</li>
<li><code>WCHAN</code>: 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>
<li><code>TTY</code>: 登入者的终端机位置</li>
<li><code>TIME</code>: 使用掉的 CPU 时间。</li>
<li><code>CMD</code>: 所下达的指令为何</li>
</ul>
<h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[matt@XXX ~]$ ps aux</div><div class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root          1  0.5  0.8 1184632 1166268 ?     Ss    2016 4029:48 /sbin/init</div><div class="line">root          2  0.0  0.0      0     0 ?        S     2016   0:00 [kthreadd]</div><div class="line">root          3  0.0  0.0      0     0 ?        S     2016  36:36 [migration/0]</div></pre></td></tr></table></figure>
<p>上面各个参数的含义：</p>
<ul>
<li><code>USER</code>：该 process 属于那个使用者账号的</li>
<li><code>PID</code>：该 process 的号码</li>
<li><code>%CPU</code>：该 process 使用掉的 CPU 资源百分比</li>
<li><code>%MEM</code>：该 process 所占用的物理内存百分比</li>
<li><code>VSZ</code>：该 process 使用掉的虚拟内存量 (Kbytes)</li>
<li><code>RSS</code>：该 process 占用的固定的内存量 (Kbytes)</li>
<li><code>TTY</code>：该 process 是在那个终端机上面运作，若与终端机无关，则显示 <code>?</code>，若为 <code>pts/0</code> 等等的，则表示为由网络连接进主机的程序。</li>
<li><code>STAT</code>：该程序目前的状态</li>
<li><code>START</code>：该 process 被触发启动的时间</li>
<li><code>TIME</code>：该 process 实际使用 CPU 运作的时间</li>
<li><code>COMMAND</code>：该程序的实际指令</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>ps 的常用命令主要有以下几种用法：</p>
<ul>
<li><code>ps -A</code>: 显示所有进程信息</li>
<li><code>ps -u root</code>: 显示指定用户信息</li>
<li><code>ps -ef</code>: 显示所有进程信息，连同命令行</li>
<li>与 <code>grep</code> 一起，来查看指定的进程。</li>
</ul>
<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2013/03/08/2949194.html" target="_blank" rel="external">每天一个linux命令（56）：netstat命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/28/2837345.html" target="_blank" rel="external">每天一个linux命令（47）：iostat命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="external">每天一个linux命令（41）：ps命令</a></li>
<li><a href="http://www.cnblogs.com/peida/archive/2012/12/25/2831814.html" target="_blank" rel="external">每天一个linux命令（45）：free 命令</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章的内容，基本来自&lt;a href=&quot;http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://matt33.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 Producer Metadata 更新机制（二）</title>
    <link href="http://matt33.com/2017/07/08/kafka-producer-metadata/"/>
    <id>http://matt33.com/2017/07/08/kafka-producer-metadata/</id>
    <published>2017-07-08T15:51:00.000Z</published>
    <updated>2017-07-09T01:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，已经介绍了 Producer 的发送模型，Producer <code>dosend()</code> 方法中的第一步，就是获取相关的 topic 的 metadata，但在上篇中并没有深入展开，因为这部分的内容比较多，所以本文单独一篇文章进行介绍，本文主要来讲述以下三个问题：</p>
<ol>
<li>metadata 内容是什么；</li>
<li>Producer 更新 metadata 的流程；</li>
<li>Producer 在什么情况下会去更新 metadata；</li>
</ol>
<h2 id="Metadata-内容"><a href="#Metadata-内容" class="headerlink" title="Metadata 内容"></a>Metadata 内容</h2><p>Metadata 信息的内容可以通过源码看明白：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个类被 client 线程和后台 sender 所共享,它只保存了所有 topic 的部分数据,当我们请求一个它上面没有的 topic meta 时,它会通过发送 metadata update 来更新 meta 信息,</span></div><div class="line"><span class="comment">// 如果 topic meta 过期策略是允许的,那么任何 topic 过期的话都会被从集合中移除,</span></div><div class="line"><span class="comment">// 但是 consumer 是不允许 topic 过期的因为它明确地知道它需要管理哪些 topic</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Metadata</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Metadata.class);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_MS = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TOPIC_EXPIRY_NEEDS_UPDATE = -<span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> refreshBackoffMs; <span class="comment">// metadata 更新失败时,为避免频繁更新 meta,最小的间隔时间,默认 100ms</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> metadataExpireMs; <span class="comment">// metadata 的过期时间, 默认 60,000ms</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version; <span class="comment">// 每更新成功1次，version自增1,主要是用于判断 metadata 是否更新</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRefreshMs; <span class="comment">// 最近一次更新时的时间（包含更新失败的情况）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastSuccessfulRefreshMs; <span class="comment">// 最近一次成功更新的时间（如果每次都成功的话，与前面的值相等, 否则，lastSuccessulRefreshMs &lt; lastRefreshMs)</span></div><div class="line">    <span class="keyword">private</span> Cluster cluster; <span class="comment">// 集群中一些 topic 的信息</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needUpdate; <span class="comment">// 是都需要更新 metadata</span></div><div class="line">    <span class="comment">/* Topics with expiry time */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Long&gt; topics; <span class="comment">// topic 与其过期时间的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Listener&gt; listeners; <span class="comment">// 事件监控者</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResourceListeners clusterResourceListeners; <span class="comment">//当接收到 metadata 更新时, ClusterResourceListeners的列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needMetadataForAllTopics; <span class="comment">// 是否强制更新所有的 metadata</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> topicExpiryEnabled; <span class="comment">// 默认为 true, Producer 会定时移除过期的 topic,consumer 则不会移除</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 topic 的详细信息（leader 所在节点、replica 所在节点、isr 列表）都是在 <code>Cluster</code> 实例中保存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并不是一个全集,metadata的主要组成部分</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cluster</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 从命名直接就看出了各个变量的用途</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isBootstrapConfigured;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Node&gt; nodes; <span class="comment">// node 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; unauthorizedTopics; <span class="comment">// 未认证的 topic 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; internalTopics; <span class="comment">// 内置的 topic 列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, PartitionInfo&gt; partitionsByTopicPartition; <span class="comment">// partition 的详细信息</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; partitionsByTopic; <span class="comment">// topic 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;PartitionInfo&gt;&gt; availablePartitionsByTopic; <span class="comment">//  可用（leader 不为 null）的 topic 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, List&lt;PartitionInfo&gt;&gt; partitionsByNode; <span class="comment">// node 与 partition 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; nodesById; <span class="comment">// node 与 id 的对应关系</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResource clusterResource;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// org.apache.kafka.common.PartitionInfo</span></div><div class="line"><span class="comment">// topic-partition: 包含 topic、partition、leader、replicas、isr</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node leader;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] replicas;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] inSyncReplicas;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Cluster</code> 实例主要是保存：</p>
<ol>
<li>broker.id 与 <code>node</code> 的对应关系；</li>
<li>topic 与 partition （<code>PartitionInfo</code>）的对应关系；</li>
<li><code>node</code> 与 partition （<code>PartitionInfo</code>）的对应关系。</li>
</ol>
<h2 id="Producer-的-Metadata-更新流程"><a href="#Producer-的-Metadata-更新流程" class="headerlink" title="Producer 的 Metadata 更新流程"></a>Producer 的 Metadata 更新流程</h2><p>Producer 在调用 <code>dosend()</code> 方法时，第一步就是通过 <code>waitOnMetadata</code> 方法获取该 topic 的 metadata 信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等待 metadata 的更新</span></div><div class="line"><span class="function"><span class="keyword">private</span> ClusterAndWaitTime <span class="title">waitOnMetadata</span><span class="params">(String topic, Integer partition, <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    metadata.add(topic);<span class="comment">// 在 metadata 中添加 topic 后,如果 metadata 中没有这个 topic 的 meta，那么 metadata 的更新标志设置为了 true</span></div><div class="line">    Cluster cluster = metadata.fetch();</div><div class="line">    Integer partitionsCount = cluster.partitionCountForTopic(topic);<span class="comment">// 如果 topic 已经存在 meta 中,则返回该 topic 的 partition 数,否则返回 null</span></div><div class="line"></div><div class="line">    <span class="comment">// 当前 metadata 中如果已经有这个 topic 的 meta 的话,就直接返回</span></div><div class="line">    <span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> begin = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</div><div class="line">    <span class="keyword">long</span> elapsed;</div><div class="line"></div><div class="line">    <span class="comment">// 发送 metadata 请求,直到获取了这个 topic 的 metadata 或者请求超时</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        log.trace(<span class="string">"Requesting metadata update for topic &#123;&#125;."</span>, topic);</div><div class="line">        <span class="keyword">int</span> version = metadata.requestUpdate();<span class="comment">// 返回当前版本号,初始值为0,每次更新时会自增,并将 needUpdate 设置为 true</span></div><div class="line">        sender.wakeup();<span class="comment">// 唤起 sender，发送 metadata 请求</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            metadata.awaitUpdate(version, remainingWaitMs);<span class="comment">// 等待 metadata 的更新</span></div><div class="line">        &#125; <span class="keyword">catch</span> (TimeoutException ex) &#123;</div><div class="line">            <span class="comment">// Rethrow with original maxWaitMs to prevent logging exception with remainingWaitMs</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</div><div class="line">        &#125;</div><div class="line">        cluster = metadata.fetch();</div><div class="line">        elapsed = time.milliseconds() - begin;</div><div class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);<span class="comment">// 超时</span></div><div class="line">        <span class="keyword">if</span> (cluster.unauthorizedTopics().contains(topic))<span class="comment">// 认证失败，对当前 topic 没有 Write 权限</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TopicAuthorizationException(topic);</div><div class="line">        remainingWaitMs = maxWaitMs - elapsed;</div><div class="line">        partitionsCount = cluster.partitionCountForTopic(topic);</div><div class="line">    &#125; <span class="keyword">while</span> (partitionsCount == <span class="keyword">null</span>);<span class="comment">// 不停循环,直到 partitionsCount 不为 null（即直到 metadata 中已经包含了这个 topic 的相关信息）</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (partition != <span class="keyword">null</span> &amp;&amp; partition &gt;= partitionsCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(</div><div class="line">                String.format(<span class="string">"Invalid partition given with record: %d is not in the range [0...%d)."</span>, partition, partitionsCount));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, elapsed);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 metadata 中不存在这个 topic 的 metadata，那么就请求更新 metadata，如果 metadata 没有更新的话，方法就一直处在 <code>do ... while</code> 的循环之中，在循环之中，主要做以下操作：</p>
<ol>
<li><code>metadata.requestUpdate()</code> 将 metadata 的 <code>needUpdate</code> 变量设置为 true（强制更新），并返回当前的版本号（version），通过版本号来判断 metadata 是否完成更新；</li>
<li><code>sender.wakeup()</code> 唤醒 sender 线程，sender 线程又会去唤醒 <code>NetworkClient</code> 线程，<code>NetworkClient</code> 线程进行一些实际的操作（后面详细介绍）；</li>
<li><code>metadata.awaitUpdate(version, remainingWaitMs)</code> 等待 metadata 的更新。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新 metadata 信息（根据当前 version 值来判断）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">awaitUpdate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> lastVersion, <span class="keyword">final</span> <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxWaitMs &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Max time to wait for metadata updates should not be &lt; 0 milli seconds"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.version &lt;= lastVersion) &#123;<span class="comment">// 不断循环,直到 metadata 更新成功,version 自增</span></div><div class="line">        <span class="keyword">if</span> (remainingWaitMs != <span class="number">0</span>)</div><div class="line">            wait(remainingWaitMs);<span class="comment">// 阻塞线程，等待 metadata 的更新</span></div><div class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - begin;</div><div class="line">        <span class="keyword">if</span> (elapsed &gt;= maxWaitMs)<span class="comment">// timeout</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Failed to update metadata after "</span> + maxWaitMs + <span class="string">" ms."</span>);</div><div class="line">        remainingWaitMs = maxWaitMs - elapsed;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Metadata.awaitUpdate()</code> 方法中，线程会阻塞在 <code>while</code> 循环中，直到 metadata 更新成功或者 timeout。</p>
<p>从前面可以看出，此时 Producer 线程会阻塞在两个 <code>while</code> 循环中，直到 metadata 信息更新，那么 metadata 是如何更新的呢？如果有印象的话，前面应该已经介绍过了，主要是通过 <code>sender.wakeup()</code> 来唤醒 sender 线程，间接唤醒 NetworkClient 线程，NetworkClient 线程来负责发送 Metadata 请求，并处理 Server 端的响应。</p>
<p>在 <a href="http://matt33.com/2017/06/25/kafka-producer-send-module/">Kafka 源码分析之 Producer 发送模型（一）</a> 中介绍 Producer 发送模型时，在第五步 <code>sender</code> 线程会调用 <code>NetworkClient.poll()</code> 方法进行实际的操作，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);<span class="comment">// 判断是否需要更新 meta,如果需要就更新（请求更新 metadata 的地方）</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"Unexpected error during I/O"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// process completed actions</span></div><div class="line">        <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</div><div class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        handleAbortedSends(responses);</div><div class="line">        handleCompletedSends(responses, updatedNow);<span class="comment">// 通过 selector 中获取 Server 端的 response</span></div><div class="line">        handleCompletedReceives(responses, updatedNow);<span class="comment">// 在返回的 handler 中，会处理 metadata 的更新</span></div><div class="line">        handleDisconnections(responses, updatedNow);</div><div class="line">        handleConnections();</div><div class="line">        handleInitiateApiVersionRequests(updatedNow);</div><div class="line">        handleTimedOutRequests(responses, updatedNow);</div><div class="line"></div><div class="line">        <span class="comment">// invoke callbacks</span></div><div class="line">        <span class="keyword">for</span> (ClientResponse response : responses) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response.onComplete();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                log.error(<span class="string">"Uncaught error in request completion:"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> responses;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，主要会以下操作：</p>
<ul>
<li><code>metadataUpdater.maybeUpdate(now)</code>：判断是否需要更新 Metadata，如果需要更新的话，先与 Broker 建立连接，然后发送更新 metadata 的请求；</li>
<li>处理 Server 端的一些响应，这里主要讨论的是 <code>handleCompletedReceives(responses, updatedNow)</code> 方法，它会处理 Server 端返回的 Metadata 结果。</li>
</ul>
<p>先看一下 <code>metadataUpdater.maybeUpdate()</code> 的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="comment">// should we update our metadata?</span></div><div class="line">        <span class="comment">// metadata 是否应该更新</span></div><div class="line">        <span class="keyword">long</span> timeToNextMetadataUpdate = metadata.timeToNextUpdate(now);<span class="comment">// metadata 下次更新的时间（需要判断是强制更新还是 metadata 过期更新,前者是立马更新,后者是计算 metadata 的过期时间）</span></div><div class="line">        <span class="comment">// 如果一条 metadata 的 fetch 请求还未从 server 收到恢复,那么时间设置为 waitForMetadataFetch（默认30s）</span></div><div class="line">        <span class="keyword">long</span> waitForMetadataFetch = <span class="keyword">this</span>.metadataFetchInProgress ? requestTimeoutMs : <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> metadataTimeout = Math.max(timeToNextMetadataUpdate, waitForMetadataFetch);</div><div class="line">        <span class="keyword">if</span> (metadataTimeout &gt; <span class="number">0</span>) &#123;<span class="comment">// 时间未到时,直接返回下次应该更新的时间</span></div><div class="line">            <span class="keyword">return</span> metadataTimeout;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node node = leastLoadedNode(now);<span class="comment">// 选择一个连接数最小的节点</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            log.debug(<span class="string">"Give up sending metadata request since no node is available"</span>);</div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> maybeUpdate(now, node); <span class="comment">// 可以发送 metadata 请求的话,就发送 metadata 请求</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a metadata request to the list of sends if we can make one</div><div class="line">     */</div><div class="line">    <span class="comment">// 判断是否可以发送请求,可以的话将 metadata 请求加入到发送列表中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now, Node node)</span> </span>&#123;</div><div class="line">        String nodeConnectionId = node.idString();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (canSendRequest(nodeConnectionId)) &#123;<span class="comment">// 通道已经 ready 并且支持发送更多的请求</span></div><div class="line">            <span class="keyword">this</span>.metadataFetchInProgress = <span class="keyword">true</span>; <span class="comment">// 准备开始发送数据,将 metadataFetchInProgress 置为 true</span></div><div class="line">            MetadataRequest.Builder metadataRequest; <span class="comment">// 创建 metadata 请求</span></div><div class="line">            <span class="keyword">if</span> (metadata.needMetadataForAllTopics())<span class="comment">// 强制更新所有 topic 的 metadata（虽然默认不会更新所有 topic 的 metadata 信息，但是每个 Broker 会保存所有 topic 的 meta 信息）</span></div><div class="line">                metadataRequest = MetadataRequest.Builder.allTopics();</div><div class="line">            <span class="keyword">else</span> <span class="comment">// 只更新 metadata 中的 topics 列表（列表中的 topics 由 metadata.add() 得到）</span></div><div class="line">                metadataRequest = <span class="keyword">new</span> MetadataRequest.Builder(<span class="keyword">new</span> ArrayList&lt;&gt;(metadata.topics()));</div><div class="line"></div><div class="line"></div><div class="line">            log.debug(<span class="string">"Sending metadata request &#123;&#125; to node &#123;&#125;"</span>, metadataRequest, node.id());</div><div class="line">            sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);/ 发送 metadata 请求</div><div class="line">            <span class="keyword">return</span> requestTimeoutMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If there's any connection establishment underway, wait until it completes. This prevents</span></div><div class="line">        <span class="comment">// the client from unnecessarily connecting to additional nodes while a previous connection</span></div><div class="line">        <span class="comment">// attempt has not been completed.</span></div><div class="line">        <span class="keyword">if</span> (isAnyNodeConnecting()) &#123;<span class="comment">// 如果 client 正在与任何一个 node 的连接状态是 connecting,那么就进行等待</span></div><div class="line">            <span class="comment">// Strictly the timeout we should return here is "connect timeout", but as we don't</span></div><div class="line">            <span class="comment">// have such application level configuration, using reconnect backoff instead.</span></div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;<span class="comment">// 如果没有连接这个 node,那就初始化连接</span></div><div class="line">            <span class="comment">// we don't have a connection to this node right now, make one</span></div><div class="line">            log.debug(<span class="string">"Initialize connection to node &#123;&#125; for sending metadata request"</span>, node.id());</div><div class="line">            initiateConnect(node, now);<span class="comment">// 初始化连接</span></div><div class="line">            <span class="keyword">return</span> reconnectBackoffMs;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Long.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="comment">// 发送 Metadata 请求   </span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInternalMetadataRequest</span><span class="params">(MetadataRequest.Builder builder,</span></span></div><div class="line">                                         String nodeConnectionId, <span class="keyword">long</span> now) &#123;</div><div class="line">    ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, <span class="keyword">true</span>);<span class="comment">// 创建 metadata 请求</span></div><div class="line">    doSend(clientRequest, <span class="keyword">true</span>, now);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以，每次 Producer 请求更新 metadata 时，会有以下几种情况：</p>
<ol>
<li>如果 node 可以发送请求，则直接发送请求；</li>
<li>如果该 node 正在建立连接，则直接返回；</li>
<li>如果该 node 还没建立连接，则向 broker 初始化链接。</li>
</ol>
<p>而 KafkaProducer 线程之前是一直阻塞在两个 <code>while</code> 循环中，直到 metadata 更新</p>
<ol>
<li>sender 线程第一次调用 <code>poll()</code> 方法时，初始化与 node 的连接；</li>
<li>sender 线程第二次调用 <code>poll()</code> 方法时，发送 <code>Metadata</code> 请求；</li>
<li>sender 线程第三次调用 <code>poll()</code> 方法时，获取 <code>metadataResponse</code>，并更新 metadata。</li>
</ol>
<p>经过上述 sender 线程三次调用 <code>poll()</code>方法，所请求的 metadata 信息才会得到更新，此时 Producer 线程也不会再阻塞，开始发送消息。</p>
<p><code>NetworkClient</code> 接收到 Server 端对 Metadata 请求的响应后，更新 Metadata 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理任何已经完成的接收响应</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCompletedReceives</span><span class="params">(List&lt;ClientResponse&gt; responses, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (NetworkReceive receive : <span class="keyword">this</span>.selector.completedReceives()) &#123;</div><div class="line">            String source = receive.source();</div><div class="line">            InFlightRequest req = inFlightRequests.completeNext(source);</div><div class="line">            AbstractResponse body = parseResponse(receive.payload(), req.header);</div><div class="line">            log.trace(<span class="string">"Completed receive from node &#123;&#125;, for key &#123;&#125;, received &#123;&#125;"</span>, req.destination, req.header.apiKey(), body);</div><div class="line">            <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> MetadataResponse)<span class="comment">// 如果是 meta 响应</span></div><div class="line">                metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> ApiVersionsResponse)</div><div class="line">                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body); <span class="comment">// 如果是其他响应</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                responses.add(req.completed(body, now));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理 Server 端对 Metadata 请求处理后的 response</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCompletedMetadataResponse</span><span class="params">(RequestHeader requestHeader, <span class="keyword">long</span> now, MetadataResponse response)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.metadataFetchInProgress = <span class="keyword">false</span>;</div><div class="line">            Cluster cluster = response.cluster();</div><div class="line">            <span class="comment">// check if any topics metadata failed to get updated</span></div><div class="line">            Map&lt;String, Errors&gt; errors = response.errors();</div><div class="line">            <span class="keyword">if</span> (!errors.isEmpty())</div><div class="line">                log.warn(<span class="string">"Error while fetching metadata with correlation id &#123;&#125; : &#123;&#125;"</span>, requestHeader.correlationId(), errors);</div><div class="line"></div><div class="line">            <span class="comment">// don't update the cluster if there are no valid nodes...the topic we want may still be in the process of being</span></div><div class="line">            <span class="comment">// created which means we will get errors and no nodes until it exists</span></div><div class="line">            <span class="keyword">if</span> (cluster.nodes().size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.metadata.update(cluster, now);<span class="comment">// 更新 meta 信息</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果 metadata 中 node 信息无效,则不更新 metadata 信息</span></div><div class="line">                log.trace(<span class="string">"Ignoring empty metadata response with correlation id &#123;&#125;."</span>, requestHeader.correlationId());</div><div class="line">                <span class="keyword">this</span>.metadata.failedUpdate(now);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="Producer-Metadata-的更新策略"><a href="#Producer-Metadata-的更新策略" class="headerlink" title="Producer Metadata 的更新策略"></a>Producer Metadata 的更新策略</h2><p>Metadata 会在下面两种情况下进行更新</p>
<ol>
<li>KafkaProducer 第一次发送消息时强制更新，其他时间周期性更新，它会通过 Metadata 的 <code>lastRefreshMs</code>, <code>lastSuccessfulRefreshMs</code> 这2个字段来实现；</li>
<li>强制更新： 调用 <code>Metadata.requestUpdate()</code> 将 <code>needUpdate</code> 置成了 true 来强制更新。</li>
</ol>
<p>在 NetworkClient 的 <code>poll()</code> 方法调用时，就会去检查这两种更新机制，只要达到其中一种，就行触发更新操作。</p>
<p>Metadata 的强制更新会在以下几种情况下进行：</p>
<ol>
<li><code>initConnect</code> 方法调用时，初始化连接；</li>
<li><code>poll()</code> 方法中对 <code>handleDisconnections()</code> 方法调用来处理连接断开的情况，这时会触发强制更新；</li>
<li><code>poll()</code> 方法中对 <code>handleTimedOutRequests()</code> 来处理请求超时时；</li>
<li>发送消息时，如果无法找到 partition 的 leader；</li>
<li>处理 Producer 响应（<code>handleProduceResponse</code>），如果返回关于 Metadata 过期的异常，比如：没有 topic-partition 的相关 meta 或者 client 没有权限获取其 metadata。</li>
</ol>
<p>强制更新主要是用于处理各种异常情况。</p>
<p>参考文档：</p>
<ul>
<li><a href="http://blog.csdn.net/chunlongyu/article/details/52622422" target="_blank" rel="external">Kafka源码深度解析－序列2 －Producer －Metadata的数据结构与读取、更新策略</a>；</li>
<li><a href="http://luodw.cc/2017/05/02/kafka02/" target="_blank" rel="external">kafka源码分析之Producer</a>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，已经介绍了 Producer 的发送模型，Producer &lt;code&gt;dosend()&lt;/code&gt; 方法中的第一步，就是获取相关的 topic 的 metadata，但在上篇中并没有深入展开，因为这部分的内容比较多，所以本文单独一篇文章进行介绍，本文主要
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>买房感想</title>
    <link href="http://matt33.com/2017/07/02/buy-little-room/"/>
    <id>http://matt33.com/2017/07/02/buy-little-room/</id>
    <published>2017-07-02T13:38:38.000Z</published>
    <updated>2017-08-30T12:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>落户+买房的事情终于搞定得差不多了（就差贷款合同的签署），六月份这个月已经往来杭州3趟，从四月底开始看房到现在，这一路真是五味杂粮、感慨颇多，亲身地感觉到生活之不易，无忧无虑的生活从离开大学的那一刻开始就已经结束，读研这两年半看似浑浑噩噩，但早已没有大学时的那种轻松惬意，或许这就是成长。</p>
<h2 id="去库存历史进程"><a href="#去库存历史进程" class="headerlink" title="去库存历史进程"></a>去库存历史进程</h2><p>从四月底看房到7.1签合同，杭州房价整体至少涨了20%（间接地上涨，刚需买房的成本涨得更多），简单举几个例子，都是个人的亲身经历：</p>
<ul>
<li>万科杭宸，成品装修，同学三月购入，当时三成首付、单价 2w 出头，五月我去看房时，销售态度也很好，让等认筹通知，等到六月份时，杭宸通知只接受全款或七成首付（最后情况是只接受全款）；</li>
<li>西溪璞园，四月底去看，当时有特价房，125 平大概 245w（均价1.9w，位置还好），6月初通知有一套小户型房源，顶楼，单价2.2w，遂吧；</li>
<li>东海闲湖城，三月开盘三幢楼，由于政府限价，均价只有1.2w，结果很明显，两三天就被抢完（当时市场还并不是太热），后面由于备案价格上不去，开发商目前选择直接封盘（后面三幢据说下半年开盘），车位从5月开始由 13w 涨到 16w；</li>
<li>万家之星，六月初去看盘，销售不怎么搭理，直接明说，现在要买的话只能去找关系，让去找滨江或旭辉的内部人员；</li>
<li>雅居乐国际花园，六月初第一次看，开盘当天小户型全部售罄，只剩 128 平，不过户型很好，只是没有看上这个小区，感觉小区人太多、楼太高（32层，4000户），后来六月再次开盘时，小户型依然是难抢；</li>
<li>….</li>
</ul>
<p>上面都是自己去踩过的盘，也都是真实的信息，我们可以再看一下去年7月份之前一些楼盘的价格，比如杭宸1.8w（现在2.3w）、桃源小镇 8k（现在1.8w）、科技城 1.5w（现在中心地带已经 3w+）、蒋村二手 2w 多点（现在 3.7w+）…，如果按 2016 年初的价格现在基本平均已经翻了 2-3 倍，当然并不是仅仅是杭州，全国一线城市和强二线城市都一样，郑州东区均价都到 1.5w、北京东西城均价 13w+ 朝阳海淀均价 9w+（目前调控虽说降了，但没什么卵用）、天津杭州均价到了 2w（之前是 1w），浩浩荡荡，当一线二线城市开始猛涨时，我们才意识到原来特么这就是<strong>去库存</strong>，通过房子把政府的债务轻轻松松转移到了普通百姓的身上，我们拿着纸面上的财富开始为银行打工。当然如果你有机会去为银行打工，那证明你还算是幸运的，因为你抓住机会已经买了房，更多的人根本就没抓住机会（就像楼主我），有人在这一历史进程中 all in 杭州，在短短一年的时间赚了几百万。</p>
<p>能看到机会的人毕竟是少数，当所有人都意识到机会的时候，市场已经变得疯狂，而且各种限购政策开始实施，这时候入场的人能赚到大钱的已经很少，很多可能已经开始站岗。去库存这一历史进程，在共和国、乃至中华民族史上都是可以载入史册的大事件（好坏无法评论，很多东西只有过些年才能看清楚其意义），它让一线城市有房的人身价迅速加了 500w+（多套房的就增加了千万），强二线城市有房的人身价涨了 100w+，这一切短短只需要一年，在这之前恐怕很少人相信现实是这么疯狂。而对于那些房价没有翻倍的城市，从此消彼长的角度看相当于其财富洗劫了，被一线二线城市洗劫，而且即使三四线城市的房价翻一倍，也免不了被洗劫的命运，北京翻一倍就是几百万上千万，而三四线只是几十万，这没有任何可比性。去库存造就了多少百万富翁，实在想不出来建国以来除了改革开放还有什么能造就这么多富翁。</p>
<p>任何事情都有好坏两方面，对于政府来说，可以实现两个效果：一、地方债务转移；二、一二线城市开始驱逐低收入或者买不起房的人，表面上看对于政府都是利好的，深层次分析，就不好说了，长征五号连续发射失败对于政府应该是一个警钟。从个人的角度来说，买到房的人（上车的人）个人资产迅速翻倍，没有买到房的人离买房越来越遥远。而买到房抓住机会的永远是少数，大部分人是这次去库存的受害者，去库存前可能马上就攒够了首付的钱，但一年之后却发现首付涨得远远超过了攒钱的速度，收入高点的还好说，可以去二线城市占坑，但另外一些人，他们已经被遗忘了。</p>
<p>现实就是这么残酷，没有人会去同情，我们只能去依靠自己，努力工作，为自己也为家人，其他的我们又能做些什么呢？</p>
<p>亲身经历浩浩荡荡的去库存历史进程，也算是大开眼界，这种事情在全世界史上都不是很常见，我们再次用了极短的时间完成发达国家几十年甚至上百年的进程，不出意外，未来我们还会经历更多可以载入史册的事件，但此时我们希望的是自己能够抓住机会，历史告诉我们，大事件背后隐藏的都是巨大的机会（过去的已经成为历史，历史不会重复，但我们可以从历史中去学习经验）。就像雄安一出来，那么多人跑过去买房，但是雄安早已封盘，而且雄安的商品房规划可能会像新加坡一样，政府全面提供廉租房，商品房在雄安将会退出历史舞台，这并不是那些炒房客的机会，他们只是得了去库存的后遗症。</p>
<h2 id="一线赶人，二线抢人"><a href="#一线赶人，二线抢人" class="headerlink" title="一线赶人，二线抢人"></a>一线赶人，二线抢人</h2><p>小时候，我们一直被灌输一种概念：人口是负担，如果我们人少一些，我们也可以过上美国人一样的生活。但是，现在我们却发现，人口是国家财富，看看那些鬼城，没有人的话规划得再好，没有任何用。北上深，这三个一线城市，他们在过去三十年的快速发展，既有政府集全国之力去发展（深圳除外，主要指北京和上海），可以修建的东方明珠、鸟巢，花得是全国公民的钱，但是却修在了上海和北京，这就是政策利好，然后到现在，以北京为例，出了以下这些政策：</p>
<ul>
<li>北京落户名额每年都在缩减；</li>
<li>北京控地，近两年新增住宅用地达到历史最低水平；</li>
<li>北京高校对非京籍博士总额做限制；</li>
<li>疏解低端产业，未来北京人口减少到 X；</li>
<li>…</li>
</ul>
<p>这都在向我们传递一个信号：北京不是想呆就能呆的地方，曾经<code>北京欢迎你</code>的时代已经过去，现在是一个新的时代。同时，也可以看到政府规划了各种城市群，来缓解一线的压力，中国 2016 的城市化率是 57%，经验告诉我们，一旦达到这个值之后，后面的城市化率将会以更快速度的增长，在之前，大部分高校毕业生都去了一线城市，做起了北漂、上漂、深漂，然而这几个大城市的容量是有限的，早些年来的人已经在一线扎根，现在留给我们的就会已经很少了。现在政府开始鼓励毕业生去二线城市发展，比较牛的二线城市，像杭州、南京、武汉以及一线城市深圳，都开始搞出了各种吸引人才政策，希望能把相关专业的高校毕业生（所谓的才人）吸引到本地，杭州和深圳本地高校少，只能从外地吸引，武汉和南京本地高校多，想的是怎么把自己培养的毕业生留下来，不得不说这几个城市哪个能吸引到更多高校毕业生，哪个城市未来的潜力就会更大一些。对于高校毕业生来说，大家主要关心是两方面：一个就业机会、一个是房价，一线城市的房价已经远远超出普通人的承受能力，甚至可以说，年薪100w（税前）在北上深都很有压力。所以对于二线城市来说，拥有较好就业机会以及较低房价的城市，未来肯定会吸引到更多的人才，只有把人吸引来了，这个城市未来才能飞速发展，中国确实需要培养更多的大城市，仅仅靠北上深三个城市，是带不起整个中国的。</p>
<h2 id="生活之不易，最难的永远在后面"><a href="#生活之不易，最难的永远在后面" class="headerlink" title="生活之不易，最难的永远在后面"></a>生活之不易，最难的永远在后面</h2><p>在国内，这几年讨论最多的就是房价，记得高中时，房价就已经是家常便饭，尤其是《蜗居》这部电视剧热播，全民开始讨论房价，但从现在来看，那时的房价真叫一个便宜。房子是我们的生活必需品，更何况房子跟户口、学校都是绑定在一起的，这就让房子成为家庭的必需品，结婚要婚房、小孩上学要学区房。。。一套房贷款之后，基本上要还30年，未来就要为银行工作30年，如果不买房，自己就是在为房东打工，甚至随时都会面对房租的上涨，所有的一切都逼着你去买房。</p>
<p>昨天正式签了合同，刚需的问题总算解决了，买的位置不是很好，未来的前景很难说，但是不买又没办法，今天还能买这，过半年可能就只能买更远的地方了。买完之后，跟一个朋友聊天，突然觉得压力更大了，贷款的压力还可以接受。但未来一旦有了孩子，孩子的支出、上学等等，这些都不是小数目，真的怀疑自己能不能承受住这么大支出，现在真的很理解那些选择不要孩子的一族。经济越发达的地方，生育率就越低，尤其是东亚这边深受儒家文化影响的民族，像日本韩国生育率比欧洲、澳洲、美洲低很多，东亚民族普遍对孩子投入较多，导致父母压力更大，所以越来越多的人不愿意去生孩子。</p>
<p>眼前的问题解决了，去年定一个的最重要的年度计划完成了，但是更大、更难的问题还在后面，然而<strong>现在能做的只能是花更多的时间去投资自己</strong>，不然的话真的害怕自己没有足够的能力为家庭提供一个好的生活。内地一年毕业600w+的大学生，在这样的竞争压力下，你若不努力，就会被淘汰，这就是现实社会中的达尔文主义。</p>
<h2 id="寒门再难在一二线扎根"><a href="#寒门再难在一二线扎根" class="headerlink" title="寒门再难在一二线扎根"></a>寒门再难在一二线扎根</h2><p>之前看到一个说法，说的是：中国70-90年代的精英大多来自农村，而90年代后的精英大都来自中产阶级。以互联网为例，这些大佬们，马云、马化腾、李彦宏、周鸿祎、刘强东、王兴等，家境较差的也只有刘强东了，其他人的家庭背景至少都是中产，农村走出来的人，在目前的精英阶层中还占有一定比例，未来的话这个比例估计会越来越低，最明显的是今年（2017）的高考状元，没有一个农村出身（网上的新闻），虽然这个并不能完全反映，但至少间接地反映了一些问题。</p>
<p>回到本文的主题 —- 房子，现在普遍有一种说法，想在北京扎根，家庭至少要能提供 200w 资金，要不然几乎不太有可能在北京扎根，昌平顺义的房子现在都已经 4w+ 了，离地铁近的恐怕都得 5w+，一般家庭的人如何负担得起。在去库存的这一历史进程中，一二城市的房价都已经翻倍，没有房子的人，相当于自己的财富被洗劫了一番，因为他并没有增加任何财富，而自己未来购房的成本却翻了不止一倍。对于普通人，尤其是来自农村家庭的孩子，感觉未来真的很难在一二线城市扎根，农村的孩子受到的教育本来就比城市差一些，而且父母管教得也不多，如果这些孩子再不知道努力的话，他们以后如何突破？甚至有可能会导致一个恶性循环，就像美国贫民区一样。</p>
<p>以前的时候在政治、历史书老是看到什么农民阶级的愚昧无知，鲁迅先生经常就会批判，因为自己出身于农村，每次回到家里，其实都能明显感觉到这一点，他们对于很多新鲜的事务都不是很了解、不懂理财不懂投资、更不懂得去投资自己，想想这样教育出来好孩子的几率有多大？成长的环境、父母的局限性对孩子性格、思维的培养影响是很大的，可是又能怎么办？这些父母可能并不知道未来他们孩子的竞争压力有多大，今年一个高考状元的采访，大概就是说：自己在城市长大，能接触到更好的学习方法、教育资源，而且父母对自己教育也非常上心，但农村孩子，很多人大学之前可能连电脑都没摸过，很难跟这些城市的孩子去竞争。唉，这就是残酷的现实，未来随着更多人去二线城市扎根，相信二线城市的房价还会再上升一部分，而这些想二线城市扎根的人付出的成本将会更大，给寒门出身的孩子们，留得机会并不多了，希望他们都能努力些。</p>
<h2 id="杂想"><a href="#杂想" class="headerlink" title="杂想"></a>杂想</h2><p>想想自己有了孩子之后，可能要为孩子牺牲很多，然后去慢慢培养孩子，等孩子长大后孩子在接着重复着我之前的生活，那人生的意义到底在哪里？仅仅为了繁衍么？近段在看《未来简史》，现在人文主义主宰世界，犹如之前宗教之于世界，人类不断为自己的生命寻找意义，以前我们认为自己是上帝伟大计划的一部分，这就是我们人类的全部意义，可是现在，估计很少有人相信这些，每个人都在寻找自己的信仰——follow your heart，都在试图找寻自己人生的意义。每当想到这些，看到那些为了孩子牺牲自己很多的父母时，我感觉到很可悲，这样的人生意义在哪里？以前很不明白为什么这样，现在有些明白了，但这完全不是我想要的生活。之前网上听到北京四中的校长讲到：一个为孩子付出一切的家庭，最后得到的往往是悲剧。这句话用在农村里，真的不为过，我们这代人，父母多生于文革年代，记事时赶上了恢复高考、改革开放，村里抓住机会的那批人已经在一站二线城市扎根，有的甚至已经在国外定居，每个乡每个镇多多少少都会有这样的人，这些走出去的人现在被称为当今社会的精英阶层，能走去的这些人大部分靠得都是高考，少数靠得是头脑和商机，他们的生活让依然生活在农村的父母一代羡慕。有长远眼光的父母就会从小对孩子管理严格，教育上投入更大，当然，在农村，投入更大也只是意味着找关系送礼上个当地更好的学校，最多寒暑假再上个补习班，幸运的是，我的父母属于这一类，父母一直希望我能走出农村，虽然他们只是初中文凭，但他们知道未来没有学历没有知识在这个社会很难有好的出路，打我记事开始，父母工作就很努力（在镇上做小生意），他们希望的是当我未来买房或者结婚的时候，能给我提供更大的支持，希望我能在二线甚至一线生存下去，非常感谢自己的父母，这么多年来，父母对自己默默付出了那么多。现在每次看到曾经的小学同学早已结婚生子，现在很多都在大城市里打工，在农村，如果没有考上大学，大部分走的都是这条路，这种生活明显不是我想要的生活，但是少年时代的自己并不知道这些、并不知道什么是自己想要的什么不是自己想要的，很幸运自己能够考上大学，走了农村孩子的另外一条路。而大部分的农村孩子并没有这种幸运，当然也有一些孩子，父母不怎么管教最后走出了一条很好的路，一是这种孩子较少，另一个是一个孩子性格的养成离不开其生活环境，父母在教育上没有管理太多，但在其他方面（隐性方面）对孩子的投入不见得小，这种孩子也很幸运，因为他们进入了一个正循环中，但是最多的那种，是没有考上大学而父母也没有为其提供一个很好出路的农村孩子，他们父母在孩子的投入不见得比别的孩子少，但结果并不如想象的那样，这中间有个体差异的原因，但是更多的是可悲、是无可奈何、或者说是不公平，这些孩子跟城里孩子是一样的，然而不同的生活环境造就了不同的人生路径，出身对一个人的影响有多大是不言而喻的，正所谓橘生淮南则为橘、橘生淮北则为枳。BBC有个纪录片叫做《七年》，有兴趣的朋友可以看一下，让人生走向一个正循环多么重要，而一个社会底层的人要想让人生走向正循环比例很低，中产阶级的孩子比例会大很多倍，这些中产阶级的孩子从小会接受更好的教育，成长的环境也比农村孩子强太多倍，但未来这些孩子们都将在同一个赛道上竞争，公平在这里显得苍白无力，随着经济的发展，更多私立中小学的兴起，公平又会从何而来？内心感觉很悲凉，可又无可奈何，未来自己终究也会走入这样的漩涡，明知不知道自己想要的生活，但又无法摆脱这种束缚，当想到这时，就会不由自主地去质疑人生的意义何在？《未来简史》没有告诉我答案，有信仰的人为自己的信仰而生，而我这种没有信仰的人却又当如何？为房子而活？为未来的孩子而活？为家庭而活？这都不是我想要的答案，为民族而活这句话说出来我自己都不相信，这些都不是我人生的意义，但又该是什么呢？我自己现在也不知道，但我会不停地去寻找答案。</p>
<h2 id="杭州看房的一些建议"><a href="#杭州看房的一些建议" class="headerlink" title="杭州看房的一些建议"></a>杭州看房的一些建议</h2><p>最后，再说一下买房的一些建议吧，杭州看房的话，有两个网站比较推荐：</p>
<ol>
<li>透明房，新房的最新消息，预售证信息、备案家都会在这个网站发布；</li>
<li>口水楼市，杭州方式论坛楼盘的论坛，有很多重要信息。</li>
</ol>
<p>我在看房的时候，主要记录以下这些信息，大家可以自行参考，选择自己认为比较重要的部分。</p>
<table>
<thead>
<tr>
<th>楼盘名</th>
<th>板块</th>
<th>状态</th>
<th>单价（中间套/边套）</th>
<th>面积</th>
<th>大概总价</th>
<th>得房率</th>
<th>交房时间</th>
<th>精装/毛坯</th>
<th>楼盘优惠</th>
<th>地铁（规划）</th>
<th>幼儿园</th>
<th>小学</th>
</tr>
</thead>
<tbody>
<tr>
<td>滨江旭辉·万家之星</td>
<td>勾庄北、拱辰北</td>
<td>目前还有三幢等待开售，预计价格是2.1-2.2万</td>
<td>2.2万</td>
<td>89 平</td>
<td>195w</td>
<td>-</td>
<td>-</td>
<td>毛坯</td>
<td>-</td>
<td>4号线</td>
<td>良渚通运幼儿园(公办)、勾庄中心幼儿园(公办)、12班幼儿园(规划)</td>
<td>运河小学(在建)、良渚二小运河校区</td>
</tr>
<tr>
<td>海德公园</td>
<td>勾庄北、拱辰北</td>
<td>开盘都已经卖完，下个月会在开盘一幢</td>
<td>~</td>
<td>83、89平</td>
<td>-</td>
<td>76%</td>
<td>2019年中旬交付</td>
<td>毛坯</td>
<td>-</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>最后，这篇文章是在杭州回北京的火车上完成的，这一路真的是感慨颇多，文章也如流水账一番，逻辑性不是很强，或许几年之后回头再看，就会嘲笑自己当年怎么这么无知。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;落户+买房的事情终于搞定得差不多了（就差贷款合同的签署），六月份这个月已经往来杭州3趟，从四月底开始看房到现在，这一路真是五味杂粮、感慨颇多，亲身地感觉到生活之不易，无忧无虑的生活从离开大学的那一刻开始就已经结束，读研这两年半看似浑浑噩噩，但早已没有大学时的那种轻松惬意，或
    
    </summary>
    
      <category term="随笔" scheme="http://matt33.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://matt33.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 源码分析之 Producer 发送模型（一）</title>
    <link href="http://matt33.com/2017/06/25/kafka-producer-send-module/"/>
    <id>http://matt33.com/2017/06/25/kafka-producer-send-module/</id>
    <published>2017-06-25T04:53:39.000Z</published>
    <updated>2017-06-25T15:06:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>早就开始计划写 Kafka 源码分析的文章，但却一直迟迟没有动手，直到看到一位同事的博客 <a href="http://blog.bcmeng.com/" target="_blank" rel="external">编程小梦</a>，彻底受到了打击，这位同事是去年本科毕业，年龄算起来应该比我小两岁，但是非常厉害，在刚工作半年的时候就成为了 Apache Kylin 的 commiter，看到身边同事这么优秀，而且还这么努力 （<a href="http://blog.bcmeng.com/post/booklist.html" target="_blank" rel="external">编程小梦-我的书单</a>），自己实在没有理由不努力了，因此，在 github 上给自己提了一个 issue <a href="https://github.com/wangzzu/awesome/issues/7" target="_blank" rel="external">Kafka 源码分析系列</a>，希望自己能够在未来半年里，至少每两周输出一篇 Kafka 源码分析的文章，本文是这个系列的第一篇 —— Producer 的发送模型（以 <strong>Kafka 0.10.2</strong> 为例）。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kafka，作为目前在大数据领域应用最为广泛的消息队列，其内部实现和设计有很多值得深入研究和分析的地方。</p>
<p>再 0.10.2 的 Kafka 中，其 Client 端是由 Java 实现，Server 端是由 Scala 来实现的，在使用 Kafka 时，Client 是用户最先接触到部分，因此，计划写的源码分析也会从 Client 端开始，会先从 Producer 端开始，今天讲的是 Producer 端的发送模型的实现。</p>
<h1 id="Producer-使用"><a href="#Producer-使用" class="headerlink" title="Producer 使用"></a>Producer 使用</h1><p>在分析 Producer 发送模型之前，先看一下用户是如何使用 Producer 向 Kafka 写数据的，下面是一个关于 Producer 最简单的应用示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/7/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String topicName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> msgNum;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> key;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"127.0.0.1:9092,127.0.0.2:9092"</span>);</div><div class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</div><div class="line"></div><div class="line">        topicName = <span class="string">"test"</span>;</div><div class="line">        msgNum = <span class="number">10</span>; <span class="comment">// 发送的消息数</span></div><div class="line"></div><div class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; msgNum; i++) &#123;</div><div class="line">            String msg = i + <span class="string">" This is matt's blog."</span>;</div><div class="line">            producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topicName, msg));</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出 Kafka 为用户提供了非常简单的 API，在使用时，只需要如下两步：</p>
<ol>
<li>初始化 <code>KafkaProducer</code> 实例；</li>
<li>调用 <code>send</code> 接口发送数据。</li>
</ol>
<p>本文主要是围绕着 Producer 在内部是如何实现 <code>send</code> 接口而展开的。</p>
<h1 id="Producer-数据发送流程"><a href="#Producer-数据发送流程" class="headerlink" title="Producer 数据发送流程"></a>Producer 数据发送流程</h1><p>下面通过对 <code>send</code> 源码分析来一步步剖析 Producer 数据的发送流程。</p>
<h2 id="Producer-的-send-实现"><a href="#Producer-的-send-实现" class="headerlink" title="Producer 的 send 实现"></a>Producer 的 send 实现</h2><p>用户是直接使用 <code>producer.send()</code> 发送的数据，先看一下 <code>send()</code> 接口的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 异步向一个 topic 发送数据</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> send(record, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向 topic 异步地发送数据，当发送确认后唤起回调函数</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</div><div class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></div><div class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? record : <span class="keyword">this</span>.interceptors.onSend(record);</div><div class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据发送的最终实现还是调用了 Producer 的 <code>doSend()</code> 接口。</p>
<h2 id="Producer-的-doSend-实现"><a href="#Producer-的-doSend-实现" class="headerlink" title="Producer 的 doSend 实现"></a>Producer 的 doSend 实现</h2><p>下面是 <code>doSend()</code> 的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;RecordMetadata&gt; <span class="title">doSend</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</div><div class="line">       TopicPartition tp = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 1.确认数据要发送到的 topic 的 metadata 是可用的</span></div><div class="line">           ClusterAndWaitTime clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</div><div class="line">           <span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</div><div class="line">           Cluster cluster = clusterAndWaitTime.cluster;</div><div class="line">           <span class="comment">// 2.序列化 record 的 key 和 value</span></div><div class="line">           <span class="keyword">byte</span>[] serializedKey;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               serializedKey = keySerializer.serialize(record.topic(), record.key());</div><div class="line">           &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert key of class "</span> + record.key().getClass().getName() +</div><div class="line">                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</div><div class="line">                       <span class="string">" specified in key.serializer"</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">byte</span>[] serializedValue;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               serializedValue = valueSerializer.serialize(record.topic(), record.value());</div><div class="line">           &#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Can't convert value of class "</span> + record.value().getClass().getName() +</div><div class="line">                       <span class="string">" to class "</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</div><div class="line">                       <span class="string">" specified in value.serializer"</span>);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 3. 获取该 record 的 partition 的值（可以指定,也可以根据算法计算）</span></div><div class="line">           <span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</div><div class="line">           <span class="keyword">int</span> serializedSize = Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);</div><div class="line">           ensureValidRecordSize(serializedSize); <span class="comment">// record 的字节超出限制或大于内存限制时,就会抛出 RecordTooLargeException 异常</span></div><div class="line">           tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</div><div class="line">           <span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp(); <span class="comment">// 时间戳</span></div><div class="line">           log.trace(<span class="string">"Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;"</span>, record, callback, record.topic(), partition);</div><div class="line">           Callback interceptCallback = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? callback : <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</div><div class="line">           <span class="comment">// 4. 向 accumulator 中追加数据</span></div><div class="line">           RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);</div><div class="line">           <span class="comment">// 5. 如果 batch 已经满了,唤醒 sender 线程发送数据</span></div><div class="line">           <span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</div><div class="line">               log.trace(<span class="string">"Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch"</span>, record.topic(), partition);</div><div class="line">               <span class="keyword">this</span>.sender.wakeup();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> result.future;</div><div class="line">       &#125; <span class="keyword">catch</span> (ApiException e) &#123;</div><div class="line">           log.debug(<span class="string">"Exception occurred during message send:"</span>, e);</div><div class="line">           <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</div><div class="line">               callback.onCompletion(<span class="keyword">null</span>, e);</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> FutureFailure(e);</div><div class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptException(e);</div><div class="line">       &#125; <span class="keyword">catch</span> (BufferExhaustedException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">this</span>.metrics.sensor(<span class="string">"buffer-exhausted-records"</span>).record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</div><div class="line">           <span class="keyword">this</span>.errors.record();</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">this</span>.interceptors.onSendError(record, tp, e);</div><div class="line">           <span class="keyword">throw</span> e;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在 <code>dosend()</code> 方法的实现上，一条 Record 数据的发送，可以分为以下五步：</p>
<ol>
<li>确认数据要发送到的 topic 的 metadata 是可用的（如果该 partition 的 leader 存在则是可用的，如果开启权限时，client 有相应的权限），如果没有 topic 的 metadata 信息，就需要获取相应的 metadata；</li>
<li>序列化 record 的 key 和 value；</li>
<li>获取该 record 要发送到的 partition（可以指定，也可以根据算法计算）；</li>
<li>向 accumulator 中追加 record 数据，数据会先进行缓存；</li>
<li>如果追加完数据后，对应的 RecordBatch 已经达到了 batch.size 的大小（或者batch 的剩余空间不足以添加下一条 Record），则唤醒 <code>sender</code> 线程发送数据。</li>
</ol>
<p>数据的发送过程，可以简单总结为以上五点，下面会这几部分的具体实现进行详细分析。</p>
<h1 id="发送过程详解"><a href="#发送过程详解" class="headerlink" title="发送过程详解"></a>发送过程详解</h1><h2 id="获取-topic-的-metadata-信息"><a href="#获取-topic-的-metadata-信息" class="headerlink" title="获取 topic 的 metadata 信息"></a>获取 topic 的 metadata 信息</h2><p>Producer 通过 <code>waitOnMetadata()</code> 方法来获取对应 topic 的 metadata 信息，这部分后面会单独抽出一篇文章来介绍，这里就不再详述，总结起来就是：在数据发送前，需要先该 topic 是可用的。</p>
<h2 id="key-和-value-的序列化"><a href="#key-和-value-的序列化" class="headerlink" title="key 和 value 的序列化"></a>key 和 value 的序列化</h2><p>Producer 端对 record 的 <code>key</code> 和 <code>value</code> 值进行序列化操作，在 Consumer 端再进行相应的反序列化，Kafka 内部提供的序列化和反序列化算法如下图所示：</p>
<p><img src="/images/kafka/serialize.png" alt="Kafka serialize &amp; deserialize"></p>
<p>当然我们也是可以自定义序列化的具体实现，不过一般情况下，Kafka 内部提供的这些方法已经足够使用。</p>
<h2 id="获取-partition-值"><a href="#获取-partition-值" class="headerlink" title="获取 partition 值"></a>获取 partition 值</h2><p>关于 partition 值的计算，分为三种情况：</p>
<ol>
<li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li>
<li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</li>
<li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 <code>round-robin</code> 算法。</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当 record 中有 partition 值时，直接返回，没有的情况下调用 partitioner 的类的 partition 方法去计算（KafkaProducer.class）</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</div><div class="line">    Integer partition = record.partition();</div><div class="line">    <span class="keyword">return</span> partition != <span class="keyword">null</span> ?</div><div class="line">            partition :</div><div class="line">            partitioner.partition(</div><div class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Producer 默认使用的 <code>partitioner</code> 是 <code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>，用户也可以自定义 partition 的策略，下面是这个类两个方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</div><div class="line">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</div><div class="line">        <span class="keyword">int</span> numPartitions = partitions.size();</div><div class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;<span class="comment">// 没有指定 key 的情况下</span></div><div class="line">            <span class="keyword">int</span> nextValue = nextValue(topic); <span class="comment">// 第一次的时候产生一个随机整数,后面每次调用在之前的基础上自增;</span></div><div class="line">            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</div><div class="line">            <span class="comment">// leader 不为 null,即为可用的 partition</span></div><div class="line">            <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</div><div class="line">                <span class="keyword">return</span> availablePartitions.get(part).partition();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 有 key 的情况下,使用 key 的 hash 值进行计算</span></div><div class="line">            <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; <span class="comment">// 选择 key 的 hash 值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据 topic 获取对应的整数变量</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</div><div class="line">        AtomicInteger counter = topicCounterMap.get(topic);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == counter) &#123; <span class="comment">// 第一次调用时，随机产生</span></div><div class="line">            counter = <span class="keyword">new</span> AtomicInteger(<span class="keyword">new</span> Random().nextInt());</div><div class="line">            AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter);</div><div class="line">            <span class="keyword">if</span> (currentCounter != <span class="keyword">null</span>) &#123;</div><div class="line">                counter = currentCounter;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter.getAndIncrement(); <span class="comment">// 后面再调用时，根据之前的结果自增</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这就是 Producer 中默认的 partitioner 实现。</p>
<h2 id="向-accumulator-写数据"><a href="#向-accumulator-写数据" class="headerlink" title="向 accumulator 写数据"></a>向 accumulator 写数据</h2><p>Producer 会先将 record 写入到 buffer 中，当达到一个 <code>batch.size</code> 的大小时，再唤起 <code>sender</code> 线程去发送 <code>RecordBatch</code>（第五步），这里先详细分析一下 Producer 是如何向 buffer 中写入数据的。</p>
<p>Producer 是通过 <code>RecordAccumulator</code> 实例追加数据，<code>RecordAccumulator</code> 模型如下图所示，一个重要的变量就是 <code>ConcurrentMap&lt;TopicPartition, Deque&lt;RecordBatch&gt;&gt; batches</code>，每个 <code>TopicPartition</code> 都会对应一个 <code>Deque&lt;RecordBatch&gt;</code>，当添加数据时，会向其 topic-partition 对应的这个 queue 最新创建的一个 <code>RecordBatch</code> 中添加 record，而发送数据时，则会先从 queue 中最老的那个 <code>RecordBatch</code> 开始发送。</p>
<p><img src="/images/kafka/recordbatch.png" alt="Producer RecordAccumulator 模型"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// org.apache.kafka.clients.producer.internals.RecordAccumulator</span></div><div class="line">     <span class="comment">// 向 accumulator 添加一条 record，并返回添加后的结果（结果主要包含: future metadata、batch 是否满的标志以及新 batch 是否创建）其中， maxTimeToBlock 是 buffer.memory 的 block 的最大时间</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></div><div class="line">                                     <span class="keyword">long</span> timestamp,</div><div class="line">                                     <span class="keyword">byte</span>[] key,</div><div class="line">                                     <span class="keyword">byte</span>[] value,</div><div class="line">                                     Callback callback,</div><div class="line">                                     <span class="keyword">long</span> maxTimeToBlock) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        appendsInProgress.incrementAndGet();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Deque&lt;RecordBatch&gt; dq = getOrCreateDeque(tp);<span class="comment">// 每个 topicPartition 对应一个 queue</span></div><div class="line">            <span class="keyword">synchronized</span> (dq) &#123;<span class="comment">// 在对一个 queue 进行操作时,会保证线程安全</span></div><div class="line">                <span class="keyword">if</span> (closed)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</div><div class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq); <span class="comment">// 追加数据</span></div><div class="line">                <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)<span class="comment">// 这个 topic-partition 已经有记录了</span></div><div class="line">                    <span class="keyword">return</span> appendResult;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 为 topic-partition 创建一个新的 RecordBatch, 需要初始化相应的 RecordBatch，要为其分配的大小是: max（batch.size, 加上头文件的本条消息的大小）</span></div><div class="line">            <span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, Records.LOG_OVERHEAD + Record.recordSize(key, value));</div><div class="line">            log.trace(<span class="string">"Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;"</span>, size, tp.topic(), tp.partition());</div><div class="line">            ByteBuffer buffer = free.allocate(size, maxTimeToBlock);<span class="comment">// 给这个 RecordBatch 初始化一个 buffer</span></div><div class="line">            <span class="keyword">synchronized</span> (dq) &#123;</div><div class="line">                <span class="keyword">if</span> (closed)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot send after the producer is closed."</span>);</div><div class="line"></div><div class="line">                RecordAppendResult appendResult = tryAppend(timestamp, key, value, callback, dq);</div><div class="line">                <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>) &#123;<span class="comment">// 如果突然发现这个 queue 已经存在，那么就释放这个已经分配的空间</span></div><div class="line">                    free.deallocate(buffer);</div><div class="line">                    <span class="keyword">return</span> appendResult;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 给 topic-partition 创建一个 RecordBatch</span></div><div class="line">                MemoryRecordsBuilder recordsBuilder = MemoryRecords.builder(buffer, compression, TimestampType.CREATE_TIME, <span class="keyword">this</span>.batchSize);</div><div class="line">                RecordBatch batch = <span class="keyword">new</span> RecordBatch(tp, recordsBuilder, time.milliseconds());</div><div class="line">                <span class="comment">// 向新的 RecordBatch 中追加数据</span></div><div class="line">                FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, callback, time.milliseconds()));</div><div class="line"></div><div class="line">                dq.addLast(batch);<span class="comment">// 将 RecordBatch 添加到对应的 queue 中</span></div><div class="line">                incomplete.add(batch);<span class="comment">// 向未 ack 的 batch 集合添加这个 batch</span></div><div class="line">                <span class="comment">// 如果 dp.size()&gt;1 就证明这个 queue 有一个 batch 是可以发送了</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            appendsInProgress.decrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>总结一下其 record 写入的具体流程如下图所示：</p>
<p><img src="/images/kafka/RecordBatch_append.png" alt="Producer RecordAccumulator record 写入流程"></p>
<ol>
<li>获取该 topic-partition 对应的 queue，没有的话会创建一个空的 queue；</li>
<li>向 queue 中追加数据，先获取 queue 中最新加入的那个 <code>RecordBatch</code>，如果不存在或者存在但剩余空余不足以添加本条 record 则返回 null，成功写入的话直接返回结果，写入成功；</li>
<li>创建一个新的 <code>RecordBatch</code>，初始化内存大小根据 <code>max(batch.size, Records.LOG_OVERHEAD + Record.recordSize(key, value))</code> 来确定（防止单条 record 过大的情况）；</li>
<li>向新建的 <code>RecordBatch</code> 写入 record，并将 <code>RecordBatch</code> 添加到 queue 中，返回结果，写入成功。</li>
</ol>
<h2 id="发送-RecordBatch"><a href="#发送-RecordBatch" class="headerlink" title="发送 RecordBatch"></a>发送 RecordBatch</h2><p>当 record 写入成功后，如果发现 <code>RecordBatch</code> 已满足发送的条件（通常是 queue 中有多个 batch，那么最先添加的那些 batch 肯定是可以发送了），那么就会唤醒 <code>sender</code> 线程，发送 <code>RecordBatch</code>。</p>
<p><code>sender</code> 线程对 <code>RecordBatch</code> 的处理是在 <code>run()</code> 方法中进行的，该方法具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">        Cluster cluster = metadata.fetch();</div><div class="line">        <span class="comment">// 获取那些已经可以发送的 RecordBatch 对应的 nodes</span></div><div class="line">        RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</div><div class="line"></div><div class="line">        <span class="comment">// 如果有 topic-partition 的 leader 是未知的,就强制 metadata 更新</span></div><div class="line">        <span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</div><div class="line">            <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</div><div class="line">                <span class="keyword">this</span>.metadata.add(topic);</div><div class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果与node 没有连接（如果可以连接,同时初始化该连接）,就证明该 node 暂时不能发送数据,暂时移除该 node</span></div><div class="line">        Iterator&lt;Node&gt; iter = result.readyNodes.iterator();</div><div class="line">        <span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</div><div class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">            Node node = iter.next();</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</div><div class="line">                iter.remove();</div><div class="line">                notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.connectionDelay(node, now));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 返回该 node 对应的所有可以发送的 RecordBatch 组成的 batches（key 是 node.id）,并将 RecordBatch 从对应的 queue 中移除</span></div><div class="line">        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="keyword">this</span>.maxRequestSize, now);</div><div class="line">        <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</div><div class="line">            <span class="comment">//记录将要发送的 RecordBatch</span></div><div class="line">            <span class="keyword">for</span> (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;</div><div class="line">                <span class="keyword">for</span> (RecordBatch batch : batchList)</div><div class="line">                    <span class="keyword">this</span>.accumulator.mutePartition(batch.topicPartition);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将由于元数据不可用而导致发送超时的 RecordBatch 移除</span></div><div class="line">        List&lt;RecordBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.abortExpiredBatches(<span class="keyword">this</span>.requestTimeout, now);</div><div class="line">        <span class="keyword">for</span> (RecordBatch expiredBatch : expiredBatches)</div><div class="line">            <span class="keyword">this</span>.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);</div><div class="line"></div><div class="line">        sensors.updateProduceRequestMetrics(batches);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</div><div class="line">        <span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</div><div class="line">            log.trace(<span class="string">"Nodes with data ready to send: &#123;&#125;"</span>, result.readyNodes);</div><div class="line">            pollTimeout = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 发送 RecordBatch</span></div><div class="line">        sendProduceRequests(batches, now);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.client.poll(pollTimeout, now); <span class="comment">// 关于 socket 的一些实际的读写操作（其中包括 meta 信息的更新）</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码前面有很多是其他的逻辑处理，如：移除暂时不可用的 node、处理由于元数据不可用导致的超时 <code>RecordBatch</code>，真正进行发送发送 <code>RecordBatch</code> 的是 <code>sendProduceRequests(batches, now)</code> 这个方法，具体是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Transfer the record batches into a list of produce requests on a per-node basis</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequests</span><span class="params">(Map&lt;Integer, List&lt;RecordBatch&gt;&gt; collated, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;RecordBatch&gt;&gt; entry : collated.entrySet())</div><div class="line">        sendProduceRequest(now, entry.getKey(), acks, requestTimeout, entry.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a produce request from the given record batches</div><div class="line"> */</div><div class="line"><span class="comment">// 发送 produce 请求</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequest</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">int</span> destination, <span class="keyword">short</span> acks, <span class="keyword">int</span> timeout, List&lt;RecordBatch&gt; batches)</span> </span>&#123;</div><div class="line">    Map&lt;TopicPartition, MemoryRecords&gt; produceRecordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</div><div class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, RecordBatch&gt; recordsByPartition = <span class="keyword">new</span> HashMap&lt;&gt;(batches.size());</div><div class="line">    <span class="keyword">for</span> (RecordBatch batch : batches) &#123;</div><div class="line">        TopicPartition tp = batch.topicPartition;</div><div class="line">        produceRecordsByPartition.put(tp, batch.records());</div><div class="line">        recordsByPartition.put(tp, batch);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ProduceRequest.Builder requestBuilder =</div><div class="line">            <span class="keyword">new</span> ProduceRequest.Builder(acks, timeout, produceRecordsByPartition);</div><div class="line">    RequestCompletionHandler callback = <span class="keyword">new</span> RequestCompletionHandler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(ClientResponse response)</span> </span>&#123;</div><div class="line">            handleProduceResponse(response, recordsByPartition, time.milliseconds());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    String nodeId = Integer.toString(destination);</div><div class="line">    ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != <span class="number">0</span>, callback);</div><div class="line">    client.send(clientRequest, now);</div><div class="line">    log.trace(<span class="string">"Sent produce request to &#123;&#125;: &#123;&#125;"</span>, nodeId, requestBuilder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码就简单很多，总来起来就是，将 <code>batches</code> 中 leader 为同一个 node 的所有 RecordBatch 放在一个请求中进行发送。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文是对 Kafka Producer 端发送模型的一个简单分析，下一篇文章将会详细介绍 metadata 相关的内容，包括 metadata 的内容以及在 Producer 端 metadata 的更新机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就开始计划写 Kafka 源码分析的文章，但却一直迟迟没有动手，直到看到一位同事的博客 &lt;a href=&quot;http://blog.bcmeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;编程小梦&lt;/a&gt;，彻底受到了打击，这位同事是去年本科毕
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>CSS 一些常用方法的总结</title>
    <link href="http://matt33.com/2017/06/21/css-summary/"/>
    <id>http://matt33.com/2017/06/21/css-summary/</id>
    <published>2017-06-20T17:03:30.000Z</published>
    <updated>2017-06-20T17:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 指的是层叠样式表（Cascading StyleSheet），在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制，本文对 css 一些基本内容及常用功能进行一下总结，总结的内容主要是来自实验楼的 <a href="https://www.shiyanlou.com/courses/53" target="_blank" rel="external">CSS 速成教程</a>，这篇文章会实时更新，后续如果遇到什么好的有用功能，也会更新到这篇文章中。</p>
<h1 id="css-基础语法"><a href="#css-基础语法" class="headerlink" title="css 基础语法"></a>css 基础语法</h1><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">selector &#123;</div><div class="line">    declaration1;</div><div class="line">    declaration2;</div><div class="line">    ...</div><div class="line">    declarationN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>选择器通常是需要改变的 HTML 元素，每条声明都由一个属性和一个值组成，每个属性都有一个值，属性和值被冒号分开。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">   <span class="attribute">color</span>:red;</div><div class="line">   <span class="attribute">font-size</span>:<span class="number">14px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="css-基本样式"><a href="#css-基本样式" class="headerlink" title="css 基本样式"></a>css 基本样式</h1><p>介绍 css 的一些基本样式，这些都是 css 中一些常用的设置。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>css 是允许使用纯色作为背景，也允许使用背景图像实现一些相当复杂的效果。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-attachment</td>
<td>背景图像是否固定或者随着页面的其余部分滚动</td>
</tr>
<tr>
<td>background-color</td>
<td>设置元素的背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>把图片设置为背景</td>
</tr>
<tr>
<td>background-position</td>
<td>设置背景图片的起始位置</td>
</tr>
<tr>
<td>background-repeat</td>
<td>设置背景图片是否及如何重复，其中，<code>no-repeat</code>：表示不能重复，<code>repeat</code>：可重复（默认值），<code>repeat-x</code>：表示 x 轴重复，<code>repeat-y</code>：表示 y 轴重</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域</td>
</tr>
<tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
</tbody>
</table>
<p>举个例子，如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">   background-color: red;</div><div class="line">   background-image: url("hha.jpg");</div><div class="line">   background-repeat: no-repeat;</div><div class="line">   background-position: center top;</div><div class="line">   background-attachment: fixed;</div><div class="line">   background-size：100px 100px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p&#123;</div><div class="line">    width: 150px;</div><div class="line">    padding: 10px;</div><div class="line">    background-color: #0014ff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果如下下图所示：</p>
<p><img src="/images/web/css1.png" alt="效果图"></p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>css 文本可定义文本的外观，通过文本的属性，可以改变文本的颜色、字符间距、对齐方式等等。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>文本颜色</td>
</tr>
<tr>
<td>direction</td>
<td>文本方向</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
</tr>
<tr>
<td>letter-spacing</td>
<td>字符间距</td>
</tr>
<tr>
<td>text-align</td>
<td>对齐元素中的文本，可选择 left、right 和 center</td>
</tr>
<tr>
<td>text-decoration</td>
<td>向文本添加修饰</td>
</tr>
<tr>
<td>text-indent</td>
<td>缩进元素中文本的首行</td>
</tr>
<tr>
<td>text-transform</td>
<td>元素中的字母</td>
</tr>
<tr>
<td>unicode-bidi</td>
<td>设置文本方向</td>
</tr>
<tr>
<td>white-space</td>
<td>元素中空白的处理方式</td>
</tr>
<tr>
<td>word-spacing</td>
<td>字间距</td>
</tr>
</tbody>
</table>
<p>应用时，可以进行以下设置</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">   <span class="attribute">color</span>: red;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>: <span class="number">5em</span>;&#125;</div></pre></td></tr></table></figure>
<p>在网页展现时，标签 <code>body</code> 和 <code>p</code> 中元素就会按照设置进行显示。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在 css 的链接属性中，可以对其颜色、字体、背景进行相应的设置，不同的状态我们可以设置对应的样式。</p>
<h3 id="4种链接状态"><a href="#4种链接状态" class="headerlink" title="4种链接状态"></a>4种链接状态</h3><p>css 共有以下几种链接状态：</p>
<ol>
<li><code>a:link</code>：普通的、未被访问的链接；</li>
<li><code>a:visited</code>：用户已访问的链接；</li>
<li><code>a:hover</code>：鼠标指针位于链接的上方；</li>
<li><code>a:active</code>：链接被点击的时刻。</li>
</ol>
<p>在进行设置中，有以下两种要求：</p>
<ul>
<li><code>a:hover</code> 必须位于 <code>a:link</code> 和 <code>a:visited</code> 之后；</li>
<li><code>a:active</code> 必须位于 <code>a:hover</code> 之后。</li>
</ul>
<h3 id="修改链接下划线"><a href="#修改链接下划线" class="headerlink" title="修改链接下划线"></a>修改链接下划线</h3><p>只需要在链接属性中添加 <code>text-decoration</code> 属性，将对应的值设置为空即可。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>:<span class="number">#B2FF99</span>;</div><div class="line">    <span class="attribute">text-decoration</span>:none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FFFF85</span>;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;&#125;</div></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在 html 中学习过列表的一些设置，这里主要讲述的是如何通过 css 进行列表的设置。</p>
<h3 id="简单的列表类型"><a href="#简单的列表类型" class="headerlink" title="简单的列表类型"></a>简单的列表类型</h3><p>列表有无序、有序之分，无序列表又可以用不同的标记来区分，而 <code>list-style-type</code> 这个属性我们就可以用来控制标记类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* html 中添加以下内容 */</div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"circle"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>wawa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">olclass="square"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>wawa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">/* css 中的设置 */</div><div class="line">ul.circle &#123;list-style-type:circle&#125;</div><div class="line">ol.square &#123;list-style-type:upper-roman&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="列表项图片"><a href="#列表项图片" class="headerlink" title="列表项图片"></a>列表项图片</h3><p>在无序列表中，除了进行一些默认的设置外，并没有其他可选的内容，但是 css 可以提供图片来作为标记。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.img1</span>&#123;<span class="attribute">list-style-image</span>:<span class="built_in">url</span>(<span class="string">"1.ico"</span>)&#125;</div></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在 css 表格的设置中，需要先了解一下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-collapse</td>
<td>设置是否把表格边框合并为单一的边框</td>
</tr>
<tr>
<td>border-spacing</td>
<td>设置分隔单元格边框的距离。</td>
</tr>
<tr>
<td>caption-side</td>
<td>设置表格标题的位置。</td>
</tr>
<tr>
<td>empty-cells</td>
<td>设置是否显示表格中的空单元格。</td>
</tr>
<tr>
<td>table-layout</td>
<td>设置显示单元、行和列的算法。</td>
</tr>
</tbody>
</table>
<p>这里也以一个例子来说明：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"tb"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>number<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"tr2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"tr2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>li<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* css 部分*/</span></div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid green;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span>&#123;</div><div class="line">    <span class="attribute">border-collapse</span>: collapse;</div><div class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">th</span>&#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">background-color</span>: lightseagreen;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#tb</span> <span class="selector-tag">tr</span><span class="selector-class">.tr2</span> <span class="selector-tag">td</span>&#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#B2FF99</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下图</p>
<p><img src="/images/web/css3.png" alt="效果图"></p>
<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。CSS outline 属性规定元素轮廓的样式、颜色和宽度。涉及到的属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>outline</td>
<td>在一个声明中设置所有的轮廓属性。</td>
</tr>
<tr>
<td>outline-color</td>
<td>设置轮廓的颜色.</td>
</tr>
<tr>
<td>outline-style</td>
<td>设置轮廓的样式。</td>
</tr>
<tr>
<td>outline-width</td>
<td>设置轮廓的宽度。</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span>This is mtt's blog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">#p1&#123;</div><div class="line">    outline-color: #FF704D;</div><div class="line">    outline-style: groove;</div><div class="line">    outline-width: 10px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#p2&#123;</div><div class="line">    outline-style: dotted;</div><div class="line">    outline-color: green;</div><div class="line">    outline-width: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下图所示：</p>
<p><img src="/images/web/css2.png" alt="效果图"></p>
<h1 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h1><p>选择器是 css 中最常用的组件，本节就介绍一下 css 中最常见的几种选择器。</p>
<h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><p>最常见的选择器就是元素选择器，文档的元素的就是最基本的选择器。比如<code>h1</code>、<code>a</code>等，在 css 中可以这样实现：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*第一种，直接对某个元素进行相应的设置*/</span></div><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第二种，对多个元素执行同样的操作*/</span></div><div class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第三种，对没有特别特定元素设置的元素都执行同样的操作（除 h4外，其他执行的操作都一样）*/</span></div><div class="line">*&#123;</div><div class="line">  <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h4</span>&#123;</div><div class="line">    <span class="attribute">color</span>: darkslategray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>类选择器允许以一种独立与文档元素的方式来制定样式。<code>.class{}</code> 这是类选择器的标志，点后面是属性名，大括号里面就是具体的设置，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*第一种，最简单的使用方法*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;div class="div"&gt;matt&lt;/div&gt; */</span></div><div class="line"><span class="selector-class">.div</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第二种，将类选择器结合元素选择器来使用，下面的例子这个 .div 就只会对 h1 起作用*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;h1 class="div"&gt;matt&lt;/div&gt; */</span></div><div class="line"><span class="selector-tag">h1</span><span class="selector-class">.div</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*第三种，多类选择器（.class.class&#123;&#125;），它可以继承多个类的作用*/</span></div><div class="line"><span class="comment">/* 调用方式：&lt;p class="p1 p2"&gt;shiyanlou is my home&lt;/p&gt; */</span></div><div class="line"><span class="selector-class">.p1</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cadetblue;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.p1</span><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">font-style</span>: italic;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h2><p>id 选择器类似于类选择器，id 选择器的引入是用<code>#</code>，就和类选择器的<code>.</code>是一样的效果，它与类选择器的区别是：</p>
<ul>
<li>id 顾名思义只能在文档中使用一次，而类可以使用多次；</li>
<li>id 选择器不能像刚才类选择器一样结合使用。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* html 中的用法 */</div><div class="line">&lt;p id="div"&gt;matt's blog&lt;/p&gt;</div><div class="line"></div><div class="line">/* css 中的配置*/</div><div class="line">#div&#123;</div><div class="line">    color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>对带有指定属性的 HTML 元素设置样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 第一种，对带有 title 属性的所有元素设置样式 */</span></div><div class="line"><span class="selector-attr">[title]</span> &#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 第二种，为 title="te" 的所有元素设置样式 */</span></div><div class="line"><span class="selector-attr">[title=te]</span>&#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 第三种，为 href="http://matt33.com" 的标签 a 设置元素样式 */</span></div><div class="line"><span class="comment">/* 调用方式：&lt;a href="http://matt33.com"&gt;matt's blog&lt;/a&gt; */</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://matt33.com"]</span>&#123;</div><div class="line">    <span class="attribute">color</span>: cornflowerblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h2><p>其他的还有：</p>
<ul>
<li>后代选择器</li>
<li>子元素选择器</li>
<li>相邻兄弟选择器</li>
</ul>
<p>下面仅列出一种后代选择器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* html */</div><div class="line">&lt;p&gt;This is &lt;strong&gt;my&lt;/strong&gt; blog.&lt;/p&gt;</div><div class="line"></div><div class="line">/* css */</div><div class="line">p strong&#123;</div><div class="line">    color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="css-盒子模型"><a href="#css-盒子模型" class="headerlink" title="css 盒子模型"></a>css 盒子模型</h1><p> css 的盒子模型主要适用于网页的布局。</p>
<h2 id="盒子模型概述"><a href="#盒子模型概述" class="headerlink" title="盒子模型概述"></a>盒子模型概述</h2><p>盒子的组成包括：</p>
<ul>
<li>margin(外边距)：边框以外就是外边距，默认外边距是透明的（可以为负）；</li>
<li>border(边框)：内边距的边缘就是边框；</li>
<li>padding(内边距)：直接包围内容的部分，它呈现了元素的背景；</li>
<li>content(内容)：正文框的最内部分就是实际的内容.</li>
</ul>
<p>其中，内边距、边框和外边距都是可选的，默认值是0。下面用一张简单的图来描述它们的结构</p>
<p><img src="/images/web/css4.png" alt="盒子模型"></p>
<h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>内边据在正文（content）外、边框（border）内，控制该区域最简单的属性是 <code>padding</code> 属性</p>
<ul>
<li><code>padding</code> 属性接受长度值或百分比值，但不允许使用负值；</li>
<li>也可以进行统一的内边距设置，也可以进行单边的内边距设置。</li>
<li>设置某一边的边据时，可以通过以下四个属性：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code>.</li>
</ul>
<p>举个栗子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">h1 &#123;</div><div class="line">    padding-left: 5cm;</div><div class="line">    padding-right: 5cm;</div><div class="line">    padding-top: 30px;</div><div class="line">    padding-bottom: 30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/web/css5.png" alt="内边距"></p>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。</p>
<ul>
<li>边框的宽度可以通过这几个参数来设置：<code>border-top-width</code>、<code>border-right-width</code>、<code>border-bottom-width</code>、<code>border-left-width</code>；</li>
<li>同样可以使用属性控制各个边框的颜色：<code>border-top-color</code>、<code>border-right-color</code>、<code>border-bottom-color</code>、<code>border-left-color</code>。</li>
</ul>
<h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p> 外边距就是围绕在内容框的区域，也可以使用任何长度的单位、百分数来进行设置。</p>
<ul>
<li>宽度的设置：<code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code>、<code>margin-left</code>；</li>
<li>margin 的默认值是 0;</li>
<li>在宽度设置时，可以借助于对称复制；</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wb"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bk"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nj"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"zw"</span>&gt;</span></div><div class="line">                matt's blog</div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.wb&#123;</div><div class="line">    margin: 100px;</div><div class="line">&#125;</div><div class="line">.bk&#123;</div><div class="line">    border-style: groove;</div><div class="line">&#125;</div><div class="line">.nj&#123;</div><div class="line">    padding: 10px;</div><div class="line">&#125;</div><div class="line">.zw&#123;</div><div class="line">    background-color: cornflowerblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/web/css5.png" alt="盒子模型举例"></p>
<h1 id="css-一些高级用法"><a href="#css-一些高级用法" class="headerlink" title="css 一些高级用法"></a>css 一些高级用法</h1><p> 这里是 css 中一些高级的常见用法</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位，就是定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</p>
<p>在 css 中，有三种基本的定位机制：</p>
<ol>
<li>普通流：在位置顺序决定排版顺序；</li>
<li>浮动：浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止；</li>
<li>绝对定位：绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。</li>
</ol>
<p>定位有以下几个属性:</p>
<ul>
<li>position：将元素放在一个静态的，相对的，绝对的或固定的位置；</li>
<li>通过对 top、left、right、bottom 这四个属性的赋值让元素向对应的方向偏移；</li>
<li>overflow：设置元素溢出其区域发生的事情；</li>
<li>clip：设置元素的显示形状，多用于图片；</li>
<li>vertical-align：设置元素的垂直对其方式；</li>
<li>z-index：设置元素的堆叠顺序。</li>
</ul>
<p><code>position</code> 属性，有以下四种设置：</p>
<ol>
<li>relative：就是普通流；</li>
<li>absolute：这个就是绝对定位，该元素区域会与文档区域重合，因为它使用该元素与文档流无关；</li>
<li>fixed：将元素固定下来,就算滚动屏幕,它也会在同一个地方不会动；</li>
<li>static：设置以后,偏移量什么的就没用了。</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.position1</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">background-color</span>: cornflowerblue;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">left</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>这里涉及到的属性就是 <code>float</code>，其值可以赋值为：</p>
<ul>
<li>left: 元素向左浮动；</li>
<li>right: 元素向右浮动；</li>
<li>none: 不浮动；</li>
<li>inherit: 从父级继承浮动的属性；</li>
<li>clear: 主要用于去掉向各方向的浮动属性(包括继承来的属性)。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"qd"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wd"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ed"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.qd&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightskyblue;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">.wd&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightseagreen;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">.ed&#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: lightsalmon;</div><div class="line">    float: right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/images/web/css7.png" alt="css 浮动"></p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>尺寸属性允许你控制元素的高度和宽度。同样，它允许你增加行间距。涉及到的属性有：</p>
<ul>
<li>height– 设置元素的高度。</li>
<li>line-height –设置行高。</li>
<li>max-height– 设置元素的最大高度。</li>
<li>max-width –设置元素的最大宽度。</li>
<li>min-height –设置元素的最小高度。</li>
<li>min-width –设置元素的最小宽度。</li>
<li><p>width –设置元素的宽度。</p>
<p>举例说明</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-class">.p1</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: normal;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.p2</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.p3</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">200%</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p>这里通过一个示例来实现导航栏的功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>blog4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">ul&#123;</div><div class="line">    list-style: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">li&#123;</div><div class="line">    float:left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a:link,a:visited&#123;</div><div class="line">   text-decoration: none;</div><div class="line">   background-color: lightgray;</div><div class="line">   display: block;</div><div class="line">   width: 100px;</div><div class="line">   margin:5px 10px;</div><div class="line">&#125;</div><div class="line">a:active,a:hover&#123;</div><div class="line">    background-color: cadetblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="/images/web/css9.png" alt="水平导航栏"></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>插入一张图片，加上一句描述符，使用 <code>div</code> 继承</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* html 部分 */</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./hha.jpg"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hha.jpg"</span> <span class="attr">width</span>=<span class="string">"150px"</span> <span class="attr">height</span>=<span class="string">"150px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">/* css 部分 */</div><div class="line">.image&#123;</div><div class="line">    border: 2px solid darkgrey;</div><div class="line">    width: auto;</div><div class="line">    height: auto;</div><div class="line">    float: left;</div><div class="line">    text-align: center;</div><div class="line">    padding: 5px;</div><div class="line">&#125;</div><div class="line">img&#123;</div><div class="line">    padding: 5px;</div><div class="line">&#125;</div><div class="line">.text&#123;</div><div class="line">    font-size: 20px;</div><div class="line">    margin-bottom: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="/images/web/css8.png" alt="css 图片"></p>
<p>然后可以通过 <code>opacity</code> 属性来设置透明度，属性值的范围为0-1，0是完全透明，1是完全不透明。</p>
<p>到这里，css 基本内容已经总结完了，不过本文后续会一直更新，遇到什么常用的设置，都会更新到本文中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 指的是层叠样式表（Cascading StyleSheet），在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制，本文对 css 一些基本内容及常用功能进行一下总结，总结的内容主要是来自实验楼的 &lt;a href=&quot;h
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://matt33.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>HTML 一些常用方法的总结</title>
    <link href="http://matt33.com/2017/06/18/html-summary/"/>
    <id>http://matt33.com/2017/06/18/html-summary/</id>
    <published>2017-06-17T16:24:31.000Z</published>
    <updated>2017-06-17T16:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 是一种语言，是用来描述网页的语言，它是一种标记语言，HTML 就是使用标记标签来描述网页。</p>
<p>HTML 算是最容易学习的语言之一，它也是必须掌握的一门语言，之前对 HTML 只是大概了解，并没有开发过前端页面，现在在工作中，会使用前端框架已经成为了一项必备技能，所以花了点时间简单看了一下<a href="https://www.shiyanlou.com/courses/19" target="_blank" rel="external">实验楼-HTML 基础课</a>，稍微再学习一下 HTML 的相关知识，本文记录一下一些常用的 HTML 内容，后期还会对 css 简单总结一下。</p>
<h1 id="HTML-最基本用法"><a href="#HTML-最基本用法" class="headerlink" title="HTML 最基本用法"></a>HTML 最基本用法</h1><p>这里先介绍一下 HTML 的最基本用法。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>HTML 文档也被称为网页，它包括标签和文本。Web 浏览器的作用就是读取 HTML 文档，并以网页的形式显示出它们，浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>first paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面是最简单的一个网页，其中：</p>
<ol>
<li>&lt; html&gt; 与 &lt; /html&gt; 之间的文本描述网页；</li>
<li>&lt; body&gt; 与 &lt; /body&gt; 之间的文本是可见的页面内容；</li>
<li>&lt; h1&gt; 与 &lt; /h1&gt; 之间的文本被显示为标题；</li>
<li>&lt; p&gt; 与 &lt; /p&gt; 之间的文本被显示为段落。</li>
</ol>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>标签：就是上面这些 <code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;table&gt;</code> 等被尖括号<code>&lt;</code>和<code>&gt;</code>包起来的对象，绝大部分的标签都是成对出现的，如 <code>&lt;table&gt;&lt;/talbe&gt;</code>、<code>&lt;form&gt;&lt;/form&gt;</code>；</li>
<li>标签对中的第一个标签是开始标签，第二个标签是结束标签，开始和结束标签也被称为开放标签和闭合标签；</li>
<li>也有少部分不是成对出现的，如<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>等；</li>
<li>标签就是用来标记 HTML 元素的，位于起始标签和结束标签之间的文本就是HTML元素的内容。</li>
<li>HTML 元素就是通过使用 HTML 标签进行定义的，比如 <code>&lt;p&gt;</code> 这就是一个标签，而 <code>&lt;p&gt;内容&lt;/p&gt;</code> 这就是一个<strong>元素</strong>，也就是说<code>元素由一个开始的标签和结束的标签组成，用来包含某些内容</code>，这里有一个值得注意的例外，即 <code>&lt;br&gt;</code> 本身既是开始标签也是结束标签，但不包含任何内容，所以这只是个标签。</li>
</ul>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>四种最基本的标签：</p>
<ol>
<li>标题：通过 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 等标签进行定义的；</li>
<li>段落：通过 <code>&lt;p&gt;</code> 标签进行定义的；</li>
<li>链接：是通过 <code>&lt;a&gt;</code> 标签进行定义的，<code>&lt;a href=&quot;http://matt33.com&quot;&gt;matt&lt;/a&gt;</code>；</li>
<li>图像：通过 <code>&lt;img&gt;</code> 标签进行定义的，<code>&lt;img src=&quot;matt.jpg&quot; width=&quot;100&quot; height=&quot;142&quot; /&gt;</code>；</li>
</ol>
<p>注： HTML 标签对大小写不敏感：<code>&lt;P&gt;</code> 等同于 <code>&lt;p&gt;</code>.</p>
<h1 id="HTML-文本"><a href="#HTML-文本" class="headerlink" title="HTML 文本"></a>HTML 文本</h1><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p><strong>HTML 元素</strong>指的是从开始标签（start tag）到结束标签（end tag）的所有代码。</p>
<p>HTML网页实际上就是由许许多多各种各样的HTML元素构成的文本文件，并且任何网页浏览器都可以直接运行HTML文件。</p>
<h3 id="元素语法"><a href="#元素语法" class="headerlink" title="元素语法"></a>元素语法</h3><p>元素语法特点：</p>
<ul>
<li>HTML 元素以开始标签起始；</li>
<li>HTML 元素以结束标签终止；</li>
<li>元素的内容是开始标签与结束标签之间的内容；</li>
<li>某些 HTML 元素具有空内容（empty content）；</li>
<li>空元素在开始标签中进行关闭（以开始标签的结束而结束）；</li>
<li>大多数 HTML 元素可拥有属性。</li>
</ul>
<h3 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h3><p>HTML 元素的内容是开始标签与结束标签之间的内容，而某些 HTML 元素具有空内容（empty content），这种元素被叫做<strong>空元素</strong>，比如说换行符<code>&lt;br&gt;</code>。</p>
<p>为了规范起见，换行符最好还是用 <code>&lt;br/&gt;</code>。</p>
<p><code>&lt;p&gt;</code> 标签结束以后也后一个换行的动作，那 <code>&lt;p&gt;</code> 标签和 <code>&lt;br/&gt;</code> 标签有什么异同呢？</p>
<ol>
<li>相同之处是 <code>&lt;br&gt;</code> 和 <code>&lt;p&gt;</code> 都是有换行的属性及作用；</li>
<li>区别 <code>&lt;br/&gt;</code> 是只需一个单独使用，而 <code>&lt;p&gt;</code> 和 <code>&lt;/p&gt;</code> 是一对使用；</li>
<li><code>&lt;br/&gt;</code> 标签是小换行提行（相当于我们平时文本中输入一个回车），<code>&lt;p&gt;</code> 标签是大换行（分段，相当与两个回车）,隔行作用。</li>
</ol>
<h2 id="HTML-属性"><a href="#HTML-属性" class="headerlink" title="HTML 属性"></a>HTML 属性</h2><p>某些标签要按照开发者的意愿来实现在网页上，就得需要一定信息的补充，这信息就叫<strong>属性</strong>，HTML 标签可以加上属性的描述，属性提供了有关 HTML 元素的更多的信息。</p>
<p>关于属性有以下语法规则：</p>
<ul>
<li>是在 HTML 元素的开始标签中定义；</li>
<li>总是以名称和值对应的形式出现，比如：<code>name=&quot;value&quot;</code>。</li>
<li>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。</li>
</ul>
<p>举例，下面这个就是 <code>&lt;a&gt;</code> 标签的属性，是对 <code>&lt;a&gt;</code> 标签的补充说明，既指向网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>大多数的标签都会有各种各样的属性，没必要记住所有的属性，只需要在实践中多积累，知道哪些属性是常用的，知道如何查资料即可。</p>
<h2 id="HTML-文本格式化"><a href="#HTML-文本格式化" class="headerlink" title="HTML 文本格式化"></a>HTML 文本格式化</h2><p>一般我们在网页中能看见有各种各样的字体、文本样式，这就是文本格式化标签的功劳。下面的文本格式化标签是比较常用的：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;b&gt;</code></td>
<td>（bold）粗体</td>
</tr>
<tr>
<td><code>&lt;big&gt;</code></td>
<td>（big）大字体</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>（emphasized）强调字</td>
</tr>
<tr>
<td><code>&lt;i&gt;</code></td>
<td>（italic）斜体</td>
</tr>
<tr>
<td><code>&lt;small&gt;</code></td>
<td>（small）小字体</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>(strong)加重语气</td>
</tr>
</tbody>
</table>
<h2 id="HTML-样式"><a href="#HTML-样式" class="headerlink" title="HTML 样式"></a>HTML 样式</h2><p>style 提供了一种改变所有 HTML 元素的样式的通用方法。这里可以将，背景颜色，字体样式，字体尺寸，字体颜色，对齐方式一并定义好。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center;font-family:verdana;color:gray"</span>&gt;</span> verdana and white<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-family:time;color:greeen"</span>&gt;</span> time and green words<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="HTML-超文本"><a href="#HTML-超文本" class="headerlink" title="HTML 超文本"></a>HTML 超文本</h1><h2 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h2><p>通过网页中超链接，可以连接到自己感兴趣的地方。</p>
<h3 id="给文字及图片添加超链接"><a href="#给文字及图片添加超链接" class="headerlink" title="给文字及图片添加超链接"></a>给文字及图片添加超链接</h3><p>最简单的链接就是将文字添加链接连接到网页和另外的 HTML 文件，给图片添加链接。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"matt.html"</span>&gt;</span>another html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"touxiang.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接的打开方式"><a href="#超链接的打开方式" class="headerlink" title="超链接的打开方式"></a>超链接的打开方式</h3><p>打开方式分为在本页打开和在新的浏览器窗口打开，超级链接标签提供了 <code>target</code> 属性进行设置，取值分别为<code>_self</code>（在本页打开，默认）、<code>_blank</code>（创建新窗口打开新）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接添加提示文字"><a href="#超链接添加提示文字" class="headerlink" title="超链接添加提示文字"></a>超链接添加提示文字</h3><p>有些时候超链接文字不足以说明点击以后所要链接的内容，所以这个时候我们就需要给超链接添加提示文字，加以描述下一个链接的内容，当光标停留在超链接上时，提示语言就会显现，会让页面显现的很简介。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>let's have an example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>   </div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://matt33.com"</span> <span class="attr">title</span>=<span class="string">"this word will link to the wed of matt's blog."</span>&gt;</span>matt<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="超链接实现书签"><a href="#超链接实现书签" class="headerlink" title="超链接实现书签"></a>超链接实现书签</h3><p>在阅读小说时，会发现当在点击相应章节的题目时，可以跳转到相应的章节，想实现这种效果，就必须要了解什么是锚（anchor），实际上就是锚用于在单个网页内不同位置的跳转，锚也叫做书签。</p>
<ul>
<li>涉及到的标签还是 <code>&lt;a&gt;</code> 标签，超级链接标签的 <code>name</code> 属性用于定义锚的名称；</li>
<li>一个页面可以定义多个锚，通过超级链接的 <code>href</code> 属性可以根据 <code>name</code> 跳转到对应的锚。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:20px"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span>HTML LEARNING<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c1"</span>&gt;</span>  HTML first<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c2"</span>&gt;</span>HTML second <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c3"</span>&gt;</span>HTML third <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c1"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 1 first HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c2"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 2 second HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"c3"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>chapter 3 chaowenben 1 HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>lalalaalalal<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML 表格"></a>HTML 表格</h2><p>表格在 HTML 中是不可缺少的元素，表格主要包括了 <code>table</code>、<code>tr</code> 和 <code>td</code> 这几个标签：</p>
<ol>
<li>表格由 <code>&lt;table&gt;</code> 标签来定义；</li>
<li>每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义）；</li>
<li>每行被分割为若干单元格（由 <code>&lt;td&gt;</code> 标签定义）;</li>
<li>字母 <code>td</code> 指表格数据（table data），即数据单元格的内容。<code>&lt;th&gt;</code>标签用来定义表头;</li>
<li><code>border=&quot;1&quot;</code>定义的是最外面边框粗细，为1，你也可以设置为0，就是不显示边框；</li>
<li><code>colspan</code>：控制此单位所占列数；</li>
<li><code>rowspan</code>：控制此单位所占行数；</li>
</ol>
<p>还有一些其他的属性：</p>
<ul>
<li>标签：<code>&lt;th&gt;表头&lt;/th&gt;</code>：设置表头；</li>
<li>标签：<code>&lt;caption&gt;标题&lt;/caption&gt;</code>：设置表的标题；</li>
<li>属性：<code>cellpadding=&quot;...&quot;</code> 设置单元格边距；</li>
<li><p>属性：<code>bgcolor=&quot;...&quot;</code> 设置表格背景颜色；</p>
</li>
<li><p>属性：<code>background=&quot;...&quot;</code> 以某张图片作为表格背景。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span> &gt;</span>TABLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:30px"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span>table practice<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">table</span>  <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">border</span>=<span class="string">"15"</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>first row and first column<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>second row and first column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>second row and second column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span> &gt;</span>second row and third column<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>third row and first column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                 <span class="tag">&lt;<span class="name">td</span>&gt;</span>third row and second column <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">             <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span>   </div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p>对于 HTML 图像，一般涉及到的就是以下几类：</p>
<ul>
<li>将图片作为背景；</li>
<li>插入图片</li>
<li>将图片作为链接。</li>
</ul>
<h3 id="图片作为背景"><a href="#图片作为背景" class="headerlink" title="图片作为背景"></a>图片作为背景</h3><p>在 <code>body</code> 属性中添加 <code>background</code> 属性来添加背景图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">"./qwe.gif"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="插入一张图片"><a href="#插入一张图片" class="headerlink" title="插入一张图片"></a>插入一张图片</h3><p>通过 <code>img</code> 标签给网页插入一张图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片的路径"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在 <code>&lt;img&gt;</code> 标签中加入 <code>align</code> 属性，来对其进行调整，可以进行调整的参数有：</p>
<ul>
<li>可以上下调整的参数有：<code>bottom</code>、<code>middle</code>、<code>top</code>，默认是 <code>bottom</code>；</li>
<li>可以左右调整的参数有：<code>right</code> 和 <code>left</code>，默认为 <code>right</code>；</li>
<li>尺寸的调整：<code>width</code> 和 <code>height</code> 两个属性。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> align top<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./julizi.png"</span> <span class="attr">align</span>=<span class="string">"top"</span> <span class="attr">width</span>=<span class="string">"10%"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="将图片作为链接"><a href="#将图片作为链接" class="headerlink" title="将图片作为链接"></a>将图片作为链接</h3><p>将图片做链接，一般情况下，触发链接的方式就是点击图片的任何地方都可以链接到跳转地址，但有时需要实现，点击图片的不同地方跳转到不同的地方，也就是，一张图片可以创建带有可供点击区域的图像地图，其中每个区域就是一个超链接。</p>
<p>涉及到的标签就是 <code>&lt;map&gt;</code> 标签，用来指定图片，<code>&lt;area&gt;</code> 用来指定超链接区域。</p>
<p>在 <code>&lt;area&gt;</code> 标签中我们会涉及到 <code>shape</code> ，<code>coords</code>， <code>href</code> 属性，分别用来指定超链接区域形状，超链接区域坐标，还有超链接跳转地。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;image test&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body background="./qwe.gif"&gt;</div><div class="line"></div><div class="line">    &lt;p&gt;tap the li zi &lt;/p&gt;</div><div class="line">    &lt;img src="./julizi.png" usemap="#lizi"/&gt;</div><div class="line"></div><div class="line">    &lt;map name="lizi"&gt;</div><div class="line">     &lt;area shape="rect" coords="50,10,100,60" href="img.html" target="_blank"</div><div class="line">    &lt;/map&gt;  </div><div class="line"></div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>shape</code> 属性的取值可以是：<code>rect</code>(矩形)、<code>circle</code>(圆形)、<code>poly</code>(多边形)和 <code>default</code> (整个图像区域)，这里采用的是矩形。</li>
<li><code>coords</code> 属性对于矩形而言，<code>coords</code> 有4个值，分别用逗号隔开，表示矩形区域左上角x坐标、左上角y坐标、右下角x坐标和右下角y坐标，这里获取坐标的方式，就用截图工具帮忙就好。</li>
</ul>
<h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表始于 <code>&lt;ol&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code> 标签。列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</p>
<p>在有序列表中我们还能定义其他的排序方式，上面是默认的数字排序，下面我们再加上字母排序和罗马数字排序</p>
<ol>
<li>通过添加 <code>type</code> 属性来设置排序方式，<code>a</code> 表示以小写字母来排序，<code>A</code> 就是使用大写字母来排序，<code>i</code> 就是以小写罗马数字来排序，<code>I</code> 就是以大写罗马数字来排序；</li>
<li>还可以添加 <code>start</code> 属性，决定起始的序号。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"font-size:20px;background-color:gray"</span> &gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"2"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>c <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"a"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>c <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表始于 <code>&lt;ul&gt;</code> 标签，每个列表项始于 <code>&lt;li&gt;</code>。</p>
<p>无需列表排序的时候就是给每个列表项加各种小符号其中分为<code>Disc</code>（默认）实心黑点，<code>Circle</code>小圈，<code>square</code>方点，与有序列表的属性都是用的一样的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"circle"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="定义性列表"><a href="#定义性列表" class="headerlink" title="定义性列表"></a>定义性列表</h3><p>定义列表通常用于术语的定义和解释。定义列表由 <code>&lt;dl&gt;</code> 开始，术语由 <code>&lt;dt&gt;</code> 开始，解释说明由 <code>&lt;dd&gt;</code> 开始，<code>&lt;dd&gt;....&lt;/dd&gt;</code> 里的文字缩进显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>it's useful!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ti's nice!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-块"><a href="#HTML-块" class="headerlink" title="HTML 块"></a>HTML 块</h2><p>HTML元素被定义为块级元素或内联元素。</p>
<ul>
<li>块级元素(block)特性：<ol>
<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示；</li>
<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制，就像以前用到的 <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;table&gt;</code>标签。</li>
</ol>
</li>
<li>内联元素(inline)特性：<ol>
<li>和相邻的内联元素在同一行；</li>
<li>宽度(width)、高度(height)、内边距的 <code>top</code>/<code>bottom</code>(<code>padding-top</code>/<code>padding-bottom</code>)和外边距的<code>top</code>/<code>bottom</code>(<code>margin-top</code>/<code>margin-bottom</code>)都不可改变，就是里面文字或图片的大小，就像以前用到的<code>&lt;b&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code> 标签。</li>
</ol>
</li>
</ul>
<p>在这里我们先介绍两个标签 <code>&lt;div&gt;</code> 标签和 <code>&lt;span&gt;</code> 标签。</p>
<ul>
<li><code>&lt;div&gt;</code> 用来定义文档中的分区或节（division/section），没有特定的含义，它是可用于组合其他 HTML 元素的容器；</li>
<li><code>&lt;span&gt;</code> 用来组合文档中的行内元素，也没有特定的含义.</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:white"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is a header.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragrph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-布局"><a href="#HTML-布局" class="headerlink" title="HTML 布局"></a>HTML 布局</h2><p>大多的网页布局是需要配合 css 来完成，后面会总结一篇关于 css 基本用法的文章，这里先不涉及太多。</p>
<p>这里通过一个示例，它是使用 <code>&lt;table&gt;</code> 元素和 <code>&lt;div&gt;</code> 元素实现的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"gray"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"1000"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">style</span>=<span class="string">"background-color: royalblue"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>matt' blog<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"background-color: darkorange;width:300px"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>list of blogs<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;<span class="name">dd</span>&gt;</span></div><div class="line">                          <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                              <span class="tag">&lt;<span class="name">li</span>&gt;</span>kafka<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line">                      <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"background-color: forestgreen;height:500px;width:700px;"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"font-size: 20px;text-align: center"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                    this is matt's blog</div><div class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">style</span>=<span class="string">"background-color: powderblue;text-align:center;height: 100px"</span>&gt;</span></div><div class="line">                    good good study day day up<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过表格来设计一个网页如下图所示。</p>
<p><img src="/images/web/html_lianxi.png" alt="示例"></p>
<p>上面的示例使用表格来进行表示的一个网页，如果使用 <code>div</code> 元素应该怎么做，下面使用 <code>div</code> 元素来重新设计一下上面的网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">            div#container&#123;width:1000px&#125;</div><div class="line">            div#header &#123;background-color: royalblue ;height: 100px;text-align:center;font-size: 20px&#125;</div><div class="line">            div#sidebar&#123;background-color: darkorange;height:400px;width:300px;float:left;&#125;</div><div class="line">            div#mainbody &#123;background-color: forestgreen;height:400px;width:700px;float:left;&#125;</div><div class="line">            div#footer &#123;background-color: powderblue;height: 100px;clear:both;text-align:center;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>matt's blog<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">dl</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>list of blogs<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">dd</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>hadoop<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">li</span>&gt;</span>kafka<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mainbody"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello word<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is matt's blog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>good good study day day up<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单标签是什么呢？这个是在网页是很常见的，表单标签就是用于网页中的数据提交，比如我们注册网页，在留言板中留言、评论等可以填写数据，提交处理地方都需要表单标签，<code>form</code> 表单标签内有输入框 input、单选、多选、<code>select</code> 下拉列表菜单与跳转菜单、提交按钮等标签内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    user：</div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    password：</div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> /&gt;</span> Male</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span> /&gt;</span> Female</div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"married"</span> /&gt;</span></div><div class="line">    married</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"have a job"</span> /&gt;</span></div><div class="line">    have a job</div><div class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"chinese"</span> /&gt;</span></div><div class="line">    chinese</div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，name 是明文显示，password 是隐藏的，<code>radio</code> 属性是单选，<code>checkbox</code> 属性是双选，上面展示的效果如下图所示。</p>
<p><img src="/images/web/html_form.png" alt="示例"></p>
<p>后面还会单独写一篇文章对 css 进行一下总结，html 和 css 的这两篇文章，会不定时更新，以后用到什么比较常用内容或者遇到什么好的方法，会更新到这两篇文章中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML 是一种语言，是用来描述网页的语言，它是一种标记语言，HTML 就是使用标记标签来描述网页。&lt;/p&gt;
&lt;p&gt;HTML 算是最容易学习的语言之一，它也是必须掌握的一门语言，之前对 HTML 只是大概了解，并没有开发过前端页面，现在在工作中，会使用前端框架已经成为了一项
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://matt33.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>入职培训感想</title>
    <link href="http://matt33.com/2017/05/27/induction-training-think/"/>
    <id>http://matt33.com/2017/05/27/induction-training-think/</id>
    <published>2017-05-27T13:44:51.000Z</published>
    <updated>2017-05-29T02:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周参加了公司的封闭式入职培训，总共是五天的时间，今年是公司第一次进行校招封闭式培训。记得去年七月份来公司实习，一起入职的校招同事参加的入职培训才两天时间，而且也不是封闭式的，一年的时间，变化还是很大的，这也间接证明公司的发展速度很快。作为公司第一届参加封闭式入职培训的员工（不是这届的第一批），在这五天中明显感觉到了收获了很多，这里记录总结一下。</p>
<h2 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h2><p>今天上午九点从公司出发到酒店，早上起来的时候还只是小雨，九点多出发的时候已经变成了大到暴雨，京城的雨本来就很少，但是很多时候一旦雨一下来就收不住了。从公司门口到大巴车只有短短的100米，但全身已被淋湿了很多，好在到了酒店之后雨已经差不多停了。</p>
<p>到了酒店会议室之后，已经快到中午了，同组同学相互认识一下，然后负责培训的同事介绍一下培训期间的一些规则，之后就到了吃午饭的时间（关于伙食就不想多介绍了，冷暖自知😂）。</p>
<h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>下午的第一节课，是对公司的一些基本介绍，第一节课讲课的老师是大熊老师，大熊老师现在在公司从事人力资源方向的工作，有近十年的工作经验，从他身上看到了一些值得我们去学习的地方：</p>
<ol>
<li>他对公司业务的理解，虽然大熊老师现在是从事人力资源方向，但是无论在技术还是业务方向都有很多认识，尤其是在业务方面，他思考的还很深的，包括对公司发展战略、客户的需求等方面，他都有一些很独特的见解；</li>
<li>对新事物充满<strong>好奇心</strong>，课上大熊老师问了一句：有多少人用过快手？好像当时课上没什么人举手，但是大熊老师说：快手现在这么火，我们还是应该去试用一下，看看这个产品为什么这么火，对这些新事物，我们应该保持一颗好奇心（包括阿里提出的”新零售”战略）；</li>
<li>思考问题时，很多时候并不能只站在自己的角度去想，上个台阶去看问题，可能会就会明白公司或者领导的要求了，<strong>低头做事时也要时常抬头，要有大局观</strong>；</li>
</ol>
<p>下午后面几节课就是介绍公司的一些规章制度，不过作为一名资深的老员工（实习近八个月），这些我基本上已经很了解了😄。</p>
<p>课程结束后，接着就去了酒店一楼的餐厅吃饭，饭后直接回到了会议室等待晚上的课程，结果竟错过北京近几年来最美的晚霞，只能默默在朋友圈欣赏他人的晚霞了，很可惜（这里选了一张网上的图片镇楼）。</p>
<p><img src="/images/essary/070522night.jpeg" alt="难得一遇的晚霞"></p>
<h3 id="晚上-《国家联盟》"><a href="#晚上-《国家联盟》" class="headerlink" title="晚上 《国家联盟》"></a>晚上 《国家联盟》</h3><p>这个游戏可能很多公司的培训都会使用，我是第一次玩这个游戏，我们组是巨人国，我们国家的战力很强，但是却极度缺乏资源，所以我们在第二年的时候为了完成目标就率先发动了战争，但是战争的结果并不如预期那样，如果严格按照比赛规则的话，可能我们就直接被淘汰了。关于这个游戏，个人有以下几点感想：</p>
<ol>
<li>首先我们并没有完全搞清楚游戏的规则，规则没有搞懂就进入了游戏，这基本上就注定了失败的结局；</li>
<li>在与其他团队沟通的过程中，应该有相应的技巧，在谈判的过程中，要理性地看待问题，然而时间紧迫的情况下，很多人并不理性，也包括我自己；</li>
<li>与他人合作的过程中，我们应该更多是考虑共赢合作，而不是损人利己；</li>
<li>既然彼此要合作，就应该相互信任；</li>
</ol>
<p>游戏结束，就进入了一个很开心的游戏——狼人杀，狼人杀在培训期间给我们增加了很多的欢乐，在高玩的带领下，学到了很多的技巧😀。</p>
<h2 id="周二"><a href="#周二" class="headerlink" title="周二"></a>周二</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>今天上午只有一节课 —— 职场必修课，这个应该算是入职培训的标配课程吧。</p>
<p>课程的核心有以下几点：</p>
<ul>
<li>人生的职业生涯大致分为几个阶段，在前期最主要的是<strong>学习、成长</strong>；</li>
<li>对于职场小白，如何学习、如何成长？其中很关键的一点是要有人去带你，<strong>跟着带你的人去学习成长</strong>；</li>
<li>职场礼仪：与他人沟通时要注意<strong>聆听</strong>，对同时表扬或称赞时，要<strong>基于事实去称赞</strong>。</li>
</ul>
<p>讲解这门课程的老师，在培训行业深耕近十年，她曾经在 LG 的培训界创造了很多的神话，现在她依然奋战在培训行业的第一线，未来的职业规划也是继续从事培训行业，很优秀、职业规划很清晰的一位培训老师。</p>
<h3 id="下午-户外拓展活动"><a href="#下午-户外拓展活动" class="headerlink" title="下午 户外拓展活动"></a>下午 户外拓展活动</h3><p>今天下午是一节户外扩展课，全员分为四组进行比赛，比赛的项目基本都是围绕着团队合作的目的进行的。这节课是这几天培训中最让人印象深刻的课程之一，这里说一下个人的感想以及一些感悟和收获：</p>
<ul>
<li><strong>增强了队员之间的相互了解</strong>，在之前大家基本上都是在上课，只是混了个面熟，并不是很熟悉，名字也没有记很清楚，但经过这个活动之后，至少我们小组内部（11个人）有了更多的了解；</li>
<li><strong>团队合作</strong>，五个比赛的小项目，都是需要全员参与的，需要团队之间的相互配合；</li>
<li>整个过程中，游戏并不难，难的地方主要在于大家的互相合作，大家之前并不认识，性格、思维也有很大差异，但却需要我们一起在短时间内完成一个需要强力配合的游戏，这对我们也是很大的挑战，<strong>在很短的时间内，大家要熟悉起来，并且找到默契</strong>。</li>
</ul>
<p>活动大概是6点结束的，很遗憾我们组只拿到了第二名，与第一名只有1分之差，不过这个活动最赞的地方是给了我们大家一个互相了解的机会，它并不是一个简简单单的比赛。</p>
<h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3><p>今晚的讲师是公司一位很优秀的员工，他15年本科毕业，现在正式入职还不到两年，已经开始带了7个人的团队，个人有以下几点感想：</p>
<ol>
<li>他的升职历程，在其他行业可能是不可思议的，但是在互联网行业，由于公司业务发展迅速，这样例子是数不胜数的，<strong>既是机遇也是挑战，做好准备的人才能脱颖而出</strong>；</li>
<li>虽然他工作不到两年，但他却从工作和管理的过程中，总结了很多方法论，先不说方法论的对错，仅这些就能证明他这个人很好学、爱总结，他是一个<strong>爱看书、爱总结、上进心很强</strong>的一个工程师；</li>
<li><strong>对新技术的关注以及对业务的理解</strong>，全程我可能提到了很多次这个概念 —— 对业务的理解，主要是因为我一直处于一个唯技术论的圈子里，大家讨论更多的是技术，对业务关注不是很多，然而<strong>经济是检验技术的唯一标准</strong>（当然有些技术的价值可能需要长远才能体现出来，但牛逼的技术依然是需要有经济价值的），所以每次遇到对业务理解很深的人，我都会不自由自主地感觉这个人很厉害。</li>
<li>他的演讲能力很不错，这个要跟他的工作年限一起看，非常值得我去学习。</li>
</ol>
<p>课程结束之后，又到了狼人杀时间，印象最深的就是猎人被假冒预言家的狼查杀但是却没有将狼带走、而且预言家还没有上警，这局游戏竟然成了一个我们培训中的一个槽点了😂。</p>
<h2 id="周三"><a href="#周三" class="headerlink" title="周三"></a>周三</h2><h3 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h3><p>今天上午的课程 —— 客服听音，对于服务性的企业，很多公司也都会有这项课程，主要有以下几点感想：</p>
<ol>
<li><strong>以客户为中心</strong> 是公司的价值观与企业文化，但是如何将这个条进行落实，客服是挽回用户的最后一道防线，所以客服这项工作对于公司整体发展而言是非常重要的，之前用过很多次美团，当时对美团的印象非常好，就是因为客服非常 nice，效率很高；</li>
<li>给用户提供超预期的服务。</li>
</ol>
<h3 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h3><p>下午是关于公司业务流程的讲解，有五六个前辈来讲解，印象最深的有两个：一个外卖，另一个是丽人。</p>
<h4 id="外卖业务"><a href="#外卖业务" class="headerlink" title="外卖业务"></a>外卖业务</h4><p>关于外卖，这个是公司最近几年最重视的业务，通过这位前辈的讲解，对外卖的整体有了更进一步的了解：</p>
<ul>
<li>前辈完整地经历过外卖的发展和成长，虽然在外卖领域我们是后来者，但是最后我们与饿了么一起进入了下半场，而且从目前的数据来看美团外卖的优势会更明显一些，美团有自己的智能配送系统，有可能未来会向京东物流一样发展成一个配送平台，而反观饿了么现在正在与阿里云合作去做智能配送（这两天刚爆出的新闻），这也间接地证明了美团外卖在配送领域确实与饿了么拉开了一定的差距；</li>
<li>从她的介绍过程中，明确能感觉到他对整个行业那洞察力，对商业、战略的理解已经远超我们普通人，着实很厉害，<strong>如果在一个公司里能跟随一个新业务迅速成长起来，这是非常幸运的，这样迅速成长的机会并不是常有的</strong>；</li>
<li>虽然与饿了么是竞争对手，但是外卖这边还是很<strong>尊重竞争对手的（学习对方的长处）</strong> ，饿了么那边的团队也是非常厉害的，要不然两家不会焦灼这么长时间，美团这边也是很希望有个竞争对手的，因为这样才能逼迫着我们自己去进步；</li>
<li>外卖市场现在还没有哪一家公司是占有绝对优势的，稍不留神可能就会被对手远远甩在后面，外卖现在是不盈利的，而且我们并不着急地去盈利，<strong>不为了盈利而盈利，否则就可能会损害用户的利益</strong>；</li>
<li><strong>产品在设计时一定要走在业务之前</strong>，要为业务开展以及未来的发展做准备，而不是说业务有这个需要了才开始去改进产品（期间也一定要考虑风控，这个是很重要，要不然很多的钱可能就白花了）；</li>
<li>竞争时，<strong>差异化竞争很重要，但前提是你走的是正确的道路</strong>，如果对手选择了一个正确的道路，你这时候选择差异化，那么就是在自己作死。</li>
</ul>
<p>虽然前辈只讲了不到两个小时，但让我们感觉收获了很多，无论是关于公司业务的理解还是关于一些商业行为的思考，很感谢！</p>
<h4 id="丽人业务"><a href="#丽人业务" class="headerlink" title="丽人业务"></a>丽人业务</h4><p>丽人业务，在之前并没有了解太多，后来才知道丽人业务里也有三驾马车——美发、美甲、美容美体（细心的人可能会发现这就是美团 app 中丽人栏目里的三个大图标），虽然丽人并不是一个很高频的业务，但是从这位前辈的讲述中，能感觉到的是这个团队非常有战斗力和自信心，有以下几点感触：</p>
<ul>
<li>每个细分领域，都面对着很多竞争对手，但前辈给人的感觉是他们这个团队非常有激情、对这块业务非常自信；</li>
<li>他们这个团队在这个细分的领域做了很多的事情，并没有因为这是个低频业务就不重视，他们紧紧追随着竞争对手的步伐，并没有丝毫懈怠，很赞。</li>
</ul>
<h3 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h3><p>晚上是趣味运动会，也是一些考察团队合作的小项目，只不过这些活动是可以在室内做的，运动量也不大，总体来说玩得还是很开心的。</p>
<p>之后，又进行了2局的狼人杀，都是九人局的，唉，不堪回首，全输了，不做太多解释，第一局猎人背锅，第二局女巫背锅。</p>
<h2 id="周四"><a href="#周四" class="headerlink" title="周四"></a>周四</h2><h3 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h3><p>今天上午只有一节课 —— 有效沟通，从两个方面来说：一是对老师的感觉，二是课程的内容：</p>
<p>关于对老师的感觉：</p>
<ol>
<li>这节课的内容<strong>总结了很多的方法论</strong>，这证明这位老师平时还是很喜欢读书和思考的；</li>
<li>课程也涉及了一些心理学的内容，再次证明了这位老师爱看书；</li>
<li>他自己是带团队的，在工作过程中，也需要跟其他的部门进行合作，课程的内容也是根据他看到的一些方法论和工作经验进行总结的，<strong>学以致用，并在用的过程中进行总结</strong>，这点是很值得学习的。</li>
</ol>
<p>关于课程内容，核心内容主要有以下四点：</p>
<ol>
<li>Ask；</li>
<li>Listen：听明白事、感受、以及背后被满足与不满足的需要；</li>
<li>Look：肢体语言，在不同场合着装、动作都要注意；</li>
<li>Speak：察情传理，主要是要考虑他人的感受。</li>
</ol>
<h3 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h3><p>今天下午的课程，是一位公司的高 P 来讲解的，这节课主要是讲解思维方式的。这里先总结一下课程的内容：</p>
<ul>
<li>思维方式分类<ol>
<li>惯性思维：是靠经验、直觉是判断；</li>
<li>逻辑思维：推理+逻辑分析（垂直思维）；</li>
<li>水平思维：创意天马行空，很有可能碰撞出一个非常好的灵感；</li>
<li>结构化思维：先框架再细节，强调快速、系统地解决问题。</li>
</ol>
</li>
<li>结构化思维的分析方式：<ol>
<li>先聚焦问题与目标；</li>
<li>从假设入手进行分析；</li>
<li>分析问题的关键；</li>
<li>从这些关键点入手。</li>
</ol>
</li>
<li>分析的三个原则：<ol>
<li>以终为始；</li>
<li>MECE：建立分析结构（相互独立、完全穷尽）；</li>
<li>二八原则：抓住关键的少数。</li>
</ol>
</li>
<li>麦肯锡的电梯理论：<ol>
<li>最短的时间把问题表达清楚——直奔主题与结果；</li>
<li>归纳的话，尽量三条以内。</li>
</ol>
</li>
</ul>
<p>老师的课程很风趣，课上互动也较多，从课程中也能明显地感觉到这位老师是一位<strong>爱思考、爱读书、爱总结</strong>的优秀工程师。无论是在各行各业，那些优秀人才基本上都有这些共性，这几点可以说成为优秀人才的至尊宝典，只是能够一直坚持下去的人很少，我本人的毅力也不是很强，很多的时候只能逼迫自己呆在一个充满竞争力的环境中，让竞争激烈的环境逼迫着自己去努力，也希望自己未来能够从主观上有所改变。</p>
<h3 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h3><p>今晚没有安排额外的课程，然而却比上课都累，因为明天下午我们要做毕业呈现，各个小组的产品设计要进行比赛，我们团队基本上是通宵进行的产品设计，自从上了研究生之后就没怎么熬过夜了，第一次熬那么久，还是值得记录一下的。</p>
<ol>
<li>方向篇：想在一晚上就把一个产品的设计方案做出来还是很难的，不说别的，单纯的方向就很难找。我们刚开始想的是把美团与慈善结合起来，后来发现太难做了，而且可行性较差，后来又想到的是借鉴趣运动，做运动场馆的预定。美团app在运动场馆方面只能进行团购，而不能去预定时间段，这是不能够满足用户需求的，这是一个很好的方向，而且实施起来比较简单。本来方向已经确定了这个，结果我再次查看美团app时，发现我经常去的那个场馆已经可以直接预定时间段了，天呐，美团已经开始做了！！！我们只能放弃这个方案，去寻找新的方向，后来突然想到了 app 的积分商城，我们就确定了去做积分商城这个方向，这个时候已经是晚上10点了，我们才确定了产品的方向。</li>
<li>产品设计篇：然后就是具体的改进方向，我们决定设计了一个美食达人类似的晋级策略，鼓励用户使用美团品尝美食，然后进行达人升级，后面就是具体产品实现、落地档案以及产品呈现。细节还没有讨论清楚会议室就到了关门时间，我们全组只好转战到了酒店的二楼继续进行。</li>
<li>激烈讨论：在讨论的过程中，我们有很多的争执，做 RD 的总是感觉没必要这么较真，一直聚焦在产品细节的设计上，时间有限，应该直接开始做，后面有时间的话，我们再去优化产品。而组里的另外两名 QA 和 PM 却认为这很重要，一直聚焦在产品的具体表现形式上。最后觉得争执也没有什么用，我只好开始先做 PPT，具体产品实现由他们来做。</li>
<li>感慨：通过这次的产品设计，能明确感受到我们之间思维的差异，这当然没有对错之分，作为工程师，我们在乎的是能不能按时完成，或者是更有效率地完成，而产品经理考虑则是产品的细节上。</li>
</ol>
<p>最后奋战到了凌晨四点半，直到 PPT 做得差不多了，我们才回去休息，这时候脑袋基本上已经停止了思考，实在是太困了，这是近三年来睡得最晚的一次。</p>
<h2 id="周五"><a href="#周五" class="headerlink" title="周五"></a>周五</h2><p>凌晨5点才睡觉，睡到早上九点爬起来去上课。</p>
<h3 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h3><p>上午的课程是介绍产品相关的内容，但是这节课说实话并不是很好，可能一个是自己比较困，并没有认真听讲，但在跟其他的学员交流后，发现我们的感受都差不多，在课程中并没有想象中收获的那么多。培训的同学大都是 rd，pm 很少，我们很希望这门课应该是一个产品经理的入门课程，通过这节课至少会对一个产品经理的日常工作以及产品的设计方面有一个基本的了解，但是这节课的安排并没有那么好，感觉太偏理论性，先介绍理论然后快速把案例过了一下，并没有很好地将理论与具体的案例结合起来，这样的话培训的效果就会很差，作为一个入门的产品小白，并没有从这节课中收获到更多的东西。</p>
<h3 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h3><p>上午的课程结束之后，我们就赶紧修改了我们的 PPT，好在最后在1点半前把 PPT 完成了，由于 PPT 的第一部分是我写的，所以这部分的内容是由我来讲解的，在台上讲解并没有想象中的那么紧张😝，但是演讲技能还是需要很大提高的，很多的时候心里想的东西，在台上讲解时就很自然地忘记了，还是有待锻炼的。虽然我们产品的呈现并不是很理想，但在这个过程中，收获了很多，有以下几点感想：</p>
<ol>
<li>现在我依然认为我们确实是找到了产品的一个缺陷，但是业内目前都没有一个很好的解决方案，应用场景基本上都一致，但是我们在分析其他公司的积分商城时，只考虑 IT 行业，并没有去研究一些传统行业的做法，没有<strong>使用水平思维去看待问题</strong>；</li>
<li>优秀的产品一定要是简单，我们产品设计和呈现都有些过于复杂， 而且还没有对他人讲解清楚，一个好的产品呈现，应该是能够简单清晰地表达出来的；</li>
<li>并没有更多地去分析如果推出了这个产品之后的效果，是不是会像预期的效果那样，用户会不会去 care 这样的一个变动；</li>
<li>其他组的产品在呈现上设计得更加优美，而且有几个产品的设计得确实很不错，简单名了。</li>
</ol>
<p>虽然我们并没有拿到大奖，但是通过这次活动，了解到了一个产品设计的设计过程，尤其是当你去寻找方向时，会发现很多的领域都已经被巨头占领了，创业公司很难能够有所突破。</p>
<h3 id="高管交流会"><a href="#高管交流会" class="headerlink" title="高管交流会"></a>高管交流会</h3><p>这次来交流的是公司的穆总，去年初到公司时，就听同事说到过穆总的大名，后来也参加过一次搜狐的高管交流会，中间也听到了搜狐北研的负责人讲起了穆总当年的那些事，而这次终于有机会能够与穆总面对面交流。听穆总讲话确实收获颇丰，交流会全程分为两个部分：先是穆总给我们的一些建议，后面是穆总的一些 QA。</p>
<p>穆总给我们的三个建议，也是穆总的一些感概：</p>
<ol>
<li><strong>学习成长，持续的学习和成长</strong>，这个社会变化很快，离开学校只是一个起点，并不是学习的终点，未来的社会可能会变化更快，这就要求我们必须<strong>活到老学到老</strong>，去拥抱变化；</li>
<li>要<strong>下苦功夫</strong>，10000小时理论是大家广泛周知的一个理论，听说过这个理论可能有50%的人，但真正去做的可能不到25%，而最后能够下苦功夫坚持做下来的连10%也不到，而最终能够做到的这10%的人将会去管理这剩下90%的人；</li>
<li><strong>耐心</strong>，现在的互联网发展很快，也使得很多人都变得浮躁，没有耐心去认真地做事情，当年（07年左右）从 BAT 离职创业的那些人90%的并没有他们之前的同事过得更好，现在我们的面前充满着各种各样的”机会”，但是我们要去分辨着这些”机会”，看看这些是不是真的”机会”（通过商业的本质去分析一家公司的机会）。</li>
</ol>
<p>穆总讲完这三点之后，给我们留了足够的时间进行 QA，QA 的三个问题都是业务方面，能明确感受到大家对美团点评前景的担心，毕竟公司的负面新闻太多，我们确实也在各个领域均遇到强劲的对手，在穆总的耐心解答中，总结了以下几点，有对穆总的感觉，也有穆总对公司业务的分析：</p>
<ul>
<li>穆总对商业的洞察力、对产品的思考，都很深入的，<strong>商业的本质就是去解决现实中存在的问题</strong>；</li>
<li>穆总非常<strong>务实</strong>，他现在负责美团金融，我们问未来美团会不会出一款类似与微信支付或支付宝的产品时，穆总很直接地说了，现在的市场是不需要一家类似于支付宝或微信支付的产品，但是我们依然有东西要去做，当把一些基本的东西做好之后，未来如果出现新的变革，我们就有机会去做一些事情；</li>
<li>创新：应该多去尝试，很多业务都是尝试出来的，以现在要发展的美团打车为例，打车领域有巨头，但不代表我们必须要放弃这个市场，出行市场是足够大的，不应该只有一家公司存在，如果这样的话，其实对于用户也不是很好的选择，<strong>就像电商领域，虽然阿里占据垄断地位，但是京东、唯品会依然过得不错</strong>，打车领域做到第一很难，但我们可以去做第二或第三，既然打车是吃喝玩乐的一部分，而美团点评是定位为吃喝玩乐一站式的平台，那么打车就必须要做，还有一点是很重要就是：打车领域的需求并不是都被满足了，至少对于打车师傅而言，由于滴滴抽成太高师傅们都是不满的；</li>
<li>居安思危：这点从穆总的交流中，能明显感觉出来，美团是一家很谨慎的公司，创业公司稍不留神可能就会被淘汰，所以美团的高管们<strong>危机意识</strong>很强，在去年的时候，当时我就能感受到未来支付宝可能是美团最强劲的对手，而糯米并不足以为率，当时只是纳闷为什么美团不进行正面反击，支付宝通过口碑、饿了么对美团发起强攻，但美团除了外卖高歌猛进其他的业务似乎是一直在守，这个令我很不解，现在再去回头看，就清晰很多了，一个是公司没有那么大的财力去多线强烈作战，另一个是公司在过去一到两年里一直在勤练内功，避免像 BAT 那样浪费资源，相信过不了多久美团就会强力反击，但前提是内功要先练好；</li>
<li>总结教训：穆总是从百度出来的，离开百度的时候还是 BAT，现在已经变成 AT 了，百度的没落有很多种原因，我们能做的就是从中吸取教训，避免走百度的老路，可能<strong>谷歌的退出就是百度没落的开始</strong>，没有竞争对手就会让一家企业忘乎所以。</li>
</ul>
<p>通过近两个多小时的交流，关于业务一些不理解的地方，瞬间开朗了很多，也对公司未来的前景非常看好。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>五天的培训，很快就结束了，通过这次培训，感觉很幸运能够加入美团点评 —— 一个认真做实事的公司，希望美团点评明天更好，下面是一张我们全体学员的合照，希望大家明天更好！</p>
<p><img src="/images/essary/070523training.jpeg" alt="大家庭"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周参加了公司的封闭式入职培训，总共是五天的时间，今年是公司第一次进行校招封闭式培训。记得去年七月份来公司实习，一起入职的校招同事参加的入职培训才两天时间，而且也不是封闭式的，一年的时间，变化还是很大的，这也间接证明公司的发展速度很快。作为公司第一届参加封闭式入职培训的员工
    
    </summary>
    
      <category term="随笔" scheme="http://matt33.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://matt33.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>腾讯传，一个激情澎湃的时代</title>
    <link href="http://matt33.com/2017/04/16/tencent-read/"/>
    <id>http://matt33.com/2017/04/16/tencent-read/</id>
    <published>2017-04-16T08:11:14.000Z</published>
    <updated>2017-06-21T00:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两周把<a href="https://book.douban.com/subject/26929955/" target="_blank" rel="external">《腾讯传》</a>看完了，这本书去年出版的时候就想去看，但是一拖就拖到了现在，直到上周出去玩，回来的时候路上遇到了堵车，车上实在无聊，就开始看这本书。我平时是比较喜欢看这类科技史或科技公司史的书，第一次看这种类型的书，读的吴军老师的<a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">《浪潮之巅》</a>，当时真叫是一个过瘾，至今还记得当时那种情景 —— 怎一个爽字了得，一口气连着两天在图书馆把这本书看完了。可是现在在看《腾讯传》时，已经没有了那种感觉，但最后还是在两周的时间里把这本书看完了，跟着吴晓波一起重温了一个伟大互联网公司（3Q 之后的腾讯）发展历程 —— 一个激情澎湃的时代。</p>
<p>改革开放三十多年以来，个人认为给中国经济带来最大贡献的应该是两个方面：制造业和互联网。这十几年来，互联网公司上市造富神话，可以说是激励一批又一批的有志青年投身创业大潮。互联网这个行业应该可以说是所有行业里面竞争最透明、最激烈的行业了，它成功冲破了国企垄断的壁垒、也幸运地战胜了美国的一些互联网巨头的入侵，使得中国市场在全球显得独树一帜。从八十年代中国第一次连入到全球互联网开始，中国的互联网主要经历了三个重要阶段：</p>
<ol>
<li>1999年左右，以新闻行业（靠广告挣钱）为基本生态，出现了新浪、搜狐和网易三巨头；</li>
<li>2007年之后，出现了以应用平台为基本业态的大洗牌，门户们陷入“模式困境”，出现了成长乏力的态势，而百度、阿里巴巴和腾讯则分别从搜索、电子商务和即时通信工具三个方向出发，到2010年前后完成了反向超越，成为“新三巨头”，它们被合称为 BAT。</li>
<li>从2012年开始，智能手机异军突起，互联网的用户重心从电脑端向移动端快速平移，移动互联网时代开始，出现了诸如小米、美团、滴滴、头条的几个小巨头，百度在不到5年的时间里由于没有抓住机遇迅速衰退，互联网进入白热化时代 —— 腾讯阿里争霸时代。</li>
</ol>
<p>曾经有段时间，我们感觉互联网行业好像机会已经很少了，各个方向都有巨头在做，可是在2014年，大数据开始火热，2016年，人工智能开始迅速走进了所有人的视野，斯坦福也开始设置数据科学的专业，美国中国的政府都开始发力，抢占人工智能的风口。可以这样说从2016年开始，互联网开始进入人工智能争战的时代，估计在2020年左右也会出现几个像美团、滴滴、头条这样的小巨头，互联网行业似乎时刻都充满着机会，竞争也从来没有间断，稍不留心可能就会被对手迅速甩开。但腾讯似乎总能抓住这些热潮，至少从目前来看是这样的，这本书就是带领我们去看一下腾讯这家巨头的发家史。</p>
<p>说到腾讯发家史，有个故事，大家应该都听过 —— 马化腾当年要以100W 的价格将 QQ 卖掉，可是别人只出50W，最后因为价格没谈拢，交易就没成功。那个时期应该是腾讯起家时最困难的一段时间，其他的公司，像网易通过卖邮件系统和广告、搜狐新浪也是通过卖广告已经过得很滋润了，甚至都开始到美国上市了，而腾讯当时还在破产边缘挣扎。腾讯在推出 QQ 之后，并没有找到一个合适的商业模式，后来随着 QQ 用户达到100W、1000W，需要越来越多的服务器，腾讯在其他领域挣的钱全都投入到 QQ 这个项目上了，但公司维持起来依然很艰难，幸好腾讯在2000年互联网泡沫前拿到了风险投资，否则腾讯可能真的就不撑不下去了。</p>
<p>拿到投资之后的腾讯，暂时缓解资金的压力，但是如果找不到合适的变现途径，这种模式依然是不能持续下去的。腾讯甚至在一段时间里由于用户量暴增，不得不对每天的 QQ 注册量进行限制，在这期间，腾讯可以说被用户骂得要死，而且其他的竞争对手公司，像网易都开始推出自己的即时通信工具（网易泡泡）来狙击腾讯，腾讯被迫只能继续开放 QQ 免费注册。腾讯在这段时间内依然面对着巨大的资金压力，腾讯找到的第一个商业模式，就是与中国移动合作，当时中国移动刚从中国电信中独立出来，同样需要迅速找到一种商业模式与中国电信、联通进行竞争，于是乎推出了一个移动梦网的项目，腾讯从这中间拿到分成，曾经一度这个项目就是腾讯生存下去的基础（如果后来不是移动自己推出飞信并取消其他公司分成的话，恐怕腾讯也不会变得这么骁勇）。直到后来 QQ 秀的出现，这应该是腾讯历史上的一个重要事件，算是腾讯找到了第二个商业模式。QQ 秀是从韩国的一款产品中借鉴而来的，腾讯对其进行了本土化的改造，中间进行了很多的微创新，腾讯自己都没想到这款款产品一推出就获得出乎意料的欢迎，腾讯推出第一个砖石系列以及 QQ 币等支付产品，这是腾讯第一次从 QQ 用户直接获取收入，腾讯这个时候才开始意识到 QQ 强大的商业价值。在很长的时间里，腾讯陆续推出了网游、棋牌、QQ 空间（偷菜）、QQ 音乐、腾讯网门户网站、搜搜等产品，大多数的产品都获得了巨大的成功，腾讯过得是不亦乐乎，腾讯也基本上也形成了抄袭+微创新+对产品打磨这个套路，靠着这个套路，腾讯攻城掠地，到了2010年，腾讯已经成为了中国互联网的老大。腾讯自己过得很滋润，正所谓此消彼长，其他人过得就不如人意了，尤其是那些被腾讯抄袭并彻底打垮的公司。腾讯凭借自己 QQ 强大的用户基础不断抄袭（借鉴）其他公司的产品，并将其移植到自己的生态下，而被抄袭的企业后来基本上都跪了。</p>
<p>在当时，对于这位互联网老大，整个业界都是敢怒不敢言，当时很多创业公司在融资时，都会面对一个问题 —— 如果腾讯也做这个的话，怎么办？后来就出现了互联网史上比较出名的 3Q 大战。具体的孰对孰错，现在来说已经不重要了，不过这个事件显示了业界对腾讯的愤怒，腾讯几乎成了众矢之的。腾讯在这次危机中，面临着很大的舆论压力，后来腾讯开始进入半年的调整期，后来决定拥抱开放（互联网的基本精神）。腾讯确定了”连接一切”的战略，开始开放自己的平台，也开始承担自己应该承担的责任，陆续投资了很多的互联网公司，像大众点评、滴滴、微票儿等等，建立了一个很强大的生态（又称腾讯系），现在也只有阿里可以与之抗衡。可以说，如果没有 3Q 大战，就没有后来的腾讯，腾讯在移动互联网之争中，就很有可能与百度一样被阿里甩到后面。所以说，遇到危机，如果能从吸取教训，那么在下次机会到来时就有可能抓住机会。</p>
<p>还有一点要说的是，腾讯在发展的过程中，有两点非常值得学习：</p>
<ol>
<li>产品的打磨：腾讯应该第一个对产品这么重视的公司，毕竟腾讯的产品都是直接与用户打交道的，腾讯的产品文化，很值得学习；</li>
<li>公司内部的赛马机制：这个机制本来是为了鼓励一些中层领导的团队之间相互竞争，它最成功的产品就是微信，现在微信可以说是已经彻底融入到我们的生活中了。</li>
</ol>
<p>腾讯的成功，有很多的原因，最大的原因应该就是机遇 —— 合适的时间做了合适的事情，在一个激情澎湃的时代，与一群志同道合的人，做了一件不甘于平凡的事情。</p>
<hr>
<p>读书中记录的笔记</p>
<blockquote>
<p>中国互联网发生过三次“圈地运动”。第一次是在1999年前后，以新闻门户为基本业态，出现了新浪、搜狐和网易“三巨头”。2007年之后，出现了以应用平台为基本业态的大洗牌，门户们陷入“模式困境”，出现了成长乏力的态势，而百度、阿里巴巴和腾讯则分别从搜索、电子商务和即时通信工具三个方向出发，到2010年前后完成了反向超越，成为“新三巨头”，它们被合称为BAT。而从2012年开始，智能手机异军突起，互联网的用户重心从电脑端向移动端快速平移，由此发生了第三次“圈地运动”。—— Kindle Edition. loc. 151-156.</p>
</blockquote>
<p>Notes: 1) 互联网的三个重要时期,现在理论上应该处于第四个时期—人工智能。</p>
<blockquote>
<p>马化腾的七种武器”，它们包括： 第一种武器：产品极简主义。—— Kindle Edition. loc. 183-183.</p>
</blockquote>
<p>Notes: 1) 简单是美</p>
<blockquote>
<p>第二种武器：用户驱动战略。—— Kindle Edition. loc. 188-188.</p>
</blockquote>
<p>Notes: 1) 用户为核心。</p>
<blockquote>
<p>第三种武器：内部赛马机制。—— Kindle Edition. loc. 192-192.</p>
</blockquote>
<p>Notes: 1) 中层通过创新的产品可以实现超越。</p>
<blockquote>
<p>第四种武器：试错迭代策略。—— Kindle Edition. loc. 196-196.</p>
</blockquote>
<p>Notes: 1) 就如同小米提出的“快,极致,专注口碑”。</p>
<blockquote>
<p>第五种武器：生态养成模式。—— Kindle Edition. loc. 199-200.</p>
</blockquote>
<p>Notes: 1) 管理。</p>
<blockquote>
<p>第六种武器：资本整合能力。—— Kindle Edition. loc. 204-204.</p>
</blockquote>
<p>Notes: 1) 资本为公司生态服务。</p>
<blockquote>
<p>第七种武器：专注创业初心。—— Kindle Edition. loc. 207-207.</p>
</blockquote>
<p>Notes: 1) 勿忘初心</p>
<blockquote>
<p>在中国乃至全球的互联网史上，从1998年到1999年的两年间，是一个神秘的时期，错过了这一段，也就错过了一个世代。—— Kindle Edition. loc. 621-622.</p>
</blockquote>
<p>Notes: 1) 正好与前两天雄安新区设立形成对比,当年人创业激情非常饱满,对成功很渴望,而现在的人则 2) 正好与前两天雄安新区设立形成对比,当年人创业激情非常饱满,对成功很渴望,而现在的人则变了很多。</p>
<blockquote>
<p>OICQ在日后被业界评价为一个不可多得的“天才产品”，宣称其系统架构在用户发展至亿级时仍然能够支撑。唯有张志东清楚其中的艰辛，所谓的“天才”都是靠徐钢武、吴宵光以及后来无数工程师不断“重写”和优化的结果。“用户快速增长，性能瓶颈不断出现，为了不让用户失望，逼得团队不断优化性能，不断克服瓶颈。说到底，都是逼出来的结果。”张志东日后回忆至此，无限感喟。——<br> Kindle Edition. loc. 814-818.</p>
</blockquote>
<p>Notes: 1) 传言并不准确,系统后来还是zuole 很多优化的,技术是为业务而服务的。</p>
<blockquote>
<p>这就是创业到第20个月的腾讯：在走了一段弯路之后，它找到了核心产品，拥有了一支志同道合的团队和一个可爱的品牌形象，它还不知道该如何盈利，不过已经有人愿意为它的未来买单。—— Kindle Edition. loc. 1121-1122.</p>
</blockquote>
<p>Notes: 1) 腾讯的发展着实曲折,没有盈利模式的互联网企业在融资过程中只是会面对资金匮乏的过程情况,可是那么牛逼的互联网公司在初创时期又有几个能直接就找到盈利模式的。</p>
<blockquote>
<p>市场在不停地变化，企业所在行业的利润来源区也不停在变，企业必须随着利润区的变化而变换自己的企业设计和盈利模式。（亚德里安·斯莱沃斯基（美国管理学家），《发现利润区》）—— Kindle Edition. loc. 1125-1126.</p>
</blockquote>
<p>Notes: 1) 多观察其他领域的盈利模式,说不定就会找到一些借鉴之处。</p>
<blockquote>
<p>在腾讯的历史，乃至中国互联网史上，QQ秀都堪称一款革命性的收费产品，它可以被视为全球互联网产业的一次“东方式应用创新”。腾讯不是这一创新的发起者，可是它却凭借这一创新获得真正商业上的成功。而比商业利益更有价值的是，QQ秀让腾讯与它的亿级用户建立了情感上的归属关系。—— Kindle Edition. loc. 1422-1424.</p>
</blockquote>
<p>Notes: 1) 没想到qq 秀启到的作用竟然这么大,虽然不是腾讯首先提出的,但腾讯却将它利用得淋漓尽致。</p>
<blockquote>
<p>围绕“QQ人”，为他们提供各种服务是腾讯商业模式的本质。—— Kindle Edition. loc. 1461-1462.</p>
</blockquote>
<p>Notes: 1) 人们需要的聊天工具并不是只有聊天的功能。</p>
<blockquote>
<p>程苓峰敏锐地窥视出了腾讯多元化战略中的一个特征：紧盯市场动态，以最快的方式复制成功者模式，利用QQ用户优势进行后发超越。—— Kindle Edition. loc. 2030-2031.</p>
</blockquote>
<p>Notes: 1) 腾讯在开始形成的一个传统,这个传统也给腾讯未来带来了很多的负面问题。</p>
<blockquote>
<p>“模仿而不创新”“以天下为敌”和“拒绝开放”便成为腾讯的“三宗罪”。—— Kindle Edition. loc. 2043-2043.</p>
</blockquote>
<p>Notes: 1) 腾讯在最开始时,不断寻找自己的商业模式,一直在盈利而发愁,直到qq 秀的出现让腾讯意识到原来自己是可以通过用户导流量、从用户身上获取利润的。qq 秀也是腾讯借鉴的商业模式,让腾讯开始尝到了甜头,在后来腾讯慢慢形成了后发制人,由于自己强大的用户规模,明目张胆抄袭他人的商业模式,近而在一段时间甚至成了全民公敌。</p>
<blockquote>
<p>腾讯在此次事件中所遭遇到的舆论攻击更让马化腾一度意兴阑珊，在访谈中，我能够非常清楚地感受到他的困惑与郁闷，甚至在某些时刻，他的价值观都有点动摇。正如黑格尔所言，获得认可的欲望是人类生存最基本的愿望，马化腾一向自诩为产品经理，日夜所思皆是用户体验及得到他们的认可，然而，就是在这个层面上，他遭遇了致命的质疑。—— Kindle Edition. loc. 3676-3679.</p>
</blockquote>
<p>Notes: 1) 3q 大战之后,腾讯开始改变了自己的策略,从一个封闭、向全行业开战的平台变成了一个开放的平台,这也使得腾讯能够在下一波互联网战争中(移动互联网时代),没有失去自己的先机,反观百度,已经落后了很多。</p>
<blockquote>
<p>过去，我们总在思考什么是对的。但是现在，我们要更多地想一想什么是能被认同的。 （马化腾，《给全体员工的邮件》）—— Kindle Edition. loc. 3683-3684.<br>Notes: 1) 换句话说,对的东西并不一代被认同。</p>
<p>无论是年轻化方向、娱乐社交战略，还是场景化通信的打法，QQ在移动互联网时代的玩法渐渐清晰，与微信之间的关系也更加明朗。通过完善两大社交平台的生态，腾讯用两条腿走路的整体布局成为可能。—— Kindle Edition. loc. 4245-4247.</p>
</blockquote>
<p>Notes: 1) qq 是偏年轻化的一款产品,功能太多,对于成年人来说甚至有些臃肿,但微信就会简单很多,遵循互联网的极简主义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两周把&lt;a href=&quot;https://book.douban.com/subject/26929955/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《腾讯传》&lt;/a&gt;看完了，这本书去年出版的时候就想去看，但是一拖就拖到了现在，直到上周出去玩，回来的
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>欧洲简史</title>
    <link href="http://matt33.com/2017/04/04/read/"/>
    <id>http://matt33.com/2017/04/04/read/</id>
    <published>2017-04-04T08:11:14.000Z</published>
    <updated>2017-08-19T00:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近几周把这本<a href="https://book.douban.com/subject/5366248/" target="_blank" rel="external">你一定爱读的极简欧洲史</a>读完了，在阅读的过程中，感觉真的是很爽，不愧是豆瓣的8+分图书。读完本书，可以对欧洲的历史有一个大概的了解，即便是最后很多的细节记不清楚，但是整个历史过程还是会有一定的印象，能建立一个大概的时间线。读完本书，如果再有人问你<code>为什么现代科学、政治制度会诞生在西方，而不是一直领先的中国？</code>你应该也能说几个理由的。</p>
<p>全本主要分为两个部分，第一部分整体介绍了一下欧洲的大概历史进程，第二部分选取了其中的六个比较重要的方面进行介绍。纵观欧洲整个历史，大题可分为三个时代：古典时期、中世纪和近代，如下图所示。古典时期主要是古希腊和古罗马时代，而中世纪又称黑暗的中世纪，直到公元十五世纪开始文艺复兴之后，欧洲才逐渐从中世纪中走出来，进入到近代。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/573840-8f214b350ec6cd08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欧洲历史年表"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/573840-07a2b5d47fe3f014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宗教与西方"></p>
<p>从最开始看这本书，到这本书看完，大概花了三周时间，看书的时间依然在上下班的途中，都是利用一些零碎的时间去看的，到了现在书中能记住的东西已经不是很多，这里根据脑海中残留的大概印象对以上三个时代做一下总结：</p>
<ul>
<li>古典时期：那是个百花齐放的时代，科技、文化、政治都能达到了很大的高度，在西方人民的心中（特别是中世纪人民），那个时代简直可望而不可即，所以那个时期被称为古典时期。那个时代出现了苏格拉底、柏拉图、亚里士多德（古希腊三贤）等人，在天文上也提出了“地心说”的理论，古希腊在几何的贡献也是我们现代数学的基础，当年雅典也出现了很多的民主制度，后来的古罗马基本继承了古希腊的制度，进一步发扬了古希腊文化。在古罗马时代，出现了很多的宗教，可以说百家争鸣，后来的基督教在当时还是很小众的一个教派，直到后来古罗马帝国的君士坦丁堡大帝开始信奉基督教，导致了基督教开始走进古罗马的权力中心，开始影响欧洲历史之路。</li>
<li>中世纪：中世纪之所以被称为<strong>黑暗中世纪</strong>，完全是因为在那个时代，人们没有宗教信仰自由，只能信奉基督教，也就是天主教，其他的教派（新教、伊斯兰教等）都被称为异教；也没有读书自由（暂且这样说吧），很多古罗马时代书都被教皇保留下来，但教皇是为了通过这些著作也印证基督教的真实正确；也没有民主等等。当年人们为了死后进入天堂也是煞费苦心，教皇发放救赎劵，教众们就会去买，也不管教皇拿着这些钱作何用途（事实上是为了十字军东征）。说起这个时代的开始，就离不开日耳曼民族，当然现在的日尔曼民族已经不是当年的日尔曼民族，现在欧洲大部分的人应该都是当年日尔曼民族的后代，那个时代的日尔曼民族又叫做<strong>日尔曼蛮族</strong>，它们类似于现在的非洲部落，虽说都是日尔曼蛮族，但是却有多方的势力，并没有形成一个统一的组织，但就是这样一批人，把当年不可一世的古罗马帝国灭掉了（确切说应该是西罗马帝国），西罗马帝国被灭掉当然也有其自身衰落的原因。日尔曼蛮族虽然灭掉了西罗马帝国，但他们只是来抢东西，并没有统治这片土地的意思，而且他们最后居然保留了基督教，甚至很多人都开始慢慢信奉基督教。当时的西方虽然被很多封主、国王统治，但基督教却是一个非常统一的组织。可以说在当时君权和教皇各是一个权力终端，它们相互制约、相互牵制、相互斗争，有时候甚至是相互利用。有句话叫做有压迫就由反抗，后来马丁路德建立起新教学说就是对现任教皇的一个反抗，新教从个人的自由出发，很快就吸引了很多的民众，新教和天主教只是对《圣经》的不同解读。</li>
<li>近代：近代应该是从文艺复兴开始，文艺复兴实际上就是对古希腊罗马学术的发现和再发现，他们不希望一直接受一个被教会阉割的古典。在以前，教会虽然保留了很多古希腊罗马的学术，但是都是为了用来印证《圣经》、为教会而服务，但是现在，大家突然发现原来古希腊罗马的学术不是这样的，原来古典时期的学术、制度是那么发达，令当代人敬仰。不过随着文艺复兴的影响进一步加深，当代的思想得到很大的解放，一批如哥白尼、伽利略、牛顿等人的出现，让当时的人民觉得原来我们一点也不比古希腊罗马人笨、甚至还比他们更聪明，他们也发现原来古希腊罗马的学术并不一定全是正确的，于是各种科学开始迅速发展，为现代文明奠定基础。</li>
</ul>
<p>在本书的第二部分，重点从以下六个小的方面开始讲述欧洲历史的发展，这六个方面可以说是欧洲文明的重点组成，甚至可以说是现代欧洲文明的基石：</p>
<ol>
<li>争战一千年。从最开始的日尔曼蛮族入侵，欧洲在之后的一千年里，几乎是纷争不断，后来的穆斯林入侵、维京人入侵、十字军东征，不过这也激发了欧洲人爱冒险的血性，对后来的大航海时代也有一定的作用。</li>
<li>民主意识，这样开始的。欧洲文明给人类带来的一个重大财富就是——民主，民主最开始是诞生在古希腊，后来随着中世纪的到来，欧洲人民并没有实质意义上的民主，但也因为欧洲在罗马帝国之后就再也没有出现过一个统一的帝国，这才幸运地阻止了欧洲陷入东亚帝王专制的世界里。</li>
<li>有国王的民主，没国王的极权。这部分主要是指英国与欧洲大陆，英帝国有国王，但是因为新教（崇尚个人自由）和国会（对国王的选择起很大的作用）的缘故，使得英帝国率先走向君主立宪制，建立了民主的英帝国。反观欧洲大陆，有的地方却很极权，比如法国，最后导致了法国大革命，不过民主终究胜于极权。</li>
<li>皇帝和教皇到底谁大？欧洲有一个很特殊的现象，那就是它有两个很强大的权力系统，一个是教会，一个是政府，这两个冤家相互争斗、相互利用，都是为了各自的利益。只要皇帝并没有建立一个统一的帝国，皇帝终究是摆脱了教会的束缚，而教会也会为了自己的利益利用手中的权力来约束皇帝的权利，反而给民主提供了很好的土壤。</li>
<li>语言：从两种变几十种。欧洲的主要语言体系应该是两种：日尔曼语系和罗曼语系（拉丁语系）。</li>
<li>平民百姓的生活面貌。在工业革命之前，一千多年，欧洲85%以上的人口就是从事农业相关，这也是西方人见面经常会问天气的原因，因为天气会影响到大部分人的生活。</li>
</ol>
<p>读完本书，确实会对欧洲大概的历史有一个认识，但毕竟是欧洲简史，如果想了解欧洲历史的细节，这本书是远远不够的，但这本书会给你打开一个欧洲文明史的大门，非常推荐。</p>
<hr>
<p>下面是在读书过程中对一些自认为比较重要的内容，做的一些笔记。</p>
<blockquote>
<p>第二次的大侵略来自穆斯林，时为7世纪到8世纪，距离日耳曼蛮族入侵仅仅两百年。伊斯兰教始祖穆罕默德原为阿拉伯商人，得到神的天启后创立该教。他这支借由神助发展出来的宗教，与犹太教和基督教有紧密联系；穆斯林也承认耶稣和耶稣之前的先知们确实是先知，但深信穆罕默德是世上最后一位先知，能指引大家走向唯一真神安拉的怀抱。伊斯兰教比起基督教来说简单许多。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 800-804</p>
</blockquote>
<p>Notes: 1) 伊斯兰教发源</p>
<blockquote>
<p>国王，也就是先前的日耳曼战士首领，他将土地分发给自己的子弟兵，而这些下属必须提供国王打仗所需的战力作为回报，一个国家就建基于这样的关系上。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1112-1113</p>
</blockquote>
<p>Notes: 1) 君主处于弱势的开始,君主对于土地、税收不再直接掌控,而这些权力尽数被封主拿去。</p>
<blockquote>
<p>由于立足点薄弱，封建制度的君主必须征询国内权势人士的建言。他们没有一支自己能够全权控制的军队，也没有常态的征税制度或行政部门，因此，在做决定之前，他们会邀集重要人士，听取这些人的意见并征得同意才能拍板定案。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1143-1145</p>
</blockquote>
<p>Notes: 1) 间接地限制了国王的权力,这也是西方没有形成封建专制的原因。</p>
<blockquote>
<p>英国国会让自己成了宪政体制的一个常设单位。整个过程没有流一滴血，史称“光荣革命”。—— 约翰•赫斯特, 你一定爱读的极简欧洲史， loc. 1265-1266</p>
</blockquote>
<p>Notes: 1) 欧洲大陆在走向专制的过程中,英国并没有步入后尘,宗教在这过程中起到了很大的作用,英国此时已是新教的天下,国王想通过天主教达到自己的目的反而适得其反。</p>
<blockquote>
<p>新教教义从一开始便是以保障个人自由为出发点，因为它干犯教皇和主教的权威，提升了个人的意识和地位。在英国，它与自由的关系更是密不可分，因为英国的敌人——法国和西班牙的专制君主都是天主教徒，而那些试图架空议会的英国国王不是信奉天主教就是对天主教手软之辈。保存国会与保存新教信仰合而为一，成了殊途同归的新教志业。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1281-1285</p>
</blockquote>
<p>Notes: 1) 在西方,自从罗马帝国之后,宗教与政治就变得密不可分,而天主教更侧重于上层人的利益,甚至是专制,新教则是从个人出发,更侧重于个人的自由,限制了君主的权力,比较符合国会的利益,因此,英国甚至把新教写进权力法案,以保护国会的权力。(当然国会最开始代表的并不是普通民众的利益)。</p>
<blockquote>
<p>查理大帝建立的帝国消失了，教皇也失去了保护他的强人。有一段时间教皇得过且过，哪个地方王侯支持他，他就把谁加冕为王。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1435-1436</p>
</blockquote>
<p>Notes: 1) 教皇也逐渐成了政治的一部分,教皇也只是为了寻找一个保护伞。</p>
<blockquote>
<p>双方（皇帝和教皇）都承认对方的存在有其必要，争的只是彼此的相对权力。这是西罗马帝国一个非常重要的特色，也是它和东罗马帝国的分野所在。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1495-1496</p>
</blockquote>
<p>Notes: 1) 东罗马帝国的教皇则完全由皇帝指定。</p>
<blockquote>
<p>拉丁语，跟罗马帝国的概念一样，已经气若游丝很久了。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1748-1749</p>
</blockquote>
<p>Notes: 1) 拉丁语跟罗马帝国一样,可以说是一直存在着,对后世影响深远。</p>
<blockquote>
<p>所有的人都老是为收成担心害怕。谈天气不是为了没话找话说，而是一群人在忧心自己的命运。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1810-1811</p>
</blockquote>
<p>Notes: 1) 西方见面聊天气原来是这个原因,有很多的历史背景,在工业革命之前西方基本上85%以上从事农业相关,所以大部分人都对天气非常重视。</p>
<blockquote>
<p>在欧洲，当国王的总是强敌环伺，而中国皇帝的君权无人能比，这是他们拥有的优势——或者说是陷阱。欧洲国家之间相互为敌，是它们向海外扩张的一股推动力量。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1949-1950</p>
</blockquote>
<p>Notes: 1) 中国皇帝权力过大,而西方的国王从未有如此之强权。</p>
<blockquote>
<p>欧洲的历史演进泰半从奠基的这一刻起便已注定。政府对人民毫无掌控能力，它们必须殚思竭虑，才可能争取到人民的服从。它们若想扩张势力，就得提供良好的政府——也就是维护治安作为回报，它们不能像亚洲和中东不计其数的帝国及王国那样，光靠收税机制和进贡就能运转。 数百年来，这些国王最大的威胁是他们最有权势的下属——土地贵族阶级。这些权臣最后终于俯首，但因为已在自己的领土上雄霸够久，早就为自己也为他们土地上的人民争取到私有财产的保障。“不是所有的东西都属于国王”，这是欧洲自由和繁荣的基石。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1956-1962</p>
</blockquote>
<p>Notes: 1) 这是西方与东方政府的主要区别,没有东方这种“普天之下,莫非王臣,普天之地,莫非王土”思想,政府对人民并没有绝对的控制力,人民有自己的私有财产,这也是公民限制政府权力的基础。</p>
<blockquote>
<p>在中国，权力是极其明确地集中在皇帝手里，以儒家为尊的精英文化对君权统治也支持有加。无论是个人修为或待人处世，中国人莫不以儒家思想为圭臬，它已深深扎根于整个社会和国家。统治者不管有没有合法性都得熟读四书五经，而你得通过儒家经典考试才能当上国家官员。 反观欧洲，权力不但分散，精英文化也是个大拼盘，与君权统治之间的系带并不牢固。中国人非常聪明，可是他们的聪明从来不会脱轨失控，纵有奇思异想，基本上都不曾造成纷扰。欧洲社会的开放则是源远流长。<br>近代欧洲在经济上爆发力十足，智识生活百家争鸣，皆是基于一个事实：不管是好是坏，从来没有一个单一强权掌控过它、形塑过它。它多元的历史遗产因此能被充分发掘、延伸；希腊的数学观念在科学革命时期得到实现，从而建立起科技创新的一个新基础。—— 约翰•赫斯特, 你一定爱读的极简欧洲史, loc. 1991-1997</p>
</blockquote>
<p>Notes: 1) 分析了欧洲与中国的一个巨大区别</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几周把这本&lt;a href=&quot;https://book.douban.com/subject/5366248/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;你一定爱读的极简欧洲史&lt;/a&gt;读完了，在阅读的过程中，感觉真的是很爽，不愧是豆瓣的8+分图书。读
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Storm 对 0.10.x 版 Kafka 支持解析</title>
    <link href="http://matt33.com/2017/03/17/storm-kafka-0-10-1/"/>
    <id>http://matt33.com/2017/03/17/storm-kafka-0-10-1/</id>
    <published>2017-03-17T14:24:31.000Z</published>
    <updated>2017-07-23T07:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于 0.10.x 版 Kafka 与 0.8.x 版有很大的变化，这种变化对下游 Storm 有非常大的影响，0.10.x 版的 Kafka 不但增加了权限管理的功能，而且还将 simple 和 high consumer 的 offsets 进行统一管理，也就意味着在 0.8.x 中 Storm 需要去负责管理 offsets，而在 0.10.x 中，Storm 不需要关心 consumer 的 offsets 的问题，这对 KafkaSpout 的设计有很大的影响，本文就是对 <code>Storm 对 0.10.x 版 Kafka 支持的实现</code>部分的解析。</p>
<h1 id="0-10-x-版-KafkaSpout-的实现"><a href="#0-10-x-版-KafkaSpout-的实现" class="headerlink" title="0.10.x 版 KafkaSpout 的实现"></a>0.10.x 版 KafkaSpout 的实现</h1><p>社区对新版 Kafka 的支持，总体分为两种情况：</p>
<ol>
<li>一种是选择自动 commit 机制；</li>
<li>另一种是非自动 commit，就是将 commit 的权利交与 Storm 来控制。</li>
</ol>
<p>下面分别对这两种情况进行分析。</p>
<p>Kafka Consumer 的一些配置会对 Storm 的性能很大影响，下面的三个参数的设置对其性能的影响最大（默认值是根据<a href="https://hortonworks.com/blog/microbenchmarking-storm-1-0-performance/" target="_blank" rel="external">MICROBENCHMARKING APACHE STORM 1.0 PERFORMANCE</a>测试得到）：</p>
<ul>
<li><code>fetch.min.bytes</code>：默认值 200；</li>
<li><code>fetch.max.wait.ms</code>：默认值 30000（30s）；</li>
<li><code>Kafka Consumer instance poll timeout</code>, 它可以在通过 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java" target="_blank" rel="external">KafkaSpoutConfig</a> 的方法 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L180-L184" target="_blank" rel="external">setPollTimeoutMs</a> 来配置，默认值是 10000000；</li>
</ul>
<h2 id="自动-commit-模式"><a href="#自动-commit-模式" class="headerlink" title="自动 commit 模式"></a>自动 commit 模式</h2><p>自动 commit 模式就是 commit 的时机由 Consumer 来控制，本质上是异步 commit，当定时达到时，就进行 commit。而 Storm 端并没有进行任何记录，也就是这部分的容错完全由 Consumer 端来控制，而 Consumer 并不会关心数据的处理成功与否，只关心数据是否 commit，如果未 commit，就会重新发送数据，那么就有可能导致下面这个后果：</p>
<h3 id="造成那些已经-commit、但-Storm-端处理失败的数据丢失"><a href="#造成那些已经-commit、但-Storm-端处理失败的数据丢失" class="headerlink" title="造成那些已经 commit、但 Storm 端处理失败的数据丢失"></a>造成那些已经 commit、但 Storm 端处理失败的数据丢失</h3><p><strong>丢失的原因</strong></p>
<p>一些数据发送到 Spout 之后，恰好 commit 的定时到达，进行了 commit，但是这中间有某条或者几条数据处理失败，这就是说，这几条处理失败的数据已经进行 commit 了，Kafka 端也就不会重新进行发送。</p>
<p>可能出现的这种后果也确定了自动 commit 模式不能满足我们的需求，为了保证数据不丢，需要数据在 Storm 中 ack 之后才能被 commit，因此，commit 还是应该由 Storm 端来进行控制，才能保证数据被正确处理。</p>
<h2 id="非自动-commit-模式"><a href="#非自动-commit-模式" class="headerlink" title="非自动 commit 模式"></a>非自动 commit 模式</h2><p>当选用非自动的 commit 机制（实际上就是使用 Consumer 的同步 commit 机制）时，需要手动去设置 commit 的参数，有以下两项需要设置：</p>
<ul>
<li><code>offset.commit.period.ms</code>：设置 spout 多久向 Kafka commit一次，在 KafkaSpoutConfig 的 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L189-L193" target="_blank" rel="external">setOffsetCommitPeriodMs</a> 中配置；</li>
<li><code>max.uncommitted.offsets</code>：控制在下一次拉取数据之前最多可以有多少数据在等待 commit，在 KafkaSpoutConfig 的 <a href="https://github.com/apache/storm/blob/1.0.x-branch/external/storm-kafka-client/src/main/java/org/apache/storm/kafka/spout/KafkaSpoutConfig.java#L211-L217" target="_blank" rel="external">setMaxUncommittedOffsets</a> 中配置；</li>
</ul>
<h3 id="spout-的处理过程"><a href="#spout-的处理过程" class="headerlink" title="spout 的处理过程"></a>spout 的处理过程</h3><p>关于 Kafka 的几个 offset 的概念，可以参考<a href="http://matt33.com/2017/01/16/kafka-group/#offset-那些事"> offset的一些相关概念</a></p>
<p>KafkaSpout 的处理过程主要是在 <code>nextTuple()</code> 方法，其处理过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialized) &#123;</div><div class="line">        <span class="keyword">if</span> (commit()) &#123;<span class="comment">// Step1 非自动 commit,并且定时达到</span></div><div class="line">            commitOffsetsForAckedTuples();<span class="comment">// 对所有已经 ack 的 msgs 进行 commit</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (poll()) &#123;<span class="comment">//Step2 拉取的数据都已经发送,并且未 commit 的消息数小于设置的最大 uncommit 数</span></div><div class="line">            setWaitingToEmit(pollKafkaBroker());</div><div class="line">            <span class="comment">//将拉取的所有 record 都放到 waitingToEmit 集合中,可能会重复拉取数据（由于一些 msg 需要重试，通过修改 Last Committed Offset 的值来实现的）</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (waitingToEmit()) &#123;<span class="comment">//Step3 waitingToEmit 中还有数据</span></div><div class="line">            emit();<span class="comment">//发送数据,但会跳过已经 ack 或者已经发送的消息</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        LOG.debug(<span class="string">"Spout not initialized. Not sending tuples until initialization completes"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面主要分为三步：</p>
<ol>
<li>如果是非自动 commit，并且 commit 定时达到，那么就将所有已经 ack 的数据（<strong>这些数据的 offset 必须是连续的</strong>，不连续的数据不会进行 commit）进行 commit；</li>
<li>如果拉取的数据都已经发送，并且未 commit 的消息数（记录在 <code>numUncommittedOffsets</code> 中）小于设置的最大 uncommit 数，那么就根据更新后的 offset （将 offset 重置到需要重试的 msg 的最小 offset，这样该 offset 后面的 msg 还是会被重新拉取）拉取数据，并将拉取到的数据存储到 <code>waitingToEmit</code> 集合中；</li>
<li>如果 <code>waitingToEmit</code> 集合中还有数据，就发送数据，但在发送数据的过程中，会进行判断，只发送没有 ack 的数据。</li>
</ol>
<h3 id="KafkaSpout-如何进行容错"><a href="#KafkaSpout-如何进行容错" class="headerlink" title="KafkaSpout 如何进行容错"></a>KafkaSpout 如何进行容错</h3><p>举个示例，如下图所示</p>
<p><img src="/images/kafka/KafkaSpout-error.png" alt="consumer offset"></p>
<ol>
<li>图1表示一个 <code>nextTuple()</code> 循环结束之后，offset 为14那条数据处理失败，而offset 为15-18的数据处理成功；</li>
<li>图2表示在下次循环 Step 1 结束之后、Step 2 开始之前，Consumer 会将 the last committed offset 重置到 offset 为14的位置。</li>
</ol>
<p>也就是说从 offset 为14开始，后面的数据会重新发送。</p>
<p><strong>有人可能会问，那样的话会不会造成数据重复发送？</strong></p>
<p>Storm 是如何解决这个问题的呢？答案就是 Storm 会用一个 map 记录已经 ack 的数据（<code>acked</code>），Storm 在进行 commit 的时候也是根据这个 map 的数据进行 commit 的，不过 commit 数据的 offset 必须是连续的，如上图所示，只能将 offset 为11-13的数据 commit，而15-18的数据由于 offset 为14的数据未处理成功而不能 commit。offset 为11-13的数据在 commit 成功后会从 map 中移除，而 offset 为15-18的数据依然在 map 中，Storm 在将从 Kafka 拉取的数据加入到 <code>waitingToEmit</code> 集合时后，进行 emit 数据时，会先检测该数据是否存在 <code>acked</code> 中，如果存在的话，就证明该条数据已经处理过了，不会在进行发送。</p>
<p>这里有几点需要注意的：</p>
<ol>
<li>对已经 ack 的 msg 进行 commit 时，所 commit 的 msg 的 offset 必须是<strong>连续</strong>的（该 msg 存储在一个 TreeMap 中，按 offset 排序），断续的数据会暂时接着保存在集合中，不会进行 commit，如果出现断续，那就证明中间有数据处理失败，需要重新处理；</li>
<li>storm 处理 failed 的 msg，会保存到一个专门的集合中，在每次拉取数据时（是拉取数据，不是发送数据，发送数据时会检测该数据是否已经成功处理），会遍历该集合中包含的所有 TopicPartiion，获取该 partition 的 Last Committed Offset；</li>
</ol>
<p>这样设计有一个副作用就是：如果有一个 msg 一直不成功，就会导致 KafkaSpout 因为这一条数据的影响而不断地重复拉取这批数据，造成整个拓扑卡在这里。</p>
<h3 id="Kafka-Rebalance-的影响"><a href="#Kafka-Rebalance-的影响" class="headerlink" title="Kafka Rebalance 的影响"></a>Kafka Rebalance 的影响</h3><p>Kafka Rebalance 可以参考<a href="http://matt33.com/2017/01/16/kafka-group/#Consumer-Rebalance">Consumer Rebalance</a>.</p>
<p>KafkaSpout 实现了一个内部类用来监控 Group Rebalance 的情况，实现了两个回调函数，一旦发现 group 的状态变为 <code>preparingRabalance</code> 之后</p>
<ol>
<li><code>onPartitionsRevoked</code> 这个方法会在 Consumer 停止拉取数据之后、group 进行 rebalance 操作之前调用，作用是对已经 ack 的 msg 进行 commit；</li>
<li><code>onPartitionsAssigned</code> 这个方法 group 已经进行 reassignment 之后，开始拉取数据之前调用，作用是清理内存中不属于这个线程的 msg、获取 partition 的 last committed offset。</li>
</ol>
<h3 id="潜在的风险点"><a href="#潜在的风险点" class="headerlink" title="潜在的风险点"></a>潜在的风险点</h3><p>这部分还是有可能导致数据重复发送的，设想下面一种情况：</p>
<p>如果之前由于一个条消息处理失败（Partition 1），造成部分数据没有 commit 成功，在进行 rebalance 后，恰好 Partition 1 被分配到其他 spout 线程时，那么当前的 spout 就会关于 Partition 1 的相关数据删除掉，导致部分已经 commit 成功的数据（记录在 acked 中）被删除，而另外的 spout 就会重新拉取这部分数据进行处理，那么就会导致这部分已经成功处理的数据<strong>重复处理</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 0.10.x 版 Kafka 与 0.8.x 版有很大的变化，这种变化对下游 Storm 有非常大的影响，0.10.x 版的 Kafka 不但增加了权限管理的功能，而且还将 simple 和 high consumer 的 offsets 进行统一管理，也就意味着在 
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
      <category term="storm" scheme="http://matt33.com/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 之 Group 状态变化分析及 Rebalance 过程</title>
    <link href="http://matt33.com/2017/01/16/kafka-group/"/>
    <id>http://matt33.com/2017/01/16/kafka-group/</id>
    <published>2017-01-16T11:07:32.000Z</published>
    <updated>2017-07-23T07:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间看一下 Kafka 的部分源码（0.10.1.0 版），对一些地方做了一些相应的总结。本文主要就 Kafka Group 方面的内容做一下详细的讲述，重点讲述 Consumer Client 如何进行初始化、Server 端对应的 Consumer Group 状态如何进行变化以及对一些 Kafka 的新设计（与旧版不同之处）简单介绍一下。</p>
<h1 id="Group-状态机"><a href="#Group-状态机" class="headerlink" title="Group 状态机"></a>Group 状态机</h1><p>在 0.9.0.0 之后的 Kafka，出现了几个新变动，一个是在 Server 端增加了 GroupCoordinator 这个角色，另一个较大的变动是将 topic 的 offset 信息由之前存储在 zookeeper 上改为存储到一个特殊的 topic 中（<code>__consumer_offsets</code>）。</p>
<h2 id="offset-那些事"><a href="#offset-那些事" class="headerlink" title="offset 那些事"></a>offset 那些事</h2><p>在 Kafka 中，无论是写入 topic，还是从 topic 读取数据，都免不了与 offset 打交道，关于 Kafka 的 offset 主要有以下几个概念，如下图。</p>
<p><img src="/images/kafka/consumer-figure2.png" alt="consumer offset"></p>
<p>其中，Last Committed Offset 和 Current Position 是与 Consumer Client 有关，High Watermark 和 Log End Offset 与 Producer Client 数据写入和 replica 之间的数据同步有关。</p>
<ul>
<li>Last Committed Offset：这是 group 最新一次 commit 的 offset，表示这个 group 已经把 Last Committed Offset 之前的数据都消费成功了；</li>
<li>Current Position：group 当前消费数据的 offset，也就是说，Last Committed Offset 到 Current Position 之间的数据已经拉取成功，可能正在处理，但是还未 commit；</li>
<li>Log End Offset：Producer 写入到 Kafka 中的最新一条数据的 offset；</li>
<li>High Watermark：已经成功备份到其他 replicas 中的最新一条数据的 offset，也就是说 Log End Offset 与 High Watermark 之间的数据已经写入到该 partition 的 leader 中，但是还未成功备份到其他的 replicas 中，这部分数据被认为是不安全的，是不允许 Consumer 消费的。</li>
</ul>
<h2 id="Topic-consumer-offsets"><a href="#Topic-consumer-offsets" class="headerlink" title="Topic __consumer_offsets"></a>Topic <code>__consumer_offsets</code></h2><p><code>__consumer_offsets</code> 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有50个 partition，每个 partition 三副本，而具体 group 的消费情况要存储到哪一个 partition 上，是根据 <code>abs(GroupId.hashCode()) % NumPartitions</code> 来计算（其中，<code>NumPartitions</code> 是<code>__consumer_offsets</code> 的 partition 数，默认是50个）的。</p>
<h2 id="GroupCoordinator"><a href="#GroupCoordinator" class="headerlink" title="GroupCoordinator"></a>GroupCoordinator</h2><p>根据上面所述，一个具体的 group，是根据其 group 名进行 hash 并计算得到其具对应的 partition 值，该 partition leader 所在 Broker 即为该 Group 所对应的 GroupCoordinator，GroupCoordinator 会存储与该 group 相关的所有的 Meta 信息。</p>
<p>在 Broker 启动时，每个 Broker 都会启动一个 GroupCoordinator 服务，但只有 <code>__consumer_offsets</code> 的 partition 的 leader 才会直接与 Consumer Client 进行交互，也就是其 group 的 GroupCoordinator，其他的 GroupCoordinator 只是作为备份，一旦作为 leader 的 Broker 挂掉之后及时进行替代。</p>
<h2 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h2><p>Server 端，Consumer 的 Group 共定义了五个状态</p>
<ul>
<li>Empty：Group 没有任何成员，如果所有的 offsets 都过期的话就会变成 Dead，一般当 Group 新创建时是这个状态，也有可能这个 Group 仅仅用于 offset commits 并没有任何成员（Group has no more members, but lingers until all offsets have expired. This state also represents groups which use Kafka only for offset commits and have no members.）；</li>
<li>PreparingRebalance：Group 正在准备进行 Rebalance（Group is preparing to rebalance）；</li>
<li>AwaitingSync：Group 正在等待来 group leader 的 assignment（Group is awaiting state assignment from the leader）；</li>
<li>Stable：稳定的状态（Group is stable）；</li>
<li>Dead：Group 内已经没有成员，并且它的 Meta 已经被移除（Group has no more members and its metadata is being removed）。</li>
</ul>
<p>其各个状态的定义及转换都在 <a href="https://github.com/apache/kafka/blob/0.10.1/core/src/main/scala/kafka/coordinator/GroupMetadata.scala" target="_blank" rel="external">GroupMetadata</a> 中定义，根据状态转移的条件和转移的结果做一个状态转移图如下所示</p>
<p><img src="/images/kafka/group.png" alt="group-state"></p>
<p>各个状态转化的情况，只有有对应箭头才能进行转移，比如 Empty 到 PreparingRebalance 是可以转移的，而 Dead 到 PreparingRebalance 是不可以的。后面会根据一个 Consumer Client 启动的过程，讲述一下其 Group 状态变化情况。</p>
<h1 id="Consumer-初始化"><a href="#Consumer-初始化" class="headerlink" title="Consumer 初始化"></a>Consumer 初始化</h1><p>Server 端 Group 状态的变化，其实更多的时候是由 Client 端触发的，一个 group 在最初初始化的过程总其实就是该 Group 第一个 Consumer Client 初始化的过程。</p>
<h2 id="Consumer-poll-过程解析"><a href="#Consumer-poll-过程解析" class="headerlink" title="Consumer poll 过程解析"></a>Consumer poll 过程解析</h2><p>对 Consumer 的初始化，正如 <a href="http://matt33.com/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍</a> 这篇文章所述，Consumer 的核心逻辑部分主要在其 poll 模型。而其源码的实现上，主要的逻辑实现也是在 <code>pollOnce</code> 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 一次 poll 过程</span></div><div class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(<span class="keyword">long</span> timeout) &#123;</div><div class="line">    coordinator.poll(time.milliseconds());<span class="comment">//NOTE： 获取 GroupCoordinator 并连接、加入 Group、Group 进行 rebalance 并获取 assignment</span></div><div class="line"></div><div class="line">    <span class="comment">// fetch positions if we have partitions we're subscribed to that we</span></div><div class="line">    <span class="comment">// don't know the offset for</span></div><div class="line">    <span class="keyword">if</span> (!subscriptions.hasAllFetchPositions())<span class="comment">//<span class="doctag">NOTE:</span> 更新 offset</span></div><div class="line">        updateFetchPositions(<span class="keyword">this</span>.subscriptions.missingFetchPositions());</div><div class="line"></div><div class="line">    <span class="comment">// if data is available already, return it immediately</span></div><div class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</div><div class="line">    <span class="comment">//NOTE： 根据最大限制拉取数据（按 partition 拉取,这个 partition 数据拉取完之后,拉取下一个 partition）</span></div><div class="line">    <span class="keyword">if</span> (!records.isEmpty())</div><div class="line">        <span class="keyword">return</span> records;</div><div class="line">    <span class="comment">//<span class="doctag">NOTE:</span> 说明上次 fetch 到是的数据已经全部拉取了,需要再次发送 fetch 请求,从 broker 拉取数据</span></div><div class="line"></div><div class="line">    <span class="comment">// send any new fetches (won't resend pending fetches)</span></div><div class="line">    fetcher.sendFetches();<span class="comment">//<span class="doctag">NOTE:</span> 向订阅的所有 partition 发送 fetch 请求,会从多个 partition 拉取数据</span></div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = time.milliseconds();</div><div class="line">    <span class="keyword">long</span> pollTimeout = Math.min(coordinator.timeToNextPoll(now), timeout);</div><div class="line"></div><div class="line">    client.poll(pollTimeout, now, <span class="keyword">new</span> PollCondition() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// since a fetch might be completed by the background thread, we need this poll condition</span></div><div class="line">            <span class="comment">// to ensure that we do not block unnecessarily in poll()</span></div><div class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// after the long poll, we should check whether the group needs to rebalance</span></div><div class="line">    <span class="comment">// prior to returning data so that the group can stabilize faster</span></div><div class="line">    <span class="keyword">if</span> (coordinator.needRejoin())</div><div class="line">        <span class="keyword">return</span> Collections.emptyMap();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fetcher.fetchedRecords();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与 Server 进行交互，尤其初始化 Group 这一部分，主要是在 <code>coordinator.poll()</code> 方法，源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    invokeCompletedOffsetCommitCallbacks();<span class="comment">//<span class="doctag">NOTE:</span> 触发回调函数</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned() &amp;&amp; coordinatorUnknown()) &#123;</div><div class="line">        <span class="comment">//<span class="doctag">NOTE:</span> 通过 subscribe() 方法订阅 topic,并且 coordinator 未知</span></div><div class="line">        ensureCoordinatorReady();<span class="comment">//<span class="doctag">NOTE:</span> 获取 GroupCoordinator 地址,并且建立连接</span></div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needRejoin()) &#123;<span class="comment">//<span class="doctag">NOTE:</span> 判断是否需要重新加入 group,如果订阅的 partition 变化或则分配的 partition 变化时,需要 rejoin</span></div><div class="line">        <span class="comment">// due to a race condition between the initial metadata fetch and the initial rebalance,</span></div><div class="line">        <span class="comment">// we need to ensure that the metadata is fresh before joining initially. This ensures</span></div><div class="line">        <span class="comment">// that we have matched the pattern against the cluster's topics at least once before joining.</span></div><div class="line">        <span class="keyword">if</span> (subscriptions.hasPatternSubscription())</div><div class="line">            client.ensureFreshMetadata();</div><div class="line"></div><div class="line">        ensureActiveGroup();</div><div class="line">        <span class="comment">//<span class="doctag">NOTE:</span> 确保 group 是 active;加入 group;分配订阅的 partition</span></div><div class="line">        now = time.milliseconds();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pollHeartbeat(now);<span class="comment">//<span class="doctag">NOTE:</span> 检查心跳线程运行是否正常,如果心跳线程失败,则抛出异常,反之更新 poll 调用的时间</span></div><div class="line">    maybeAutoCommitOffsetsAsync(now);<span class="comment">//<span class="doctag">NOTE:</span> 自动 commit 时,当定时达到时,进行自动 commit</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ensureCoordinatorReady()</code> 方法是获取该 group 对应的 GroupCoordinator 地址，并建立连接，然后再进行判断，如果当前的这个 Consumer Client 需要加入一个 group，将进行以下操作（向 Server 端发送 join-group 请求以加入 group，然后再发送 sync-group 请求，获取 client 的 assignment）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">NOTE:</span> 确保 Group 是 active,并且加入该 group</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureActiveGroup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// always ensure that the coordinator is ready because we may have been disconnected</span></div><div class="line">    <span class="comment">// when sending heartbeats and does not necessarily require us to rejoin the group.</span></div><div class="line">    ensureCoordinatorReady();<span class="comment">//<span class="doctag">NOTE:</span> 确保 GroupCoordinator 已经连接</span></div><div class="line">    startHeartbeatThreadIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 启动心跳发送线程（并不一定发送心跳,满足条件后才会发送心跳）</span></div><div class="line">    joinGroupIfNeeded();<span class="comment">//<span class="doctag">NOTE:</span> 发送 JoinGroup 请求,并对返回的信息进行处理，还包括了发送 sync-group 请求并进行相应处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Consumer-初始化时-group-状态变化"><a href="#Consumer-初始化时-group-状态变化" class="headerlink" title="Consumer 初始化时 group 状态变化"></a>Consumer 初始化时 group 状态变化</h2><p>这里详述一下 Client 进行以上操作时，Server 端 Group 状态的变化情况。当 Consumer Client 首次进行拉取数据，如果该其所属 Group 并不存在时，Group 的状态变化过程如下：</p>
<ol>
<li>Consumer Client 发送 join-group 请求，如果 Group 不存在，创建该 Group，Group 的状态为 <strong>Empty</strong>；</li>
<li>由于 Group 的 member 为空，将该 member 加入到 Group 中，并将当前 member （client）设置为 Group 的 leader，进行 rebalance 操作，Group 的状态变为 <strong>preparingRebalance</strong>，等待 <code>rebalance.timeout.ms</code> 之后（为了等待其他 member 重新发送 join-group，如果 Group 的状态变为 <code>preparingRebalance</code>，Consumer Client 在进行 poll 操作时，<code>needRejoin()</code> 方法结果就会返回 true，也就意味着当前 Consumer Client 需要重新加入 Group），Group 的 member 更新已经完成，此时 Group 的状态变为 <strong>AwaitingSync</strong>，并向 Group 的所有 member 返回 join-group 响应；</li>
<li>client 在收到 join-group 结果之后，如果发现自己的角色是 Group 的 leader，就进行 assignment，该 leader 将 assignment 的结果通过 sync-group 请求发送给 GroupCoordinator，而 follower 也会向 GroupCoordinator 发送一个 sync-group 请求（只不过对应的字段为空）；</li>
<li>当 GroupCoordinator 收到这个 Group leader 的请求之后，获取 assignment 的结果，将各个 member 对应的 assignment 发送给各个 member，而如果该 Client 是 follower 的话就不做任何处理，此时 group 的状态变为 <strong>Stable</strong>（也就是说，只有当收到的 Leader 的请求之后，才会向所有 member 返回 sync-group 的结果，这个是只发送一次的，由 leader 请求来触发）。</li>
</ol>
<h2 id="Consumer-Rebalance"><a href="#Consumer-Rebalance" class="headerlink" title="Consumer Rebalance"></a>Consumer Rebalance</h2><p>根据上图，当 group 在 Empty、AwaitSync 或 Stable 状态时，group 可能会进行 rebalance；<br>rebalance 的过程就是：等待所有 member 发送 join-group（上述过程的第2步），然后设置 Group 的 leader，进行 reassignment，各个 client 发送 sync-group 来同步 server 的 assignment 结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间看一下 Kafka 的部分源码（0.10.1.0 版），对一些地方做了一些相应的总结。本文主要就 Kafka Group 方面的内容做一下详细的讲述，重点讲述 Consumer Client 如何进行初始化、Server 端对应的 Consumer Group 状态
    
    </summary>
    
      <category term="技术" scheme="http://matt33.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://matt33.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>别人向上，我们却在向下</title>
    <link href="http://matt33.com/2017/01/08/book/"/>
    <id>http://matt33.com/2017/01/08/book/</id>
    <published>2017-01-08T08:11:14.000Z</published>
    <updated>2017-01-08T15:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>花了两周多的时间把钱穆老先生这部神作读完了，读完之后的感觉是，书中有太多的观点让我有醍醐灌顶之感，钱老读史思考的深度远非常人所及，这本书非常值得拜读，豆瓣上也同样给出了9分以上评价，真的名不虚传（<a href="https://book.douban.com/subject/11229072/" target="_blank" rel="external">《中国历代政治得失》</a>）。因为这本书并不是一气看完，大部分是在上下班的班车上看的，每天看一部分，持续半个月之后才看完，所以书中一些感觉很不错的观点到现在可能已经忘了一部分，现在回忆起整本书，大概有三点让我印象非常深刻，下面也会就这三点讲述一下。</p>
<p>第一点印象最深的地方当然是<strong>制度</strong>这一部分了，全文几乎都是在围绕着历代的政治制度而讲述。好的制度可以让这个国家更简单、更高效地运转，中国自古有句俗话，叫做”打天下容易，坐天下难”，在打天下的时候，少则几年、多则十几年就能打下天下。但随着队伍、领地的扩大，很多问题会暴露出来，由于之前是战时，这些问题可以暂时不管，而一旦国家归于统一、社会稳定下来之后，这些问题就不能不管了，如何为政府选取人才、如何指定合理的徒土地政策、赋役政策以及军队政策等，这些问题哪一个处理不好，都可能会导致功亏一篑，所以说坐天下难。但是难也得干下去，正所谓在其位谋其政，历代政府都使出自己的浑身解数，制定了一套政策，让这个庞大的国家开始缓慢地运转，而有些政策因其非常重要可能会以明文记载作为制度来保证政策高效地运行，制度一旦形成，甚至就如信仰一般，无人敢违逆。每个朝代在开始时期，都会指定一套保证政府运转的制度（而有的朝代却攻于权术，想着各种手段维护自己的统治，而不是尽一个政府的职责），而这些制度一旦形成，随着发展，到后期可能会变得漏洞百出而成为一些利息集团的保护伞，正所谓此一时彼一时，时代在发展，历史上也没有一套制度可以高效地运作几千年或者几百年而不离其初心。而且一旦利息集团形成，后世的知识分子又如何去改变呢？有的知识分子虽然看到这些弊端，如王安石，他同样也身居高危开始变法，也有了皇帝的支持，可是最后依然没有成功，中国人老是讲一句”祖宗之法不能改”。这种观念反而束缚了后世，如果制度不用变，后世还要政治家干什么？这也导致一个朝代兴起之后，后来因慌于人事而逐渐走向下坡路。朝代初兴之时，一般会出现很多人才，也会有圣明的皇帝，这种情况下，一些制度是可以按照其初心正常运作，而几十年或者百年之后，如果人事不给力，谁来保证？多少朝代由于这而毁，这也就突出一个好制度的重要性。制度，名义上一种规章制度，是大家共同遵守的信仰，也是约束大家的法则，但制度又不能一成不变，中国有时候就非常认死理，制度竟然可以原封不动运行几百年，这到后面怎么可能不出问题？这时候如果说中国没有法制观念反而不合适，我们反观一下西方人，他们的制度或法律其实是不在不断变化的、或者是进入了一个不断完善的轨道，西方的一些政府人员是是由人民选举出来，所以必然会代表多数人的利益，要不然下次肯定会被选下去，所以他们的制度或者法律也是会必然代表多数人的利益，而多数人的利益在发展的过程中是在不断变化的、而不是一成不变的，这也是它们制度能够自我完善的一个原因。而历史中的我们，就很难做到这一点，如果皇帝大臣是圣人君子还好，如果不是，受苦的只能是老百姓，这就说明，我们虽然有制度，但是并没有好的制度来保证这个国家的长久运转。</p>
<p>第二点说一下利益集团，或者是权力集团，钱老提出的这点观点还是很令我感到新奇的。西方社会刚开始的权力是把握在教会手中，后来又到了贵族手中，从来没有开放给全社会，这也是西方民众对主权、对权力的非常看重的原因，而我们则不一样，可以说从秦朝开始权力就已经开放给全社会或者很大一部分开放给全社会了，除了皇室，其他的职位到后来已经没有世袭，只要你有能力有才华而且又能证明自己，即使你出身低贱也能走向巅峰，如商鞅、韩信等。后来到了唐朝之后，就开始形成了科举制度，读书人科举成功即可入朝为官，可以说从此之后，中国社会的权力集团就是这些知识分子，他们才是保证这个国家运转的核心。虽说中国是皇权社会，但是皇帝只是一个人，不可能管理整个国家，皇帝的背后必然会有一群体支持着皇帝，帮着皇帝去管理整个国家。有了科举制度之后，整个国家的运转就靠着这些选举出来的人才来管理，而那些朝廷大员又非世袭，很多丞相或者内个大学士都出身贫苦，国家靠着这些读书人管理着整个国家，所以可以说中国是一个”仕人社会”，只不过到了元朝和清朝就变成了”部族社会”，这就另说了。</p>
<p>第三点读完之后的感受就是在两千年的历史（从汉到清）中，能明确感受到以下几点：1.中央政府在不断地集权、而地方政府的权力在衰落，地方政府的地位也在降低，尤其是那些真正管理百姓的县长，到后来职位是越来越低，甚至与中央通话都要隔着三四级，他们上要讨好上级，下要管理百姓，其实也是着实为难；2.政府为了防止百姓造反采取了很多的政策，比如在内部分裂知识分子以及普通民众，这也导致国人越发得不团结，不团结也就没有力量，甚至国人开始慢慢变得异常窝里斗，我们民族的这些糟粕都是有其缘由的；3.中国官本位也是有其原因的，自古以来优秀人才都被引入到了仕途，读书人心中也形成了一种观点——“学而优则仕”，而且政府到后来反而在不断地抑商，一是人才不断涌向政府，政府又用不了这么人，造成政府人事不断臃肿，二是其他行业需要人才反而又得不到人才，导致发展缓慢；4.民众的自由程度在不断压缩，甚至到了清朝为了防止汉人反清还实行了一些政策，取消了言论自由、结社自由和出版自由，这些在清朝之前都是很正常的东西，后来就慢慢给禁止了，而随后大家竟然慢慢习惯了，这也是因为个人力量非常薄弱，而大家又很难团结一起。这些不断形成的东西，站在民族长远的角度来看，对我们中华民族是非常有害的、不利的。</p>
<p>读完之后，尤其是与西方的历史对比，心中总是少不了些许疼痛，曾经引领世界的、有着全世界最优秀制度的民族，到最后竟然轮到没有自由的部族政治，清朝之害，远重于崖山。</p>
<hr>
<blockquote>
<p>汉光武自身是一好皇帝，明帝，章帝都好，然而只是人事好，没有立下好制度。因此皇帝好，事情也做得好。皇帝坏了，而政治上并不曾有管束皇帝的制度，这是东汉政治制度上的一个大问题。也是将来中国政治制度史上一个大问题。——钱穆, 中国历代政治得失, loc. 414-416</p>
</blockquote>
<p>Notes: 1) 缺少一种好的制度来防止其他情况的出现。</p>
<blockquote>
<p>但日子久了，那制度就变坏了。这不只是汉代选举制度如是，我们可以说，古今中外一切制度，都必如是。否则一项好制度，若能永远好下去，便将使政治窒息，再不需后代人来努力政治了。——钱穆, 中国历代政治得失, loc. 448-450</p>
</blockquote>
<p>Notes: 1) 任何政策都有其漏洞,时间越久,漏洞也就越多</p>
<blockquote>
<p>《唐六典》的，仍不应仅当它是一部历史书，为记载唐代现实制度的书，而应同时当它是一部理论和思想的书看。因唐代人对政治上的种种理论和思想，都已在此书中大部具体化制度化了。制度的背后，都应有理论和思想。一切制度，决不会凭空无端地产生。若我们忽略了中国以往现实的政治制度，而来空谈中国人以往的政治思想，也决无是处。——钱穆, 中国历代政治得失, loc. 568-571</p>
</blockquote>
<p>Notes: 1) 唐代的巨大进步</p>
<blockquote>
<p>总之中国是一个广土众民的大国家，必需得统一，而实不宜于过分的中央集权。这在中国的政治课题上，是一道值得谨慎应付的大题目。现在专说唐代，似乎其中央行政比汉进步，而地方行政则不如汉。中央的监察官变成了地方行政官，这是一大缺点。而由军队首领来充地方行政首长，则更是大毛病。唐室之崩溃，也可说即崩溃在此一制度上。——钱穆, 中国历代政治得失, loc. 609-612</p>
</blockquote>
<p>Notes: 1) 节度使既掌握军事又掌管地方事务,很危险</p>
<blockquote>
<p>从此可知，政治制度是现实的，每一制度，必须针对现实，时时刻刻求其能变动适应。任何制度，断无二三十年而不变的，更无二三百年而不变的。但无论如何变，一项制度背后的本原精神所在，即此制度之用意的主要处则仍可不变。于是每一项制度，便可循其正常轨道而发展。此即是此一项制度之自然生长。——钱穆, 中国历代政治得失, loc. 639-642</p>
</blockquote>
<p>Notes: 1) 制度因时因地而异.</p>
<blockquote>
<p>理论是此制度之精神生命，现实是此制度之血液营养，二者缺一不可。——钱穆, 中国历代政治得失, loc. 643-644</p>
</blockquote>
<p>Notes: 1) 理论是理想的,现实是不断完善理论,两则相辅相成。</p>
<blockquote>
<p>其实革命的本质，应该是推翻制度来迁就现实的，绝非是推翻现实来迁就制度的。我们此刻，一面既否定了传统制度背后的一切理论根据，一面又忽略了现实环境里面的一切真实要求。——钱穆, 中国历代政治得失, loc. 646-648</p>
</blockquote>
<p>Notes: 1) 制度为解决现实问题而生。</p>
<blockquote>
<p>当知任何一种制度之建立，傥是仅由一二人之私意便能实现了，这便无制度可讲。若谓此乃皇帝欺骗民众，而且凭此欺骗，便能专制几百年，古今中外，绝无此理。若民众如此易欺易骗，我们也无理由再来提倡民主政治。凭事实讲，科举制度显然在开放政权，这始是科举制度之内在意义与精神生命。汉代的选举，是由封建贵族中开放政权的一条路。唐代的公开竞选，是由门第特殊阶级中开放政权的一条路。——钱穆, 中国历代政治得失, loc. 673-677</p>
</blockquote>
<p>Notes: 1) 制度产生之历史背景,有其合理的地方,不能一言以蔽之。</p>
<blockquote>
<p>而中国则自唐以下，便已犯了政权开放之流毒。以水救水，以火救火，不仅是药不对病，而且会症上加症。若要解决中国社会之积弊，则当使知识分子不再集中到政治一途，便该奖励工商业，使聪明才智转趋此道。然结果又很易变成资本主义。在西方是先有了中产社会，先有了新兴工商资本，然后再来打开仕途，预闻政治。而中国则不然，可说自两汉以来，早已把政权开放给全国各地，不断奖励知识分子加入仕途，而同时又压抑工商资本。只鼓舞人为大学者，当大官，却不奖励人为大商人，发大财。节制资本，平均地权，大体上是中国历史上的传统政策。政治措施，存心在引导民间聪明才智，不许其为私家财力打算无限制的发展。——钱穆, 中国历代政治得失, loc. 683-689</p>
</blockquote>
<p>Notes: 1) 知识分子都涌入政治,造成官员庸肿不堪,直到今天依然如此,一个局长会有近十个副局长。 政治无法消化所有的优秀人才,应该将人才引入其他该需要的地方,以发挥最大的价值。</p>
<blockquote>
<p>即就账籍制度言，可见每一项制度之推行与继续，也必待有一种与之相当的道德意志与服务忠诚之贯注。否则徒法不能以自行，纵然法良意美，终是徒然。而且任何一制度，也必与其他制度发生交互影响。故凡一制度之成立，也绝非此制度可以单独成立的。——钱穆, 中国历代政治得失, loc. 717-720</p>
</blockquote>
<p>Notes: 1) 并不完全依靠法治,对道德水准有一定要求。</p>
<blockquote>
<p>好像汉代是在社会上层节制资本，而下层则没有力量管；唐代注意社会下层，由国家来计划分配，而让上层的富民能自由发展。这一情形，似乎唐代人更要高明些。他可以许你过富，却不让你过穷。——钱穆, 中国历代政治得失, loc. 774-776</p>
</blockquote>
<p>Notes: 1) 汉唐经济思想之精髓</p>
<blockquote>
<p>不过事情隔久了，这事情演变之本原意义忘失了，后人便只见得皇帝之尊严与宰相之卑微了。——钱穆, 中国历代政治得失, loc. 893-893</p>
</blockquote>
<p>Notes: 1) 一个制度的确立有其原因,但随着时间其原意慢慢被抛到脑后,久而久之也就为人所不知了。</p>
<blockquote>
<p>宋代制度之缺点，在散，在弱，不在专与暴。直到南宋宁宗时，已快亡国，皇帝时时下手条，当时称为御札，还激起朝臣愤慨，说事不出中书，是为乱政。可见宋代相权，还有它传统客观的地位。我们此刻只根据历史来说宋不如唐，所谓宋代宰相失职，一切仍是制度问题。并不是只有皇帝专制，更不要制度。——钱穆, 中国历代政治得失, loc. 916-919</p>
</blockquote>
<p>Notes: 1) 制度中的问题看似只是一条命令,实则影响巨大,制度要有自我完善机制</p>
<blockquote>
<p>无制度的政府，哪能有好施为，哪能有好结——钱穆, 中国历代政治得失, loc. 964-964</p>
</blockquote>
<p>Notes: 1) 制度的确立是有其缘由的,要明白背后的原因才能更好地让制度用在正途。</p>
<blockquote>
<p>宋代则把财富兵力都集中到中央，不留一点在地方上，所以中央一失败，全国土崩瓦解，再也没办法。——钱穆, 中国历代政治得失, loc. 985-986</p>
</blockquote>
<p>Notes: 1) 越往后,君权越大,中央集权越严重。</p>
<blockquote>
<p>任何一省都如此。给你这一半，割去你那一半。好使全国各省，都成支离破碎。既不能统一反抗，而任何一区域也很难单独反抗。这是行省制的内在精神。——钱穆, 中国历代政治得失, loc. 1321-1322</p>
</blockquote>
<p>Notes: 1) 背后的原因</p>
<blockquote>
<p>举人以下就没有做大官的份，如是则科举场中也分了流品。进士及第是清流，浮在上面直向前，秀才举人则变成了浊流，沉淀在下面，永远不超升。鼎——钱穆, 中国历代政治得失, loc. 1428-1430</p>
</blockquote>
<p>Notes: 1) 此思想毒害后代</p>
<blockquote>
<p>而且纵使存心公正善良的人，其所创制度，也可有偏弊，有流害。我们必如是想，才能对政治制度有深一层之研讨与警惕。——钱穆, 中国历代政治得失, loc. 1459-1460</p>
</blockquote>
<p>Notes: 1) 制度逐渐演化,已经在慢慢背离初衷。</p>
<blockquote>
<p>制度指政而言，法术只是些事情或手段；不好说是政治。大抵制度是出之于公的，在公的用心下形成的一些度量分寸是制度。而法术则出之于私，因此没有一定恰好的节限。所谓方法与权术，二者之间，当然又不能仔细分。——钱穆, 中国历代政治得失, loc. 1548-1550</p>
</blockquote>
<p>Notes: 1) 一个有度,一个没有</p>
<blockquote>
<p>论汉代，西汉可说是制度，东汉则多半出于光武的私心。论唐代，确实可说在建立制度，而宋代则有许多只算是一种法术。明代，有许多只能说它是一些事，不能说它是一些制。尤其是清代，可说全没有制度。它所有的制度，都是根据着明代，而在明代的制度里，再加上他们许多的私心。这种私心，可说是一种“部族政权”的私心。一切有满洲部族的私心处罚，所以全只有法术，更不见制度。——钱穆, 中国历代政治得失, loc. 1553-1557</p>
</blockquote>
<p>Notes: 1) 崖山之后无中国。并不准确。</p>
<blockquote>
<p>可是我们中国历史从汉代起，就不能叫皇权，因皇帝一个人不可能掌握一个国家的大权。也不能说它是贵族政权，因自汉代起，已没有显然的贵族。说是军人政权吗？我们也看不出汉政府以下，是由军人掌握的。说是资产阶级的政权吗？中国一向没有资产阶级。所以若说政权，则中国应该是一种士人政权，政府大权都掌握在士——读书人手里，从汉到明都如此。——钱穆, 中国历代政治得失, loc. 1569-1573</p>
</blockquote>
<p>Notes: 1) 这点分析得很好,利益总是被这些少数群体把握着。</p>
<blockquote>
<p>美国人尽管看重东方的商业，但他只可想旁的方法，不能派一总督来管理菲律宾，而把他们开国以来全部历史精神推翻了。所以今天苏维埃说美国帝国主义，其实是名实不相符。但若说英国对香港是一种帝国主义，这是百辩难逃的。因他把全国家分成了两部分，一部是本国，一部是征服地。这才始得叫帝国。清代有所谓本部十八省，外边又有藩属，故说它像西方的帝国，但细辩又不同。因清人待蒙古，比待中国本部的人还要好，蒙古人得封亲王，中国人是没有的。英国人断不能待香港人比待他本国的人好，可见就算清代也是帝国，还是东西巧妙不同的。——钱穆, 中国历代政治得失, loc. 1765-1770</p>
</blockquote>
<p>Notes: 1) 如果这样来看,确实如此,清朝也可以认为与英国一样。</p>
<blockquote>
<p>我们现在的毛病，就在喜欢随便使用别人家的现成名词，而这些名词的确实解释，我们又多不了解。——钱穆, 中国历代政治得失, loc. 1770-1771</p>
</blockquote>
<p>Notes: 1) 不明缘由</p>
<blockquote>
<p>当时的洪杨，并不是推不翻满清，但他们同时又要推翻中国全部历史，所以他们只可有失败。——钱穆, 中国历代政治得失, loc. 1811-1811</p>
</blockquote>
<p>Notes: 1) 缺少刘伯闻这样的谋士,这种谋士要上通天文,下知地理,也就是熟悉中国历史。</p>
<blockquote>
<p>但康有为只知道皇帝无害于立宪，却不知道满清皇帝的后面是一个部族政权在撑腰。部族政权是决不容有所谓立宪的。孙中山先生主张革命，一定要推翻皇帝，康有为的变法就变成了保皇，似乎又像非要皇帝不可了。康有为实在没有看清楚，他以为只要光绪皇帝听他话，变法就变得成，这是他的大错误。这个错误也就是错误在他没有像西洋人般懂得政治上的所谓主权的观念。他不懂得当时的中国政治，是满洲部族主权的政治。掌握主权的是满洲人，哪里是像他所谓的皇帝专制呢？他误认为中国传统政治只是皇帝专制，故而以为只要皇帝听我话，便可由皇帝专制一变而为皇帝立宪。——钱穆, 中国历代政治得失, loc. 1817-1822</p>
</blockquote>
<p>Notes: 1) 争论到最后变成了是否要保皇,已经失其初心。而且清帝国并非只是皇帝一人专制,后面利益何其复杂。</p>
<blockquote>
<p>至于中国历史上的传统政权，无论汉、唐、宋、明，却并无私权力，私立场，私背景，它的立场背景便是全国人民，便是全社会。所以遇到政治腐败，只要换一批人，把制度腐败了的略略修改，就仍可继续下。——钱穆, 中国历代政治得失, loc. 1828-1830</p>
</blockquote>
<p>Notes: 1) 两千年历史没有革命。 2) 两千年历史没有革命,变得很少。</p>
<blockquote>
<p>中国政治，实在一向是偏重于法治的，即制度化的，而西方近代政治，则比较偏重在人治在事实化。何以呢？因为他们一切政制，均决定于选举，选举出来的多数党，就可决定一切了。法制随多数意见而决定，而变动，故说它重人、重事实。我们的传统政治，往往一个制度经历几百年老不变，这当然只说是法治，是制度化。法治之下，人才就受束缚了。所以明末的黄梨洲要慨然说：“有治人，无治法。”这因一向制度太繁密，故使他太不看重法，太看重人，而要提出此主张。——钱穆, 中国历代政治得失, loc. 1905-1909</p>
</blockquote>
<p>Notes: 1) 这样的解释醍醐灌顶之感,我们一般认为中国缺少法治基因,而实际并非如此。</p>
<blockquote>
<p>孙先生不是读死书的人，他这几句话，并不由任何西方抄袭来，他真是深识远虑，确有他所见。政府是该属于民众的，但不是，也不能，定要全体民众直接来掌握此政权。理论上，国家政权当然在民众，该以民众大家的意见为意见。但民众意见，终是句空话。如何来表达出此民众的意见呢？今天中国多数民众，尚依赖政府来注意教和领导，他们哪有办法来过问政治？然而一个国家总要有一个不可动摇的中心，即如目前的日本，他们把历史上的传统中心皇帝尊严摇动了，急切间社会也会发生摇动的，他们拿什么东西来填补，来维系？这在他们也将成为一问题。中国也会碰到这问题的，而且早已碰到了。——钱穆, 中国历代政治得失, loc. 1924-1929</p>
</blockquote>
<p>Notes: 1) 孙中山先生有其擅长的地方,也有其不擅长的地方。</p>
<blockquote>
<p>历史终是客观事实，历史没有不对的，不对的是在我们不注重历史，不把历史作参考。至少我们讲人文科学方面的一切，是不该不懂历史的。政治也是人文科学中一门，我们回头把以前历史经过，再看一道，总还不是要不得。——钱穆, 中国历代政治得失, loc. 1948-1950</p>
</blockquote>
<p>Notes: 1) 历史是宝贵的财富,也是文化传统,焉能一笔抹杀</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了两周多的时间把钱穆老先生这部神作读完了，读完之后的感觉是，书中有太多的观点让我有醍醐灌顶之感，钱老读史思考的深度远非常人所及，这本书非常值得拜读，豆瓣上也同样给出了9分以上评价，真的名不虚传（&lt;a href=&quot;https://book.douban.com/subjec
    
    </summary>
    
      <category term="书屋" scheme="http://matt33.com/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://matt33.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
