<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matt&#39;s Blog</title>
  <subtitle>wangzzu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangzzu.github.io/"/>
  <updated>2016-11-20T10:49:23.000Z</updated>
  <id>http://wangzzu.github.io/</id>
  
  <author>
    <name>Matt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从《驴得水》到《我不是潘金莲》的一些思考</title>
    <link href="http://wangzzu.github.io/2016/11/20/movie-think/"/>
    <id>http://wangzzu.github.io/2016/11/20/movie-think/</id>
    <published>2016-11-20T10:47:19.000Z</published>
    <updated>2016-11-20T10:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年好久没去电影院看过电影了，今天趁着周末去看场电影，选了最近比较火的<a href="https://movie.douban.com/subject/26630781/?from=showing" target="_blank" rel="external">《我不是潘金莲》</a>，据说这部电影跟《驴得水》有些相似之处，比较贴近现实，并那么做作。看完之后确实感慨很多，相比于以前的那些烂电影真的要好很多。</p>
<p>今年上映的国产电影，不得不说有几部确实还是挺不错的，虽然还是烂片居多。关于电影，其实我一直都是有个疑问，之前看过很多的韩国电影，看完真心感觉很多韩国电影拍得很不错，尤其是近几年，韩国的犯罪系列电影拍得很精彩，韩国也拍了很多反应社会现实的电影，如《熔炉》、《金福南杀人事件》，这些电影其实都可以归结于人性系列。那么问题来了，为什么韩国的电影近几年能够异军突起，甚至有成为亚洲电影骄傲的趋势，而我们大陆拍得电影，几乎每年都被在吐槽烂、简直扶不上墙，更别提走出国门了，一年上映几百部的电影，而豆瓣评分过7分也只有个位数，原因何在？是我们的导演不如韩国？编剧不如韩国？或者说文化氛围不如韩国？貌似这些理由都没有说服力，毕竟我们曾经拍出《让子弹飞》、《霸王别姬》、《大话西游》等这些优秀的电影，而且我们国家也出了诺贝尔文学奖获得者莫言，那么原因在哪里？很多人说是广电总局的问题，说我们国家的电影审核太严，我同样也认为这是其重要的原因之一，电影的剧本要符合主流价值观，这也使得很多好的题材并不能过审。而近段上映的两部电影——《驴得水》和《我不是潘金莲》，多多少少让我们感觉到影中的情景就是赤赤裸裸的现实，让我们明显感觉到中国电影的环境在慢慢变得健康，而不像以前那样的畸形，这两部电影的大热也不是没有原因的。</p>
<p>电影是艺术的一种，关于这一点，是我们不可否认的，一部好的艺术作品，是能够启发每个人的思考，而不仅仅是嘻嘻哈哈就过去了，对于电影作品也是如此。</p>
<p>在《驴得水》中，首先是基层人员为了能够获得更多的利益，谎报在编正式人员数，甚至不惜伪造；其次，中层领队对上级拨下来的教育扶贫资金克扣，影中克扣了70%，剩下的30%在基层人员手里大家再分一点，最后真正落到实处的都不足两成、甚至不足一成；最后，为了应付上级领导的检查，中层领导和基层人员为了各自的利益一起糊弄上级领导。这种现象在现实中大家都应该深有体会，尤其对那些三四五线的小城市，恐怕更为严重，这也是年轻人毕业 之后纷纷选择竞争更为公平的一线强二线的城市去打拼的原因（当然并不是说一线强二线就是绝对公平的，相比于三四五线还是要好很多的）。记得当时看过驴得水之后，为影中的剧情拍手叫好，当时看完电影甚至感觉有些诧异，这种电影竟然过审了？</p>
<p>今天看了《我不是潘金莲》，女主李雪莲因为一件离婚案去县里、市里告，在去市里喊冤的时候，为了不影响市里的精神文明检查她还在省委领导视察期间被关进派出所，最后幸运的是她去北京告状的时候遇到了中央的首长，更幸运的是遇到了一个比较好的中央首长，当然故事还在继续，就是因为她这一告从法院院长、县长、市长都一并被处置了，但唯独没有处置她的前夫秦玉河，这里先不讨论李雪莲是否有理（其实这个并不重要，李雪莲确实是个法盲，这部电影给人的思考更应该关注这些人民公仆的表现），在这个过程中我们看到了从下到上、从县到省是如何对待普通公民李雪莲的。首先判官李公道对这个案子判决根据我们已有的法律知识是没有问题的，但是后面的各个官员对于普通公民的态度呢？影片中也出现了法院院长喝酒应酬的情景，李雪莲前去告状，他们连深入了解这个案件的耐心都没有，甚至还生怕李雪莲在前任院长面前说了什么不该说的话，他们直接告诉李雪莲你要是对法院判决不服那就去市里告、检举法院厅长的话去检察院，这跟我们没关系，然后李雪莲就问：你们难道就不管了吗？那人说：我们什么时候说不管了，关键是我们管不了。</p>
<p>这些说的这听起来确实也没有错，当李雪莲在法院院长应酬的饭店外面蹲点，去拦截法院院长的车告状，这里看一下当时影中的情景是怎样的？</p>
<ul>
<li>李雪莲前去告状，法院中另一人直接抱住李雪莲，不让李雪莲在前任院长面前说话，生怕李雪莲说了什么队他们的不利的东西，当时前任院长有心想问一下，这时候他老婆说了一句：你已经退休了，这些事情你管不了了。这个场景我想我们大家都有深有体会的，因为很真实、很现实；</li>
<li>那些法院公职人员对待公民的态度问题，其中那个抱住李雪莲的人还一把把李雪莲推倒在地上，反而自己还大吼道：你想干嘛，真是巨大的讽刺。</li>
<li>影中还出现了两次（记得是两次）打扮颇为靓丽的年轻女子，一次在与两人法院院长吃饭的饭局上，另一次在市长与县长谈话的那个小桥边，同样也有讽刺意味十足。</li>
</ul>
<p>影片也丝毫没有遮掩下级干部是如何欺瞒、甚至糊弄上级，影中连省长向中央首长汇报都是这样，省长都向人代表明确暗示在首长面前不要多说话、讨论仅限昨天会议问题、绝对不能扯远，由此可见，别说民意上达中央了，估计省里都懒得去管。个人认为《我不是潘金莲》这部影片最牛逼的地方在于它直接就映照现实，这些东西以前可都是忌口，就连《驴得水》还用了民国做背景，而它倒好，故事背景直接就发生在近二十年，故事的最后也提高了计划生育政策，普通公民为了多生一个孩子甚至不惜以离婚作掩护，而现在的现实是很多夫妻为了多买套房、享受优惠不惜假离婚，当然也出现了一些假的变成了真的场景，在新闻上是屡见不鲜，可见一切都在改变，而似乎有些东西又丝毫没变，不知道那些这样做的人，过了二十年之后再回忆会是什么感想。</p>
<p>从《驴得水》到《我不是潘金莲》这两部电影，其实我感慨最多还是中国的电影环境在变化，大家都知道2015年和2016年这两年其中一个处在风口的行业是什么？是内容，广大普通民众对于那些套用各大明星的烂电影简直是深恶痛绝，也对那些省级卫视里那些无聊的电视剧和娱乐节目感到厌烦。记得前段时间看新闻，还说今年的票房相比去年下降了很多，我想这更多就是民众再对烂电影的一次共同抗议吧。但这也成了很多用心做内容公司一次机遇，就以电影行业为例，心迷宫、夏洛特烦恼、大圣回来等小投资的电影大热，口碑和票房双丰收，可见市场这只无形的手确实在发挥它应用的作用。</p>
<p>内容行业的人估计也在意识到现在的一些年轻人喜好正在发生改变，假大空、没有任何深入的电影，真的让人无法接受，浪费钱就不说了，更重要的是浪费了我们宝贵的时间。这种结果也是互联网对这个行业冲击的影响，首先，互联网对电影口碑的传播几乎起着决定性的作用，之前是豆瓣评分，现在朋友圈好友推荐，口碑传播的方式在慢慢变化，一部作品的口碑对其最后的成功与否也起着越来越大的作用；再者，互联网的发展，让普通民众接收到了不同信息，民众也不再像以前那样，给什么信息我们就只能接收什么信息，信息的接收渠道十分有限，但是现在我们可以接收到更多的信息，这也在潜移默化影响我们的生活，其实，我就是想说一句话，随着经济的发展，公民观念的水位在慢慢上升。举一个例子，之前那段时间我们一直都在看美国的总统大选，看得好不热闹，然后这两天也刚我们国家的人大代表换届选举，搞笑的场景就出现了，新闻上有一个地方川普的得票率达到了10%，而这个地方总投票率却不到半数，最后选举只好重新举行。对于在大城市生活的人来说，我们还是能明确感受普通公民权利意识的觉醒，这也是我们国家正在进步的表现。</p>
<p>最后，一部好的电影作品是应该引人思考、深入人性的，希望我们国家拍得电影越来越好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年好久没去电影院看过电影了，今天趁着周末去看场电影，选了最近比较火的&lt;a href=&quot;https://movie.douban.com/subject/26630781/?from=showing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《我不是潘
    
    </summary>
    
      <category term="影如人生" scheme="http://wangzzu.github.io/categories/%E5%BD%B1%E5%A6%82%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="电影随想" scheme="http://wangzzu.github.io/tags/%E7%94%B5%E5%BD%B1%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>校招找工作小记</title>
    <link href="http://wangzzu.github.io/2016/11/15/job-summary/"/>
    <id>http://wangzzu.github.io/2016/11/15/job-summary/</id>
    <published>2016-11-15T10:51:40.000Z</published>
    <updated>2016-11-19T09:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年，是一个很重要的年份，不但是自己的本命年，还是自己要踏出校园、走向工作的一年。从今年过完年回到学校，记得大概是2月底，这期间经历刷题、找实习、校招，直到前两天把三方交上，今天公司盖完章拿到回执信，工作也算终于确定了下来。在这过程中，经历过失落、兴奋、伤心等等，中间的喜悲，也只有自己最清楚了，趁着这几天晚上有点时间，回想一下过去几个月的心理路程写一篇校招的小记，也算是对这几个月的酸甜苦辣做一下总结。</p>
<blockquote>
<p>莎士比亚：不要因为一次失败，就放弃你原来决心想达到的目标。</p>
</blockquote>
<h1 id="慌慌张张找实习"><a href="#慌慌张张找实习" class="headerlink" title="慌慌张张找实习"></a>慌慌张张找实习</h1><p>记得当时二月底回到实验室，刚来没几天，网易的实习招聘就开始了，当时还没到三月，丫的网易直接把实习的战线拉到了二月底。当时感觉真是日了狗了，啥都没准备，所以也就没有内推网易。然后就开始慌慌张张地准备找实习了（<strong>提醒：找实习就是找工作，一定要认真对待</strong>），先是写简历，把自己在实验室做的那些项目总结一下，重点是把项目给整理一下，根据面试的经验，对于简历中的项目一般会问以下这几个问题（这几个问题有的难度大有的小，看个人人品了，不过最后都准备一下）：</p>
<ol>
<li>项目的目的是什么？要解决什么问题？</li>
<li>为了解决这个问题或完成这个项目，设计方案是什么？以及为什么要使用这个设计方案？</li>
<li>项目中遇到了哪些难点，如何解决？</li>
<li>你再回头看这个设计方案，有什么哪些地方可以再优化？</li>
<li>如果现在让你重新设计方案来解决这个问题，你会怎么设计？（这种问题一般是之前的设计方案有漏洞或者有可以改进的地方时，面试官才会问到）。</li>
</ol>
<p>整理完自己的项目之后，就开始看一些计算机的基础知识，因为自己是做大数据方向，所以当时也就选定了 Java 开发工程师或者是大数据开发工程师的职位，其他的职位就不再考虑了。在准备 Java 基础的时候，主要就是看一下一些常见的 Java 面试题，这个网上有很多，个人的经验，觉得面的最多的就是：容器（hash 很重要）、多线程、并发等了，这个还是比较容易准备的，但当时由于自己准备的太晚，而且很多大公司的实习生开始得也比较早，所以当时就感觉时间很紧张。</p>
<p>如果想投开发岗的话，算法是必须要准备的，《<strong>剑指 Offer</strong>》这本书是肯定要刷一遍的，记得当时自己花了四五天时间急急忙忙把这本书看完，但只是看了算法过程，并没有手写代码，后来在面试中也就吃了亏，手写算法还是要好好准备的，准备一些常见的算法即可。对于 Java 开发，除了算法，JVM 的一些内容也要重点掌握，这个就是看《<strong>深入理解 Java 虚拟机</strong>》这本书了。反正对于我，记得当时刚开始面试时，遇到这种问题基本上都是一脸懵逼，不过面的多了，就知道往哪方面准备了。记得当时先投了阿里云那边，是室友的一个同学内推的，室友的这个同学先对我进行了预面试，问得也是 Java 和大数据方面的基础知识，面试完就感觉自己前几天准备的东西白准备了，都没怎么记住，当时瞬间感觉自己要完了、感觉要完全找不到实习了。</p>
<p>即使当时预面试的结果不是很理想，但是也得投简历，要不然连面试的机会都没了，所以就先投了阿里云。然后紧接着第二天中午就收到了面试电话，聊的内容当时感觉还是很深的，但从现在的角度看，其实也就那样（校招的时候很多公司问得会更深）。这是人生中第一次正式工作面试，中间聊得还挺不错的，面试官对我还比较满意，还让我推荐实验室的同学。我当时也是很幸喜，谁知道好景不长，第二天傍晚就收到了阿里的二面电话，先问了一个问题：介绍一下 Hadoop 生态圈的技术，当时就开始从 MapReudce、hdfs、HBase 开始讲起了，讲了有足足五分钟，电话那边连个音都没有（当时都怀疑那边是不是还有人在听），当时面的时候还是很紧张的，在介绍 hdfs 的时候，面试官突然问到：secondNameNode 的作用是什么？然后就回答错了，之后面试官又开始问了 spark、linux、flink 等相关的问题，自己全程是不会来结束讨论的，然后就没有然后了，这个面试只持续了15分钟就结束了，到了第二天，官网上状态就显示自己的面试结果是已回绝。第一次应聘就这样结束了，当时分析失败的原因认为主要是个人基础准备不足，还有一个是缺乏面试经验，一方面是自己准备的确实不好，另一方面是面试的时候没有把面试官领到自己熟悉的领域上来，而且前面在讨论 hadoop 的时候，并没有与面试官进行一些互动，总之，面的第一家公司就这样挂了。</p>
<p>自己当初找工作时候的目标，其实很明确，就是想去阿里的中间件做 Java 开发工程师。可惜天公不作美，阿里是我面试的第一家公司，也是第一个拒掉我的公司。经历这次面试之后，自己又把相关的基础准备了一下，接着又面了XX街、XX之家，这两家都属于比较小的公司，当时想的是积累一下面试经验，XX之家实在是太耿直了，面了一面就给了 offer，面试官人还挺好，说实话自己到现在还挺愧疚的，去那边面试了，人家给了 offer，结果自己又没去，感觉这样确实不太好。</p>
<p>其实当时自己想的也很清楚，也就准备重点投一下这6家公司：BAT、某滴、某米、某团，其他的投的话只是积累一下面试经验。当然，虽然想得很好，但现实却很骨感，T 家从头到尾都没给面试机会，感觉老是投不对岗，实习的时候投的后台，发现大都是招 C++，听人说大数据应该投基础研究，然后校招投的基础研究，笔试的时候发现题目全特么都是机器学习相关的，当时心中真是一万只草泥马奔腾而过啊，注定无缘。对于 B 家，实习的时候师兄帮忙内推的，面的是一个比较对口的部门，不过因为准备的不充分、基础也回答得不好，虽然一面面了一个半小时，结果还是挂了，不过面试官真的很 nice，面完的时候还对我的面试情况做了一下总结，说我哪地方不好，哪地方还可以，唉，最终还是挂了，校招内推的时候也没敢投，因为这次面我的这个面试官是百度负责 Kafka 技术的小组 leader，当时感觉如果校招再投简历的话简历还是会到他那里，所以就没敢再投。虽然后面百度正式校招的时候也参加了笔试，自我感觉做得还可以，不过最后还是没有面试的机会，也是无缘了。关于 A 家，因为之前实习的时候没过，后来校招的时候也找了内推，但是今年 A 家基本上没怎么校招，今年的校招基本上都是实习生转正，还有一些是内推。因为自己一直想去 A 家的中间件团队，校招的时候就找到了<a href="http://weibo.com/u/2176287895?topnav=1&amp;wvr=6&amp;topsug=1" target="_blank" rel="external">黑桃夹克</a>师兄帮忙内推，师兄很热心，但是今年 A 家的 hc 实在太少，记得当时简历投了一个月都没人理，最后直接变成了校招，让参加笔试，真心感觉 A 家今年没怎么招人，当然这跟具体部门、职位有关。</p>
<p>慢慢的就过了五一，当时实验室好多人的实习基本上已经确定了，大家基本上都拿到了一个比较好的 offer，那段时间自己心里还是能明显感觉到找实习的压力，记得那期间还失眠了一段时间。既然没找到心仪的实习 offer，只能对面试经验再做总结，自己不会的再好好准备。随后，某米和美团的实习也开始了，然后就让师兄师姐帮忙内推，关于某米的面试经历印象还是很深刻的，去面某米之前，其实还是挺想去某米的，自己对某米的商业模式是一直比较看好，但是面试结果真的是大跌眼镜了。当时的一面面试官感觉是一个刚毕业一两年的工程师，随便问了一些大数据和 java 相关的基础知识，然后就开始写算法了，写了一道算法和一个 mr，然后就进入到二面，二面面试官让我设计一个系统，用一个朋友圈来举例，全程聊了将近一个半小时，感觉最后的结果是面试官不理解我说的，而我也没完全理解面试官说的问题，总之，中间聊的时候我都想直接甩袖子走人。面完某米，记得当时我都开始怀疑自己是不是理解能力有问题，不过也深刻地明白了一个道理：<strong>一定要跟面试官确定好问题</strong>，如果你默认是这样，很有可能就中了面试官的套。</p>
<p>面完某米之后，没过几天就收到了美团的面试通知，然后就去美团面试，面美团之前想的是面面再说，反正最后也不一定去，当时约的是两点，我去的比较早，一点半就到了，然后到了一个会议室开始面试，记得当时跟一面面试官聊了一个半小时，关于 Kafka 相关的聊了近 40 min，聊的还比较深，然后又聊了很多基础知识，还写了两道算法。当时面完一面之后，当时感觉自己拿这个 offer 应该还是很稳的，因为自己在实验室做的跟这边做的完全对口。过了一会就开始了二面，刚好跟二面面试官是老乡，二面面试官是做实时的，聊了很多 storm 相关的，因为美团要求前二面必须手写算法，所以又做了一道算法，基本上就结束了，大概也聊了六七十分钟。最后又跟三面面试官聊了半个小时，三面聊了一点点技术，其他的基本上就是聊聊兴趣、聊聊人生什么的。当时从下午两点开始面，面完基本上快六点了，当时面完的感觉是美团这边招人还是挺严格的，纯技术面一口气面了三面。不过美团真的很给力，面完的第二天就给了 offer，因为我当时7月份才能实习，面试官也愿意等我到七月份入职，当时考虑一周之后，就把 offer 签了，决定去美团这边实习，当然最主要的原因是跟我的之前做的很对口，还有就是感觉那边面试还是挺严格的，所以觉得技术应该也不会差到哪去。</p>
<h1 id="实习篇"><a href="#实习篇" class="headerlink" title="实习篇"></a>实习篇</h1><p>到了七月之后，准时到公司报到，去的时候第一周就领到了全新的 Mac pro，之前没用过 mac，各种不顺手，不过用了一周之后，就觉得 Mac 用着真特么爽。去了之后，才知道，当时我的一面面试官，就是之后带我的 Mentor，他已经工作五年了，之前在阿里工作过4年，技术还是很不错的，当时觉得自己还是很幸运的，能有这位师兄带我，之前二面面试官是我们小组的 leader，三面面试官是我们大部门的 leader，被称为百度的 Metrcis 之父，还真没想到这边居然还卧虎藏龙。所以，在刚开始那段时间对自己的工作特别满意，自己在这边确实也能学到东西，被 Mator 逼着看 Kafka 的源码（感谢）。</p>
<p>这里，顺便说一下关于大公司与小公司的选择问题吧。下面纯属个人想法，关于这个选择，如果由能力能去清华的计算机，那不用考虑去就行了，毕竟那里牛人更多、氛围也更好，但是如果去不了清华的计算机，而只能去清华的XX（就是就业很不好的那种小众专业），那完全可以选择去北航的计算机或北邮的计算机。也就是说，如果有能力拿到 BAT 的核心部门的 offer，那就去；但如果只能拿到边缘部门的 offer，那完全可以选择其他公司（某滴、某米、某团）的核心部门。毕竟选择一家公司，不能只看公司的名气、薪酬，还要看当你哪天离开这家公司的时候，你自己成长了多少，个人感觉，这个才是最重要的，在大公司当螺丝钉，也只有在大公司这个环境下你才有价值，一旦离开这个大环境，你能选择的就很少了，所以，应该把个人能力的提升放在一个比较重要的位置。这里，对于应届生，我是比较推荐这六家公司（国外的公司暂不讨论），一些较小或者偏初期的创业公司，对于应届生来说，还是要谨慎一些好。还有就是哪些处在风口的企业，也要慎重，哪些公司估值泡沫很大，而且明显让人感觉的是：哇塞，今年这家公司开的好高，但是明年开高公司又变成了另外一家，所以还是要慎重，在找工作的时候，一定要有一个清晰的目标。</p>
<h1 id="急急忙忙校招"><a href="#急急忙忙校招" class="headerlink" title="急急忙忙校招"></a>急急忙忙校招</h1><p>在美团实习了两个月之后，这时候就已经到了九月份，帝都的互联网校招基本上也开始了，记得当时在论坛随便找了一个师兄内推了 X 狐，然后就通知周末去面试，去之前心里是一点都没普，毕竟算法好久没看了，很多东西长时间不看是会忘的，算法就是这样，当时就随便准备了一下就去面试了，结果很出乎意料，在面试之前，看了一些关于 Java 并发、多线程的内容，当时还做了一下总结，写了一篇博客——<a href="http://wangzzu.github.io/2016/08/21/java-concurrency/">Java 并发学习(一)</a>，没想到的是面试官问了很多这方面的内容，虽然二面的时候有一些关于 OOM 调试的问题答的不怎么好，但没过几天 X 狐还是给发了 offer，当时可以说我拿到第一个校招，虽然最后没怎么去，还是很感觉 X 狐能给我这次机会的。</p>
<p>面完 X 狐之后又陆陆续续投一批简历，参加了一批笔试，前面已经说了 BAT 的经历，除了 BAT 之外，其他能投的公司并没有多少，之后参加了某滴的内推笔试，笔试挂，某滴今年招了很多的社招的人，B 家听说有很多人跳到了某滴，阿里正明也去滴滴了，某滴今年真是大热，不过由于发展过快，外面也爆出了很多关于某滴内部管理混乱的问题，最近 zf 又出了一系列政策，导致某滴的日子其实也不好过，今年也能明确感受到某滴校招力度较小，总之，没拿到某滴的面试机会。接着又投了某米，参加了某米的笔试，感觉笔试题做的还是不错的，后来通知去面试，面了某米的互娱事业部，一面聊的还挺好，二面问了一些很基础、平且一般接触不到的问题，比如：Java 泛型的设计有什么不好的地方？问的问题有种说不出来的感觉，当时感觉某米应该是可以过的，结果很尴尬，没有收到 offer。之后由于实习拿过XX街的 offer，所以直接参加了XX街的终面，大神华黎亲自面的（不知道华黎是谁，可以看看这本书<a href="http://item.jd.com/11449803.html" target="_blank" rel="external">《大型网站系统与Java中间件实践》</a>，华黎可是当年阿里中间件核心人物之一），后来顺利拿到了 offer，不过因为其他的一些个人原因，没有选择去，很是抱歉。十月底又顺便水了一把华为的面试，也算是见到了华为的壮观面试场景，三点半的面试，等到了6点才面，一面20min 就结束了，而且面试官跟我做的完全不对口，甚至连 CentOS 都没听说过，接着又等到了七点半开始二面，二面还是一对二同时面（一个面试官同时面两个人），面试问的问题基本上就是 hr 问得那些，后来虽然也收到 offer，但总感觉心里没谱，所以就没去，毕竟华为的声名在外啊，对华为的感觉就是，重点看学校、看学习成绩，按学校级别给工资，基本上一看是好学校差不多的话都会要，进去之后估计是再统一培训，有些人比较喜欢这种，我是不太喜欢这种文化，这也是没选择华为的原因之一。</p>
<p>接着说一下，对今年校招的感觉吧，今年的校招的工资整体要比全年高一个档次，但就业其实并没有去年好，只不过是前面那批人把校招工资拉开了一个档次，当然主要的原因还是今年互联网被华为搅得天翻地覆，谁让华为有钱，而且一招招几千甚至上万人。虽然去年也有一些公司工资开得很高，但招的人太少，影响不了互联网大局。华为就不一样了，招人多，还只招好学校的，还就完全不一样了。在之前，华为都是捡漏的，今年不但薪资高，而且校招还特别早，身边真的有很多人选择了华为放弃了 BAT。听说，当初有人拿到 BAT 其中某家的 offer，因为批发价太低，想谈一下工资，结果人家不给谈，他拿到华为 offer 之后直接就放弃了这家，再后来，这家公司开始给之前放弃 offer 的人打电话，表示工资可以谈，而且还开始补招，真是呵里个呵啊（前面的”他”实际上代表的是他们，泛指很多人）。从今年的情况来看华为的影响力还是相当大的，带动了整个互联网的薪酬水平。如果单纯讨论互联网公司，个人感觉今年首先 A 家招人很少，除了实习生转正和内推，基本上没有校招；B 家招人挺多，可能因为这家公司人员流动性比较大，每年招的人都挺多；T 家不太清楚，感觉跟那边不太对口；美团今年招人还是挺多的，比往年招的力度都要大，公司对于技术还是很重视的；某滴招人也不多，可能是社招人太多还有公司业务发展受限的原因；某米，感觉招人也不少吧，记得某米去年只招了100+人，今年发出的 offer 肯定是比这个高的。互联网公司整体校招力度跟去年比可能稍微差一些，不过由于华为今年突然发力，对于好的学校而言，整体的就业形式并不去年差。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里，推荐一篇文章，黑桃夹克师兄当时找工作的时候写的：<a href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/" target="_blank" rel="external">找工作小记——善待挫折</a>，在拿到美团 offer 之前，我也经历一段很不自信、很沮丧的时段，这篇文章在这段时间给我了很大的鼓励，很感谢师兄分享自己的经历。毕竟像师兄这种能到阿里中间件 offer 的牛人，在找工作的时候也并不是一帆风顺的。</p>
<p>最后，说一下个人的感想，我因为一开始就决定了选择走技术这条路，所以基本上也就没有考虑其他行业、其他职位，这个要看个人的选择和职业规划，技术这条路有它的好处，其坏处也很明显，很容易达到职业瓶颈，这个暂时不是我考虑的问题，实际上做技术的人大都在后来慢慢转到管理、产品、运营，甚至去创业去了，能一直在技术上坚持走下去的人并不多，这也说明了技术这条路充满着艰险，并不如想象中的那么好走，这个完全就看个人后期的职业发展了。</p>
<p>在前行的道路上，我们也应该时常停下来多思考思考，想一下自己想要的是什么、想要的生活是什么样的等，下面一句<a href="http://cnbible.com/hosea/4-6.htm" target="_blank" rel="external">圣经：何西阿书 4章6节</a>中一句话作为结束，也希望所有面临校招的童鞋们都拿到适合自己的 offer。</p>
<blockquote>
<p>我的民因无知识而灭亡。你弃掉知识，我也必弃掉你，使你不再给我作祭司。你既忘了你　神的律法，我也必忘记你的儿女。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，是一个很重要的年份，不但是自己的本命年，还是自己要踏出校园、走向工作的一年。从今年过完年回到学校，记得大概是2月底，这期间经历刷题、找实习、校招，直到前两天把三方交上，今天公司盖完章拿到回执信，工作也算终于确定了下来。在这过程中，经历过失落、兴奋、伤心等等，中间
    
    </summary>
    
      <category term="随笔" scheme="http://wangzzu.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://wangzzu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>人类简史，一段不知走向何处的简史</title>
    <link href="http://wangzzu.github.io/2016/10/23/brief-history-of-humankind/"/>
    <id>http://wangzzu.github.io/2016/10/23/brief-history-of-humankind/</id>
    <published>2016-10-23T10:51:40.000Z</published>
    <updated>2016-11-19T09:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>陆陆续续从7月份开始读这本书，直到昨天（10月底）才把这本书，拖这么久之后，发现，书中讲的很多东西已忘记的差不多了，也没有刚开始看前几章时那种爱不释手的感觉。只能根据自己一些浅显的记忆以及当时在书中记录的一些笔记来述说一下自己的感悟。</p>
<p><img src="/images/book/brief-history.jpg" alt="人类简史"></p>
<p>当初想要看这本书，是因为这本书被很多大牛们推荐，而且豆瓣也给出了<a href="https://book.douban.com/subject/25985021/" target="_blank" rel="external">人类简史-豆瓣</a> 9.3分的高分，好评如潮，感觉不得不看看这部神作。关于读书这个问题，这段时间也在同时看<a href="https://book.douban.com/subject/26874593/" target="_blank" rel="external">《技巧》</a>和<a href="https://book.douban.com/subject/26761696/" target="_blank" rel="external">《精进》</a>这两本书，这两本书都提到了学习方法、读书的方法论，作者根据自己的实践经验进行的一些总结。我个人的大概的理解是：如果是读过某本书，并没有去仔细思考， 那就是读死书，效率很低，如果能能够尝试着去理解作者的思维逻辑，然后去思考自己有哪些东西可以学习、借鉴或者是可以丰富自己的知识体系，这才是读书的真谛，想着去学习作者的经验，而不是简简单单地把书读完，等把这两本书读完，到时候会详细记录一下自己的感悟。</p>
<p>关于《人类简史》这本书，在阅读时，作者有很多非常新奇的观点，这些观点至少我之前是没有遇到过的（可能书读的少的原因），下面举几个书中的例子</p>
<blockquote>
<p>然而历史的铁则告诉我们，每一种由想象建构出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。——第八章，历史从无正义</p>
<p>一次又一次，人类要让社会有秩序的方法，就是会将成员分成各种想象出来的阶级，像是上等人、平民和奴隶；白人和黑人；贵族和平民；婆罗门和首陀罗；又或是富人和穷人。所有这些阶级，就是要让某些人在法律上、政治上或社会上高人一等，从而规范了数百万人的关系。——第八章，历史从无正义</p>
</blockquote>
<p>历史上很多出现的东西都只是智人的想象而已，比如古代的皇帝、律法等，现代的金钱、经济制度等，只不过都是我们的想象，但是我们所有人都出在和生活在这个想象之中，要是有一个人否定了这个想象，立马就会人神共愤。而且人类总是不断地去完善这个所谓的自然、必然的结果，当资本主义出现问题的时候，智人开始考虑社会主义，它向智人描述了一种乌托邦的生活愿景，但是终究抵不过人性的恶，社会主义也并没有按照智人原来的意愿去发展，反而束缚了智人。</p>
<blockquote>
<p>人类历史在过去一直是由两大周期来主导：植物的生长周期，以及太阳能的变化周期（白天和黑夜，夏季和冬季）。 ——第十七章 工业的巨轮<br>在水煮沸的那一刻，水壶或锅的盖子会开始跳上跳下。这时热能转换为动能，但是我们过去都只觉得这样乱跳有点烦人，至于一时忘记而让水煮干就更麻烦了。没人注意到这件事的真正潜力。<br>蒸汽机种类繁多，但有一个共同的原则：燃烧某种燃料（例如煤），再用产生的热将水煮沸，产生蒸汽。<br>工业革命的核心，其实就是能源转换的革命。<br>学习如何有效驾驭和转换能量之后，也解决了另一个阻碍经济成长的问题：原料短缺。 ——第十七章 工业的巨轮</p>
</blockquote>
<p>对于作者的这种想法，我当时是感到很震惊的，感觉很能刷新我的认知，工业革命对人类可以是具有划时代的重要历史事件，在作者看来，其本质就是能量的转变，之前的能量变化过程是：植物吸收太阳能，将太阳能转换为食物的能量，人类或者牛拿到这部分能量之后，再来干别的事情（人类的活动、牛耕地等活动），进行能量转换。而工业革命之后的过程是：煤（动植物存储的能量）的能量转换动能（蒸汽机），动能再进行转换，这极大地提高了智人利用能源的方式，在这个基础上，智人开始利用蒸汽机技术进行航海、火车、工厂等活动。关于最后一句，可以这样理解，人类可以利用的能源暂时可以说无穷尽的，现在还有很多已知的能量我们还不能高效地利用，更别提还有很多未知的、潜在的能量了，在不同的阶段人类利用能量的方式也不一样。举个例子：人类现在每年消耗的能量总和，地球只需要短短90分钟就可以从太阳接收这么多能量，所以对于人类来说，能量是无穷尽的，只是我们暂时还不能高效地去获取或利用这些能量。</p>
<p>文章中有很多类似的观点，包括后来金钱的由来、宗教的发展等，作者站在一个更高的地方去看待整个历史进程，而不是单纯地从历史、文化等角度，向读者展示了一个不同的视角。下面引用一段豆瓣中的内容简介</p>
<blockquote>
<p>十万年前，地球上至少有六种不同的人<br>但今日，世界舞台为什么只剩下了我们自己？<br>从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，<br>从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，<br>从认知革命、农业革命，到科学革命、生物科技革命，<br>我们如何登上世界舞台成为万物之灵的？<br>从公元前1776年的《汉摩拉比法典》，到1776年的美国独立宣言，<br>从帝国主义、资本主义，到自由主义、消费主义，<br>从兽欲，到物欲，从兽性、人性，到神性，<br>我们了解自己吗？我们过得更快乐吗？<br>我们究竟希望自己得到什么、变成什么？</p>
</blockquote>
<p>可以说，《人类简史》这本书就是围绕着上述问题来讲述的，作者使用很多假设、推断去思考这些问题，虽然并不一定完全准确，但对很多的问题的分析表达的逻辑都很清晰，这是这本书的牛X 之处。</p>
<p>在人类历史之初，这个世界应该是有很多的人种，但到最后只剩下智人一种，其他的人类种族都已经从这个世界上消失，这是什么原因，如果说这是自然灾害或是其他的原因，肯定不能使人信服。而且这些种族的灭绝都是在智人到达他们的居住地之后发生的，这就不得不使人相信：因为食物的争夺，智人消灭了他们或者是同化了他们，在那个时代，争夺食物实际上就是让自己或自己族群活下去的唯一办法，也只有达尔文的进化论能够解释通这种现象——适者生存，但是这到底是正确的还是错误的？到现在我们依然没有答案，当然如果说这个理论是合理的或是合法的，智人现在就可以肆无忌惮杀害其他物种，甚至可以可以杀害不适的智人，所以，有一点是确定的，现代达尔文主义是错误的，甚至比纳粹还要可怕，这不是人类想要的结果。</p>
<p>智人从一开始消灭其他人种，爬上食物链顶端，可以说认知革命的结果，认知革命让智人开始拥有智慧，智人可以以族群进行生活，建立社群，为了生活大家一起合作。虽然智人人口的增加了，时间一长，又发生了农业革命，智人不再经常去迁徙，而是在一个地方固定居住下来，开始种植植物、训练动物，逐步出现了村落、城市、国家，而随着这些概念的出现，又开始出现了法律、制度以及非农业人员，到最后出现国王等，现在看起来很容易理解过程，但是智人走了近十万年。从十万年前智人开始出现，到5000年前世界上第一个国家开始出现，这中间足足有十万年。</p>
<p>再看一下制度的发展，从公元前1776年的《汉摩拉比法典》，到1776年的美国独立宣言，这中间又走了三千多年。这三千年，智人从最初的一个国家雏形到最后建立一个真正意义的现代国家。在最初的农业社会，智人都是以家庭或者社群为单位生活，甚至金融、养老、处罚等都是以家庭为单位进行，几千年来都是这样，甚至中国现在一些落后的农村仍然是这样（指的是金融和养老这部分，关于这方面，可以参考陈志武老师的书）。但后来自从国家、市场的概念出来以后，就不断冲击着传统的以家庭为社会单位的地位，当然这是工业革命为整个人类带来的巨大变化。工业革命的发展，更加强化了国家、市场这些概念，甚至也驱使了后来的大航海时代、一战、二战等。似乎这几千年来，智人取得了非常巨大的成就，甚至随着现代科技的发展，尤其是现代基因工程，智人开始干预造物主的工作。但是，从开始的社群主义、帝国主义、资本主义到自由主义和消费主义，以及智人从兽欲，到物欲，从兽性、人性，到神性，智人是否了解自己？智人过得到底快乐吗？</p>
<p>关于这点，我们先看一下佛教是如何解释的</p>
<blockquote>
<p>人想要离苦得乐，就必须了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受。如此一来，虽然感受疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明、自在。这样产生的心灵平静力量强大，那些穷极一生疯狂追求愉悦心情的人完全难以想象。</p>
</blockquote>
<p>佛教与现代生物学和新世纪运动的相同点，在于都认定快乐不在于外在条件。但佛教更重要也更深刻的见解在于，真正的快乐也不在于我们的主观感受。我们如果越强调主观感受，反而就越感到苦。佛教给我们的建议是，除了别再追求外在成就之外，同时也别再追求那些感觉良好的心里感受了。但现代的自由主义则劝我们去追求内心想要的东西，但我们内心到底想要什么？恐怕智人到现在也不清楚自己自己到底想要什么？</p>
<p>最后引用本书的后记作为结尾。</p>
<blockquote>
<p>变成神的这种动物</p>
<p>在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。</p>
<p>但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。</p>
<p>在过去的几十年间，至少就人类的生存条件而言有了确实的进步，饥荒、瘟疫和战争都已减少。然而，其他动物的生存条件却是以前所未有的速度急遽恶化，而且就算是人类相关的改进，也还需要再长时间观察才能判断是否利大于弊，是否能够延续。</p>
<p>此外，虽然现在人类已经拥有许多令人赞叹的能力，但我们仍然对目标感到茫然，而且似乎也仍然总是感到不满。我们的交通工具已经从独木舟变成帆船、变成汽船、变成飞机，再变成航天飞机，但我们还是不知道自己该前往的目的地。我们拥有的力量比以往任何时候都更强大，但几乎不知道该怎么使用这些力量。更糟糕的是，人类似乎也比以往任何时候更不负责。我们让自己变成了神，而唯一剩下的只有物理法则，我们也不用对任何人负责。正因如此，我们对周遭的动物和生态系统掀起一场灾难，只为了寻求自己的舒适和娱乐，但从来无法得到真正的满足。</p>
<p>拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫过于如此了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;陆陆续续从7月份开始读这本书，直到昨天（10月底）才把这本书，拖这么久之后，发现，书中讲的很多东西已忘记的差不多了，也没有刚开始看前几章时那种爱不释手的感觉。只能根据自己一些浅显的记忆以及当时在书中记录的一些笔记来述说一下自己的感悟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
    
    </summary>
    
      <category term="书屋" scheme="http://wangzzu.github.io/categories/%E4%B9%A6%E5%B1%8B/"/>
    
    
      <category term="思考" scheme="http://wangzzu.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>json 对象添加 double 型数值遇到的问题</title>
    <link href="http://wangzzu.github.io/2016/10/15/json-kafka-bug/"/>
    <id>http://wangzzu.github.io/2016/10/15/json-kafka-bug/</id>
    <published>2016-10-15T12:49:56.000Z</published>
    <updated>2016-11-19T09:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个关于修改 Kafka 源码时遇到的一个 bug，以及后续引起的一些思考。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我们的目标是将 Kafka 中的 <code>Producer</code> 和 <code>Consumer</code> 客户端提供的 metrics，写入到一个 Json 对象中，然后再将这个 Json 对象通过 Http 请求发送到一个 service 服务上。</p>
<p>Kafka 原生提供的 metrics 信息非常多，这些 metrics 信息的大概内容如下图所示。</p>
<p><img src="/images/kafka/kafka-metrics.png" alt="Client Metrics"></p>
<p>在使用下面代码将 metrics 写入到 json 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Map.Entry&lt;MetricName, ? extends Metric&gt; metricEntry : metrics.entrySet()) &#123;</div><div class="line">	jsonObject.put(metricEntry.getKey().toString(),metricEntry.getValue().value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这部分是直接添加到 <code>kafka-client</code> 中的，将 <code>kafka-client</code> 打包后，再依赖这个 jar 包，client 在启动时就报了错误，但是并没有退出。</p>
<h1 id="原因查找"><a href="#原因查找" class="headerlink" title="原因查找"></a>原因查找</h1><p>刚开始以为json 对象的大小超出了 Http 协议中的长度限制，因为重写了 <code>MetricName</code> 类的 <code>toString()</code> 方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toFlitString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"MetricName [name="</span> + name + <span class="string">", group="</span> + group + <span class="string">", tags="</span> + tags + <span class="string">"]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将长度过长而且用途不大的 <code>description</code> 字段去掉，但是结果依然，并没有解决问题。</p>
<p>接下来为了想知道是往 json 对象添加 metrics 这部分是否执行，因此在 <code>for</code> 循环内添加了一行输出，最后发现输出十行后程序就不再输出，这一行的内容如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Key: MetricName [name=request-latency-max, group=consumer-node-metrics, description=, tags=&#123;client-id=consumer-1, node-id=node-2&#125;]	Value: -Infinity</div></pre></td></tr></table></figure>
<p>这时候发现了 <code>-Infinity</code> 这个值，参考这篇文章 <a href="http://www.cnblogs.com/zhisuoyu/archive/2016/03/24/5314541.html" target="_blank" rel="external">java中的NAN和INFINITY</a>，才知道这是一个特殊的值，所以就怀疑是这个问题，因此，写了一个小测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.meituan.kafka.json;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.json.JSONObject;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by wangmeng on 15/10/2016.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</div><div class="line">        jsonObject.put(<span class="string">"name"</span>,<span class="string">"matt"</span>);</div><div class="line">        jsonObject.put(<span class="string">"age"</span>,<span class="number">24</span>);</div><div class="line">        jsonObject.put(<span class="string">"double"</span>,<span class="number">10</span>/<span class="number">0.0</span>);</div><div class="line">        System.out.println(jsonObject.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序结果真是报错，报错内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; org.json.JSONException: JSON does not allow non-finite numbers.</div><div class="line">	at org.json.JSONObject.testValidity(JSONObject.java:1578)</div><div class="line">	at org.json.JSONObject.put(JSONObject.java:1291)</div><div class="line">	at org.json.JSONObject.put(JSONObject.java:1220)</div><div class="line">	at com.meituan.kafka.json.JsonTest.main(JsonTest.java:13)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>
<p>因此，查看了一下 <code>org.json.JSONObject.testValidity</code> 源码，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Put a key/value pair in the JSONObject. If the value is null, then the</div><div class="line"> * key will be removed from the JSONObject if it is present.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key</div><div class="line"> *            A key string.</div><div class="line"> * <span class="doctag">@param</span> value</div><div class="line"> *            An object which is the value. It should be of one of these</div><div class="line"> *            types: Boolean, Double, Integer, JSONArray, JSONObject, Long,</div><div class="line"> *            String, or the JSONObject.NULL object.</div><div class="line"> * <span class="doctag">@return</span> this.</div><div class="line"> * <span class="doctag">@throws</span> JSONException</div><div class="line"> *             If the value is non-finite number or if the key is null.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">put</span><span class="params">(String key, Object value)</span> <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null key."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">        testValidity(value);</div><div class="line">        <span class="keyword">this</span>.map.put(key, value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.remove(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Throw an exception if the object is a NaN or infinite number.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> o</div><div class="line"> *            The object to test.</div><div class="line"> * <span class="doctag">@throws</span> JSONException</div><div class="line"> *             If o is a non-finite number.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testValidity</span><span class="params">(Object o)</span> <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double) &#123;</div><div class="line">            <span class="keyword">if</span> (((Double) o).isInfinite() || ((Double) o).isNaN()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(</div><div class="line">                        <span class="string">"JSON does not allow non-finite numbers."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Float) &#123;</div><div class="line">            <span class="keyword">if</span> (((Float) o).isInfinite() || ((Float) o).isNaN()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(</div><div class="line">                        <span class="string">"JSON does not allow non-finite numbers."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查到这里，找到了具体的原因，对 <code>Double</code> 类型的对象，其值不能为 <code>NAN</code> 和 <code>INFINITY</code>，下面再看一下这个两个值在 java 中是如何定义的，对于 double 型的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Double</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding the positive infinity of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equal to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff0000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding the negative infinity of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equal to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0xfff0000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY = -<span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding a Not-a-Number (NaN) value of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equivalent to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff8000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</div><div class="line">    .....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，对于这个问题，我们已经完整地解决了，并且也查找到了最终的原因。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>之前的文章，总是会写<code>写在前面</code>这一章，本文写了一章<code>写在最后</code>。</p>
<p>这本是一个 bug，实际上并没必要写成一篇文章进行分析，而我这样做的原因是：告诉自己，或者是提醒自己，遇到问题，不但要想着解决问题，还要深入理解这个问题产生的原因。</p>
<p>以前自己在开发中，遇到过很多的坑，很多坑，找到解决办法之后就过去了，后来好久之后再遇到这个问题时，结果还需要花一些时间去查找，一个是自己的记性确实不是太好，另一个当时并没有对遇到的问题深入剖析，把问题的内部原因详细记录下来，希望这篇文章是一个起点，以后博客中，不但要有总结性的文章、思考性的文章，还要有一些详细剖析 bug 的文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个关于修改 Kafka 源码时遇到的一个 bug，以及后续引起的一些思考。&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;我们的目标是将 Kafka 
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="bug" scheme="http://wangzzu.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>JVM 学习——垃圾收集器与内存分配策略</title>
    <link href="http://wangzzu.github.io/2016/09/18/jvm-basic2/"/>
    <id>http://wangzzu.github.io/2016/09/18/jvm-basic2/</id>
    <published>2016-09-18T06:03:43.000Z</published>
    <updated>2016-11-19T09:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对《深入理解java虚拟机 第二版》第三章部分做的总结，文章中大部分内容都来自这章内容，也是博客 JVM 学习的第二部分。</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>说到垃圾收集（Garbage Collection，GC），很多人可能会认为这是 Java 自有的特性，曾经我也一度这样想，后来才知道 GC 的历史要远远长于 Java，它第一次真正使用是在 Lisp 中，现在，像 python、go 等都有自己的垃圾收集器。在 GC 最开始设计时，人们在思考 GC 时就需要完成三件事情：</p>
<ol>
<li>哪些内存需要进行回收？</li>
<li>什么时候对这些内存进行回收？</li>
<li>如何进行回收？</li>
</ol>
<p>经过将近半个多世纪的发展，内存的动态分配与垃圾回收技术现在已经非常成熟，看起来是进入半自动化时代，但是我们依然需要去学习 GC 和内存分配，因为，当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这一块进行必要的监控和调节。</p>
<p>回到 Java 语言，在前面介绍的 Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不絮地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此，这几块区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分的内存和回收都是动态的，垃圾回收器主要关注的也是这部分的内存。</p>
<h1 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h1><p>Java 的堆里存放的几乎所有的对象实例，在进行垃圾回收前，第一件事情就是要确定哪些对象还”存活”着、哪些对象已经”死去”（即不可能再被任何途径使用的对象）。</p>
<h2 id="判断的方法"><a href="#判断的方法" class="headerlink" title="判断的方法"></a>判断的方法</h2><h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
  </p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>基本思想：通过一系列的称为 <strong>GC Roots</strong> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain)，当一个对象到GC Roots没有任何引用链时，则证明此对象是不可用的。</p>
<p>在 Java 中，可作为 GC Roots 的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
</ol>
<h3 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h3><table>
<thead>
<tr>
<th></th>
<th>引用计数法</th>
<th>可达性分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>实现简单，效率高（很少使用这种方法）</td>
<td>在主流的商业程序语言（Java、C#等）的主流实现中，都使用这种方法</td>
</tr>
<tr>
<td>缺点</td>
<td>无法解决对象之间相互循环引用问题（主流的 JVM 都没有使用这种方法）</td>
<td>实现稍微有些复杂</td>
</tr>
</tbody>
</table>
<h2 id="对象的四种引用"><a href="#对象的四种引用" class="headerlink" title="对象的四种引用"></a>对象的四种引用</h2><p>在 Java 中，如果仅仅把对象分为引用和没有被引用这两种状态，那么在一些场景下就无能为力了，比如：我们希望有这样一类对象，当内存空间充足时，则能保留在内存之中，而如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。因此，在 JDK1.2 之后，Java 就对引用的概念进行了扩充，将引用非为一下四种：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>定义</th>
<th>声明方式</th>
<th>回收条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用（ Strong Reference）</td>
<td>强引用就是指在程序代码之中普遍存在的</td>
<td>类似于<code>Object obj= new Object()</code> 这类的引用</td>
<td>只要强引用还在，永不会回收</td>
</tr>
<tr>
<td>软引用（ Soft Reference）</td>
<td>软引用是用来描述一些还有用但并非必需的对象</td>
<td>使用<code>SoftReference</code> 类来声明</td>
<td>系统将要发生内存溢出异常之前，将会把这些对象列入回收范围，进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</td>
</tr>
<tr>
<td>弱引用（ Weak Reference）</td>
<td>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些</td>
<td>使用 <code>WeakReference</code> 类实现弱引用</td>
<td>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</td>
</tr>
<tr>
<td>虚引用（WeakReference）</td>
<td>它是最弱的一种引用关系，一个引用是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</td>
<td>使用<code>PhantomReference</code> 类来实现虚引用</td>
<td>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</td>
</tr>
</tbody>
</table>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法；</li>
<li>当对象没有覆盖 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，虚拟机将这两种情况都视为<strong>没有必要执行</strong>；</li>
<li>如果对象要在 <code>finalize()</code> 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。 任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次。</li>
</ol>
<p>这里有两点要注意：</p>
<ol>
<li>如果一个对象被判定有必要执行 <code>finalize()</code> 方法，那这个对象会先被放置在一个叫做 <code>F-Queue</code> 的队列中，并由虚拟机自动建立的、低优先级的 <code>Finalizer</code> 线程去执行它。这里的 “执行” 指的是虚拟机会触发这个方法，但不会承诺等待它运行结束，原因是：如果一个对象在执行 <code>finalize()</code> 时运行缓慢，或者发生死循环，将很有可能导致 <code>F-Queue</code> 队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。</li>
<li>不鼓励大家使用这种方法来拯救对象。相反，建议大家尽量避免使用它，因为它不是 C/ C++ 中的析构函数，而是 Java 刚诞生时为了使 C/ C++ 程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 关闭外部资源，使用 <code>try- finally</code> 或者其他方式都可以做得更好、更及时，所以笔者大家完全可以忘掉 Java 语言中有这个方法的存在。</li>
</ol>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（或者 HotSpot 的永久代）是没有垃圾收集的，Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价” 一般比较低。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<p>判断一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻很多。类需要同时满足下面 3 个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收；</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收；</li>
<li>该类对应的 <code>java. lang. Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>是否对类进行回收， HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose: class</code> 以及 <code>-XX:+ TraceClassLoading</code>、<code>- XX:+ TraceClassUnLoading</code> 查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、 CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>本节主要是介绍一下垃圾收集算法的思想，并不涉及具体的实现。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法，有两个阶段</p>
<ol>
<li>首先标记所有需要回收的对象；</li>
<li>在标记完成后统一进行回收。</li>
</ol>
<p>执行过程如下图所示。</p>
<p><img src="/images/java/jvm/mark-sweep.png" alt="mark-sweep"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p>算法执行过程如下图所示</p>
<p><img src="/images/java/jvm/copy.png" alt="copy"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor[ 1]。 当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<p>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8: 1。 当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（ Handle Promotion）。 如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-整理算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>算法执行过程如下图所示</p>
<p><img src="/images/java/jvm/mark-compact.png" alt="mark-compact"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用分代收集（ Generational Collection） 算法。</p>
<p>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</li>
</ul>
<h2 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h2><table>
<thead>
<tr>
<th>算法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记-清除</td>
<td>最基础的算法，不是一般的简单</td>
<td>一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片</td>
</tr>
<tr>
<td>复制</td>
<td>实现简单，运行高效</td>
<td>减少了内存使用空间；而且在对象存活率较高时需要进行较多的复制操作（不适合老年代）</td>
</tr>
<tr>
<td>标记-整理</td>
<td>根据老年代的特点提出的一种算法，适合老年代</td>
<td>只适合于某些特定情况</td>
</tr>
<tr>
<td>分代收集</td>
<td>使用多种收集算法，根据各自的特点选用不同的收集算法</td>
<td>在具体的实现上比前面的更加复杂</td>
</tr>
</tbody>
</table>
<h1 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h1><p>上面介绍的基础的理论，这一节讲述一下 HotSpot 虚拟机如何实现这些算法的。</p>
<h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的。</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>在 OopMap 的协助下， HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得更高。</p>
<p>实际上，HotSpot 并没有为每条指令都生成 OopMap，而只是在 “特定的位置” 记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在达到安全点时才能暂停。</p>
<p>Safepoint 的选定既不能太少以至于让 GC 等待时间太长，也不能多余频繁以至于过分增大运行时的负载。所以，安全点的选定基本上是以 “是否具有让程序长时间执行的特征” 为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，”长时间执行” 的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。</p>
<p>对于 Safepoint， 另一个需要考虑的问题是如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都“跑”到最近的安全点上再停顿下来： 抢先式中断（ Preemptive Suspension） 和主动式中断（ Voluntary Suspension）</p>
<ol>
<li>抢占式中断：它不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它 “跑” 到安全点上。</li>
<li>主动式中断：当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ol>
<p>现在<strong>几乎没有虚拟机采用抢占式中断来暂停线程从而响应 GC 事件</strong>。</p>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>在使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际上情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但如果程序在 “不执行” 的时候呢？所谓程序不执行就是没有分配 CPU 时间，典型的例子就是处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，JVM 也显然不太可能等待线程重新分配 CPU 时间。对于这种情况，就需要<strong>安全区域（Safe Regin）</strong>来解决了。</p>
<p>在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾收集器是内存回收的具体实现，这里讨论的收集器是 JDK 1.7 Update 14 之后的 HotSpot 虚拟机（目前 G1 仍然处于实验状态），这个虚拟机包含的所有收集器如下图所示。</p>
<p><img src="/images/java/jvm/hotspot.png" alt="hotspot"></p>
<p>下面会介绍一下这几种收集器的特性、基本原理和使用场景，并重点分析 CMS 和 G1 这两个相对复杂的收集器，了解它们的部分运作细节。</p>
<blockquote>
<p>注：这里只是介绍这些收集器，进行一下比较，但并非是挑选一个最好的收集器，目前到现在为止还没有最好的收集器出现，更没有万能的收集器，我们只是选择对具体应用最合适的收集器。</p>
</blockquote>
<h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>它曾是最基本、发展历史最悠久的收集器，它是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会是使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。<strong>Stop The World</strong> 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图展示了 Serial/Serial old 收集器的运行过程。</p>
<p><img src="/images/java/jvm/serial.png" alt="serial"></p>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。ParNew/Serial old 收集器的运行过程如下图所示</p>
<p><img src="/images/java/jvm/parnew.png" alt="ParNew"></p>
<p>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。（CMS收集器第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。）</p>
<p>CMS 作为老年代的收集器，却无法与 JDK 1. 4. 0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，只能选择ParNew或者Serial收集器中的一个。ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 选项后的默认新生代收集器，也可以使用 <code>-XX:+UseParNewGC</code> 选项来强制指定它。</p>
<p>由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。但是，当 CPU 的数量增加时，它对于 GC 时系统资源的有效利用还是很有好处的，它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（使用超线程时）的环境下，可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。</p>
<h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>它与其他收集器的不同之处在于：它的关注点与其他收集器不同。CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（ Throughput）。</p>
<blockquote>
<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
</blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量：</p>
<ol>
<li>控制最大垃圾收集停顿时间， <code>-XX:MaxGCPauseMillis</code>，设置时间小一点并不能使用系统的收集速度更快，因为 GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的；</li>
<li>直接设置吞吐量大小， <code>-XX:GCTimeRatio GC</code>，CTimeRatio是指垃圾收集时间占总时间的比率。</li>
</ol>
<p>Parallel Scavenge 收集器经常称为 “吞吐量优先” 收集器。Parallel Scavenge 收集器还提供一个参数 <code>-XX:+ UseAdaptiveSizePolicy</code>，当这个参数打开后，就不需要收工指定一些细节参数了（如：新生代的大小等），虚拟机会动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为<strong>GC 自适应的调解策略（GC Ergonomics）</strong>。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>
<h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 “标记-整理” 算法。</p>
<p>这个收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，那么它主要还有两大用途：</p>
<ol>
<li>在 JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用；</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ol>
<p>Serial Old 收集器的工作过程如下图所示</p>
<p><img src="/images/java/jvm/serial.png" alt="serial"></p>
<h2 id="Parallel-old-收集器"><a href="#Parallel-old-收集器" class="headerlink" title="Parallel old 收集器"></a>Parallel old 收集器</h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。 这个收集器是在 JDK 1. 6 中才开始提供的。在此之前，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（ PS MarkSweep） 收集器外别无选择（还记得上面说过 Parallel Scavenge 收集器无法与 CMS 收集器配合工作吗？）。由于老年代 Serial Old 收集器在服务端应用性能上的拖累，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。</p>
<p>知道 Parallel old 收集器出现后，”吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel old 收集器，Parallel old 收集器的工作过程如下图所示</p>
<p><img src="/images/java/jvm/parallelold.png" alt="Parallel Old"></p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间为目标，多数应用于互联网站或者B/S系统的服务器端上。</p>
<p>CMS 是基于 “标记—清除” 算法实现的，整个过程分为4个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>有以下几个特点：</p>
<ul>
<li>其中，初试标记、重新标记这两个步骤仍然需要 “Stop The World”；</li>
<li>初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快；</li>
<li>并发标记阶段就是进行 GC Roots Tracing 的过程；</li>
<li>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初试标记阶段稍长一些，但远比并发标记的时间短。</li>
</ul>
<p>CMS 收集器的运作步骤如下图所示，在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="/images/java/jvm/cms.png" alt="cms"></p>
<ul>
<li>优点<ol>
<li>并发收集、低停顿， Sun 公司的一些官方文档中也称之为并发低停顿收集器（ Concurrent Low Pause Collector）。</li>
</ol>
</li>
<li>缺点<ol>
<li>CMS 收集器对 CPU 资源非常敏感。</li>
<li>CMS 收集器无法处理浮动垃圾（ Floating Garbage），可能出现 “Concurrnet Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 <code>-XX: CMSInitiatingOccupancyFraction</code> 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。要是 CMS 运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 <code>-XX: CM SInitiatingOccupancyFraction</code> 设置得太高很容易导致大量” Concurrent Mode Failure” 失败，性能反而降低。</li>
<li>收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次 Full GC。CMS 收集器提供了一个 <code>-XX:+UseCMSCompactAtFullCollection</code> 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
</ol>
</li>
</ul>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>  G1 是一款面向服务器应用垃圾收集器，与其他GC收集器想必，G1具备以下特点：</p>
<ol>
<li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短 Stop The World 停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1 收集器仍然可以通过并发的方式让Java程序继续执行；</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一半时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：与CMS的 “标记-清理” 算法不同，G1从整体上看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间)上来看是基于“复制”算法实现，无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。</li>
<li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，小号在垃圾收集上的时间不能超过N毫秒，这几乎已经是实时Java(RTSJ）的垃圾收集器的特征了。<br>  <br>下图展示 G1 收集器的运行步骤</li>
</ol>
<p><img src="/images/java/jvm/g1.png" alt="G1"></p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记（Initial Marking）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短；</li>
<li>并发标记（Concurrent Marking）：从 GC Roots 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li>
<li>最终标记（Final Marking）：最终标记则是为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行；</li>
<li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划，根据 Sun 公司透露的信息来看，这个阶段是可以做到与用户程序并发执行。</li>
</ol>
<h2 id="垃圾收集器对比"><a href="#垃圾收集器对比" class="headerlink" title="垃圾收集器对比"></a>垃圾收集器对比</h2><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>特性</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial 收集器</td>
<td>复制算法；单线程；新生代；简单而高效；需要进行 stop the world。</td>
<td>它是虚拟机运行在 Client 模式下的默认新生代收集器</td>
</tr>
<tr>
<td>ParNew 收集器</td>
<td>复制算法；Serial 的多线程版本；新生代；默认的线程数与 CPU 数一致</td>
<td>它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。</td>
</tr>
<tr>
<td>Parallel Scavenge 收集器</td>
<td>复制算法；并行多线程；新生代；吞吐量优先原则；有自适应调节策略</td>
<td>适合后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Serial Old 收集器</td>
<td>标记-整理算法；老年代；单线程；</td>
<td>这个收集器的主要意义在于给 Client 模式下的虚拟机使用</td>
</tr>
<tr>
<td>Parallel Old 收集器</td>
<td>标记-整理；老年代；多线程；与 parallel scavenge 收集器结合实现吞吐量优先</td>
<td>与 Parallel Scavenge 结合使用，适用那些注重吞吐量以及对 CPU 资源敏感的场合</td>
</tr>
<tr>
<td>CMS 收集器</td>
<td>标记-清除；老年代；并发收集、低停顿；有三个缺点（参见上面）</td>
<td>非常适合那些重视响应速度，希望系统停顿时间最短的应用</td>
</tr>
<tr>
<td>G1 收集器</td>
<td>分代收集；空间整合；可预测的停顿</td>
<td>面向服务器应用垃圾收集器</td>
</tr>
</tbody>
</table>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>Jvm运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器进行垃圾回收</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用ParNew + CMS + Serial Old的收集器组合进行内存回收，Serial Old作为CMS出现“Concurrent Mode Failure”失败后的后备收集器使用。</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Jvm运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>使用Parallel Scavenge + Parallel Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Subrvivor = 8:1</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄，每次Minor GC之后，年龄就加1，当超过这个参数的值时进入老年代</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>动态调整java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>-XX:+HandlePromotionFailure</td>
<td>是否允许新生代收集担保，进行一次minor gc后, 另一块Survivor空间不足时，将直接会在老年代中保留</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>设置并行GC进行内存回收的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio GC</td>
<td>时间占总时间的比列，默认值为99，即允许1%的GC时间，仅在使用Parallel Scavenge 收集器时有效</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间，在Parallel Scavenge 收集器下有效</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%，仅在CMS收集器时有效，-XX:CMSInitiatingOccupancyFraction=70</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>由于CMS收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在CMS收集器时有效</td>
</tr>
<tr>
<td>-XX:+CMSFullGCBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与UseCMSCompactAtFullCollection参数一起使用</td>
</tr>
<tr>
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型优化</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>是否关闭手动System.gc</td>
</tr>
<tr>
<td>-XX:+CMSParallelRemarkEnabled</td>
<td>降低标记停顿</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小不可设置过大，会影响Perm的大小，-XX:LargePageSizeInBytes=128m</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>告诉虚拟机在发送垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配情况</td>
</tr>
</tbody>
</table>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>本节主要探讨给对象分配内存的部分，对象主要分配在新生代的 Eden 区上，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，取决于使用的哪种垃圾收集器组合以及 jvm 的参数设置。下面会介绍几条最普遍的内存分配规则。</p>
<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。</p>
<ol>
<li>新生代 GC（ Minor GC）： 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>老年代 GC（ Major GC/ Full GC）： 指发生在老年代的 GC， 出现了 Major GC， 经常会伴随至少一次的 Minor GC（ 但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。 Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li>
</ol>
<p>堆空间分配例子：</p>
<p><code>-verbose: gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails -XX:SurvivorRatio=8</code></p>
<p>在运行时通过 <code>-Xms20M</code>、<code>-Xmx20M</code>、<code>-Xmn10M</code> 这 3 个参数限制了 Java 堆大小为 20MB， 不可扩展，其中 10MB 分配给新生代，剩下的 10MB 分配给老年代。<code>-XX:SurvivorRatio=8</code> 决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8: 1</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>大对象对虚拟机的内存分配来说是一个坏消息（）遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”它们。</p>
<p><code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配（避免了在 Eden 以及两个 Survivor 区之间发送大量的内存复制）。 <code>PretenureSizeThreshold</code> 参数只对 Serial 和 ParNew 两款收集器有效， Parallel Scavenge 收集器不认识这个参数。</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。 对象在 Survivor 区中每熬过一次 Minor GC， 年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX: MaxTenuringThreshold</code> 设置。</p>
<h2 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h2><p>为了适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 <code>MaxTenuringThreshold</code> 才能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。当大量对象在 Minor GC 后仍绕存活，就需要老年代进行空间分配担保，把 Survivor 无法容纳的对象直接进入老年代。如果老年代的判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次 Full GC。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1472975542&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">深入理解java虚拟机</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对《深入理解java虚拟机 第二版》第三章部分做的总结，文章中大部分内容都来自这章内容，也是博客 JVM 学习的第二部分。&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://wangzzu.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习——java 内存区域与内存溢出分析</title>
    <link href="http://wangzzu.github.io/2016/09/07/jvm-basic1/"/>
    <id>http://wangzzu.github.io/2016/09/07/jvm-basic1/</id>
    <published>2016-09-07T13:03:43.000Z</published>
    <updated>2016-11-19T09:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对《深入理解java虚拟机 第二版》第二章部分做的总结，文章中大部分内容都来自这章内容，之所以记录到博客，是想通过这个过程加深自己的理解，并且方便以后遇到相关问题之后进行查阅。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>Java 虚拟机所管理的内存包括以下几个运行时数据区域，如下图所示。</p>
<p><img src="/images/java/jvm/jvm.png" alt="jvm"></p>
<ul>
<li>线程间共享区域：方法区和堆；</li>
<li>线程间私有区域：虚拟机栈、本地方法栈和程序计数器。</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>特点：</p>
<ol>
<li>它是一块较小的内存空间，可以看出当前线程所执行的字节码的行号指示器；</li>
<li>字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都要靠它完成；</li>
<li>每个线程都有一个自己的计数器，线程之间的计数器互不影响；</li>
<li>JVM多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的；</li>
<li>执行Native方法时，计数器不起作用，职位空缺（null）；</li>
<li>此区域是唯一没有规定OOM的区域。</li>
</ol>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frmae）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表存放了编译期可知的基本数据类型（boolean、byte、char、shot、int、float、long、double）、对象引用（reference 类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>其中，long、double因为长度为64bit，会占用两个Slot，其余的数据类型只占用一个。由此可知局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>虚拟机栈中可能会出现两种异常情况：</p>
<ol>
<li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度.</li>
<li><code>OutOfMemoryError</code>：虚拟机栈动态扩展内存时，无法申请到足够的内存.</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈作用很相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java Heap 是 jvm 所管理的内存中最大的区域。Java Heap 是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例和数组都在这里分配内存。</p>
<p>Java Heap 是垃圾收集器管理的主要区域，也叫做 GC 堆。其可细分为新生代和老年代，而新生代又可分为Eden 空间、From Survivor 空间和 To Survivor 空间。</p>
<p>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code> 和<code>-Xms</code>控制）。但如果在堆中没有内存完成实例分配，并且也无法再扩展时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>特点</p>
<ol>
<li>线程间共享的内存区域；</li>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li>
<li>当方法区无法满足内存的分配需求时，将抛出 <code>OutOfMemoryError</code> 异常；</li>
</ol>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池 Runtime Constant Pool"></a>运行时常量池 Runtime Constant Pool</h2><p>特点</p>
<ol>
<li>属于方法区的一部分，</li>
<li>保存Class文件中描述的符号引用和各种字面量.</li>
<li>因为是方法区的一部分，所以会受到方法区内存的限制，当常量池无法再申请到内存时，抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h2 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存 Direct Memory"></a>直接内存 Direct Memory</h2><ol>
<li>直接内存不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也可能会出现 <code>OutOfMemoryError</code> 异常；</li>
<li>在 JDK 1.4 中新加入了 NIO（<code>New Input/Output</code>），引入 <code>Channel</code> 和 <code>Buffer</code> 的 I/O 方式，它可以用 <code>native</code> 方法申请堆外内存，然后通过 JVM 堆中的 <code>DirectByteBuffer</code> 对象操作这块内存，在一些场景下可以显著提高性能（零拷贝）；</li>
<li>虽然本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。开发者在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h1 id="HotSpot虚拟机对象解密"><a href="#HotSpot虚拟机对象解密" class="headerlink" title="HotSpot虚拟机对象解密"></a>HotSpot虚拟机对象解密</h1><p>在了解了JVM 内存的概况之后，这里再介绍一下这些虚拟机内存中的数据的其它细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样设计细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。这里我们以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，深入学习 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java 是一门面向对象的编程语言，在 Java 中无时无刻都有对象被创建出来。在语言层次上，创建对象（例如克隆、反序列化）通常只是一个 <code>new</code> 关键字而已，本小节主要讨论一下对与一个普通的 Java 对象（不包括数组和 Class 对象等）创建的过程是怎样的？</p>
<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>当虚拟机遇到一条 <code>new</code> 指令时，虚拟机会进行以下步骤创建对象。</p>
<ol>
<li>将先去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行响应的类加载过程（这部分本文暂时不涉及）；</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来；</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（这步操作保证了对象的实例字段在 Java 代码中可以不赋初值就可以直接使用）；</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象的对象头（Object Header）之中。</li>
</ol>
<p>这些步骤结束之后，对于虚拟机来说，一个新的对象已经产生了，但是从 Java 角度来看，对象创建才刚刚开始，还没有对对象进行初始化操作。</p>
<h3 id="堆内存分配方法"><a href="#堆内存分配方法" class="headerlink" title="堆内存分配方法"></a>堆内存分配方法</h3><p>从上节的第二步中可以看到，虚拟机为新生对象分配内存，相当于把一块固定大小的内存从 Java 堆中划分出来。</p>
<ol>
<li>我们假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式叫做<strong>指针碰撞</strong>（Bump the Pointer）；</li>
<li>如果 Java 堆中的内存不是完整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>空闲列表</strong>（Free List）。</li>
</ol>
<p>选择哪种分配方式由 Java 堆是否完整决定，而 Java 堆是否完整又由所采用的垃圾收集器是否带有<strong>压缩整理</strong>功能决定。</p>
<ul>
<li>在使用 Serial、ParNew 等带有 Compact 过程的收集器时，系统采用的分配算法是指针碰撞；</li>
<li>而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用的是空闲列表。</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在JVM 中，对象创建是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现在给对象 A 分配内存时，指针还没来得及修改，对象 B 又同时使用原来的指针分配内存的情况。对于这个问题，有两种解决方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用 <strong>CAS</strong> 配上失败重试的方式更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 <code>-XX:+/-UseTLAB</code> 参数来设定。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别是32bit 和64bit，官方称为”Mark Word”。</p>
<blockquote>
<p>注：对象需要存储的运行时数据很多，其实已经超出了32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，因此，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>
</blockquote>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。另外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据才是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFilds 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java 堆会先划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="/images/java/jvm/getobject1.png" alt="getobject1"></p>
<p>通过句柄访问的最大好处 reference 中存储的是稳定的句柄地址，在对象被移动（gc 时移动对象非常普遍）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
<h3 id="直接地址访问"><a href="#直接地址访问" class="headerlink" title="直接地址访问"></a>直接地址访问</h3><p>使用直接地址访问时，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p><img src="/images/java/jvm/getobject2.png" alt="getobject2"></p>
<p>使用直接指针访问方式的最大好处就是速度更快，节省了一次指针定位的开销，HotSpot 也是这是使用这种方式实现的。</p>
<h1 id="OOM-调试"><a href="#OOM-调试" class="headerlink" title="OOM 调试"></a>OOM 调试</h1><p>根据前面的介绍，我们知道在 JVM 中，除了程序计数器之后，虚拟机内存的其他几个区域都有发生 OOM 异常的可能，本节会通过一些示例来验证异常发生的场景以及讲述一下如何进行调试。</p>
<h2 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h2><p>Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子中，我们限制 Java 堆的大小为5MB，不可扩展（将堆的最小值 <code>-Xms</code> 参数与最大值 <code>-Xmx</code> 参数设置为一样即可）。JVM 参数设置为 <code>-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError</code>，程序代码如下（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/heap/HeapOOMTest.java" target="_blank" rel="external">HeapOOMTest</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOMTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_NAME = <span class="string">"matt"</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_AGE = <span class="number">18</span>;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = DEFAULT_NAME;</div><div class="line">            <span class="keyword">this</span>.age = DEFAULT_AGE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            persons.add(<span class="keyword">new</span> Person());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid9479.hprof ...</div><div class="line">Heap dump file created [11824236 bytes <span class="keyword">in</span> 0.092 secs]</div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:2245)</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:2219)</div><div class="line">	at java.util.ArrayList.grow(ArrayList.java:242)</div><div class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216)</div><div class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208)</div><div class="line">	at java.util.ArrayList.add(ArrayList.java:440)</div><div class="line">	at heap.HeapOOMTest.main(HeapOOMTest.java:47)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>
<h3 id="示例异常分析"><a href="#示例异常分析" class="headerlink" title="示例异常分析"></a>示例异常分析</h3><p>Java 堆内存的 OOM 异常是实际应用中常见的内存异常情况。当出现 Java 堆内存溢出时，会报错误信息 <code>java.lang.OutOfMemoryError</code>，会跟着进一步提示 <code>Java heap space</code>。</p>
<p>出现这个异常之后，首先需要确定内存中的数据是否是必要，也就是要先分清楚是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<ol>
<li>如果是内存泄露，可进一步通过工具查看泄露对象到 GC Roots 的引用链。于是就能找到对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的，这样就就可以定位出泄露代码的位置；</li>
<li>如果不是内存泄露，需要检查一下虚拟机的参数（<code>-Xmx</code> 与 <code>-Xms</code>），与物理机内存对比看是否还可以调大，然后再检查一下代码，是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>由于在 HotSpot 虚拟机中并不区分虚拟机栈而本地方法栈。因此，对于 HotSpot 来说，虽然 <code>-Xoss</code> 参数（设置本地方法栈大小）存在，但实际上无效的，栈容量只由 <code>-Xss</code> 参数设定。对于虚拟机栈和本地方法栈，在 Java 虚拟机中描述了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<blockquote>
<p>注：这里有一个问题，当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是针对同一件事情两种描述。</p>
</blockquote>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>对单线程的情况，尝试一下两种方法都是获得 <code>StackOverflowError</code> 异常（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/stack/StackTest1.java" target="_blank" rel="external">StackTest1</a>）</p>
<ul>
<li>使用<code>-Xss</code>参数减少栈内存容量。结果：抛出 <code>StackOverflowError</code> 异常，异常出现时输出的栈深度相应减少；</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出 <code>StackOverflowError</code> 异常时输出的堆栈深度相应减少。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss256k</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</div><div class="line">        stackLength++;</div><div class="line">        stackLeak();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        StackTest1 stackTest1=<span class="keyword">new</span> StackTest1();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            stackTest1.stackLeak();</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">            System.out.println(<span class="string">"stack length: "</span>+stackTest1.stackLength);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.StackOverflowError</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:9)</div><div class="line">stack length: 1868</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</div><div class="line">	....</div></pre></td></tr></table></figure>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>根据上面的测试结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是  <code>StackOverflowError</code> 异常。</p>
<h2 id="方法区和运行时常量池异常"><a href="#方法区和运行时常量池异常" class="headerlink" title="方法区和运行时常量池异常"></a>方法区和运行时常量池异常</h2><p>运行时常量池是方法区的一部分。可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 来限制方法区的大小，从而间接限制其中常量池的容量。下面的例子主要讲述一下方法区异常的示例。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，我们的思路是运行时产生大量的类去填满方法区，知道溢出。在我们的示例中，我们借助 CGLib 直接操作字节码运行时生成了大量的动态类（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/methodarea/JavaMethodAreaOOM.java" target="_blank" rel="external">JavaMethodAreaOOM</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            enhancer.create();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: PermGen space</div><div class="line">    Dumping heap to java_pid10480.hprof ...</div><div class="line">    Heap dump file created [10685765 bytes <span class="keyword">in</span> 0.086 secs]</div><div class="line">    Exception <span class="keyword">in</span> thread <span class="string">"main"</span></div><div class="line">    Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler <span class="keyword">in</span> thread <span class="string">"main"</span></div></pre></td></tr></table></figure>
<p>方法区溢出</p>
<ul>
<li>方法区存储类信息，当类过多时，就会导致方法区溢出.</li>
<li>实际应用中，主流框架如Spring、Hibernate（CGLIB）、JSP、OSGi等会动态生成大量Class；而类被回收的判定条件是非常苛刻的.</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1472975542&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">深入理解java虚拟机</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-vm/" target="_blank" rel="external">深入理解java虚拟机 | 极客学院</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对《深入理解java虚拟机 第二版》第二章部分做的总结，文章中大部分内容都来自这章内容，之所以记录到博客，是想通过这个过程加深自己的理解，并且方便以后遇到相关问题之后进行查阅。&lt;/p&gt;
&lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;head
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://wangzzu.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务性（MySQL 存储引擎及索引结构）</title>
    <link href="http://wangzzu.github.io/2016/08/31/database-transaction/"/>
    <id>http://wangzzu.github.io/2016/08/31/database-transaction/</id>
    <published>2016-08-31T15:33:22.000Z</published>
    <updated>2016-11-19T09:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务性"><a href="#数据库事务性" class="headerlink" title="数据库事务性"></a>数据库事务性</h1><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</li>
<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ol>
<h2 id="数据库的并发控制"><a href="#数据库的并发控制" class="headerlink" title="数据库的并发控制"></a>数据库的并发控制</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="锁的分类-oracle"><a href="#锁的分类-oracle" class="headerlink" title="锁的分类(oracle)"></a>锁的分类(oracle)</h3><ol>
<li>按操作划分，可分为DML锁、DDL锁</li>
<li>按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql）</li>
<li>按锁级别划分，可分为共享锁、排他锁</li>
<li>按加锁方式划分，可分为自动锁、显示锁</li>
<li>按使用方式划分，可分为乐观锁、悲观锁</li>
</ol>
<ul>
<li>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁));</li>
<li>DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义.</li>
<li>其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</li>
</ul>
<h1 id="数据隔离级别"><a href="#数据隔离级别" class="headerlink" title="数据隔离级别"></a>数据隔离级别</h1><p>如果不对数据库进行并发控制，可能会产生异常情况：</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li>当一个事务读取另一个事务尚未提交的修改时，产生脏读。</li>
<li>同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。</li>
</ul>
</li>
<li>非重复读(Nonrepeatable Read)：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</li>
<li>幻像读(Phantom Reads)：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。<ul>
<li>当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。</li>
</ul>
</li>
<li>丢失修改(Lost Update)<ul>
<li>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。</li>
<li>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</li>
</ul>
</li>
</ol>
<p>为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p>
<ol>
<li>未提交读(Read Uncommitted)<ul>
<li>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。</li>
<li>Read Uncommitted允许脏读。</li>
</ul>
</li>
<li>已提交读(Read Committed)<ul>
<li>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。</li>
<li>Read Commited 不允许脏读，但会出现非重复读。</li>
</ul>
</li>
<li>可重复读(Repeatable Read)<ul>
<li>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。</li>
<li>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</li>
</ul>
</li>
<li>串行读(Serializable)<ul>
<li>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
<li>Serializable 不允许不一致现象的出现。</li>
</ul>
</li>
</ol>
<h2 id="事务隔离的实现——锁"><a href="#事务隔离的实现——锁" class="headerlink" title="事务隔离的实现——锁"></a>事务隔离的实现——锁</h2><ol>
<li>共享锁(S锁)<ul>
<li>用于只读操作(<code>SELECT</code>)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</li>
</ul>
</li>
<li>更新锁(U锁)<ul>
<li>用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</li>
</ul>
</li>
<li>独占锁(X锁，也叫排他锁)<ul>
<li>一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</li>
</ul>
</li>
</ol>
<p>隔离级别如何实现，这部分的详细内容可以参考<a href="http://www.hollischuang.com/archives/943" target="_blank" rel="external">深入分析事务的隔离级别</a>一文，下表是进行的总结。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>实现原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读(Read uncommitted)</td>
<td>事务在读数据的时候并未对数据加锁；事务在修改数据的时候只对数据增加行级共享锁。</td>
</tr>
<tr>
<td>提交读(Read committed)</td>
<td>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。</td>
</tr>
<tr>
<td>可重复读(Repeatable reads)</td>
<td>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</td>
</tr>
<tr>
<td>可序列化(Serializable)</td>
<td>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</td>
</tr>
</tbody>
</table>
<h1 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h1><p>关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异。</p>
<p>对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。本节将总结和分析各个引擎的特点，以及适用场合，这里先不会纠结于更深层次的东西，下面就对MySQL支持的存储引擎进行简单的介绍。（本节主要参考<a href="http://www.jellythink.com/archives/640" target="_blank" rel="external">MySQL存储引擎介绍</a>一文）</p>
<p>在mysql客户端中，使用以下命令可以查看MySQL支持的引擎。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</div></pre></td></tr></table></figure>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p><code>MyISAM</code> 表是独立于操作系统的，这说明可以轻松地将其从 Windows 服务器移植到 Linux 服务器；每当我们建立一个 <code>MyISAM</code> 引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个 <code>MyISAM</code> 引擎的 <code>tb_Demo</code> 表，那么就会生成以下三个文件：</p>
<ul>
<li><code>tb_demo.frm</code>：存储表定义；</li>
<li><code>tb_demo.MYD</code>：存储数据；</li>
<li><code>tb_demo.MYI</code>：存储索引。</li>
</ul>
<p>有以下特点：</p>
<ul>
<li>不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不能使用</li>
<li>表级锁定：其锁定机制是表级锁定，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能</li>
<li>读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读</li>
<li>只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据</li>
</ul>
<p><code>MyISAM</code> 表无法处理事务，这就意味着有事务处理需求的表，不能使用 <code>MyISAM</code> 存储引擎。<code>MyISAM</code> 存储引擎特别适合在以下几种情况下使用：</p>
<ul>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><code>InnoDB</code> 是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。<code>InnoDB</code> 是默认的存储引擎，<code>InnoDB</code> 还引入了行级锁定和外键约束。</p>
<p>有以下几点特点：</p>
<ol>
<li>具有较好的事务支持：支持4个事务隔离级别，支持多版本读</li>
<li>行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响</li>
<li>读写阻塞与事务隔离级别相关</li>
<li>具有非常高效的缓存特性：能缓存索引，也能缓存数据</li>
<li>整个表和主键以Cluster方式存储，组成一颗平衡树</li>
<li>所有Secondary Index都会保存主键信息</li>
</ol>
<p>在以下场合下，使用 <code>InnoDB</code> 是最理想的选择：</p>
<ol>
<li>更新密集的表。<code>InnoDB</code> 存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。<code>InnoDB</code> 存储引擎是支持事务的标准 MySQL 存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，<code>InnoDB</code> 表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有 <code>InnoDB</code>。</li>
<li>支持自动增加列<code>AUTO_INCREMENT</code>属性。</li>
</ol>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，<code>InnoDB</code> 是不错的选择。</p>
<h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>使用 MySQL <code>Memory</code> 存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统<strong>内存</strong>。虽然在内存中存储表数据确实会提供很高的性能，但当 mysqid 守护进程崩溃时，所有的 <code>Memory</code> 数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在 <code>Memory</code> 数据表里的数据使用的是长度不变的格式，这意味着不能使用 <code>BLOB</code> 和 <code>TEXT</code> 这样的长度可变的数据类型，<code>VARCHAR</code> 是一种长度可变的类型，但因为它在 MySQL 内部当做长度固定不变的 <code>CHAR</code> 类型，所以可以使用。</p>
<p>一般在以下几种情况下适用 <code>Memory</code> 存储引擎：</p>
<ol>
<li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数 <code>max_heap_table_size</code> 控制 <code>Memory</code> 表的大小，设置此参数，就可以限制 <code>Memory</code> 表的最大大小；</li>
<li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li>
<li>存储在 <code>Memory</code> 表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li>
</ol>
<p><code>Memory</code> 同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<code>&lt;</code>、<code>&gt;</code>和<code>&gt;=</code>等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在<code>=</code>和<code>&lt;&gt;</code>的操作符中，不适合在<code>&lt;</code>或<code>&gt;</code>操作符中，也同样不适合用在 <code>order by</code> 子句中。</p>
<p>可以在表创建时利用 <code>USING</code> 子句指定要使用的版本。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span></div><div class="line">(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</div><div class="line">    username <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    pwd <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">index</span> <span class="keyword">using</span> <span class="keyword">hash</span> (username),</div><div class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">memory</span>;</div></pre></td></tr></table></figure>
<p>上述代码创建了一个表，在 <code>username</code> 字段上使用了 <code>HASH</code> 散列索引。下面的代码就创建一个表，使用 <code>BTREE</code> 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span></div><div class="line">(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</div><div class="line">    username <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    pwd <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">index</span> <span class="keyword">using</span> btree (username),</div><div class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">memory</span>;</div></pre></td></tr></table></figure>
<h2 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h2><p><code>MERGE</code> 存储引擎是一组 <code>MyISAM</code> 表的组合，这些 <code>MyISAM</code> 表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，<code>Merge</code> 表就是几个相同 <code>MyISAM</code> 表的聚合器；<code>Merge</code> 表中并没有数据，对 <code>Merge</code> 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 <code>MyISAM</code> 表进行操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th>适用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyISAM</td>
<td>独立于操作系统的；不支持事务；表级锁定；</td>
<td>不需要事务支持；并发相对较低；  数据修改相对较少，以读为主；数据一致性要求不是非常高</td>
</tr>
<tr>
<td>InnoDB</td>
<td>事务性；行级锁定；外键约束；</td>
<td>需要事务支持；数据更新较为频繁；   数据一致性要求较高；行级锁定对高并发有很好的适应能力</td>
</tr>
<tr>
<td>MEMORY</td>
<td>存储内存里，数据容易丢失；性能高；存储的数据表要求数据类型长度不可变</td>
<td>数据小，但是可能会被频繁访问；数据是临时，并且立即可用；  可靠性不高的数据</td>
</tr>
</tbody>
</table>
<h1 id="数据库的索引结构"><a href="#数据库的索引结构" class="headerlink" title="数据库的索引结构"></a>数据库的索引结构</h1><p>在 MySQL 官方定义中，索引（ Index ）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>在 MySQL 中，主要有四种类型的索引，分别为： B-Tree 索引， Hash 索引， Fulltext （全文）索引和 R-Tree 索引。</p>
<p>具体可以参考<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理-张洋</a>一文，本文以后会把这部分给补充上。</p>
<p>关于数据库的索引结构还有一下几篇文章推荐：</p>
<ul>
<li><a href="http://database.51cto.com/art/201504/473322_all.htm" target="_blank" rel="external">为什么要用B+树结构——MySQL索引结构的实现</a></li>
<li><a href="http://ju.outofmemory.cn/entry/29124" target="_blank" rel="external">mysql索引原理之B+/-Tree</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7786014" target="_blank" rel="external">B-树和B+树的应用：数据搜索和数据库索引</a></li>
<li><a href="http://www.2cto.com/database/201404/295109.html" target="_blank" rel="external">2014阿里实习生面试题——mysql如何实现索引的</a></li>
</ul>
<hr>
<p>参考</p>
<ul>
<li><a href="http://2627lounuo.blog.51cto.com/10696599/1787812" target="_blank" rel="external">数据库之——索引、触发器、事务（存储引擎）</a></li>
<li><a href="http://www.jellythink.com/archives/640" target="_blank" rel="external">MySQL存储引擎介绍</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理-张洋</a></li>
<li><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="external">深入分析事务的隔离级别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库事务性&quot;&gt;&lt;a href=&quot;#数据库事务性&quot; class=&quot;headerlink&quot; title=&quot;数据库事务性&quot;&gt;&lt;/a&gt;数据库事务性&lt;/h1&gt;&lt;p&gt;并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="database" scheme="http://wangzzu.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 协议</title>
    <link href="http://wangzzu.github.io/2016/08/30/http-protocol/"/>
    <id>http://wangzzu.github.io/2016/08/30/http-protocol/</id>
    <published>2016-08-30T02:33:22.000Z</published>
    <updated>2016-11-19T09:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP 协议在计算机网络中是非常重要的部分，本文主要是简单介绍其中的 TCP 协议和 IP 协议，也会涉及一些在面试中经常遇到的问题。</p>
<h1 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h1><p>在最项目开发中，经常会遇到各种协议，互联网基础通信框架就是 TCP/IP。TCP/IP 是个协议族，可分为四个层次：网络接口层（连接层）、网络层、传输层和应用层。</p>
<p>可以这样理解它们的作用：</p>
<ol>
<li>连接层负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、Wi-Fi、MPLS 等；</li>
<li>网络层负责分配地址和传送二进制数据，主要协议是IP协议，也有 ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议；</li>
<li>传输层负责传送文本数据，主要协议是 TCP 协议与 UDP 协议；</li>
<li>应用层负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是 FTP、HTTP、TELNET、SMTP、DNS 等。</li>
</ol>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>TCP提供一种面向连接的、可靠的字节流服务</li>
<li>在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li>
<li>TCP使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP使用累积确认</li>
<li>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p>
<p>TCP 连接三次握手四次挥手（下小节介绍）如下图所示（图片来自<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a>）</p>
<p><img src="/images/computebase/tcp.jpg" alt="tcp"></p>
<ol>
<li>第一次握手：建立连接<ul>
<li>客户端发送连接请求报文段，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 <code>x</code>；</li>
<li>然后，客户端进入 <code>SYN_SEND</code>状态，等待服务器的确认；</li>
</ul>
</li>
<li>第二次握手：服务器收到 <code>SYN</code> 报文段<ul>
<li>服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 <code>x+1</code> (<code>Sequence Number+1</code>)；</li>
<li>同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为<code>y</code>；服务器端将上述所有信息放到一个报文段（即 <code>SYN+ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；</li>
</ul>
</li>
<li>第三次握手：客户端收到服务器的 <code>SYN+ACK</code> 报文段<ul>
<li>将 <code>Acknowledgment Number</code> 设置为<code>y+1</code>，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li>
</ul>
</li>
</ol>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>
<h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>
<blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<p>在书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>示意图如上图所示。</p>
<p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的，这时候 TCP 采用的是四次挥手。</p>
<ol>
<li>第一次挥手<ul>
<li>主机1（可以使客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向主机2发送一个 <code>FIN</code> 报文段；</li>
<li>此时，主机1进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机2了；</li>
</ul>
</li>
<li>第二次挥手<ul>
<li>主机2收到了主机1发送的 <code>FIN</code> 报文段，向主机1回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加1；</li>
<li>主机1进入 <code>FIN_WAIT_2</code> 状态；</li>
<li>主机2告诉主机1，我“同意”你的关闭请求；</li>
</ul>
</li>
<li>第三次挥手<ul>
<li>主机2向主机1发送 <code>FIN</code> 报文段，请求关闭连接;</li>
<li>同时主机2进入 <code>LAST_ACK</code> 状态；</li>
</ul>
</li>
<li>第四次挥手<ul>
<li>主机1收到主机2发送的 <code>FIN</code> 报文段，向主机2发送 <code>ACK</code> 报文段，然后主机1进入 <code>TIME_WAIT</code> 状态；</li>
<li>主机2收到主机1的 <code>ACK</code> 报文段以后，就关闭连接；</li>
<li>此时，主机1等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p>那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机1发出 <code>FIN</code> 报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 <code>ACK</code> 报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了 <code>FIN</code> 报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ol>
<li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实 <code>FIN_WAIT_1</code> 和 <code>FIN_WAIT_2</code> 状态的真正含义都是表示等待对方的 <code>FIN</code> 报文。而这两种状态的区别是：<code>FIN_WAIT_1</code> 状态实际上是当 SOCKET 在 <code>ESTABLISHED</code> 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 SOCKET 即进入到 <code>FIN_WAIT_1</code> 状态。而当对方回应 <code>ACK</code> 报文后，则进入到 <code>FIN_WAIT_2</code> 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 <code>ACK</code> 报文，所以 <code>FIN_WAIT_1</code> 状态一般是比较难见到的，而 <code>FIN_WAIT_2</code> 状态还有时常常可以用 <code>netstat</code>看到。（主动方）</li>
<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上 <code>FIN_WAIT_2</code> 状态下的 SOCKET，表示<strong>半连接</strong>，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你( <code>ACK</code> 信息)，稍后再关闭连接。（主动方）</li>
<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 <code>ACK</code> 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>
<li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 <code>CLOSED</code> 可用状态了。（被动方）</li>
<li><code>TIME_WAIT</code>: 表示收到了对方的 <code>FIN</code> 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 <code>CLOSED</code> 可用状态了。如果 <code>FINWAIT1</code> 状态下，收到了对方同时带 <code>FIN</code> 标志和 ACK 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。（主动方）</li>
<li><code>CLOSED</code>: 表示连接中断。</li>
</ol>
<h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>这部分可以参考<a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a>一文。</p>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="什么是-SYN-攻击（SYN-Flood）？"><a href="#什么是-SYN-攻击（SYN-Flood）？" class="headerlink" title="什么是 SYN 攻击（SYN Flood）？"></a>什么是 SYN 攻击（SYN Flood）？</h3><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 ACK 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送 <code>SYN</code> 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code>SYN</code> 包将长时间占用未连接队列，正常的 <code>SYN</code> 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<p><code>SYN</code> 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。</p>
<h3 id="如何检测-SYN-攻击？"><a href="#如何检测-SYN-攻击？" class="headerlink" title="如何检测 SYN 攻击？"></a>如何检测 SYN 攻击？</h3><p>检测 <code>SYN</code> 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次 <code>SYN</code> 攻击。在 Linux/Unix 上可以使用系统自带的 <code>netstats</code> 命令来检测 <code>SYN</code> 攻击。</p>
<h3 id="如何防御-SYN-攻击？"><a href="#如何防御-SYN-攻击？" class="headerlink" title="如何防御 SYN 攻击？"></a>如何防御 SYN 攻击？</h3><p><code>SYN</code> 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 <code>SYN</code> 攻击的危害，常见的防御 <code>SYN</code> 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="TCP-与-UDP-的区别？"><a href="#TCP-与-UDP-的区别？" class="headerlink" title="TCP 与 UDP 的区别？"></a>TCP 与 UDP 的区别？</h3><ol>
<li>TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。</li>
<li>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。</li>
<li>TCP无界有拥塞控制，TCP有界无拥塞控制。</li>
</ol>
<p>补充：</p>
<ul>
<li>基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。</li>
<li>基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>特点</td>
<td>面向连接；可靠；开销大</td>
<td>无连接；不可靠；效率高；可靠性由应用层负责</td>
</tr>
</tbody>
</table>
<h3 id="三次握手过程及其原因"><a href="#三次握手过程及其原因" class="headerlink" title="三次握手过程及其原因"></a>三次握手过程及其原因</h3><p>如上面所述</p>
<h3 id="四次挥手及其原因"><a href="#四次挥手及其原因" class="headerlink" title="四次挥手及其原因"></a>四次挥手及其原因</h3><p>如上面所述</p>
<h1 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h1><p>这部分可以参考<a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a>一文。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html" target="_blank" rel="external">TCP/IP模型的一个简单解释</a></li>
<li><a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
<li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="external">TCP 协议</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></li>
<li><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP/IP 协议在计算机网络中是非常重要的部分，本文主要是简单介绍其中的 TCP 协议和 IP 协议，也会涉及一些在面试中经常遇到的问题。&lt;/p&gt;
&lt;h1 id=&quot;TCP-IP-协议&quot;&gt;&lt;a href=&quot;#TCP-IP-协议&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tcp" scheme="http://wangzzu.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发学习（一）</title>
    <link href="http://wangzzu.github.io/2016/08/21/java-concurrency/"/>
    <id>http://wangzzu.github.io/2016/08/21/java-concurrency/</id>
    <published>2016-08-21T08:49:56.000Z</published>
    <updated>2016-11-19T09:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是根据华黎的《大型网站系统与Java中间件实践》和 <a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason</a> 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。</p>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。</p>
<h2 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）要么全部执行，要么全部都不执行。</p>
<p>关于原子性，最经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作技术——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p>
<h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</p>
<p>以下面这段代码为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>; <span class="comment">// 语句1</span></div><div class="line"><span class="keyword">long</span> counter = <span class="number">0L</span>; <span class="comment">// 语句2</span></div><div class="line">counter = <span class="number">1</span>; <span class="comment">// 语句3</span></div><div class="line">started = <span class="keyword">true</span>; <span class="comment">// 语句4</span></div></pre></td></tr></table></figure>
<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p>
<h2 id="Java如何解决多线程并发问题"><a href="#Java如何解决多线程并发问题" class="headerlink" title="Java如何解决多线程并发问题"></a>Java如何解决多线程并发问题</h2><p>上面已经提出了这三个核心的概念，在 Java 多线程中，我们会经常遇到这三个概念引发的多线程并发问题，下面讲述一下 Java 如果解决这些问题。</p>
<h3 id="Java如何保证原子性"><a href="#Java如何保证原子性" class="headerlink" title="Java如何保证原子性"></a>Java如何保证原子性</h3><h4 id="锁和同步"><a href="#锁和同步" class="headerlink" title="锁和同步"></a>锁和同步</h4><p>常用的保证Java操作原子性的工具是<strong>锁</strong>和<strong>同步方法</strong>（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</div><div class="line">  lock.lock();</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span> j = i;</div><div class="line">    i = j + <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (anyObject)&#123;</div><div class="line">    <span class="keyword">int</span> j = i;</div><div class="line">    i = j + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。（这一部分会后面详细讲述）</p>
<h4 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h4><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。<code>AtomicInteger</code>使用方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; numThreads; b++) &#123;</div><div class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; iteration; a++) &#123;</div><div class="line">      atomicInteger.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">  &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Java如何保证可见性"><a href="#Java如何保证可见性" class="headerlink" title="Java如何保证可见性"></a>Java如何保证可见性</h3><p>Java提供了<code>volatile</code>关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<h3 id="Java如何保证顺序性"><a href="#Java如何保证顺序性" class="headerlink" title="Java如何保证顺序性"></a>Java如何保证顺序性</h3><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<p>Java中可通过<code>volatile</code>在一定程序上保证顺序性，另外还可以通过<code>synchronized</code>和锁来保证顺序性。</p>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为<strong>happens-before原则</strong>隐式的保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<h3 id="happens-before原则（先行发生原则）"><a href="#happens-before原则（先行发生原则）" class="headerlink" title="happens-before原则（先行发生原则）"></a>happens-before原则（先行发生原则）</h3><ul>
<li>传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性</li>
<li>锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li>
<li>volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作</li>
<li>程序次序规则：一个线程内，按照代码顺序执行</li>
<li>线程启动规则：Thread对象的start()方法先发生于此线程的其它动作</li>
<li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li>
<li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取</li>
<li>对象终结规则：一个对象构造先于它的finalize发生</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>多核时代，面向多核编程就非常重要了，基于 java 的并发和多线程开发非常重要。与其每次需要时都创建线程相比，线程池可以降低创建线程的开销，线程池在线程执行结束后进行的是回收操作，而不是真正的销毁线程。</p>
<p>线程池的好处：</p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行；</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/8/8.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPoolTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(count));</div><div class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    list.add(random.nextInt());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        threadPoolExecutor.shutdown();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            threadPoolExecutor.awaitTermination(<span class="number">1</span>,TimeUnit.DAYS);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"ThreadPool demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</div><div class="line">        System.out.println(list.size());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    list.add(random.nextInt());</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                thread.join();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Thread demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</div><div class="line">        System.out.println(list.size());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count=<span class="number">10000</span>;</div><div class="line">        threadPoolTest(count);</div><div class="line">        threadTest(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPool demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 66</div><div class="line">10000</div><div class="line">Thread demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 1333</div><div class="line">10000</div></pre></td></tr></table></figure>
<p>从例子中，可以直接地看到，使用线程池能极大地提高程序的运行速度。</p>
<p>两种方式差别在于，使用线程池的方式是复用线程的，而不使用线程池的方式是每次都要创建线程的。不使用线程时消耗时间过多，主要是由于创建线程的开销占整个时间的比例比较大。还有另外两种线程池：</p>
<ul>
<li>newFixedThreadPool创建一个指定工作线程数量的线程池（固定数量的线程 ）。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li>
<li>newCachedThreadPool创建一个可缓存的线程池（线程数量根据任务数量动态变化 ）。这种类型的线程池特点是：<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>该方法返回的线程池是没有线程上限的，因为没有办法去控制总体的线程数量，而每个线程都是消耗内存的，这可能会导致过多的内存被占用。</li>
</ul>
</li>
<li>newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</li>
<li>newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</li>
</ul>
<p>关于线程池内部原理部门可以看一下这两篇文章，未来也会把主要内容总结到博客里面</p>
<ul>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19243889" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（1）</a></li>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19283171" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（2）</a></li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>每个Java对象都可以用做一个实现同步的互斥锁，这些锁被称为内置锁。线程进入同步代码块或方法时自动获得内置锁，退出同步代码块或方法时自动释放该内置锁。进入同步代码块或者同步方法是获得内置锁的唯一途径。</p>
<h2 id="实例同步方法"><a href="#实例同步方法" class="headerlink" title="实例同步方法"></a>实例同步方法</h2><p>synchronized用于修饰实例方法（非静态方法）时，执行该方法需要获得的是该类实例对象的内置锁（同一个类的不同实例拥有不同的内置锁）。如果多个实例方法都被synchronized修饰，则当多个线程调用同一实例的不同同步方法（或者同一方法）时，需要竞争锁。但当调用的是不同实例的方法时，并不需要竞争锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>foo1()</code> 和 <code>foo2()</code>是 <code>SynchronizedDemo1</code> 的两个成员方法，在多线程编程中，调用同一个对象的 <code>foo1()</code> 或者 <code>foo2()</code>是互斥的，这是针对同一个对象的多线程方法调用互斥。</p>
<h2 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h2><p>synchronized用于修饰静态方法时，执行该方法需要获得的是该类的class对象的内置锁（一个类只有唯一一个class对象）。调用同一个类的不同静态同步方法时会产生锁竞争。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo3</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo4</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>foo3()</code> 和 <code>foo4()</code>是 <code>SynchronizedDemo2</code> 类的两个静态方法。在不同的线程中，这两个方法的调用是互斥的，不仅它们之间，任何两个不同线程之间的调用也是互斥的。</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>synchronized用于修饰代码块时，进入同步代码块需要获得synchronized关键字后面括号内的对象（可以是实例对象也可以是class对象）的内置锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo3</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo5</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo6</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(SynchronizedDemo3.class)&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>synchronized(this)</code>与<code>SynchronizedDemo3</code>中加<code>synchronized</code>的成员方法是互斥的，而<code>synchronized(SynchronizedDemo3.class)</code>与<code>SynchronizedDemo3</code>加<code>synchronized</code>的静态方法是互斥的。</p>
<p><code>synchronized</code>用于修饰代码块会更加灵活，因为其后的参数可以是任意对象。</p>
<h2 id="synchronized使用总结"><a href="#synchronized使用总结" class="headerlink" title="synchronized使用总结"></a>synchronized使用总结</h2><p>锁的使用是为了操作临界资源的正确性，而往往一个方法中并非所有的代码都操作临界资源。换句话说，方法中的代码往往并不都需要同步。此时建议不使用同步方法，而使用同步代码块，只对操作临界资源的代码，也即需要同步的代码加锁。这样做的好处是，当一个线程在执行同步代码块时，其它线程仍然可以执行该方法内同步代码块以外的部分，充分发挥多线程并发的优势，从而相较于同步整个方法而言提升性能。</p>
<p>释放Java内置锁的唯一方式是synchronized方法或者代码块执行结束。若某一线程在synchronized方法或代码块内发生死锁，则对应的内置锁无法释放，其它线程也无法获取该内置锁（即进入跟该内置锁相关的synchronized方法或者代码块）。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock是<code>java.util.concurrent.locks</code>中的一个类，是从 JDK5开始加入的，与 synchronized 用法类似，不过它需要显式地进行 unlock。Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。使用synchronized的地方一定可以用ReentrantLock代替。</p>
<p>重入锁需要显示请求获取锁，并显示释放锁。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，一般建议将释放锁操作放在finally块里，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  renentrantLock.lock();</div><div class="line">  <span class="comment">// 用户操作</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  renentrantLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）还提供了其它获取锁的方法以实现不同的效果。</p>
<ol>
<li><code>lockInterruptibly()</code>：该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。与lock方法不同的是，在阻塞期间，如果当前线程被打断（interrupt）则该方法抛出<code>InterruptedException</code>。该方法提供了一种解除死锁的途径。</li>
<li><code>tryLock()</code>：该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。</li>
<li><code>tryLock(long time, TimeUnit unit)</code>：该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：1）若该时间内锁可用，则获得锁，并返回true；2）若等待期间当前线程被打断，则抛出InterruptedException；3）若等待时间结束仍未获得锁，则返回false。</li>
</ol>
<p>重入锁可定义为公平锁或非公平锁，默认实现为非公平锁。</p>
<ol>
<li>公平锁是指多个线程获取锁被阻塞的情况下，锁变为可用时，最新申请锁的线程获得锁。可通过在重入锁（RenentrantLock）的构造方法中传入true构建公平锁，如<code>Lock lock = new RenentrantLock(true)</code>；</li>
<li>非公平锁是指多个线程等待锁的情况下，锁变为可用状态时，哪个线程获得锁是随机的。synchonized相当于非公平锁。可通过在重入锁的构造方法中传入false或者使用无参构造方法构建非公平锁。效率相对高一点。</li>
</ol>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><p>这个主要用于读多写少并且读不需要互斥的场景，这样场景使用读写锁会比使用全部互斥的锁性能高出很多，<code>ReentrantReadWriteLock</code>通过<code>readLock()</code>和<code>writeLock()</code>两个方法获取读锁和写锁。</p>
<p>实际上，<code>ReadWriteLock</code>接口并非继承自Lock接口，<code>ReentrantReadWriteLock</code>也只实现了<code>ReadWriteLock</code>接口而未实现Lock接口。<code>ReadLock()</code>和<code>WriteLock()</code>，是<code>ReentrantReadWriteLock</code>类的静态内部类，它们实现了Lock接口。</p>
<p>一个<code>ReentrantReadWriteLock</code>实例包含一个<code>ReentrantReadWriteLock.ReadLock</code>实例和一个<code>ReentrantReadWriteLock.WriteLock</code>实例。通过<code>readLock()</code>和<code>writeLock()</code>方法可分别获得读锁实例和写锁实例，并通过Lock接口提供的获取锁方法获得对应的锁。</p>
<p>读写锁的锁定规则如下：</p>
<ul>
<li>获得读锁后，其它线程可获得读锁而不能获取写锁</li>
<li>获得写锁后，其它线程既不能获得读锁也不能获得写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      readWriteLock.readLock().lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 started with read lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        readWriteLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      readWriteLock.readLock().lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 started with read lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        readWriteLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      Lock lock = readWriteLock.writeLock();</div><div class="line">      lock.lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 started with write lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">          ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sat Jun 18 21:33:46 CST 2016  Thread 1 started with <span class="built_in">read</span> lock</div><div class="line">Sat Jun 18 21:33:46 CST 2016  Thread 2 started with <span class="built_in">read</span> lock</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 2 ended</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 1 ended</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 3 started with write lock</div><div class="line">Sat Jun 18 21:33:50 CST 2016  Thread 3 ended</div></pre></td></tr></table></figure>
<p>从上面的执行结果可见，thread 1和thread 2都只需获得读锁，因此它们可以并行执行。而thread 3因为需要获取写锁，必须等到thread 1和thread 2释放锁后才能获得锁。</p>
<h1 id="volatitle"><a href="#volatitle" class="headerlink" title="volatitle"></a>volatitle</h1><p><code>synchronized</code>保证了一个线程中变量的可见性，而<code>volatile</code>则是保证了所修饰变量的可见性（可见性可以参考前面所述）。<code>volatile</code>是轻量级的实现变量可见性的方法，其具体使用也很简单。</p>
<p>对于同一个变量线程间的可见性与多个线程中操作互斥是两件事情，操作互斥是提供了操作整体的原子性，下面通过一个例子来看。</p>
<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>对于读操作来说，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i3;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getI3</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>getI1()</code>：该方法调用获取的是当前线程中的副本，这个值不一定是最新的值；</li>
<li><code>getI2()</code>：因为 i2 是被<code>volatile</code>修饰，因此对于 JVM 来说，这个变量不会又线程的本地副本，只会放在主存中，所以得到的值一定是最新的；</li>
<li><code>getI3()</code>：因为有<code>synchronized</code>关键字修饰，保证了线程的本地副本与主存的同步，所以也会得到最新的值。</li>
</ol>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>再对比一下它们的写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i1 = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i2 = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i3;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setI3</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i3 = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>setI1()</code>：当前线程调用之后会得到最新的 i1 值，而另外的线程获取不一定可以立刻看到最新而值；</li>
<li><code>setI2()</code>：可以立刻在其他线程看到新的值，因为<code>volatile</code>保证了只有一份主存中的数据；</li>
<li><code>setI3()</code>：调用后必须在<code>synchronized</code>修饰的方法或代码中读取 i3 的值才可以看到最新值，因为<code>synchronized</code>不仅会把当前线程修改的本地副本同步给主存，还会从主存读取数据更新本地副本。</li>
</ol>
<h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>因为<code>volatile</code>只是保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量。</p>
<p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">new</span> Thread( () -&gt; &#123;</div><div class="line">    <span class="keyword">while</span>(isRunning) &#123;</div><div class="line">      someOperation();</div><div class="line">    &#125;</div><div class="line">  &#125;).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> </span>&#123;</div><div class="line">  isRunning = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用<code>stop()</code>方法将<code>isRunning</code>设置为<code>false</code>，循环也不一定会立即结束。可以通过<code>volatile</code>关键字，保证<code>while</code>循环及时得到<code>isRunning</code>最新的状态从而及时停止循环，结束线程。</p>
<h1 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h1><p>在 JDK5 中增加了<code>java.util.concurrent.atomic</code>包，这个包是一些以<code>Atomic</code>开头的类，这些类主要提供一些相关的原子操作。</p>
<p>以<code>AtomicInteger</code>为例来看一个多线程计数器的场景，场景很简单，就是让多个线程都对计数器进行加1操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            counter = counter + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> counter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            counter = counter - <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> counter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在采用了<code>AtomicInteger</code>之后，代码就会变成下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter2</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> counter.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> counter.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用<code>AtomicInteger</code>之后代码变得简洁了，更重要的是性能得到了提升，而且还比较明显的提升，原因是<code>AtomicInteger</code>内部通过 JNI 的方式使用了硬件支持的 CAS 指令。</p>
<h1 id="wait、notify-和-notifyAll"><a href="#wait、notify-和-notifyAll" class="headerlink" title="wait、notify 和 notifyAll"></a>wait、notify 和 notifyAll</h1><p>wait、notify 和 notifyAll 是 java Object 对象上的三个方法，也就是所有的Java类都可以调用这三个方法。</p>
<p>在多线程情况下，可以把某个对象作为事件对象，通过这个对象的 wait、notify 和 notifyAll方法来完成线程间的状态通知，三个方法的作用如下：</p>
<ul>
<li>wait：是当前线程进行等待；</li>
<li>notify：是唤醒同一个对象 wait 方法的线程，但是只是唤醒一个等待线程；</li>
<li>notifyAll：是唤醒同一个对象 wait 方法的线程，唤醒所有的等待线程。</li>
</ul>
<p>注意：</p>
<p>wait方法需要释放锁，前提条件是它已经持有锁。所以wait和notify（或者<code>notifyAll</code>）方法都必须被包裹在<code>synchronized</code>语句块中，并且<code>synchronized</code>后锁的对象应该与调用<code>wait</code>方法的对象一样。否则抛出<code>IllegalMonitorStateException</code>.</p>
<p>wait 与 sleep 的区别</p>
<ul>
<li>wait：它是在当前线程持有 wait 对象锁的情况下，暂时放弃锁，并让出 CPU 资源，并积极等待其它线程调用同一对象的 notify 或者 notifyAll 方法。换言之，即使notify被调用，但只要锁没有被释放，原等待线程因为未获得锁仍然无法继续执行。</li>
<li>sleep：它告诉操作系统至少指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>是<code>java.util.concurrent</code>包中的一个类，<code>CountDownLatch</code>主要提供的机制是当多个线程达到了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己后续的工作。需要注意的是，等待线程可以是多个，即 CountDownLatch 是可以唤醒多个等待的线程的。达到自己预期状态的线程会调用<code>CountDownLatch</code>的<code>countDown</code>方法，而等待线程会调用<code>CountDownLatch</code>的<code>wait</code>方法。</p>
<p>如果<code>CountDownLatch</code>初始化的 count 值为1，那么这就变成了单一事件了，即由一个线程来通知其他线程，效果等同于对象的<code>wait</code>和<code>notifyAll</code>。count 值大于1是常用的方式，目的是让多个线程达到各自的预期状态，变为一个事件进行通知，线程则继续自己的行为。</p>
<h3 id="CountDownLatch适用场景"><a href="#CountDownLatch适用场景" class="headerlink" title="CountDownLatch适用场景"></a>CountDownLatch适用场景</h3><p>Java多线程编程中经常会碰到这样一种场景——某个线程需要等待一个或多个线程操作结束（或达到某种状态）才开始执行。比如开发一个并发测试工具时，主线程需要等到所有测试线程均执行完成再开始统计总共耗费的时间，此时可以通过<code>CountDownLatch</code>轻松实现。</p>
<h3 id="CountDownLatch实例"><a href="#CountDownLatch实例" class="headerlink" title="CountDownLatch实例"></a>CountDownLatch实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> countdownlatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">int</span> totalThread = <span class="number">3</span>;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(totalThread);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</div><div class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"started"</span>));</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            Thread.sleep(<span class="number">1000</span>);</div><div class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                            ex.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        countDown.countDown();</div><div class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</div><div class="line">                    &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">        countDown.await();</div><div class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</div><div class="line">        System.out.println(String.format(<span class="string">"Total time : %sms"</span>, (stop - start)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 0 started</div><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 2 started</div><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 1 started</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 2 ended</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 1 ended</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 0 ended</div><div class="line">Total time : 1029ms</div></pre></td></tr></table></figure>
<p>可以看到，主线程等待所有3个线程都执行结束后才开始执行。</p>
<h3 id="CountDownLatch主要接口分析"><a href="#CountDownLatch主要接口分析" class="headerlink" title="CountDownLatch主要接口分析"></a>CountDownLatch主要接口分析</h3><p>CountDownLatch工作原理相对简单，可以简单看成一个倒计时器，在构造方法中指定初始值，每次调用countDown()方法时讲计数器减1，而await()会等待计数器变为0。CountDownLatch关键接口如下</p>
<ul>
<li>countDown() 如果当前计数器的值大于1，则将其减1；若当前值为1，则将其置为0并唤醒所有通过await等待的线程；若当前值为0，则什么也不做直接返回。</li>
<li>await() 等待计数器的值为0，若计数器的值为0则该方法返回；若等待期间该线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为0，若在指定时间内计数器的值变为0，则该方法返回true；若指定时间内计数器的值仍未变为0，则返回false；若指定时间内计数器的值变为0之前当前线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>getCount() 读取当前计数器的值，一般用于调试或者测试。</li>
</ul>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="CyclicBarrier适用场景"><a href="#CyclicBarrier适用场景" class="headerlink" title="CyclicBarrier适用场景"></a>CyclicBarrier适用场景</h3><p>CyclicBarrier，从字面理解是指循环屏障，CyclicBarrier可以在构造时指定需要在屏障前执行await的个数，所有对await的调用都会等待，只到调用await的次数达到预定指，所有等待都会立即被唤醒。</p>
<p>从使用场景上来说，CyclicBarrier是让多个线程互相等待某一事件的发生，然后同时被唤醒。而上文讲的CountDownLatch是让某一线程等待多个线程的状态，然后该线程被唤醒。</p>
<h3 id="CyclicBarrier实例"><a href="#CyclicBarrier实例" class="headerlink" title="CyclicBarrier实例"></a>CyclicBarrier实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cyclicbarrier;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> totalThread = <span class="number">5</span>;</div><div class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</div><div class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">" is waiting"</span>));</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        barrier.await();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                        ex.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3 ended</div></pre></td></tr></table></figure></p>
<p>从执行结果可以看到，每个线程都不会在其它所有线程执行<code>await()</code>方法前继续执行，而等所有线程都执行<code>await()</code>方法后所有线程的等待都被唤醒从而继续执行。</p>
<h3 id="CyclicBarrier主要接口分析"><a href="#CyclicBarrier主要接口分析" class="headerlink" title="CyclicBarrier主要接口分析"></a>CyclicBarrier主要接口分析</h3><p>CyclicBarrier提供的关键方法如下</p>
<ul>
<li>await()：等待其它参与方的到来（调用await()）。如果当前调用是最后一个调用，则唤醒所有其它的线程的等待并且如果在构造CyclicBarrier时指定了action，当前线程会去执行该action，然后该方法返回该线程调用await的次序（getParties()-1说明该线程是第一个调用await的，0说明该线程是最后一个执行await的），接着该线程继续执行await后的代码；如果该调用不是最后一个调用，则阻塞等待；如果等待过程中，当前线程被中断，则抛出InterruptedException；如果等待过程中，其它等待的线程被中断，或者其它线程等待超时，或者该barrier被reset，或者当前线程在执行barrier构造时注册的action时因为抛出异常而失败，则抛出BrokenBarrierException。</li>
<li>await(long timeout, TimeUnit unit)：与await()唯一的不同点在于设置了等待超时时间，等待超时时会抛出TimeoutException。</li>
<li>reset()：该方法会将该barrier重置为它的初始状态，并使得所有对该barrier的await调用抛出BrokenBarrierException。</li>
</ul>
<h3 id="CountDownLatch-与-CyclicBarrier"><a href="#CountDownLatch-与-CyclicBarrier" class="headerlink" title="CountDownLatch 与 CyclicBarrier"></a>CountDownLatch 与 CyclicBarrier</h3><p><code>CountDownLatch</code> 与 <code>CyclicBarrier</code> 都是用于多个线程间的协调，二者的一个差别是：</p>
<ol>
<li><code>CountDownLatch</code>：它是在多个线程都进行了<code>latch.countDown</code>后才会触发事件，唤醒<code>await</code>在 latch 上的线程，而执行<code>countDown</code>的线程，执行完<code>countDown</code>后继续进行自己的工作，也就是说，<code>countDown</code>的线程会继续执行，而唤醒的是<code>await</code>的线程；</li>
<li><code>CyclicBarrier</code>：它是一个栅栏，用于同步所有调用<code>await</code>方法的线程，并且等待所有线程都到了<code>await</code>方法时，这些线程才一起返回继续各自的工作，因为使用<code>CyclicBarrier</code>的线程都会阻塞在<code>await</code>方法上，所以在线程池中使用<code>CyclicBarrier</code>时要特别小心，如果线程池的线程数过少，那么很容易发生死锁。</li>
</ol>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="Phaser适用场景"><a href="#Phaser适用场景" class="headerlink" title="Phaser适用场景"></a>Phaser适用场景</h3><p><code>CountDownLatch</code>和<code>CyclicBarrier</code>都是JDK 1.5引入的，而<code>Phaser</code>是JDK 1.7引入的。<code>Phaser</code>的功能与<code>CountDownLatch</code>和<code>CyclicBarrier</code>有部分重叠，同时也提供了更丰富的语义和更灵活的用法。</p>
<p><code>Phaser</code>顾名思义，与<strong>阶段</strong>相关。<code>Phaser</code>比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。</p>
<h3 id="Phaser实例"><a href="#Phaser实例" class="headerlink" title="Phaser实例"></a>Phaser实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> phaser;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">int</span> parties = <span class="number">3</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> phases = <span class="number">4</span>;</div><div class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(parties) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"====== Phase : "</span> + phase + <span class="string">" ======"</span>);</div><div class="line">                <span class="keyword">return</span> registeredParties == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i;</div><div class="line">            <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;</div><div class="line">                        System.out.println(String.format(<span class="string">"Thread %s, phase %s"</span>, threadId, phase));</div><div class="line">                        phaser.arriveAndAwaitAdvance();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread 1, phase 0</div><div class="line">Thread 2, phase 0</div><div class="line">Thread 0, phase 0</div><div class="line">====== Phase : 0 ======</div><div class="line">Thread 0, phase 1</div><div class="line">Thread 2, phase 1</div><div class="line">Thread 1, phase 1</div><div class="line">====== Phase : 1 ======</div><div class="line">Thread 1, phase 2</div><div class="line">Thread 2, phase 2</div><div class="line">Thread 0, phase 2</div><div class="line">====== Phase : 2 ======</div><div class="line">Thread 1, phase 3</div><div class="line">Thread 2, phase 3</div><div class="line">Thread 0, phase 3</div><div class="line">====== Phase : 3 ======</div></pre></td></tr></table></figure>
<p>从上面的结果可以看到，多个线程必须等到其它线程的同一阶段的任务全部完成才能进行到下一个阶段，并且每当完成某一阶段任务时，Phaser都会执行其onAdvance方法。</p>
<h3 id="Phaser主要接口分析"><a href="#Phaser主要接口分析" class="headerlink" title="Phaser主要接口分析"></a>Phaser主要接口分析</h3><p>Phaser主要接口如下</p>
<ul>
<li>arriveAndAwaitAdvance()：当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从0开始），同时其它线程的该方法也返回下一个阶段的序号。</li>
<li>arriveAndDeregister()：该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser会在后文中讲到），并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。</li>
<li>arrive()：该方法不作任何等待，直接返回下一阶段的序号。</li>
<li>awaitAdvance(int phase)：该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。该阶段数一般由arrive()方法或者arriveAndDeregister()方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前Phaser已经被终止）。</li>
<li>awaitAdvanceInterruptibly(int phase)：效果与awaitAdvance(int phase)相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出InterruptedException。</li>
<li>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)：效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException。</li>
<li>bulkRegister(int parties)：注册多个party。如果当前phaser已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该Phaser会被注册到其父Phaser中。</li>
<li>forceTermination()：强制让该Phaser进入终止状态。已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。</li>
</ul>
<h1 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h1><p>信号量维护一个许可集，构造时需要传入参数，总数就是控制并发的数量，在执行可通过<code>acquire()</code>获取许可（如果acquire 成功返回，Semaphore 可用的信号量就会减少一个，若无可用许可acquire 就会阻塞，等待有 release 释放信号后，acquire 才会得到信号并返回），通过<code>release()</code>释放许可，从而可能唤醒一个阻塞等待许可的线程。</p>
<p>与互斥锁类似，信号量限制了同一时间访问临界资源的线程的个数，并且信号量也分<strong>公平信号量</strong>与<strong>非公平信号量</strong>。而不同的是，互斥锁保证同一时间只会有一个线程访问临界资源，而信号量可以允许同一时间多个线程访问特定资源。所以信号量并不能保证原子性。</p>
<p>信号量的一个典型使用场景是限制系统访问量。每个请求进来后，处理之前都通过<code>acquire</code>获取许可，若获取许可成功则处理该请求，若获取失败则等待处理或者直接不处理该请求。</p>
<h2 id="信号量的使用方法"><a href="#信号量的使用方法" class="headerlink" title="信号量的使用方法"></a>信号量的使用方法</h2><ul>
<li>acquire(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前可用许可数少于permits指定的个数，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，则抛出InterruptedException；</li>
<li>acquire()：等价于acquire(1)；</li>
<li>acquireUninterruptibly(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前许可数少于permits，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，继续等待可用许可数大于等于permits，并且获取成功后设置线程中断状态；</li>
<li>acquireUninterruptibly()：等价于acquireUninterruptibly(1)；</li>
<li>drainPermits()：获取所有可用许可，并返回获取到的许可个数，该方法不阻塞；</li>
<li>tryAcquire(int permits)：尝试获取permits个可用许可，如果当前许可个数大于等于permits，则返回true并且可用许可数减permits；否则返回false并且可用许可数不变；</li>
<li>tryAcquire()：等价于tryAcquire(1)；</li>
<li>tryAcquire(int permits, long timeout, TimeUnit unit)：尝试获取permits（必须为非负数）个许可，若在指定时间内获取成功则返回true并且可用许可数减permits；若指定时间内当前线程被中断，则抛出InterruptedException；若指定时间内可用许可数均小于permits，则返回false；</li>
<li>tryAcquire(long timeout, TimeUnit unit)：等价于tryAcquire(1, long timeout, TimeUnit unit)；</li>
<li>release(int permits)：释放permits个许可，该方法不阻塞并且某线程调用release方法前并不需要先调用acquire方法；</li>
<li>release()：等价于release(1)。</li>
</ul>
<blockquote>
<p>注意：与<code>wait/notify</code>和<code>await/signal</code>不同，<code>acquire/release</code>完全与锁无关，因此<code>acquire</code>等待过程中，可用许可满足要求时<code>acquire</code>可立即返回，而不用像锁的<code>wait</code>和条件变量的<code>await</code>那样重新获取锁才能返回。或者可以理解成，只要可用许可满足需求，就已经获得了锁。</p>
</blockquote>
<p>如果<code>Semaphore</code>管理的信号量只有1个，那么就是互斥锁了；如果多于1个信号量，则主要用于控制并发数。</p>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p><code>Exchanger</code>从名字上来看，就是交换的意思，<code>Exchanger</code>用于在两个线程之间进行数据交换，线程会阻塞在Exchanger的<code>exchange</code>方法上，直到另外一个线程也到了同一个Exchanger的<code>exchange</code>方法时，二者进行交换，然后两个线程会继续执行自身相关的代码。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> exchanger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</div><div class="line">                list.add(<span class="number">1</span>);</div><div class="line">                list.add(<span class="number">2</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    list = exchanger.exchange(list);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Thread1"</span> + list);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</div><div class="line">                list.add(<span class="number">4</span>);</div><div class="line">                list.add(<span class="number">5</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    list=exchanger.exchange(list);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Thread2"</span> + list);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread2[1, 2]</div><div class="line">Thread1[4, 5]</div></pre></td></tr></table></figure>
<h1 id="Future-和-Future-Task"><a href="#Future-和-Future-Task" class="headerlink" title="Future 和 Future Task"></a>Future 和 Future Task</h1><p><code>Future</code>是一个接口，<code>Future Task</code>是一个具体实现类。</p>
<p>在实际开发的环境中，我们经常会遇到这样一种场景中，在一个函数中我们调用了一个函数，正常情况下，程序会在理阻塞，知道调用函数返回结果，而很多情况下返回的结果我们并不会马上使用，这样的话就浪费很多时间。我们期待的情况是：调用函数后马上返回，然后继续向下执行，等需要用数据时再来用，或者说再来等待这个数据，具体的实现方式有两种方式，一个是用<code>Future</code>，一个是用回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Future&lt;HashMap&gt; future = getDataFromRemote2();</div><div class="line"><span class="comment">// do something</span></div><div class="line">HashMap data = (HashMap) future.get();</div></pre></td></tr></table></figure>
<p>可以看到，我们调用的方式返回的是一个 Future 对象，然后接着进行自己的处理，后面通过<code>future.get()</code>来获得真正的返回值。也就说，在调用了<code>getDataFromRemote2</code>后，就已经启动了对远程计算结果的获取，同时自己的线程还在继续处理，直到需要时再获取数据。我们先看一下<code>getDataFromRemote2</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;HashMap&gt; <span class="title">getDataFromRemote2</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> threadPool.submit(<span class="keyword">new</span> Callback&lt;HashMap&gt;()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> HashMap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">			returngetDataFromRemote();</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getDataFromRemote()</code>方法是从远程获取一些计算结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">HashMap <span class="title">getDataFromRemote</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p><code>getDataFromRemote2</code>中使用了<code>getDataFromRemote</code>来完成具体操作，并且使用到了线程池，把任务添加到线程池中，把 Future 对象返回出去。我们调用了<code>getDataFromRemote2</code>的线程，然后回来继续下面的执行，而背后是另外的线程在进行远程调用及等待的工作。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>参考<a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a>。调用回调函数的函数这里称作中间函数，而调用中间函数的函数我们成为起始函数。回调函数是作为函数的参数传入到中间函数中，中间函数在运行时，在需要调用这个函数的地方就调用回调函数，并将结果返回给中间函数，中间函数再把处理后的结果返回给起始函数。</p>
<p>回调实际上有两种：阻塞式回调和延迟式回调。</p>
<ul>
<li>阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；</li>
<li>延迟式回调里，回调函数的调用有可能是在起始函数返回之后。</li>
</ul>
<p>一般使用的回调函数都是阻塞式回调，而延迟式回调通常牵扯到多线程。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11449803.html" target="_blank" rel="external">大型网站系统与 Java 中间件实践</a></li>
<li><a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason的博客：java 并发部分</a></li>
<li><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是根据华黎的《大型网站系统与Java中间件实践》和 &lt;a href=&quot;http://www.jasongj.com/categories/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jason&lt;/a&gt; 的几篇博客，对 Java 并发方
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 0.10.0 SASL/PLAIN身份认证及权限实现</title>
    <link href="http://wangzzu.github.io/2016/07/29/sasl-plain-kafka/"/>
    <id>http://wangzzu.github.io/2016/07/29/sasl-plain-kafka/</id>
    <published>2016-07-29T12:49:56.000Z</published>
    <updated>2016-11-19T09:04:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下使用官方发布的 Kafka 0.10.0 版如何实现 SASL/PLAIN 认证机制以及权限控制。</p>
<h1 id="Kafka-安全机制"><a href="#Kafka-安全机制" class="headerlink" title="Kafka 安全机制"></a>Kafka 安全机制</h1><p> Kafka 的安全机制主要分为两部分：</p>
<ul>
<li>身份认证（Authentication）：对client 与服务器的连接进行身份认证。</li>
<li>权限控制（Authorization）：实现对于消息级别的权限控制</li>
</ul>
<blockquote>
<p>In release 0.9.0.0, the Kafka community added a number of features that, used either separately or together, increases security in a Kafka cluster.<br>These features are considered to be of beta quality. The following security measures are currently supported:</p>
<ol>
<li>Authentication of connections to brokers from clients (producers and consumers), other brokers and tools, using either SSL or SASL (Kerberos). SASL/PLAIN can also be used from release 0.10.0.0 onwards.</li>
<li>Authentication of connections from brokers to ZooKeeper</li>
<li>Encryption of data transferred between brokers and clients, between brokers, or between brokers and tools using SSL (Note that there is a performance degradation when SSL is enabled, the magnitude of which depends on the CPU type and the JVM implementation.)</li>
<li>Authorization of read / write operations by clients</li>
<li>Authorization is pluggable and integration with external authorization services is supported</li>
</ol>
</blockquote>
<p>这段话的中文意思也就是说</p>
<ol>
<li>可以使用 SSL 或者 SASL 进行客户端（producer 和 consumer）、其他 brokers、tools与 brokers 之间连接的认证，SASL/PLAIN将在0.10.0中得到支持；</li>
<li>对brokers和zookeeper之间的连接进行Authentication；</li>
<li>数据传输用SSL加密，性能会下降；</li>
<li>对clients的读写操作进行Authorization；</li>
<li>Authorization 是pluggable，与外部的authorization services结合进行支持。</li>
</ol>
<h1 id="Kafka身份认证"><a href="#Kafka身份认证" class="headerlink" title="Kafka身份认证"></a>Kafka身份认证</h1><p>Kafka 目前支持SSL、SASL/Kerberos、SASL/PLAIN三种认证机制，关于这些认证机制的介绍可以参考一下三篇文章。</p>
<ul>
<li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="external">数字证书原理</a>;</li>
<li><a href="http://www.cnblogs.com/mailingfeng/archive/2012/07/18/2597392.html" target="_blank" rel="external">数字证书, 数字签名, SSL(TLS) , SASL</a>;</li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="external">SSL的延迟</a></li>
</ul>
<h2 id="SASL-PLAIN-认证"><a href="#SASL-PLAIN-认证" class="headerlink" title="SASL/PLAIN 认证"></a>SASL/PLAIN 认证</h2><p>可以参考<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a>，这个官方文档的中文版。</p>
<h3 id="Kafka-Server-端配置"><a href="#Kafka-Server-端配置" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h3><p>需要在 Kafka 安装目录下的config/server.properties文件中配置以下信息</p>
<h2 id="Kafka-Server-端配置-1"><a href="#Kafka-Server-端配置-1" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h2><p>在 kafka 安装目录下的<code>config/server.properties</code>配置一下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">listeners=SASL_PLAINTEXT://ip:pot</div><div class="line">security.inter.broker.protocol=SASL_PLAINTEXT</div><div class="line">sasl.mechanism.inter.broker.protocol=PLAIN</div><div class="line">sasl.enabled.mechanisms=PLAIN</div><div class="line">authorizer.class.name = kafka.security.auth.SimpleAclAuthorizer</div><div class="line">super.users=User:admin</div></pre></td></tr></table></figure>
<p>还需要配置一个名 <code>kafka_server_jaas.conf</code> 的配置文件，将配置文件放置在<code>conf</code>目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_admin=&quot;admin&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里，我们配置了两个用户：admin 和 alice，密码分别为 admin 和 alice。<br>最后需要为 Kafka 添加 <code>java.security.auth.login.config</code> 环境变量。在 <code>bin/kafka-run-class.sh</code> 中添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KAFKA_SASL_OPTS=<span class="string">'-Djava.security.auth.login.config=/opt/meituan/kafka_2.10-0.10.0.0/config/kafka_server_jaas.conf'</span></div><div class="line"><span class="comment"># Launch mode</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></div><div class="line">  nohup <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="built_in">exec</span> <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注：实际上，我们只是添加了第一行，并在第4和第6行中添加了 $KAFKA_SASL_OPTS 这个环境变量。</p>
</blockquote>
<h3 id="KafkaClient-配置"><a href="#KafkaClient-配置" class="headerlink" title="KafkaClient 配置"></a>KafkaClient 配置</h3><p>首先需要在客户端配置 <code>kafka_client_jaas.conf</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">KafkaClient &#123;</div><div class="line">  org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">  username=&quot;alice&quot;</div><div class="line">  password=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在（producer 和 consumer）程序中添加环境变量和配置，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"java.security.auth.login.config"</span>, <span class="string">".../kafka_client_jaas.conf"</span>); <span class="comment">// 环境变量添加，需要输入配置文件的路径</span></div><div class="line">props.put(<span class="string">"security.protocol"</span>, <span class="string">"SASL_PLAINTEXT"</span>);</div><div class="line">props.put(<span class="string">"sasl.mechanism"</span>, <span class="string">"PLAIN"</span>);</div></pre></td></tr></table></figure>
<p>配置完以上内容后，就可以正常运行 producer 和 consumer 程序，如果账户密码错误的话，程序就不能正常进行，但是不会有任何提示，这方面后面会进行一些改进。</p>
<h1 id="Kafka权限控制"><a href="#Kafka权限控制" class="headerlink" title="Kafka权限控制"></a>Kafka权限控制</h1><p>这个小节介绍一下 Kafka 的 ACL 。</p>
<h2 id="权限的内容"><a href="#权限的内容" class="headerlink" title="权限的内容"></a>权限的内容</h2><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ</td>
<td>读取topic</td>
</tr>
<tr>
<td>WRITE</td>
<td>写入topic</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除topic</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建topic</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改topic</td>
</tr>
<tr>
<td>DESCRIBE</td>
<td>获取topic的信息</td>
</tr>
<tr>
<td>ClusterAction</td>
<td></td>
</tr>
<tr>
<td>ALL</td>
<td>所有权限</td>
</tr>
</tbody>
</table>
<p>访问控制列表ACL存储在zk上，路径为<code>/kafka-acl</code>。</p>
<h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>Kafka 提供的命令如下表所示</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default</th>
<th>Option type</th>
</tr>
</thead>
<tbody>
<tr>
<td>–add</td>
<td>Indicates to the script that user is trying to add an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–remove</td>
<td>Indicates to the script that user is trying to remove an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–list</td>
<td>Indicates to the script that user is trying to list acts.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–authorizer</td>
<td>Fully qualified class name of the authorizer.</td>
<td>kafka.security.auth.SimpleAclAuthorizer</td>
<td>Configuration</td>
</tr>
<tr>
<td>–authorizer-properties</td>
<td>key=val pairs that will be passed to authorizer for initialization. For the default authorizer the example values are: zookeeper.connect=localhost:2181</td>
<td></td>
<td>Configuration</td>
</tr>
<tr>
<td>–cluster</td>
<td>Specifies cluster as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–topic [topic-name]</td>
<td>Specifies the topic as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–group [group-name]</td>
<td>Specifies the consumer-group as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–allow-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Allow</strong> permission. You can specify multiple –allow-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–deny-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Deny</strong> permission. You can specify multiple –deny-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–allow-host</td>
<td>IP address from which principals listed in –allow-principal will have access.</td>
<td>if –allow-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–deny-host</td>
<td>IP address from which principals listed in –deny-principal will be denied access.</td>
<td>if –deny-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–operation</td>
<td>Operation that will be allowed or denied. Valid values are : Read, Write, Create, Delete, Alter, Describe, ClusterAction, All</td>
<td>All</td>
<td>Operation</td>
</tr>
<tr>
<td>–producer</td>
<td>Convenience option to add/remove acls for producer role. This will generate acls that allows WRITE, DESCRIBE on topic and CREATE on cluster.</td>
<td></td>
<td>Convenience</td>
</tr>
<tr>
<td>–consumer</td>
<td>Convenience option to add/remove acls for consumer role. This will generate acls that allows READ, DESCRIBE on topic and READ on consumer-group.</td>
<td></td>
<td>Convenience</td>
</tr>
</tbody>
</table>
<h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>通过几个例子介绍一下如何进行权限设置。</p>
<h3 id="add-操作"><a href="#add-操作" class="headerlink" title="add 操作"></a>add 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为用户 alice 在 test（topic）上添加读写的权限</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --operation Read --operation Write --topic <span class="built_in">test</span></div><div class="line"><span class="comment"># 对于 topic 为 test 的消息队列，拒绝来自 ip 为198.51.100.3账户为 BadBob  进行 read 操作，其他用户都允许</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:* --allow-host * --deny-principal User:BadBob --deny-host 198.51.100.3 --operation Read --topic <span class="built_in">test</span></div><div class="line"><span class="comment"># 为bob 和 alice 添加all，以允许来自 ip 为198.51.100.0或者198.51.100.1的读写请求</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:bob --allow-principal User:alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h3 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出 topic 为 test 的所有权限账户</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --list --topic <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>输出信息为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Current ACLs <span class="keyword">for</span> resource `Topic:<span class="built_in">test</span>`:</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Describe from hosts: *</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Read from hosts: *</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Write from hosts: *</div></pre></td></tr></table></figure>
<h3 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove 操作"></a>remove 操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 移除 acl</div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --remove --allow-principal User:Bob --allow-principal User:Alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic test</div></pre></td></tr></table></figure>
<h3 id="producer-和-consumer-的操作"><a href="#producer-和-consumer-的操作" class="headerlink" title="producer 和 consumer 的操作"></a>producer 和 consumer 的操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># producer</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --producer --topic <span class="built_in">test</span></div><div class="line"></div><div class="line"><span class="comment">#consumer</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --consumer --topic <span class="built_in">test</span> —group <span class="built_in">test</span>-group</div></pre></td></tr></table></figure>
<h1 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h1><p>本小节记录了在使用 SASL/PLAIN 时遇到的一些坑。</p>
<h2 id="Controller连接broker失败"><a href="#Controller连接broker失败" class="headerlink" title="Controller连接broker失败"></a>Controller连接broker失败</h2><p>错误信息如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[2016-07-27 17:45:46,047] WARN [Controller-1-to-broker-1-send-thread], Controller 1<span class="string">'s connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</span></div><div class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:63)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll$1(NetworkClientBlockingOps.scala:112)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka$utils$NetworkClientBlockingOps$$pollUntil$extension(NetworkClientBlockingOps.scala:120)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady$extension(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</div><div class="line">    at kafka.controller.RequestSendThread.liftedTree1$1(ControllerChannelManager.scala:181)</div><div class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</div><div class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</div><div class="line">[2016-07-27 17:45:46,056] INFO [delete-topics-thread-1], Starting  (kafka.controller.TopicDeletionManager$DeleteTopicsThread)</div><div class="line">[2016-07-27 17:45:46,057] DEBUG [Topic Deletion Manager 1], Waiting for signal to start or continue topic deletion (kafka.controller.TopicDeletionManager)</div><div class="line">[2016-07-27 17:45:46,351] WARN [Controller-1-to-broker-1-send-thread], Controller 1's connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</div><div class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:63)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll<span class="variable">$1</span>(NetworkClientBlockingOps.scala:112)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka<span class="variable">$utils</span><span class="variable">$NetworkClientBlockingOps</span>$<span class="variable">$pollUntil</span><span class="variable">$extension</span>(NetworkClientBlockingOps.scala:120)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady<span class="variable">$extension</span>(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</div><div class="line">    at kafka.controller.RequestSendThread.liftedTree1<span class="variable">$1</span>(ControllerChannelManager.scala:181)</div><div class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</div><div class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</div></pre></td></tr></table></figure>
<p>查找原因查找了半天，之前以为是<code>kafka_server_jaas.conf</code>文件的格式有问题，改了之后发现 Kafka 有时启动正常，有时不能正常启动，修改之前 conf 文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_matt=“33&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后分析可能是因为没有在 user 中配置 admin 账户，因为 broker 之间也开启了身份认证，修改之后的配置文件如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_admin=&quot;admin&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>修改完之后，Kafka 就可以正常运行了。</p>
<hr>
<p>参考：</p>
<ul>
<li>confluent的官网博客：<a href="http://www.confluent.io/blog/apache-kafka-security-authorization-authentication-encryption" target="_blank" rel="external">Apache Kafka Security 101</a></li>
<li>Kafka 官网：<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">KIP-12 - Kafka Sasl/Kerberos and SSL implementation</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Security" target="_blank" rel="external">Kafka Security</a></li>
<li>Kafka 官网：<a href="http://kafka.apache.org/documentation.html#security" target="_blank" rel="external">Kafka security</a></li>
<li>Kafka 官网中文翻译<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下使用官方发布的 Kafka 0.10.0 版如何实现 SASL/PLAIN 认证机制以及权限控制。&lt;/p&gt;
&lt;h1 id=&quot;Kafka-安全机制&quot;&gt;&lt;a href=&quot;#Kafka-安全机制&quot; class=&quot;headerlink&quot; title=&quot;Kafka 安
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://wangzzu.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka 0.10.0 new Consumer使用</title>
    <link href="http://wangzzu.github.io/2016/07/22/kafak-new-consumer-use/"/>
    <id>http://wangzzu.github.io/2016/07/22/kafak-new-consumer-use/</id>
    <published>2016-07-22T12:49:56.000Z</published>
    <updated>2016-11-19T09:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下Kafka new Consumer的使用，关于new Consumer的基本概念可以参考上一篇博文<a href="http://wangzzu.github.io/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍【译】</a>，这篇对于Kafka的new Consumer介绍得比较清楚。本文的一部分内容也来自上一篇文章。</p>
<h1 id="Consumer-Client"><a href="#Consumer-Client" class="headerlink" title="Consumer Client"></a>Consumer Client</h1><p>本节主要介绍Kafka从一些topic消费数据的示例。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="初始化与配置"><a href="#初始化与配置" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>Consumer的创建过程与之前旧的API创建方法一样，一个Consumer必备的最小配置项如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>); <span class="comment">// 通过其中的一台broker来找到group的coordinator，并不需要列出所有的broker</span></div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props); <span class="comment">// consumer实例</span></div></pre></td></tr></table></figure>
<p>Consumer的其他配置项可以参考<a href="http://kafka.apache.org/documentation.html#newconsumerconfigs" target="_blank" rel="external">New Consumer Configs</a>，除了上面的这几个配置之外，其他的几个比较常用的配置信息如下表所示</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>heartbeat.interval.ms</td>
<td>3000</td>
<td>当使用Kafka的group管理机制时，consumer向coordinator发送心跳的间隔，这个值要比session.timeout.ms小，最好不要超过session.timeout.ms的\frac{1}{3}</td>
</tr>
<tr>
<td>session.timeout.ms</td>
<td>30000</td>
<td>当使用Kafka的group管理机制时用于检测到consumer失败的时长，如果在这个时间内没有收到consumer的心跳信息，就认为Consumer失败了</td>
</tr>
<tr>
<td>auto.offset.reset</td>
<td>latest</td>
<td>group首次开始消费数据时的offset，有以下几个值可以选择：earliest、latest、none、anything else.</td>
</tr>
<tr>
<td>enable.auto.commit</td>
<td>true</td>
<td>设置为true时，Consumer的offset将会被周期性地自动commit</td>
</tr>
<tr>
<td>auto.commit.interval.ms</td>
<td>5000</td>
<td>Consumer的offset自动commit时的周期</td>
</tr>
</tbody>
</table>
<h2 id="Consumer-Auto-Offset-Commit"><a href="#Consumer-Auto-Offset-Commit" class="headerlink" title="Consumer Auto Offset Commit"></a>Consumer Auto Offset Commit</h2><p>本例使用Kafka的自动commit机制，每隔一段时间（可通过<code>auto.commit.interval.ms</code>来设置）就会自动进行commit offset。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>); <span class="comment">// 自动commit</span></div><div class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>); <span class="comment">// 自动commit的间隔</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>)); <span class="comment">// 可消费多个topic,组成一个list</span></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>在使用自动commit时，系统是保证at least once，因为offset是在这些messages被应用处理成功后才进行commit的；</li>
<li>subscribe方法需要传入所有topic的列表，一个group所消费的topic是不能动态增加的，但是可以在任何时间改变这个列表，它会把前面的设置覆盖掉；</li>
<li>poll中的参数就是设置一个时长，Consumer在进行拉取数据进行block的最大时间限制；</li>
</ol>
<h2 id="Consumer-Manual-Offset-Control"><a href="#Consumer-Manual-Offset-Control" class="headerlink" title="Consumer Manual Offset Control"></a>Consumer Manual Offset Control</h2><p>要进行手动commit，需要在配置文件中将enable.auto.commit设置为false，来禁止自动commit，本例以手动同步commit为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>));</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</div><div class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工同步commit offset</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在本例中，我们调用了commitSync方法，这是同步commit的方式，同时Kafka还提供了commitAsync方法，它们的区别是：使用同步提交时，consumer会进行block知道commit的结果返回，这样的话如果commit失败就可以今早地发现错误，而当使用异步commit时，commit的结果还未返回，Consumer就会开始拉取下一批的数据，但是使用异步commit可以系统的吞吐量，具体使用哪种方式需要开发者自己权衡；</li>
<li>本例中的实现依然是保证at least once，但是如果每次拉取到数据之后，就进行commit，最后再处理数据，就可以保证at last once。</li>
</ol>
<h2 id="Consumer-Manual-Partition-Assign"><a href="#Consumer-Manual-Partition-Assign" class="headerlink" title="Consumer Manual Partition Assign"></a>Consumer Manual Partition Assign</h2><p>Kafka在进行消费数据时，可以指定消费某个topic的某个partition，这种使用情况比较特殊，并不需要coordinator进行rebalance，也就意味着这种模式虽然需要设置group id，但是它跟前面的group的机制并不一样，它与旧的Consumer中的Simple Consumer相似，这是Kafka在新的Consumer API中对这种情况的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(props);</div><div class="line">TopicPartition partition0 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">0</span>);</div><div class="line">TopicPartition partition1 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">2</span>);</div><div class="line">consumer.assign(Arrays.asList(partition0, partition1));</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</div><div class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工sync offset</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>与前面的subscribe方法一样，在调用assign方法时，需要传入这个Consumer要消费的所有TopicPartition的列表；</li>
<li>不管对于simple consumer还是consumer group，所有offset的commit都必须经过group coordinator；</li>
<li>在进行commit时，必须设置一个合适的group.id，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个CommitFailedException异常，但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</li>
</ol>
<h1 id="KafkaStream使用"><a href="#KafkaStream使用" class="headerlink" title="KafkaStream使用"></a>KafkaStream使用</h1><p>KafkaStream是在Kafka 0.10.0版中新提出的内容，Kafka官方也说了设计这个feature的原因——为了简单，之前在流处理方面，一般情况下都会使用Kafka作为消息队列，然后再搭建一个流处理环境做流处理，而现在我们可以直接在Kafka中进行流处理，不需要再搭建另外一个环境（加了这个feature之后会使得Kafka变得更加复杂，不过官网说，在使用时我们只需要在工程中添加一个外部依赖包即可使用这个功能）。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>需要在pom文件中添加如下依赖，KafkaStream在实际运行时也是依赖这个外部的jar包运行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="初始化与配置-1"><a href="#初始化与配置-1" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>KafkaStream使用的一个基本初始化部分如下所示（代码来自<a href="http://kafka.apache.org/0100/javadoc/index.html?org/apache/kafka/streams/KafkaStreams.html" target="_blank" rel="external">Javadoc</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"my-stream-processing-application"</span>);</div><div class="line">props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(StreamsConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</div><div class="line">props.put(StreamsConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</div><div class="line">props.put(StreamsConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">props.put(StreamsConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">StreamsConfig config = <span class="keyword">new</span> StreamsConfig(props);</div><div class="line"></div><div class="line">KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</div><div class="line">builder.from(<span class="string">"my-input-topic"</span>).mapValue(value -&gt; value.length().toString()).to(<span class="string">"my-output-topic"</span>);</div><div class="line"></div><div class="line">KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, config);</div><div class="line">streams.start();</div></pre></td></tr></table></figure>
<p>完整的配置选项如下表所示，也可以参考<a href="http://kafka.apache.org/documentation.html#streamsconfigs" target="_blank" rel="external">Streams Configs</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>application.id</td>
<td>流处理应用的标识，对同一个应用需要一致，因为它是作为消费的group_id的</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>bootstrap.servers</td>
<td>host1:port1,host2:port2 这样的列表，是用来发现所有Kafka节点的种子，因此不需要配上所有的Kafka节点</td>
<td>list</td>
<td></td>
</tr>
<tr>
<td>client.id</td>
<td>应用的一个客户端的逻辑名称，设定后可以区分是哪个客户端在请求</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>zookeeper</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>key.serde</td>
<td>键的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>partition.grouper</td>
<td>用于分区组织的类，需要实现PartitionGrouper接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.DefaultPartitionGrouper</td>
</tr>
<tr>
<td>replication.factor</td>
<td>流处理应用会创建change log topic和repartition topic用于管理内部状态，这个参数设定这些topic的副本数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>state.dir</td>
<td>状态仓库的存储路径</td>
<td>string</td>
<td>/tmp/kafka-streams</td>
</tr>
<tr>
<td>timestamp.extractor</td>
<td>时间戳抽取类，需要实现TimestampExtractor接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.ConsumerRecordTimestampExtractor</td>
</tr>
<tr>
<td>value.serde</td>
<td>值的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>buffered.records.per.partition</td>
<td>每个分区缓存的最大记录数</td>
<td>int</td>
<td>1000</td>
</tr>
<tr>
<td>commit.interval.ms</td>
<td>存储处理器当前位置的间隔毫秒数</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>metric.reporters</td>
<td>用于性能报告的类列表。需要实现MetricReporter接口。JmxReporter会永远开启不需要指定</td>
<td>list</td>
<td>[]</td>
</tr>
<tr>
<td>metric.num.samples</td>
<td>计算性能需要的采样数</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td>metric.sample.window.ms</td>
<td>性能采样的时间间隔</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>num.standby.replicas</td>
<td>每个任务的后备副本数</td>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>num.stream.threads</td>
<td>执行流处理的线程数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>poll.ms</td>
<td>等待输入的毫秒数</td>
<td>long</td>
<td>100</td>
</tr>
<tr>
<td>state.cleanup.delay.ms</td>
<td>一个分区迁移后，在删除状态前等待的毫秒数</td>
<td>long</td>
<td>60000</td>
</tr>
</tbody>
</table>
<h2 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h2><p>这是个将一个topic的事件进行过滤的示例，处理很简单，下面给出了这个例子的完整代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Serdes;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStream;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStreamBuilder;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.KafkaStreams;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.StreamsConfig;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.Predicate;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/7/22.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFilter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"test-filter"</span>);</div><div class="line">        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"10.4.232.70:9091,10.4.232.77:2181"</span>);</div><div class="line">        props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line">        props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line"></div><div class="line">        <span class="comment">// setting offset reset to earliest so that we can re-run the demo code with the same pre-loaded data</span></div><div class="line">        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</div><div class="line"></div><div class="line">        KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</div><div class="line"></div><div class="line">        KStream&lt;String, String&gt; source = builder.stream(<span class="string">"test"</span>);</div><div class="line"></div><div class="line">        source.filter(<span class="keyword">new</span> Predicate&lt;String, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String key, String value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> (value.split(<span class="string">","</span>)[<span class="number">3</span>]).equals(<span class="string">"food"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).to(<span class="string">"food"</span>);</div><div class="line"></div><div class="line">        KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, props);</div><div class="line">        streams.start();</div><div class="line"></div><div class="line">        <span class="comment">// usually the stream application would be running forever,</span></div><div class="line">        <span class="comment">// in this example we just let it run for some time and stop since the input data is finite.</span></div><div class="line">        Thread.sleep(<span class="number">5000L</span>);</div><div class="line"></div><div class="line">        streams.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本文只是介绍这两个重要feature的使用方法，而KafkaStream并没有深入去讨论，后面会对本文再进行更新，并且还会增加Producer和Consumer使用安全机制的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下Kafka new Consumer的使用，关于new Consumer的基本概念可以参考上一篇博文&lt;a href=&quot;http://wangzzu.github.io/2016/07/21/kafka-new-consumer/&quot;&gt;Apache Kafka 
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://wangzzu.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka 0.9 Consumer Client 介绍【译】</title>
    <link href="http://wangzzu.github.io/2016/07/21/kafka-new-consumer/"/>
    <id>http://wangzzu.github.io/2016/07/21/kafka-new-consumer/</id>
    <published>2016-07-21T02:49:56.000Z</published>
    <updated>2016-11-19T09:03:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间在公司实习，有一项任务就是负责对Kafka新版本的一些feature做一下调研，主要是调研的内容是Kafka在0.9.0版本中提供的两个新特性：New Consumer API和安全认证机制，本文是在研究Kafka的新consumer API时看过的一篇文章，对于理解新API的设计理念以及应用，有很多的帮助，因此就打算翻译一下，帮助自己更好理解的同时也为开源做一些贡献。本文译自<a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a>一文，是Confluent官方出的一篇关于Kafka新Consumer客户端介绍的文章。</p>
<blockquote>
<p>注：个人的英文及写作水平有限，虽然有些地方能够理解作者的意思，但是可能自己会表达不准确，读者遇到难以理解的地方，可以对照英文原文进行阅读。另外，有些在Kafka中经常出现专有英文名词，本文会尽量还用英文表示，本来直接看这些英文名词就非常简洁，翻译成中文反而难以理解。</p>
</blockquote>
<p>Kafka最初被设计时，它原生地提供了一个Scala版本的producer和Consumer客户端。但是随着Kafka的应用更加广泛，我们意识到这些API有很多的缺陷。比如，Kafka提供了一个<strong>high-level</strong>的Consumer API，它可以实现consumer group和自动容错，但是不能支持一些更复杂的使用场景，同时我们也提供了一套<strong>simple</strong>的Consumer API以提供更全面、更细粒度的控制，但是这种Consumer需要开发者自己设计容错机制。因此，我们重新设计和开发了客户端，以适应哪些旧的客户端很难或者无法适用的应用场景，并且建立了一套可以支持长久发展的API。</p>
<p>开始的第一阶段，在0.8.1的版本中，我们重写设计了Producer的API。最近的0.9.0版本完成了第二阶段，引入了新的Consumer API。在Kafka本身提供的一套新的<strong>group coordination protocol</strong>的基础上，新的Consumer有以下这些优势：</p>
<ul>
<li>Clean Consolidated API：新的Consumer结合了旧的”simple”和”high-level”Consumer客户端，同时提供了group协调机制和更细粒度的消费机制；</li>
<li>Reduced Dependencies：新的Consumer完全是用Java编写的，它在运行过程中没有依赖Scala或者Zookeeper，这使得我们的工程的依赖包更加轻量化；</li>
<li>Better Security：Kafka 0.9.0提供的<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">security extensions</a>只被新的Consumer所支持；</li>
<li>新的Consumer同样也增加一系列用于管理消费过程中group容错的协议。之前这部分的设计是使用Java客户端实现的，它需要频繁地与Zookeeper进行交互，这个实现逻辑上的复杂性使得这些它很难推广到其他语言的客户端上。而随着新协议的提出，实现变得更加简单，实际上<a href="https://github.com/edenhill/librdkafka" target="_blank" rel="external">C Client</a>已经开始应用这个协议了。</li>
</ul>
<p>尽管新的Consumer使用了重新设计的API和一个新的coordination protocol，但是Kafka的那些基础的概念并没有任何变化。因此，对旧的Consumer非常熟悉的开发者在理解新Consumer客户端的设计时并不会遇到太大困难。然而，却有一些不易察觉细节需要额外的关注，特别是在理解<strong>group management</strong>和<strong>thread model</strong>上时。本文的目的就是讲述一下新Consumer的使用以及解释一下这些细节问题。</p>
<blockquote>
<p>有一点需要注意：在本文还在写的时候，新的Consumer在稳定性方面仍然被认为是”beta”。</p>
</blockquote>
<p>我们已经解决了几个在0.9.0版中遇到的重要bug，如果你在使用0.9.0版时遇到任何问题，我们建议你先对这个分支进行一下测试。如果依然遇到问题，可以通过<a href="https://kafka.apache.org/contact.html" target="_blank" rel="external">mail lists</a>或者<a href="https://issues.apache.org/jira/secure/Dashboard.jspa" target="_blank" rel="external">JIRA</a>提出。</p>
<h1 id="Getting-Started：开始"><a href="#Getting-Started：开始" class="headerlink" title="Getting Started：开始"></a>Getting Started：开始</h1><p>开始讲述代码之前，我们先回顾一下Kafka的基本概念。在Kafka中，每一个topic都被分为一系列消息的集合，这些集合被称为partition，Producer会在这些消息集合的尾部追加数据，Consumer从给定的位置读取数据。Kafka通过consumer group实现规模化地消费topic数据，group是一系列Consumers共享一个共同的标识符。下图展示了一个有3个partition的topic被一个有2个成员的group消费的情况，topic的每个partition被安排到group中的一个cosumer上。</p>
<p><img src="/images/kafka/consumer-figure1.png" alt="consumer group"></p>
<p>旧的Consumer依赖ZK进行group管理，而新的Consumer则使用了一个Kafka自身提供的group coordination protocol实现。对于每一个group，都会从所有的broker中选取一个作为<strong>group coordinator</strong>，这个coordinator是负责维护和管理这个group的状态，它的主要工作是当一个consumer加入、一个consumer离开（挂掉或者手动停止等）或者topic的partition改变时重新进行partition分配，这个过程就是group的<strong>rebalance</strong>。</p>
<blockquote>
<p>这里有一个问题需要思考，每个topic的元数据信息（具体的指的是，这个topic有多少个partition，每个partition的leader在哪台broker上）是不是也有coordinator保存的？还是这些元数据信息直接保存在broker上？</p>
</blockquote>
<p>当一个group刚开始被初始化时，group中consumer可以选择从每个partition的最小或者最大的offset开始消费数据，然后每个partition中的message会按顺序依次进行消费。随着Consumer的处理，它会对已经成功处理的msg进行commit（提交的是msg的offset）。例如，如下图所示，Consumer当前消费的msg的offset（<code>Current Position</code>）是6，上一次已经提交的msg的offset（<code>Last Committed Offset</code>）是1.</p>
<p><img src="/images/kafka/consumer-figure2.png" alt="consumer offset"></p>
<p>当一个partition被分配到group中的另外一个consumer时，初始化的位置是<code>Last Committed Offset</code>。如果本例中的consumer突然挂掉，这个group中的consumer将不得不从1（<code>Last Committed Offset</code>）开始消费数据，在这种情况下，offset为1~6的message将被重新处理。</p>
<p>图中也展示了在log中其他两个比较重要的位置信息，<code>Log End Offset</code>是写入log中的最新一条message的offset，而<code>High Watermark</code>是log中已经成功备份到其他replicas中的最新一条message的offset，也就是说<code>Log End Offset</code>与<code>High Watermark</code>之间的数据已经写入到log中，但是还未成功备份到其他的replicas中。从consuemr端来看，<code>High Watermark</code>是consumer可以消费的最后一条message的offset，这种机制会阻止Consumer读取那些未备份的message，因为这些message在后面可能会丢失。</p>
<h1 id="Configuration-and-Initialization：配置与初始化"><a href="#Configuration-and-Initialization：配置与初始化" class="headerlink" title="Configuration and Initialization：配置与初始化"></a>Configuration and Initialization：配置与初始化</h1><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0-cp1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>与其他的Kafka客户端一样，新版的Consumer也需要使用一个<code>Properties</code>文件来创建。下面例子中的配置，是对于一个Consumer group来说的几个必备的配置项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div></pre></td></tr></table></figure>
<p>与旧的Consumer和Producer一样， 我们需要先配置一个brokers的初始列表，以便Consumer能够找到集群中其他的节点，这并不需要列出集群中的所有节点，客户端从列表中的broker中来找到全部的alive brokers，本例我们假设这台broker是运行在本地上的。Consumer也需要设置key和value反序列化的方式。最后，为了加入一个Consumer Group，也需要设置group id，它是group的一个标识符。在本文的下面，我们会介绍更多的配置选项。</p>
<blockquote>
<p>这里也有一个问题需要思考，Kafka是如何通过初始的broker列表来找到Kafka集群所有的节点信息？</p>
</blockquote>
<h1 id="Topic-Subscription：订阅Topic"><a href="#Topic-Subscription：订阅Topic" class="headerlink" title="Topic Subscription：订阅Topic"></a>Topic Subscription：订阅Topic</h1><p>开始消费前，必须首先配置出应用需要订阅的topic信息，下面的例子中，我们订阅了来自Topic为”foo”和”bar”的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</div></pre></td></tr></table></figure>
<p>开始订阅之后，Consumer可以与group的其他Consumer进行协调，来得到自己的partition分配，这个过程是在Consumer开始消费数据时自动进行的。下面，我们会展示如何使用<strong>assign</strong> API来手动进行partition分配，但是需要注意的是，Consumer中同时使用自动管理和手动管理是没有必要的。</p>
<p><code>subscribe</code>方法是不能增加的：程序中必须包含想要消费的所有topic列表，你可以在任何时间改变你订阅的topic的集合，但是之前订阅的这些topic会被你使用<code>subscribe</code>方法调用的新的列表所取代。</p>
<h1 id="Basic-Poll-Loop：基本的poll循环模型"><a href="#Basic-Poll-Loop：基本的poll循环模型" class="headerlink" title="Basic Poll Loop：基本的poll循环模型"></a>Basic Poll Loop：基本的poll循环模型</h1><p>Consumer需要支持并行地拉取数据，常见的情况就是从分布在不同broker上的多个topic的多个partition上拉取数据。为了实现这种情况，Kafka使用了一套类似于Unix中的<code>poll</code>或者<code>select</code>调用的API风格：一旦topic进行注册，未来所有的coordination、rebalance和数据拉取都是在一个event loop中通过一个单一的poll调用来触发的。这种实现方式是简单有效的，它可以处理来自单线程的所有IO。</p>
<blockquote>
<p>思考：Consumer在调用<code>poll</code>方法时处理逻辑是怎么样？</p>
</blockquote>
<p>在订阅了一个topic之后，你需要启动一个<code>event loop</code>来获得partition分配并开始开始拉取数据，这听起来很复杂，但是你需要做的就是在一个循环中调用<code>poll</code>方法，然后Consumer会自动处理其他的所有的事情。每一次对于<code>poll</code>方法的调用都会返回一个从其所分配的partition上拉取的message集合（集合可能会空）。下面的例子展示了在一个基本的poll循环模型中打印Consumer拉取的mmessage的offset和value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>poll</code>API返回了根据<code>Current Position</code>拉取到的record。当group第一次创建时，这个位置是根据配置来进行设置的，可以被设置每个partition的最早或者最新的offset。但是一旦这个Consumer开始commit offset，之后的每次rebalance都会把position重置到<code>Last Committed Offset</code>位置。<code>poll</code>的这个参数是用来控制当Consumer在<code>Current Position</code>等待数据时block的最大时间，只要有任何record是可用的，Consumer就会立马返回，但是如果没有任何record是可用，Consumer将会等待一定的时长（被设置的时间）。</p>
<blockquote>
<p>思考：新API中的record与旧API中的message有什么区别与联系？</p>
</blockquote>
<p>Consumer最初被设计时就是运行在它自己的线程上，在多线程情况下使用时如果没有额外的同步机制它并不是线程安全的，而且也不推荐去尝试。在这个例子中，我们使用了一个flag（<code>runnning</code>），当应用关掉时它用于从poll循环中中断。当这个flag被其他线程（例如：关闭进程的线程）设置为false时，当poll返回时循环就会结束，而且无论是否返回record应用都会结束进程。</p>
<p>当Consumer进程结束时，你应该显式地关闭Consumer进程，这样不仅可以清除使用的socket，而且可以确保Consumer会向Coordinator发送它离开group的信息。</p>
<p>在上面的例子中，我们使用了较小的定时来确保在关闭Consumer时没有太多的延迟，或者，你也可以设置一个较长的定时，通过使用<code>weakup</code>API来从循环中中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + “: ” + record.value());</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">  <span class="comment">// ignore for shutdown</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们将时长设置为了<code>Long.MAX_VALUE</code>，它意味着Consumer将会一直bolck直到下一批records返回。相比于前面例子中使用的flag，本例中线程通过调用<code>consumer.wakeup()</code>来中断poll循环，同时进程抛出一个<code>WakeupException</code>异常。这个API被其他线程调用是安全的，但值得注意的是：如果进程当前没有调用poll，这个异常会在下次调用时被抛出。在这个例子中，我们可以捕捉这个异常来阻止它继续传播。</p>
<blockquote>
<p>思考：1.只要有数据，poll就立马返回吗？还是poll会等待一段时间或者一定消息量后返回？2.poll中设置的time参数在什么情况下起作用？如果拉取的消息为空，而时间又超出的话会出现什么情况？</p>
</blockquote>
<h1 id="Putting-in-all-Together：一个完整的例子"><a href="#Putting-in-all-Together：一个完整的例子" class="headerlink" title="Putting in all Together：一个完整的例子"></a>Putting in all Together：一个完整的例子</h1><p>在下面的例子中，我们创建一个简单的<code>Runnable</code>任务，它初始化这个Consumer、订阅一个topic的列表，并且一直执行poll循环除非遇到外部触发结束进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; topics;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumerLoop</span><span class="params">(<span class="keyword">int</span> id,</span></span></div><div class="line">                      String groupId,</div><div class="line">                      List&lt;String&gt; topics) &#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.topics = topics;</div><div class="line">    Properties props = <span class="keyword">new</span> Properties();</div><div class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">    props.put(“group.id”, groupId);</div><div class="line">    props.put(“key.deserializer”, StringDeserializer.class.getName());</div><div class="line">    props.put(“value.deserializer”, StringDeserializer.class.getName());</div><div class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      consumer.subscribe(topics);</div><div class="line"></div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">          Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">          data.put(<span class="string">"partition"</span>, record.partition());</div><div class="line">          data.put(<span class="string">"offset"</span>, record.offset());</div><div class="line">          data.put(<span class="string">"value"</span>, record.value());</div><div class="line">          System.out.println(<span class="keyword">this</span>.id + <span class="string">": "</span> + data);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">      <span class="comment">// ignore for shutdown</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      consumer.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    consumer.wakeup();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了测试这个示例，需要有一个运行0.9.0版Kafka的broker，并且需要一个有一些待消费数据的topic，向一个topic写入数据的最简单的办法是使用<code>kafka-verifiable-producer.sh</code>脚本。为了确保实验更有趣，我们将topic设置为多个partition，这样的话就不用使一个parition去做所有的工作了。在本例中，Kafka的broker和Zookeeper都运行在本地，你可以在一个Kafka根目录下键入以下命令进行设置topic和partiion。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bin/kafka-topics.sh --create --topic consumer-tutorial --replication-factor 1 --partitions 3 --zookeeper localhost:2181</span></div><div class="line"></div><div class="line"><span class="comment"># bin/kafka-verifiable-producer.sh --topic consumer-tutorial --max-messages 200000 --broker-list localhost:9092</span></div></pre></td></tr></table></figure>
<p>然后我们创建了一个有三个成员的consumer group，这个group来订阅我们刚才创建的那个topic</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> numConsumers = <span class="number">3</span>;</div><div class="line">  String groupId = <span class="string">"consumer-tutorial-group"</span></div><div class="line">  List&lt;String&gt; topics = Arrays.asList(<span class="string">"consumer-tutorial"</span>);</div><div class="line">  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);</div><div class="line"></div><div class="line">  <span class="keyword">final</span> List&lt;ConsumerLoop&gt; consumers = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numConsumers; i++) &#123;</div><div class="line">    ConsumerLoop consumer = <span class="keyword">new</span> ConsumerLoop(i, groupId, topics);</div><div class="line">    consumers.add(consumer);</div><div class="line">    executor.submit(consumer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">for</span> (ConsumerLoop consumer : consumers) &#123;</div><div class="line">        consumer.shutdown();</div><div class="line">      &#125;</div><div class="line">      executor.shutdown();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        executor.awaitTermination(<span class="number">5000</span>, TimeUnit.MILLISECONDS);</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子向一个executor提交三个consumer，每一个线程都分配了一个唯一的id，便于我们清楚是哪个线程在接收数据。当进程停止时，shutdown的Hook将被触发，它将使用<code>weakup</code>中断这三个线程，并且等待它们关闭。如果你运行这个程序，你将会看到所有这些线程接收到数据，下面是运行之后的输出例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2: &#123;partition=0, offset=928, value=2786&#125;</div><div class="line">2: &#123;partition=0, offset=929, value=2789&#125;</div><div class="line">1: &#123;partition=2, offset=297, value=891&#125;</div><div class="line">2: &#123;partition=0, offset=930, value=2792&#125;</div><div class="line">1: &#123;partition=2, offset=298, value=894&#125;</div><div class="line">2: &#123;partition=0, offset=931, value=2795&#125;</div><div class="line">0: &#123;partition=1, offset=278, value=835&#125;</div><div class="line">2: &#123;partition=0, offset=932, value=2798&#125;</div><div class="line">0: &#123;partition=1, offset=279, value=838&#125;</div><div class="line">1: &#123;partition=2, offset=299, value=897&#125;</div><div class="line">1: &#123;partition=2, offset=300, value=900&#125;</div><div class="line">1: &#123;partition=2, offset=301, value=903&#125;</div><div class="line">1: &#123;partition=2, offset=302, value=906&#125;</div><div class="line">1: &#123;partition=2, offset=303, value=909&#125;</div><div class="line">1: &#123;partition=2, offset=304, value=912&#125;</div><div class="line">0: &#123;partition=1, offset=280, value=841&#125;</div><div class="line">2: &#123;partition=0, offset=933, value=2801&#125;</div></pre></td></tr></table></figure>
<p>这个输出展示三个partition的消费情况，每一个partition都被安排到其中的一个线程上。在每个partition中，你都会看到offset如期望中的一样在不断增加，你可以使用命令行或者IDE中的<code>Ctrl+C</code>关闭这个进程。</p>
<h1 id="Consumer-Liveness：Consumer存活"><a href="#Consumer-Liveness：Consumer存活" class="headerlink" title="Consumer Liveness：Consumer存活"></a>Consumer Liveness：Consumer存活</h1><p>Group中每一个Consumer都被安排它订阅topic的partitions的一个子集，group会使用一个group锁在这些partition上。只要这些锁还被持有，其他的Consumer成员就不能从这些partition上读取数据。如果这些Consumer运行正常，这种情况就是我们想要的结果，这也是避免重复读消费数据的唯一办法。但是如果由于节点或者程序故障造成Consumer异常退出时，你需要能够释放这些锁，以便这些partition可以被安排到其他健康的Consumer上。</p>
<p>Kafka的group coordination protocol通过心跳机制来解决这个问题（Consumer通过心跳机制来实现持有锁和释放锁），在每一次rebalance之后，当前group中的所有Consumer都会定期向group的coordinator发送心跳信息，如果可以收到这个Consumer的心跳信息，就证明这个Consumer是正常的。一旦收到心跳信息，这个coordinator会重新开始计时。如果定时到了而还没有收到心跳信息，coordinator将会把这个consumer标记为dead，并且会向group的其他成员发送信号，这样就会进行rebalance操作，从而重新对这些partition进行分配。定时的时长就是session 时长，它可以通过客户端的<code>session.timeout.ms</code>这个参数来设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"60000"</span>);</div></pre></td></tr></table></figure>
<p>session时长机制可以确保如果遇到节点或者应用崩亏、或者网络把consumer从group中隔离的情况，锁会被释放。但是，通常应用失败的情况处理起来有点麻烦，因为即使Consumer仍然向coordinator发送心跳信息也不能证明应用是正常运行的。</p>
<p>Consumer的poll循环是被设置为解决这个问题，当你调用<code>poll</code>方法或者其他的阻塞的API时所有的网络IO就已经完成。而且Consumer并不会在后台调用任何其他线程，这就意味着心跳信息只是在调用<code>poll</code>方法时发送给coordinator的。如果因为处理代码的逻辑部分抛出异常或者下游系统崩溃而造成应用停止<code>poll</code>方法调用，那么也会造成没有任何心跳被发送，然后session定时就会超时，这个group就会进行rebalance操作。</p>
<p>如果一个consumer在给定的时间内没有发送心跳信息，这种机制就会被触发一个虚假的rebalance操作。当然可以通过将定时设置足够大来避免这种情况的发生，它默认的时长是30s，但是它没有必要的将时长设置高达几分钟。设置为更长时长的一个问题就是它需要花费更多的时间来发现失败的Consumer。</p>
<h1 id="Delivery-Semantics：可靠的消息传递"><a href="#Delivery-Semantics：可靠的消息传递" class="headerlink" title="Delivery Semantics：可靠的消息传递"></a>Delivery Semantics：可靠的消息传递</h1><p>当一个consumer group刚开始被创建的时候，最初的offset是通过<code>auto.offset.reset</code>配置项来进行设置的。一旦Consumer开始处理数据，它根据应用的需要来定期地对offset进行commit。在每一次的rebalance之后，group会将这个offset将被设置为<code>Last Committed Offset</code>。但如果consumer在对已经处理过的message进行commit之前挂掉了，另外一个Consumer最终会重复处理这些已经处理但未commit的数据。应用中对offset进行commit越频繁，在一次崩溃后你重复消费的数据就会越少。</p>
<p>在前面的例子中，我们都已经设置了自动提交机制，当把<code>enable.auto.commit</code>设置为<code>true</code>（default）时，Consumer会周期性地自动触发的offset commit机制，这个时长可以通过<code>auto.commit.interval.ms</code>来进行配置。通过减少这个间隔，我们可以限制当崩溃发生时Consumer重新处理的数据量。</p>
<p>如果要使用consumer的commit API，首先需要在配置文件中将<code>enable.auto.commit</code>设置为false，来禁止自动commit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>);</div></pre></td></tr></table></figure>
<p>这个commit API使用起来非常简单，难点在于如何与poll循环配合使用。下面的例子，主体中包含了commit细节实现的完整的poll循环。调用同步commit的API是处理手动提交的最简单的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用无参的<code>commitSync</code>API进行commit的offset是在调用<code>poll</code>后返回的，因为是同步commit，所以这个调用将会被一直block直到commit成功或者因为不可恢复的错误而失败。处理过程中，需要特别注意的是message处理的时间大于session时长的这种情况，如果这种情况发生，coordinator就会把这个consumer踢出这个group，它会导致抛出<code>CommitFailedException</code>异常。应用程序应该能够处理这种错误，并对由于消费自从上一次成功提交后的message造成的变化进行回滚操作。</p>
<p>一般情况下，你应该确保message被成功处理后，这个offset被commit了。但是如果在commit被发送之前consumer挂掉了，然后这些messages就会被重复处理。如果这个commit机制保证<code>Last Committed Offset</code>不会超过<code>Current Position</code>（如图2所示，上图，非下图），然后系统就会保证<strong>at last once</strong>消息传递机制。</p>
<p><img src="/images/kafka/consumer-figure3.png" alt="consumer commit offset"></p>
<p>通过改变commit机制来保证<code>Current Position</code>不会超过<code>Last Committed Offset</code>，如上图所示，你将会得到<strong>at most once</strong>消息传递保证。如果在<code>Current Position</code>赶上<code>Last Committed Offset</code>之前consumer挂掉了，这段时间内的所有messages都会丢失，但是可以确定是没有消息会处理超过一次。为了实现这个机制，我们只需要改变commit和消息处理的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    consumer.commitSync();</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是，如果使用<strong>默认的自动commit机制，系统是保证<code>at least once</code>消息处理</strong>，因为offset是在这些messages被应用处理后才进行commit的。在最糟糕的情况下，系统不得不重新处理的消息数量是由自动commit的间隔决定的（可以通过<code>auto.commit.interval.ms</code>设置）。</p>
<blockquote>
<p>思考：为什么kafka不能保证exactly once？</p>
</blockquote>
<p>通过应用commit API，你可以对重复处理的消息量进行更细的控制，在更极端的情况下，你甚至可以在每一条消息被处理后都进行commit，如下面的例子所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">        consumer.commitSync(Collections.singletonMap(record.partition(), <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>)));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们调用<code>commitSync</code>方法通过对明确的offset进行commit，要注意的是，要进行commit的offset应该是应用将要读取的下一条消息的offset。当<code>commitSync</code>方法被无参调用时，这个consumer对应用返回的<code>Last Offset（+1）</code>进行commit，但是在这里并不能使用，因为我们不允许<code>The Committed Position</code>超过我们实际的处理位置（<code>Current Position</code>）。</p>
<p>由于处理线程在每次进行commit请求并等待服务器返回这个过程中需要进行加锁，很明显对于大多数的应用场景，这种设计并不适用，这种设计会严重影响到consumer的吞吐量。更合理的设计是每接收N条消息后再进行commit，为了更高的吞吐量N的值可以进行调整。</p>
<p>本例中<code>commitSync</code>方法的参数是一个map的数据结构，key为topic partition，value为<code>OffsetAndMetadata</code>的实例。Commit API允许在每次commit时包含一些额外的元数据信息，这些数据信息可以是record进行commit的时间、要发送的host、或者应用程序中需要的任何其他信息，在本例中，我们并没有添加这个额外信息。</p>
<p>相比于对每接收一条message就进行commit，一个更加合理的机制是当你处理完每个partition的数据后进行commit offset。<code>ConsumerRecords</code>集合类提供了获取它内部每个partition集合以及每个partition内数据的方法。下面的例子详细描述这种机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</div><div class="line">      List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</div><div class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords)</div><div class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">      <span class="keyword">long</span> lastoffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</div><div class="line">      consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastoffset + <span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>截止到目前为止，我们主要研究的是同步commit的API，但是consumer也提供了异步提交的API——<code>commitAsync</code>。使用异步commit一般情况下会提高系统的吞吐量，因为应用可以在commit结果还未返回时就能开始处理下一批的message。但是你可能在之后才会发现commit失败了，这是需要开发者进行权衡。下面的例子是异步commit的基本用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">// application specific failure handling</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在本例中，在<code>commitAsync</code>中我们提供了回调方法，这个方法只会在commit完成后（不管成功还是失败）才会被consumer触发。如果你不需要这个设置，你也可以使用无参的<code>commitAsync</code>API。</p>
<blockquote>
<p>思考：在进行commit时，如果commit失败，consumer会怎么处理，同步与异步的处理过程是一样的吗？</p>
</blockquote>
<h1 id="Consumer-Group-Inspection：consumer-group查看"><a href="#Consumer-Group-Inspection：consumer-group查看" class="headerlink" title="Consumer Group Inspection：consumer group查看"></a>Consumer Group Inspection：consumer group查看</h1><p>当一个consuemr group是active，你可以通过在命令行运行<code>consumer-groups.sh</code>脚本来查看partition assignment和group消费情况，这个脚本存放在Kafka的<code>bin</code>目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bin/kafka-consumer-groups.sh --new-consumer --describe --group consumer-tutorial-group --bootstrap-server localhost:9092</span></div></pre></td></tr></table></figure>
<p>输出的结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GROUP, TOPIC, PARTITION, CURRENT OFFSET, LOG END OFFSET, LAG, OWNER</div><div class="line">consumer-tutorial-group, consumer-tutorial, 0, 6667, 6667, 0, consumer-1_/127.0.0.1</div><div class="line">consumer-tutorial-group, consumer-tutorial, 1, 6667, 6667, 0, consumer-2_/127.0.0.1</div><div class="line">consumer-tutorial-group, consumer-tutorial, 2, 6666, 6666, 0, consumer-3_/127.0.0.1</div></pre></td></tr></table></figure>
<p>上面的结果展示了这个consumer group的partition分配以及哪个consumer实例消费这个partition，还有<code>Last Committed Offset</code>（这里也可以认为是<code>Current Offset</code>）。每个partition的lag就是这个partition的最后offset与<code>Last Committed Offset</code>的差值。Administrators会一直进行监控以确保consuemr group能跟得上producers。</p>
<h1 id="Using-Manual-Assignment：使用手动的assign"><a href="#Using-Manual-Assignment：使用手动的assign" class="headerlink" title="Using Manual Assignment：使用手动的assign"></a>Using Manual Assignment：使用手动的assign</h1><p>正如本文开始所述的一样，新的Consumer实现了对那些不需要group的场景进行更细粒度的控制，对这种场景的支持是建议使用新Consumer API的重要原因之一。旧的<code>simple consumer</code>虽然也提供这样的设计，但是却需要你自己做很多的容错处理。而新的Consumer API，你只需要提供了你需要读取的topic的partition，然后就可以开始读取数据，其他的东西Consumer会帮你处理。</p>
<p>下面的例子展示了如何使用<code>partitionsFor</code> API来分配安排一个topic的所有partition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (PartitionInfo partition : consumer.partitionsFor(topic))</div><div class="line">  partitions.add(<span class="keyword">new</span> TopicPartition(topic, partition.partition()));</div><div class="line">consumer.assign(partitions);</div></pre></td></tr></table></figure>
<p>和<code>subscribe</code>方法相似，调用<code>assign</code>方法时必须传入consuemr要读取的所有parition的集合，一旦partition被分配了，poll循环部分就与前面的过程基本一样。</p>
<p>有一点需要的注意的是，不管是一个simple consumer还是一个consumer group，所有offset的commit都必须经过<strong>group coordinator</strong>。因此，如果你需要进行commit，你必须设置一个合适的<code>group.id</code>，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个<code>CommitFailedException</code>异常。但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</p>
<h1 id="Conclusion：结论"><a href="#Conclusion：结论" class="headerlink" title="Conclusion：结论"></a>Conclusion：结论</h1><p>新的Consumer给Kafka社区带了很多的好处，比如，简洁的API、更好的安全性和对ZK更少的依赖。本文介绍了new consumer的基本用法，并注重于poll循环模型以及使用commit API来控制传递机制。虽然还有很多需要讨论的地方，但是本文对于基本的使用是足够了。尽管新的comsumer还在开发中，但是我们仍然鼓励你去尝试使用。使用中如果遇到什么问题，欢迎通过邮件告诉我们.</p>
<hr>
<p>参考</p>
<ul>
<li><a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间在公司实习，有一项任务就是负责对Kafka新版本的一些feature做一下调研，主要是调研的内容是Kafka在0.9.0版本中提供的两个新特性：New Consumer API和安全认证机制，本文是在研究Kafka的新consumer API时看过的一篇文章，对于理
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://wangzzu.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Mac常用软件及环境配置</title>
    <link href="http://wangzzu.github.io/2016/07/09/mac-software/"/>
    <id>http://wangzzu.github.io/2016/07/09/mac-software/</id>
    <published>2016-07-09T13:01:56.000Z</published>
    <updated>2016-11-20T12:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间因为在公司实习，公司提供的电脑都是Mac，还给发了一台全新的Mac pro，刚开始用的时候有很多不习惯的地方，但是用了几天之后就感觉Mac真的爽到爆啊，本篇文章就记录一下自己感觉在Mac上用到的一些不错的软件，以及Mac下一些常用编程工具的配置安装方法，这样也方便自己以后查看，本篇文章会一直保持更新。</p>
<h1 id="Mac基本配置"><a href="#Mac基本配置" class="headerlink" title="Mac基本配置"></a>Mac基本配置</h1><p>推荐一些Mac下常用的软件</p>
<ul>
<li>笔记：<a href="https://www.yinxiang.com/download/?offer=www_menu" target="_blank" rel="external">Evernote</a>，<a href="http://www.jianshu.com/p/a26fffc3c746" target="_blank" rel="external">Evernote（印象笔记）用户如何使用Markdown</a>；</li>
<li>MarkDown：<a href="http://zh.mweb.im/" target="_blank" rel="external">MWeb</a>、<a href="http://25.io/mou/" target="_blank" rel="external">Mou</a>、Ulysses、<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">MacDown</a>；</li>
<li>编辑器：<a href="https://atom.io/" target="_blank" rel="external">Atom</a>；</li>
<li>思维导图：<a href="http://www.xmindchina.net/" target="_blank" rel="external">XMid</a>、SimpleMind；</li>
<li>NTFS挂载：<a href="http://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="external">Tuxera NTFS</a>（<a href="http://www.orsoon.com/Mac/129966.html" target="_blank" rel="external">序列号</a>，建议买正版）；</li>
<li>播放器：MPV（mpv安装及快捷键操作参考<a href="https://intxt.net/meet-mpv/" target="_blank" rel="external">mpv安装</a>一文，<a href="https://mpv.io/installation/" target="_blank" rel="external">mpv安装地址</a>）；</li>
<li>浏览器：chrome，必须是chrome；</li>
<li>上网：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/" target="_blank" rel="external">shadowsocks</a>；</li>
<li>英文写作检查的软件：1Checker;</li>
<li><a href="http://www.jianshu.com/p/c98c73704ff6" target="_blank" rel="external">Mac vim高亮设置</a>;</li>
</ul>
<p>博文推荐</p>
<ul>
<li><a href="http://www.jianshu.com/p/19e8ffd91576" target="_blank" rel="external">Mac下开发常用的必备软件</a>，这里有office、ps等工具的安装；</li>
<li><a href="http://www.iphoneba.net/231.html" target="_blank" rel="external">Adobe After Effects CC 2015 Mac</a>，推荐使用正版；</li>
<li><a href="http://www.waitsun.com/lightroom-cc-6-0.html" target="_blank" rel="external">Adobe Photoshop Lightroom CC for Mac 6.0 优秀的图像后期处理软件</a>，推荐使用正版；</li>
</ul>
<h2 id="mpv-的一些常用快捷键"><a href="#mpv-的一些常用快捷键" class="headerlink" title="mpv 的一些常用快捷键"></a>mpv 的一些常用快捷键</h2><p>mpv 是 mac 下使用非常舒服的一款视频播放器，下面是一些常用的快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPACE</td>
<td>暂停/播放切换</td>
</tr>
<tr>
<td>UP</td>
<td>快进 60 秒</td>
</tr>
<tr>
<td>DOWN</td>
<td>回退 60 秒</td>
</tr>
<tr>
<td>LEFT</td>
<td>回退 5 秒</td>
</tr>
<tr>
<td>RIGHT</td>
<td>快进 5 秒</td>
</tr>
<tr>
<td><code>]</code></td>
<td>加速播放</td>
</tr>
<tr>
<td><code>[</code></td>
<td>减速播放</td>
</tr>
<tr>
<td>j</td>
<td>循环选择字幕</td>
</tr>
<tr>
<td>J</td>
<td>反向循环选择字幕</td>
</tr>
<tr>
<td>#</td>
<td>循环切换音轨</td>
</tr>
<tr>
<td>f</td>
<td>切换全屏状态</td>
</tr>
<tr>
<td>T</td>
<td>切换视频窗口是否总在最前</td>
</tr>
<tr>
<td>s</td>
<td>视频截图，包含字幕</td>
</tr>
<tr>
<td>S</td>
<td>视频截图，不带字幕</td>
</tr>
<tr>
<td>Alt+s</td>
<td>自动逐帧视频截图，再按一次停止截图</td>
</tr>
</tbody>
</table>
<h2 id="chrome常用配置"><a href="#chrome常用配置" class="headerlink" title="chrome常用配置"></a>chrome常用配置</h2><p>chrome既方便又强大，于是乎，不得不单独弄出一小章来介绍。</p>
<h3 id="常用小插件"><a href="#常用小插件" class="headerlink" title="常用小插件"></a>常用小插件</h3><ul>
<li>代理：<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">switchyomega</a>；</li>
<li>流程图：<a href="https://chrome.google.com/webstore/detail/gliffy-diagrams/bhmicilclplefnflapjmnngmkkkkpfad" target="_blank" rel="external">gliffy</a>;</li>
<li>MarkDown：<a href="chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html" target="_blank" rel="external">MarkDown Here</a>;</li>
<li>词典：<a href="https://chrome.google.com/webstore/detail/%E7%BF%B0%E6%9E%97%E8%8B%B1%E6%B1%89%E5%8F%8C%E8%A7%A3%E8%AF%8D%E5%85%B8/fidicgekecdkdmkjghdgadgdmcfodfid" target="_blank" rel="external">翰林英汉双解词典</a>;</li>
</ul>
<h1 id="Mac下常用快捷键"><a href="#Mac下常用快捷键" class="headerlink" title="Mac下常用快捷键"></a>Mac下常用快捷键</h1><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页刷新</td>
<td>command+r</td>
</tr>
<tr>
<td>自定义截图</td>
<td>command+shfit+4</td>
</tr>
<tr>
<td>显示器</td>
<td>control+shift+电源键</td>
</tr>
<tr>
<td>将文本编辑器由带格式变为存文本</td>
<td>command+shfit+t</td>
</tr>
<tr>
<td>EverNote无格式粘贴</td>
<td>command+shift+option+v</td>
</tr>
<tr>
<td>文件/文件夹重命名</td>
<td>选中该文件/文件夹，点击回车键</td>
</tr>
</tbody>
</table>
<p>快捷键可以参考<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">Mac键盘快捷键</a>一文.</p>
<p>这里有一篇Bash下的快捷键的wiki，<a href="https://github.com/hokein/Wiki/wiki/Bash-Shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" target="_blank" rel="external">Bash Shell常用快捷键</a>，可以方便查找bash下的常用快捷键。</p>
<p>其他博文推荐：</p>
<ol>
<li><a href="http://wuchong.me/blog/2014/06/29/the-first-experience-of-mac/" target="_blank" rel="external">Mac上手体验</a></li>
<li><a href="http://www.macx.cn/thread-2133104-1-1.html" target="_blank" rel="external">Mac快速锁屏</a></li>
<li><a href="https://support.apple.com/kb/PH18669?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="external">Mac锁屏后设置需要输密码</a></li>
<li><a href="http://www.hangge.com/blog/cache/detail_540.html" target="_blank" rel="external">Mac下文本编辑器</a></li>
<li><a href="http://popozhu.github.io/2013/09/24/mac%E5%85%89%E6%A0%87%E9%80%9F%E5%BA%A6%E8%B0%83%E6%95%B4/" target="_blank" rel="external">Mac光标速度调整</a></li>
</ol>
<h1 id="Mac终端iTerm2配置"><a href="#Mac终端iTerm2配置" class="headerlink" title="Mac终端iTerm2配置"></a>Mac终端iTerm2配置</h1><p>Mac下的iTerm2用着真的超爽</p>
<h2 id="iTerm2下载安装"><a href="#iTerm2下载安装" class="headerlink" title="iTerm2下载安装"></a>iTerm2下载安装</h2><p><a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2下载</a></p>
<p>下载完直接安装即可。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</div></pre></td></tr></table></figure>
<p>安装成功后的效果如下图所示</p>
<p><img src="/images/mac/iterm-1.png" alt="zsh"></p>
<h2 id="安装powerline"><a href="#安装powerline" class="headerlink" title="安装powerline"></a>安装powerline</h2><p>关于powerline的介绍可以参考<a href="http://cenalulu.github.io/linux/mac-powerline/" target="_blank" rel="external">为Bash和VIM配置一个美观奢华的状态提示栏</a>这篇文章，powerline就是一个全局的状态提示栏，安装方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先安装pip指令</span></div><div class="line">sudo easy_install pip</div><div class="line"><span class="comment"># 安装管道</span></div><div class="line">pip install powerline-status</div></pre></td></tr></table></figure>
<p>在第二步安装时，出现了这个错误，<code>error: [Errno 1] Operation not permitted: u&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/powerline&#39;</code>，如下图所示</p>
<p><img src="/images/mac/iterm-2.png" alt="error"></p>
<p>这个问题出现的原因，因为没有安装python，解决办法如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.安装Homebrew</span></div><div class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div><div class="line"><span class="comment"># 2.配置python</span></div><div class="line">brew install python</div><div class="line"><span class="comment"># 3.安装管道</span></div><div class="line">pip install --user powerline-status</div></pre></td></tr></table></figure>
<p>powerline的安装可以参考：</p>
<ol>
<li>brew安装参考<a href="http://brew.sh/" target="_blank" rel="external">官网</a></li>
<li>PowerLine安装参考<a href="http://powerline.readthedocs.io/en/latest/installation/osx.html" target="_blank" rel="external">官网</a></li>
</ol>
<h2 id="安装字体库"><a href="#安装字体库" class="headerlink" title="安装字体库"></a>安装字体库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载字体库</span></div><div class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git</div><div class="line"><span class="comment"># 安装所有字体</span></div><div class="line"><span class="built_in">cd</span> fonts</div><div class="line">./install.sh</div></pre></td></tr></table></figure>
<p>安装成功后，如下图所示</p>
<p><img src="/images/mac/iterm-3.png" alt="font"></p>
<p>安装完成后会提示所有的字体均已下载到<code>/Users/superdanny/Library/Fonts</code>路径。</p>
<h2 id="字体设置、配色方案设置及主题设置"><a href="#字体设置、配色方案设置及主题设置" class="headerlink" title="字体设置、配色方案设置及主题设置"></a>字体设置、配色方案设置及主题设置</h2><h3 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h3><p>安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的<code>Regular Font</code>和<code>Non-ASCII Font</code>的字体都设置成powerline的字体，我这里设置的字体是<code>14pt Meslo LG S DZ Regular for Powerline</code>.</p>
<p><img src="/images/mac/iterm-4.png" alt="font-setting"></p>
<h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><h4 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h4><p>需要先在github下下载solarized工程，<a href="https://github.com/altercation/solarized" target="_blank" rel="external">solarized github地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/altercation/solarized</div></pre></td></tr></table></figure>
<p>然后进入刚刚下载的工程的<code>solarized/iterm2-colors-solarized</code> 下双击 <code>Solarized Dark.itermcolors</code> 和 <code>Solarized Light.itermcolors</code> 两个文件就可以把配置文件导入到 iTerm2 里.</p>
<h4 id="配置配色方案"><a href="#配置配色方案" class="headerlink" title="配置配色方案"></a>配置配色方案</h4><p>通过load presets选择刚刚安装的配色主题即可</p>
<p><img src="/images/mac/iterm-5.png" alt="color"></p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>这里使用的是agnoster主题，<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="external">oh-my-zsh-agnoster-fcamblor Github地址</a></p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.下载主题</span></div><div class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor</div><div class="line"><span class="comment"># 2.安装主题</span></div><div class="line"><span class="built_in">cd</span> oh-my-zsh-agnoster-fcamblor</div><div class="line">./install</div></pre></td></tr></table></figure>
<h4 id="设置该主题"><a href="#设置该主题" class="headerlink" title="设置该主题"></a>设置该主题</h4><p>编辑<code>~/.zshrc</code>文件，然后将<code>ZSH_THEME</code>后面的字段改为<code>agnoster</code>。<code>ZSH_THEME=&quot;agnoster&quot;</code>（agnoster即为要设置的主题）.</p>
<h4 id="增加指令高亮效果"><a href="#增加指令高亮效果" class="headerlink" title="增加指令高亮效果"></a>增加指令高亮效果</h4><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮，这里需要先下载<code>zsh-syntax-highlighting</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.下载工程项目</span></div><div class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-syntax-highlighting.git</div><div class="line"><span class="comment"># 2.打开.zshrc文件，在最后添加下面内容</span></div><div class="line"><span class="built_in">source</span> /Users/matt/git//zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</div><div class="line"><span class="comment"># 3.打开.zshrc文件，在最后面添加下面内容</span></div><div class="line">plugins=(zsh-syntax-highlighting)</div></pre></td></tr></table></figure>
<p>配置完之后效果如下图所示</p>
<p><img src="/images/mac/iterm-6.png" alt="end"></p>
<h2 id="iTerm2快捷键"><a href="#iTerm2快捷键" class="headerlink" title="iTerm2快捷键"></a>iTerm2快捷键</h2><p>iTerm2快捷键的使用可以参考<a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a>这篇文章，这里给出一些常用的命令</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建标签</td>
<td>command + t</td>
</tr>
<tr>
<td>关闭标签</td>
<td>command + w</td>
</tr>
<tr>
<td>切换标签</td>
<td>command + 数字 command + 左右方向键</td>
</tr>
<tr>
<td>切换全屏</td>
<td>command + enter</td>
</tr>
<tr>
<td>查找</td>
<td>command +f</td>
</tr>
<tr>
<td>垂直分屏</td>
<td>command + d</td>
</tr>
<tr>
<td>水平分屏</td>
<td>command + shift + d</td>
</tr>
<tr>
<td>切换屏幕</td>
<td>command + option + 方向键 command + [ 或 command + ]</td>
</tr>
<tr>
<td>查看历史命令</td>
<td>command + ;</td>
</tr>
<tr>
<td>查看剪贴板历史</td>
<td>command + shift + h</td>
</tr>
<tr>
<td>清除当前行</td>
<td>ctrl + u</td>
</tr>
<tr>
<td>到行首</td>
<td>ctrl + a</td>
</tr>
<tr>
<td>到行尾</td>
<td>ctrl + e</td>
</tr>
<tr>
<td>前进后退</td>
<td>ctrl + f/b (相当于左右方向键)</td>
</tr>
<tr>
<td>上一条命令</td>
<td>ctrl + p</td>
</tr>
<tr>
<td>搜索命令历史</td>
<td>ctrl + r</td>
</tr>
<tr>
<td>删除当前光标的字符</td>
<td>ctrl + d</td>
</tr>
<tr>
<td>删除光标之前的字符</td>
<td>ctrl + h</td>
</tr>
<tr>
<td>删除光标之前的单词</td>
<td>ctrl + w</td>
</tr>
<tr>
<td>删除到文本末尾</td>
<td>ctrl + k</td>
</tr>
<tr>
<td>交换光标处文本</td>
<td>ctrl + t</td>
</tr>
<tr>
<td>清屏1</td>
<td>command + r</td>
</tr>
<tr>
<td>清屏2</td>
<td>ctrl + l</td>
</tr>
</tbody>
</table>
<h1 id="编程环境配置"><a href="#编程环境配置" class="headerlink" title="编程环境配置"></a>编程环境配置</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一般情况下，可能需要安装多个版本的JDK，具体各个版本的下载，JDK7和JDK8可以在官网上直接下载，而JDK6的下载资源就比较难找了，可以参考<a href="http://www.codecate.com/code/archives/16" target="_blank" rel="external">Mac安装jdk1.6 1.7 1.8</a>这篇文章</p>
<p>下载安装完这三个版本的JDK之后，需要进行以下配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bash下是~/.bashrc文件</span></div><div class="line"><span class="built_in">export</span> JAVA_6_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_7_HOME</span></div><div class="line"><span class="built_in">alias</span> jdk8=<span class="string">'export JAVA_HOME=$JAVA_8_HOME'</span></div><div class="line"><span class="built_in">alias</span> jdk7=<span class="string">'export JAVA_HOME=$JAVA_7_HOME'</span></div><div class="line"><span class="built_in">alias</span> jdk6=<span class="string">'export JAVA_HOME=$JAVA_6_HOME'</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</div></pre></td></tr></table></figure>
<h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><h3 id="idea安装"><a href="#idea安装" class="headerlink" title="idea安装"></a>idea安装</h3><p><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">idea下载地址</a></p>
<p>如果下载的版本是2016.1版，这里有一个<a href="http://aiyougege.com/articles/022711.html" target="_blank" rel="external">激活码</a>，不过推荐购买正版，免费版推荐社区版，一般的开发也就够用了。</p>
<h3 id="Google-Java编程规范配置"><a href="#Google-Java编程规范配置" class="headerlink" title="Google Java编程规范配置"></a>Google Java编程规范配置</h3><p>参考<a href="http://zacard.net/2016/04/11/idea-google-code-style/" target="_blank" rel="external">Idea直接导入xml文件</a>一文。</p>
<p>idea可以支持自定义的code style，并且google code style也提供了对idea的xml配置，直接导入就可以在idea中使用google提倡的code style了。</p>
<p>使用方法：</p>
<ol>
<li>从github上clone <a href="https://github.com/google/styleguide" target="_blank" rel="external">Google Style GitHub</a>；</li>
<li>复制对应的xml配置（如intellij-java-google-style.xml）到“~/Library/Preferences/IDEA/codestyles/”下</li>
<li>重启idea在Prefrence-&gt;Editor—&gt;Code Stytle-&gt;Java,选择GoogleStyle即可</li>
</ol>
<p>mac下格式化代码的快捷键： <code>command+alt+L</code></p>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>需要配置的内容主要有以下几项：</p>
<ol>
<li>自动行号显示</li>
<li>字体</li>
<li>SDK设置（就是jdk，scala等设置）</li>
<li>maven设置</li>
<li>快捷键</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>常用的快捷键如下表所示</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看所选代码的源码</td>
<td>cmd + ↓</td>
</tr>
<tr>
<td>查看maven依赖</td>
<td>opt+shift+cmd+U</td>
</tr>
<tr>
<td>智能补齐代码</td>
<td>opt + enter</td>
</tr>
<tr>
<td>生成一些常用方法，如：toString、get 等</td>
<td>control + enter</td>
</tr>
</tbody>
</table>
<p>关于快捷键可以参考<a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html" target="_blank" rel="external">Mac下idea快捷键</a>一文。</p>
<ul>
<li><a href="http://baowp.iteye.com/blog/1989575" target="_blank" rel="external">Mac下Idea打开Maven的jar包依赖图</a></li>
</ul>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="external">PyCharm下载地址</a></p>
<p>2016版的可以使用<a href="http://blog.csdn.net/jiang314/article/details/51680072" target="_blank" rel="external">注册码</a>进行破解，不过推荐购买正版。</p>
<h1 id="其他常用命令安装"><a href="#其他常用命令安装" class="headerlink" title="其他常用命令安装"></a>其他常用命令安装</h1><h2 id="tree命令安装"><a href="#tree命令安装" class="headerlink" title="tree命令安装"></a>tree命令安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 需要先安装HomeBrew</span></div><div class="line">brew install tree</div></pre></td></tr></table></figure>
<h1 id="Mac下遇到的其他问题"><a href="#Mac下遇到的其他问题" class="headerlink" title="Mac下遇到的其他问题"></a>Mac下遇到的其他问题</h1><h2 id="bashrc每次打开iterm都要重新加载"><a href="#bashrc每次打开iterm都要重新加载" class="headerlink" title="~/.bashrc每次打开iterm都要重新加载"></a>~/.bashrc每次打开iterm都要重新加载</h2><p>参考<a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">文章</a></p>
<p>原因：使用的zsh，而不是bash，所以zsh没有义务去加载<code>~/.bashrc</code>文件，zsh下别名一般放置到<code>~/.zshrc</code>文件中。</p>
<p>解决办法：在<code>~/.zshrc</code>文件的最后添加<code>source ~/.bashrc</code>.</p>
<h2 id="修改电脑名的方法"><a href="#修改电脑名的方法" class="headerlink" title="修改电脑名的方法"></a>修改电脑名的方法</h2><p>有人可能感觉跟我一样有强迫症，看到电脑名太长影响终端的显示，就想着怎么修改一下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行下面命令“mac”是你想要改的电脑名称</span></div><div class="line">sudo scutil --set HostName mac</div></pre></td></tr></table></figure>
<blockquote>
<p>注：关闭终端之后，重新打开终端就会生效。</p>
</blockquote>
<h2 id="修改电脑名导致的错误"><a href="#修改电脑名导致的错误" class="headerlink" title="修改电脑名导致的错误"></a>修改电脑名导致的错误</h2><p>使用上面的方法修改电脑名，可能会导致一个这样的错误.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 其中 mac 为自己设置的电脑名，不同的电脑名显示不一样</span></div><div class="line">java.net.UnknownHostException: mac: mac: nodename nor servname provided, or not known</div></pre></td></tr></table></figure>
<p>这个问题和路由映射有关系，处理方法就是对 mac 做个DNS解析指向127.0.0.1.</p>
<p>修改文件 <code>/etc/hosts</code>，在里面增加对 127.0.0.1 的解析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1    mac    localhost</div></pre></td></tr></table></figure>
<p>保存生效后，就没有问题了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="external">iTerm 2 &amp;&amp; Oh My Zsh</a></li>
<li><a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a></li>
<li><a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">为什么我的Mac不加载/etc/bashrc文件呢？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间因为在公司实习，公司提供的电脑都是Mac，还给发了一台全新的Mac pro，刚开始用的时候有很多不习惯的地方，但是用了几天之后就感觉Mac真的爽到爆啊，本篇文章就记录一下自己感觉在Mac上用到的一些不错的软件，以及Mac下一些常用编程工具的配置安装方法，这样也方便自
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mac" scheme="http://wangzzu.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Redis简单介绍</title>
    <link href="http://wangzzu.github.io/2016/06/06/redis-introduce/"/>
    <id>http://wangzzu.github.io/2016/06/06/redis-introduce/</id>
    <published>2016-06-06T15:56:55.000Z</published>
    <updated>2016-11-19T09:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是根据我在<a href="https://www.shiyanlou.com/courses/106" target="_blank" rel="external">实验楼-Redis基础教程</a>中学习的总结，简单讲述了一下Redis的安装和使用。</p>
<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括 <code>lists</code>, <code>sets</code>, <code>ordered sets</code> 以及 <code>hashes</code> ，当然还有和<code>Memcached</code>一样的 strings结构。Redis当然还包括了对这些数据结构的丰富操作。</p>
<p>Redis常被称作是一款数据结构服务器（<code>data structure server</code>）。Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（<code>append</code>）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p>
<h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><ul>
<li>性能极高：Redis能支持超过 100K+ 每秒的读写频率。</li>
<li>丰富的数据类型：Redis支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li>
<li>原子：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性：Redis还支持 <code>publish/subscribe</code>, 通知, key 过期等等特性。</li>
</ul>
<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>在<a href="http://redis.io/" target="_blank" rel="external">Redis官网</a>中下载最新的稳定版，这里我选用的是<code>3.2.0</code>稳定版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 解压按照包</div><div class="line">$ tar xvfz redis-3.2.0.tar.gz</div><div class="line"></div><div class="line"># 编译</div><div class="line">$ cd redis-3.2.0</div><div class="line">$ sudo make</div><div class="line">$ sudo make install</div><div class="line"></div><div class="line"># 测试</div><div class="line">$ make test</div></pre></td></tr></table></figure>
<p>测试成功的结果如下图所示：</p>
<p><img src="/images/redis/test.png" alt="test"></p>
<h1 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h1><h2 id="启动与配置"><a href="#启动与配置" class="headerlink" title="启动与配置"></a>启动与配置</h2><p>在 Redis 安装完成后，注意一些重要的文件，可用 ls 命令查看。</p>
<ul>
<li>服务端的启动脚本：<code>src/redis-server</code>；</li>
<li>客户端的启动脚本：<code>src/redis-cls</code>；</li>
<li>默认配置文件：<code>redis.conf</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动redis服务器</span></div><div class="line">$ ./src/redis-server</div></pre></td></tr></table></figure>
<p>启动成功结果如下图：</p>
<p><img src="/images/redis/start.png" alt="start"></p>
<blockquote>
<p>说明： 从上图中，可以发现启动的端口为缺省的<strong>6379</strong>. 用户可以在启动的时候，指定具体的配置文件，并在其中指定启动的端口。</p>
</blockquote>
<h2 id="配置-PATH"><a href="#配置-PATH" class="headerlink" title="配置$PATH"></a>配置$PATH</h2><p>然后将可执行文件放置在$PATH环境目录下，便于以后使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo　cp src/redis-server /usr/<span class="built_in">local</span>/bin/</div><div class="line">$　sudo cp src/redis-cli /usr/<span class="built_in">local</span>/bin/</div></pre></td></tr></table></figure>
<h2 id="查看Redis"><a href="#查看Redis" class="headerlink" title="查看Redis"></a>查看Redis</h2><p>再启动玩Redis服务器之后，可以通过以下命令来查看Redis运行情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep redis</div><div class="line"><span class="comment"># 通过启动命令检查Redis服务器状态</span></div><div class="line">$ netstat -nlt|grep 6379</div></pre></td></tr></table></figure>
<p><img src="/images/redis/state.png" alt="state"></p>
<h2 id="启动Redis-client"><a href="#启动Redis-client" class="headerlink" title="启动Redis-client"></a>启动Redis-client</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的<code>key-value</code> 存储器，正如本文开头所述Redis同时也是一种<code>data structures server</code>。传统的<code>key-value</code>是指支持使用一个<code>key</code>字符串来索引<code>value</code>字符串的存储，而Redis中，<code>value</code>不仅仅支持字符串，还支持更多的复杂结构，包括列表，集合，哈希表等。</p>
<p>在本小节中，我们一一讲解：Redis keys是采用<strong>二进制安全</strong>（这里的二进制安全可以理解为：只关心二进制化的字符串，不关心具体格式，只会严格的按照二进制的数据存取，并不会按照某种具体格式去解析，杜绝了出乱码的问题），这就意味着你可以使用任何二进制序列作为重点，从像”foo”可以联系一个 JPEG 文件。空字符串也是一个有效的密钥。</p>
<h2 id="Redis-strings"><a href="#Redis-strings" class="headerlink" title="Redis strings"></a>Redis strings</h2><p>字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。</p>
<p>这里启动<code>redis-cli</code>来看看Redis strings数据类型。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动服务器与客户端</span></div><div class="line">$ sudo service redis-server start</div><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># redis客户端下</span></div><div class="line">&gt; <span class="built_in">set</span> mykey somevalue</div><div class="line">&gt; get mykey</div></pre></td></tr></table></figure>
<p>如上例所示，可以<code>SET</code>和<code>GET</code>命令来创建和检索strings。注意,<code>set</code>命令将取代现有的任何已经存在的key。</p>
<p><code>SET</code>命令还有一个提供附加参数的选项,我们能够让<code>SET</code>命令只有在没有相同key的情况下成功，反之亦然，可以让<code>SET</code>命令在有相同key值得情况下成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey newval nx</div><div class="line">&gt; <span class="built_in">set</span> mykey newval xx</div></pre></td></tr></table></figure>
<p>即使string是Redis的基本类型，也可以对其进行一些有趣的操作，例如加法器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> counter 100</div><div class="line">&gt; incr counter</div><div class="line">&gt; incr counter</div><div class="line">&gt; incrby counter 50</div></pre></td></tr></table></figure>
<p><code>INCR</code>命令让the value 成为一个整数，运行一次<code>INCR</code>便+1。<code>INCRBY</code>命令便是一个加法运算。类似的命令如减法运算为： <code>DECR and DECRBY</code>。</p>
<p>Redis可以运用<code>MSET and MGET</code> 命令完成一次性的完成多个key-value的对应关系，使用<code>MGET</code>命令，Redis返回一个value数组。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mset a 10 b 20 c 30</div><div class="line">&gt; mget a b c</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/strings.png" alt="string"></p>
<h2 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p>
<ul>
<li><code>LPUSH</code> 命令插入一个新的元素导头部；</li>
<li><code>RPUSH</code>插入一个新元素导尾部.</li>
</ul>
<p>当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间中删除。</p>
<p><code>PUSH</code>一类的命令的返回值为list的长度。一些类表操作和结果的例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; rpush mylist A</div><div class="line">&gt; rpush mylist B</div><div class="line">&gt; lpush mylist first</div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>LRANGE</code> 利用了两个检索值，0表示list的开头第一个，-1表示list的倒数第一个，即最后一个。-2则便是list的倒数第二个，以此类推。</p>
</blockquote>
<p>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入list。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; rpush mylist 1 2 3 4 5 <span class="string">"foo bar"</span></div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<p>在Redis的命令操作中，还有一类重要的操作：<code>POP</code>，取出list元素。和<code>PUSH</code>操作类似，<code>POP</code>命令可以选择不同的方向取出元素.<code>POP</code>命令返回值为取出的元素。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; del mylist</div><div class="line">&gt; rpush mylist a b c</div><div class="line">&gt; rpop mylist</div><div class="line">&gt; lrange mylist 0 -1</div><div class="line">&gt; lpop mylist</div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/list.png" alt="list"></p>
<h2 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h2><p>Redis Hashes是字符串字段和字符串值之间的映射，因此他们是展现对象的完美数据类型。 (例如:一个有名，姓，年龄等等属性的用户)：一个带有一些字段的<code>hash</code>仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的Redis实例中。 哈希主要用来表现对象，他们有能力存储很多对象，因此你可以将哈希用于许多其他的任务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; hmset user:1000 username antirez birthyear 1977 verified 1</div><div class="line">&gt; hget user:1000 username</div><div class="line">&gt; hget user:1000 birthyear</div><div class="line">&gt; hgetall user:1000</div></pre></td></tr></table></figure>
<ul>
<li><code>HMSET</code>命令设置一个多域的hash表；</li>
<li><code>HGET</code>命令获取指定的单域；</li>
<li><code>HGETALL</code>命令获取指定key的所有信息；</li>
<li><code>HMGET</code>类似于<code>HGET</code>，只是返回一个value数组。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; hmget user:1000 username birthyear no-such-field</div></pre></td></tr></table></figure>
<p>同样可以根据需要对hash表的表项进行单独的操作，例如 <code>HINCRBY</code>， （原本birthyear 为1977，见上一图）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; hincrby user:1000 birthyear 10</div><div class="line">&gt; hincrby user:1000 birthyear 10</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/hash.png" alt="hash"></p>
<h2 id="Redis-无序集合"><a href="#Redis-无序集合" class="headerlink" title="Redis 无序集合"></a>Redis 无序集合</h2><p>Redis 集合（Set）是一个<strong>无序的字符串集合</strong>. 你可以以$O(1)$的时间复杂度 (无论集合中有多少元素时间复杂度都是常量）完成添加、删除，以及测试元素是否存在。 Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（<code>unions</code>）, 求交集（<code>intersections</code>），找出不同的元素（<code>differences of sets</code>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sadd myset 1 2 3</div><div class="line">&gt; smembers myset</div></pre></td></tr></table></figure>
<ul>
<li><code>SADD</code>命令产生一个无序集合，并返回集合的元素个数；</li>
<li><code>SMEMBER</code>用于查看集合；</li>
<li><code>SISMEMBER</code>用于查看集合是否存在，匹配项包括集合名和元素个数，匹配成功返回1，匹配失败返回0。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sismember myset 3</div><div class="line">&gt; sismember myset 30</div><div class="line">&gt; sismember mys 3</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set1.png" alt="set1"></p>
<h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>Redis有序集合与普通集合非常相似，是一个<strong>没有重复元素的字符串集合</strong>。不同之处是有序集合的没有成员都关联了一个<strong>评分</strong>，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。 使用有序集合你可以以非常快的速度（$O\log{N}$）添加，删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（<code>score</code>）或者次序（<code>position</code>）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。</p>
<p><code>ZADD</code>与<code>SADD</code>类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; zadd hackers 1940 <span class="string">"Alan Kay"</span></div><div class="line">&gt; zadd hackers 1957 <span class="string">"Sophie Wilson"</span></div><div class="line">&gt; zadd hackers 1953 <span class="string">"Richard Stallman"</span></div><div class="line">&gt; zadd hackers 1949 <span class="string">"Anita Borg"</span></div><div class="line">&gt; zadd hackers 1965 <span class="string">"Yukihiro Matsumoto"</span></div><div class="line">&gt; zadd hackers 1914 <span class="string">"Hedy Lamarr"</span></div><div class="line">&gt; zadd hackers 1916 <span class="string">"Claude Shannon"</span></div><div class="line">&gt; zadd hackers 1969 <span class="string">"Linus Torvalds"</span></div><div class="line">&gt; zadd hackers 1912 <span class="string">"Alan Turing"</span></div></pre></td></tr></table></figure>
<ul>
<li><code>ZRANGE</code>是查看正序的集合;</li>
<li><code>ZREVRANGE</code>是查看反序的集合。0表示集合第一个元素，-1表示集合的倒数第一个元素。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; zrange hackers 0 -1</div><div class="line">&gt; zrevrange hackers 0 -1</div></pre></td></tr></table></figure>
<p>使用<code>WITHSCORES</code> 参数返回记录值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; zrange hackers 0 -1 withscores</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set2.png" alt="set2"></p>
<h1 id="Redis系统管理"><a href="#Redis系统管理" class="headerlink" title="Redis系统管理"></a>Redis系统管理</h1><p>在Redis中，命令大小写不敏感。</p>
<h2 id="适合全体类型的常用命令"><a href="#适合全体类型的常用命令" class="headerlink" title="适合全体类型的常用命令"></a>适合全体类型的常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动服务器与客户端</span></div><div class="line">$ redis-server</div><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<h3 id="EXISTS-and-DEL"><a href="#EXISTS-and-DEL" class="headerlink" title="EXISTS and DEL"></a>EXISTS and DEL</h3><ul>
<li><code>EXISTS key</code> 判断一个key是否存在，存在返回 1;否则返回0;</li>
<li><code>DEL key</code> 删除某个key，或是一系列key，<code>DEL key1 key2 key3 key4</code>。成功返回1，失败返回0（key值不存在）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey hello</div><div class="line">&gt; exists mykey</div><div class="line"></div><div class="line">&gt; del mykey</div><div class="line">&gt; exists mykey</div></pre></td></tr></table></figure>
<p><img src="/images/redis/exist.png" alt="exist"></p>
<h3 id="TYPE-and-KEYS"><a href="#TYPE-and-KEYS" class="headerlink" title="TYPE and KEYS"></a>TYPE and KEYS</h3><ul>
<li><code>TYPE key</code>：返回某个key元素的数据类型 ( none:不存在,string:字符,list,set,zset,hash)，key不存在返回空。</li>
<li><code>KEYS key—pattern</code> ：返回匹配的key列表 (<code>KEYS foo*</code>:查找foo开头的keys)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey x</div><div class="line">&gt; <span class="built_in">type</span> mykey</div><div class="line">&gt; keys my*</div><div class="line">&gt; del mykey</div><div class="line">&gt; keys my*</div><div class="line">&gt; <span class="built_in">type</span> mykey</div></pre></td></tr></table></figure>
<p><img src="/images/redis/type.png" alt="type"></p>
<h3 id="RANDOMKEY-and-CLEAR"><a href="#RANDOMKEY-and-CLEAR" class="headerlink" title="RANDOMKEY and CLEAR"></a>RANDOMKEY and CLEAR</h3><ul>
<li><code>RANDOMKEY</code> ： 随机获得一个已经存在的key，如果当前数据库为空，则返回空字符串</li>
<li><code>CLEAR</code> ：清除界面。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; randomkey</div><div class="line">&gt; clear</div></pre></td></tr></table></figure>
<h3 id="RENAME-and-RENAMENX"><a href="#RENAME-and-RENAMENX" class="headerlink" title="RENAME and RENAMENX"></a>RENAME and RENAMENX</h3><ul>
<li><code>RENAME oldname newname</code>：改key的名字，新键如果存在将被覆盖;</li>
<li><code>RENAMENX oldname newname</code>：更改key的名字，如果名字存在则更改失败.</li>
</ul>
<p>笔者randomkey结果为mylist，将此key值更名为newlist。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; randomkey</div><div class="line">&gt; rename mylist newlist</div><div class="line">&gt; exists mylist</div><div class="line">&gt; exists newlist</div></pre></td></tr></table></figure>
<p><img src="/images/redis/rename.png" alt="rename"></p>
<h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><p><code>DBSIZE</code> ：返回当前数据库的key的总数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dbsize</div></pre></td></tr></table></figure>
<h2 id="Redis-时间相关命令"><a href="#Redis-时间相关命令" class="headerlink" title="Redis 时间相关命令"></a>Redis 时间相关命令</h2><h3 id="限定key生存时间"><a href="#限定key生存时间" class="headerlink" title="限定key生存时间"></a>限定key生存时间</h3><p>这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的DEL操作。</p>
<ul>
<li><code>EXPIRE</code>：设置某个key的过期时间（秒）,(<code>EXPIRE bruce 1000</code>：设置<code>bruce</code>这个key1000秒后系统自动删除)</li>
</ul>
<blockquote>
<p>注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> key some-value</div><div class="line">&gt; expire key 10</div><div class="line"><span class="comment"># 马上执行此命令</span></div><div class="line">&gt; get key</div><div class="line"><span class="comment"># 10s后执行此命令</span></div><div class="line">&gt; get key</div></pre></td></tr></table></figure>
<p>结果显示，执行EXPIRE命令后，马上GET，显示key存在。10秒后再GET时，key 已经被自动删除。</p>
<p><img src="/images/redis/ttl.png" alt="ttl"></p>
<h3 id="查询key剩余生存时间"><a href="#查询key剩余生存时间" class="headerlink" title="查询key剩余生存时间"></a>查询key剩余生存时间</h3><p>限时操作可以再<code>SET</code>命令中实现，并且可用<code>TTL</code>命令查询key剩余生存时间。</p>
<p><code>TTL</code>：查找某个key还有多长时间过期,返回时间秒</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> key 100 ex 30</div><div class="line">&gt; ttl key</div><div class="line">&gt; ttl key</div></pre></td></tr></table></figure>
<h3 id="清除key"><a href="#清除key" class="headerlink" title="清除key"></a>清除key</h3><ul>
<li><code>FLUSHDB</code>：清空当前数据库中的所有键;</li>
<li><code>FLUSHALL</code>：清空所有数据库中的所有键.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; flushdb</div><div class="line">&gt; flushall</div></pre></td></tr></table></figure>
<h2 id="Redis设置相关命令"><a href="#Redis设置相关命令" class="headerlink" title="Redis设置相关命令"></a>Redis设置相关命令</h2><p>Redis有其配置文件，可以通过client-command窗口查看或者更改相关配置。相关命令介绍如下：</p>
<h3 id="CONFIG-GET-and-CONFIG-SET"><a href="#CONFIG-GET-and-CONFIG-SET" class="headerlink" title="CONFIG GET and CONFIG SET"></a>CONFIG GET and CONFIG SET</h3><ul>
<li><code>CONFIG GET</code>：用来读取运行Redis服务器的配置参数。</li>
<li><code>CONFIG SET</code>：用于更改运行Redis服务器的配置参数。</li>
<li><code>AUTH</code> : 认证密码，下面针对Redis密码的示例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; config get requirepass （查看密码）</div><div class="line">&gt; config <span class="built_in">set</span> requirepass <span class="built_in">test</span>123 （设置密码为<span class="built_in">test</span>123 ）</div><div class="line">&gt; config get requirepass  （报错，没有认证）</div><div class="line">&gt; auth <span class="built_in">test</span>123</div><div class="line">&gt; config get requirepass</div></pre></td></tr></table></figure>
<p>由结果可知，刚开始时Reids并未设置密码，密码查询结果为空。然后设置密码为test123，再次查询报错。经过auth命令认证后，可正常查询。</p>
<p>可以经过修改Redis的配置文件redis.conf修改密码。</p>
<p><code>CONFIG GET</code>命令是以list的key-value对显示的，如查询数据类型的最大条目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; config get *max-*-entries*</div></pre></td></tr></table></figure>
<p><img src="/images/redis/pass.png" alt="pass"></p>
<h3 id="重置报告"><a href="#重置报告" class="headerlink" title="重置报告"></a>重置报告</h3><p><code>CONFIG RESETSTAT</code>：重置数据统计报告，通常返回值为’OK”。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; CONFIG RESETSTAT</div></pre></td></tr></table></figure>
<h2 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h2><p><code>INFO [section]</code> ：查询Redis相关信息。 INFO命令可以查询Redis几乎所有的信息，其命令选项有如下：</p>
<ul>
<li><code>server</code> : Redis server的常规信息</li>
<li><code>clients</code> : Client的连接选项</li>
<li><code>memory</code> : 存储占用相关信息</li>
<li><code>persistence</code> : RDB and AOF 相关信息</li>
<li><code>stats</code> : 常规统计</li>
<li><code>replication</code> : Master/slave请求信息</li>
<li><code>cpu</code> : CPU 占用信息统计</li>
<li><code>cluster</code> : Redis 集群信息</li>
<li><code>keyspace</code> : 数据库信息统计</li>
<li><code>all</code> : 返回所有信息</li>
<li><code>default</code> : 返回常规设置信息</li>
</ul>
<p>若命令参数为空，info命令返回所有信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; info keyspace</div><div class="line">&gt; info server</div></pre></td></tr></table></figure>
<h1 id="Redis的高级应用"><a href="#Redis的高级应用" class="headerlink" title="Redis的高级应用"></a>Redis的高级应用</h1><p>本节来讲述Redis的高级应用，包括：安全性设置，主从复制，事务处理， 持久化机制， 虚拟内存的使用。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>设置在客户端连接是需要指定的密码（由于redis速度相当的快，一秒钟可以150K次的密码尝试，所以需要设置一个密码强度很大的密码）。</p>
<p>设置密码的方式有两种：</p>
<ol>
<li>使用<code>config set</code> 命令的<code>requirepass</code> 参数，具体格式为<code>config set requirepass “password”</code>;</li>
<li>配置<code>redis.conf</code> 中设置<code>requirepass</code>属性，后面为密码。</li>
</ol>
<p>输入认证的方式也有两种：</p>
<ol>
<li>登录时可以 <code>redis-cli -a password</code>;</li>
<li>登录后使用 <code>auth password</code>.</li>
</ol>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>第一种密码设置方式在上面已经提到，（在<code>CONFIG SET</code>命令讲解的实例），此处我们来看看第二种方式设置密码。</p>
<p>首先需要进入Redis的安装目录，然后修改配置文件<code>redis.conf</code>。根据<code>grep</code>命令的结果，使用vi编辑器修改<code># requirepass foobared</code> 为<code>requirepass test123</code>，然后保存退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep -n requirepass /etc/redis/redis.conf</div><div class="line">$ sudo vim /etc/redis/redis.conf</div></pre></td></tr></table></figure>
<h3 id="重启redis-server-与redis-cli"><a href="#重启redis-server-与redis-cli" class="headerlink" title="重启redis-server 与redis-cli"></a>重启redis-server 与redis-cli</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重启redis server。</span></div><div class="line">$ sudo service redis-server restart</div></pre></td></tr></table></figure>
<p>进入到redis-cli交互界面进行验证</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">&gt; info</div><div class="line">&gt; auth <span class="built_in">test</span>123</div><div class="line">&gt; info</div><div class="line">&gt; <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>结果表明第一次<code>info</code>命令失败，在<code>auth</code>认证之后<code>info</code>命令正常返回。最后退出<code>redis-cli</code>。</p>
<p>另外一种密码认证方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli <span class="_">-a</span> <span class="built_in">test</span>123</div><div class="line">&gt; info</div></pre></td></tr></table></figure>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制配置和使用都比较简单，通过主从复制可以允许多个slave server拥有和master server相同的数据库副本。从服务器只能读，不能写。</p>
<p>Redis主从复制特点：</p>
<ol>
<li>master可以拥有多个slave;</li>
<li>多个slave可以连接同一个master外，还可以连接到其他的slave。（当master宕机后，相连的slave转变为master）;</li>
<li>主从复制不会阻塞master，再同步数据时，master可以继续处理client请求;</li>
<li>提高了系统的可伸缩性。</li>
</ol>
<p>Redis主从复制的过程：</p>
<ol>
<li>Slave与master建立连接，发送sync同步命令;</li>
<li>Master会启动一个后台进程，将数据库快照保存到文件中，同时Master主进程会开始收集新的写命令并缓存;</li>
<li>后台完成保存后，就将此文件发送给Slave;</li>
<li>Slave将此文件保存到磁盘上。</li>
</ol>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令，当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; multi</div><div class="line">&gt; <span class="built_in">set</span> name a</div><div class="line">&gt; <span class="built_in">set</span> name b</div><div class="line">&gt; <span class="built_in">exec</span></div><div class="line">&gt; get name</div></pre></td></tr></table></figure>
<p><img src="/images/redis/multi.png" alt="multi"></p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p>
<p>Redis支持两种持久化方式：</p>
<ol>
<li><code>snapshotting</code>（快照），将数据存放到文件里，默认方式。<br>是将内存中的数据已快照的方式写入到二进制文件中，默认文件<code>dump.rdb</code>，可以通过配置设置自动做快照持久化的方式。可配置Redis在n秒内如果超过m个key被修改就自动保存快照。<ul>
<li><code>save 900 1</code>: 900秒内如果超过1个key被修改，则发起快照保存;</li>
<li><code>save 300 10</code>: 300秒内如果超过10个key被修改，则快照保存.</li>
</ul>
</li>
<li><code>Append-only file</code>（缩写为<code>aof</code>），将读写操作存放到文件中。</li>
</ol>
<blockquote>
<p>Note: 由于快照方式在一定间隔时间做一次，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</blockquote>
<p><code>aof</code>比快照方式有更好的持久化性，是由于使用<code>aof</code>时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p>
<p>由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉redis我们想要通过<code>fsync</code>函数强制os写入到磁盘的时机。</p>
<p>配置文件中的可配置参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">appendonly   yes     //启用aof持久化方式</div><div class="line">#appendfsync  always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化</div><div class="line">appendfsync   everysec  //每秒中写入磁盘一次，在性能和持久化方面做了很好的折中</div><div class="line">#appendfsync  no     //完全依赖os，性能最好，持久化没有保证</div></pre></td></tr></table></figure>
<p>在redis-cli的命令中，SAVE命令是将数据写入磁盘中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">help</span> save</div><div class="line">&gt; save</div></pre></td></tr></table></figure>
<h2 id="虚拟内存的使用"><a href="#虚拟内存的使用" class="headerlink" title="虚拟内存的使用"></a>虚拟内存的使用</h2><p>虚拟内存管理在2.6及之上版本取消了，本文安装的的是3.2.0版本的redis ，所以配置文件中并没有虚拟内存管理功能的配置选项。此处仅仅是大概介绍一下。</p>
<p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其他的访问数据，尤其对于redis这样的内存数据库，内存总是不够用的。除了分隔到多个redis server外，提高数据库的容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。</p>
<p>通过配置vm相关的<code>redis.config</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vm-enable  yes                   #开启vm功能</div><div class="line">vm-swap-file    /tmp/redis.swap  #交换出来的value保存的文件路径</div><div class="line">vm-max-memory    10000000        #redis使用的最大内存上线</div><div class="line">vm-page-size   32       #每个页面的大小32字节</div><div class="line">vm-pages     123217729    #最多使用多小个页面</div><div class="line">vm-max-threads     4        #用于执行value对象换入的工作线程数量</div></pre></td></tr></table></figure>
<hr>
<p>参考</p>
<ul>
<li><a href="http://redis.io/" target="_blank" rel="external">Redis官网</a></li>
<li><a href="http://www.redis.cn/" target="_blank" rel="external">Redis中文网站</a></li>
<li><a href="http://redisdoc.com/" target="_blank" rel="external">Redis命令参考</a></li>
<li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">Redis | 菜鸟教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是根据我在&lt;a href=&quot;https://www.shiyanlou.com/courses/106&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼-Redis基础教程&lt;/a&gt;中学习的总结，简单讲述了一下Redis的安装和使用。&lt;/p&gt;
&lt;h1
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="database" scheme="http://wangzzu.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化学习</title>
    <link href="http://wangzzu.github.io/2016/05/21/java-serializable/"/>
    <id>http://wangzzu.github.io/2016/05/21/java-serializable/</id>
    <published>2016-05-21T09:11:30.000Z</published>
    <updated>2016-11-19T09:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要是对Java序列化学习的一些总结，一来是方便自己以后查阅，二来是希望通过本文能给他人带来一些帮助。</p>
<h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>Java提供了一种对象序列化的机制，在该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以再从文件中读取出来，并且对它进行反序列化，也就是说，可以根据对象的类型信息、对象的数据、还有对象中的数据类型可以在内存中新建该对象。</p>
<p>在实际的应用中，我们为什么需要对象序列化机制呢？因为在一般情况下，只有当JVM进程处于运行时，JVM建立的对象才可能存在，也就是说，这些对象的生命周期不会比JVM进程的生命周期更长。但是在现实的应用中，有时需要在JVM进程停止运行之后能够保存(持久化)指定的对象，并且在将来某个时刻重新读取被保存的对象，或者我们希望将一个进程创建的对象传送到另一个JVM进程中。Java的对象序列化机制就能够帮助我们实现这些功能（这就意味着序列化机制是可以自动弥补不同操作系统之间的差异）。</p>
<p>一般来说，对象的序列化主要有两种用途：</p>
<ul>
<li>把对象的字节序列持久化到硬盘，通常保存在一个文件中；</li>
<li>在网络上传输对象的字节序列；</li>
</ul>
<p>我们在使用Java对象序列化时，会把对象的状态保存为一组字节序列，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的<strong>状态</strong>，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量，因为静态变量是类的状态。</p>
<p>这个整个过程都是Java虚拟机（JVM）独立完成的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>但是一个类的对象如果要想序列化成功，必须满足两个条件：</p>
<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性<strong>必须注明是短暂</strong>的。</li>
</ul>
<p>如果你想知道一个Java标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现<code>java.io.Serializable</code>接口即可。</p>
<h1 id="序列化实现的示例"><a href="#序列化实现的示例" class="headerlink" title="序列化实现的示例"></a>序列化实现的示例</h1><ul>
<li>对象序列化时，首先要创建某个<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，只需要调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>（对象化序列是基于字节的，因要使用<code>InputStream</code>和<code>OutputStream</code>继承层次结构）；</li>
<li>对象反序列化时，需要将一个<code>InputStream</code>对象封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>方法；</li>
</ul>
<p>对象序列化时，不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内包含的每个这样的引用进行追踪，并保存那些对象，这种情况有时被称为“对象网”。</p>
<p>这里我们先建立一个对象<code>Person</code>，如下（<a href="https://github.com/wangzzu/java_learn/tree/master/java_thinking/src/javabasic/serialize" target="_blank" rel="external">示例参考</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person.java</span></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">private</span> Gender gender;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Gender gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">		<span class="keyword">this</span>.id = (<span class="keyword">new</span> Random()).nextInt(<span class="number">10</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Gender <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Gender gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">", "</span> + age + <span class="string">", "</span> + gender + <span class="string">", "</span> + id + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面，我们在一个进程里对其进行序列化，然后再反序列化出该对象（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Serialize.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Serialize.java</span></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Person p1 = <span class="keyword">new</span> Person(<span class="string">"wm0"</span>, <span class="number">10</span>, Gender.MALE);</div><div class="line">		Person p2 = <span class="keyword">new</span> Person(<span class="string">"wm1"</span>, <span class="number">18</span>, Gender.MALE);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"p1 = "</span> + p1);</div><div class="line">		ObjectOutputStream out = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 写入本地文件</span></div><div class="line">			out.writeObject(<span class="string">"Person1 storage\n"</span>);</div><div class="line">			out.writeObject(p1);</div><div class="line">			out.close(); <span class="comment">// Also flushes output</span></div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 从本地文件读取</span></div><div class="line">			String s = <span class="keyword">null</span>;</div><div class="line">			Person p11 = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				s = (String) in.readObject();</div><div class="line">				p11 = (Person) in.readObject();</div><div class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p11);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"\n"</span>+ <span class="string">"p2 = "</span> + p2);</div><div class="line">			ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream(); <span class="comment">// 将数据写入缓冲区</span></div><div class="line">			ObjectOutputStream out2 = <span class="keyword">new</span> ObjectOutputStream(bout);</div><div class="line">			out2.writeObject(<span class="string">"Person2 storage\n"</span>);</div><div class="line">			out2.writeObject(p2);</div><div class="line">			out2.flush();</div><div class="line">			ObjectInputStream in2 = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray())); <span class="comment">// 通过toByteArray()获取数据</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				s = (String) in2.readObject();</div><div class="line">				Person p22 = (Person) in2.readObject();</div><div class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p22);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一点要注意的是：反序列化Person对象时，需要要能找到<code>Person.class</code>，否者就会抛出<code>ClassNotFoundException</code>的异常。</p>
<h1 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h1><p>通过上面的例子，我们可以看出序列化的使用，其实还是很简单的，但是，如果我们有特殊的需要那又该怎么办呢？下面我们介绍几种序列化的控制机制。</p>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p>如果我们希望对象的一部分被序列化，而另一部分不被序列化；或者一个对象被还原之后，某子对象需要重新创建，从而不必将该子对象序列化。在这种情况下，我们可以通过实现<code>Externalization</code>接口——该接口实现<code>Serializable</code>接口，同时增加两个方法：<code>writeExternal()</code>和<code>readExternal()</code>，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作。</p>
<p>这与恢复<code>Serializable</code>对象不同，对于<code>Serializable</code>对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。但是对于一个<code>Externalization</code>对象，所有普通的默认构造器都会被调用（包括字段定义时的初始化），然后调用<code>readExternal()</code>。</p>
<blockquote>
<p>必须要注意这一点：所有默认的构造器都会被调用，才能使<code>Externalization</code>对象产生正确的行为。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Blip3.java</span></div><div class="line"><span class="keyword">import</span> java.io.Externalizable;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">private</span> String s; <span class="comment">// No initialization</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3 Constructor"</span>);</div><div class="line">		<span class="comment">// s, i not initialized</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3(String x, int a)"</span>);</div><div class="line">		s = x;</div><div class="line">		i = a;</div><div class="line">		<span class="comment">// s &amp; i initialized only in non-default constructor.</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> s + i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3.writeExternal"</span>);</div><div class="line">		<span class="comment">// You must do this:</span></div><div class="line">		out.writeObject(s);</div><div class="line">		out.writeInt(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3.readExternal"</span>);</div><div class="line">		<span class="comment">// You must do this:</span></div><div class="line">		s = (String) in.readObject();</div><div class="line">		i = in.readInt();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</div><div class="line">		Blip3 b3 = <span class="keyword">new</span> Blip3(<span class="string">"A String "</span>, <span class="number">47</span>);</div><div class="line">		System.out.println(b3);</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Blip3.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Saving object:"</span>);</div><div class="line">		o.writeObject(b3);</div><div class="line">		o.close();</div><div class="line">		<span class="comment">// Now get it back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Blip3.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Recovering b3:"</span>);</div><div class="line">		b3 = (Blip3) in.readObject();</div><div class="line">		System.out.println(b3);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* Output:</span></div><div class="line">* Constructing objects:</div><div class="line">* Blip3(String x, int a)</div><div class="line">* A String 47</div><div class="line">* Saving object:</div><div class="line">* Blip3.writeExternal</div><div class="line">* Recovering b3:</div><div class="line">* Blip3 Constructor</div><div class="line">* Blip3.readExternal</div><div class="line">* A String 47</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>在上面的例子中，字段<code>s</code>和<code>i</code>只会在第二个构造器中初始化，而不是在默认的构造器中初始化。这意味着假如不在<code>readExternal()</code>中初始化<code>s</code>和<code>i</code>，<code>s</code>就会为<code>null</code>，而<code>i</code>就会为零（因为在创建对象的第一步中将对象的存储空间清理为0）。如果我们把<code>writeExternal()</code>方法中两行注释掉，对象还原后，<code>s</code>是<code>null</code>，而<code>i</code>是零。</p>
<p>我们如果从一个<code>Externalization</code>对象继承，通常需要调用基类版本的<code>writeExternal()</code>和<code>readExternal()</code>来为基类组件提供恰当的存储和恢复功能。</p>
<p>因此，为了正常运行，我们不仅需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalization</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据。</p>
<h2 id="Transient关键字"><a href="#Transient关键字" class="headerlink" title="Transient关键字"></a>Transient关键字</h2><p>在进行序列化控制时，可能某个特定子对象不想让Java的序列化机制自动保存和恢复。如果子对象表示的是我们不希望将其序列化的敏感信息（如密码），那么我们就会面临这种情况。即使对象中的这些信息是<code>private</code>属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问到它。</p>
<p>有两种方法可以实现上述要求：</p>
<ol>
<li>将类实现<code>Externalizable</code>接口，这样的话，没有任何东西是可以自动序列化，并且可以在<code>writeExternal()</code>内部只对所需部门进行显式的序列化；</li>
<li>如果在操作的是一个<code>Serializable</code>对象，那么所有序列化操作都会自动进行，为了能够进行控制，可以用<code>transient</code>关键字逐个字段地关闭序列化，这个关键字的意思就是<strong>不用麻烦你保存或者回复数据——我自己会处理的</strong>。</li>
</ol>
<p><a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Login.java" target="_blank" rel="external">示例</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Login.java</span></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="comment">//: io/Logon.java</span></div><div class="line"><span class="comment">//Demonstrates the "transient" keyword.</span></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</div><div class="line">	<span class="keyword">private</span> String username;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String password;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name, String pwd)</span> </span>&#123;</div><div class="line">		username = name;</div><div class="line">		password = pwd;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"logon info: \n   username: "</span> + username + <span class="string">"\n   date: "</span> + date + <span class="string">"\n   password: "</span> + password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Login a = <span class="keyword">new</span> Login(<span class="string">"Hulk"</span>, <span class="string">"myLittlePony"</span>);</div><div class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Logon.out"</span>));</div><div class="line">		o.writeObject(a);</div><div class="line">		o.close();</div><div class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// Delay</span></div><div class="line">		<span class="comment">// Now get them back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Logon.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Recovering object at "</span> + <span class="keyword">new</span> Date());</div><div class="line">		a = (Login) in.readObject();</div><div class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="comment">/*</span></div><div class="line">* logon a = logon info:</div><div class="line">*   username: Hulk</div><div class="line">*    date: Tue May 17 11:11:28 CST 2016</div><div class="line">*    password: myLittlePony</div><div class="line">* Recovering object at Tue May 17 11:11:29 CST 2016</div><div class="line">* logon a = logon info:</div><div class="line">*    username: Hulk</div><div class="line">*    date: Tue May 17 11:11:28 CST 2016</div><div class="line">*    password: null</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到，其中的<code>date</code>和<code>username</code>域是一般的（不是<code>transient</code>的），所以它们会被自动序列化。而<code>password</code>是<code>transient</code>的，所以不会被自动保存到磁盘；另外，自动序列化机制也不会尝试去恢复它。当对象被恢复时，<code>password</code>域就会变成<code>null</code>。我们还可以发现，<code>date</code>字段也是从存储到了磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
<blockquote>
<p>由于实现<code>Externalizable</code>接口的对象在默认情况下不保存它们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用。</p>
</blockquote>
<h2 id="重写writeObject-和readObject-方法"><a href="#重写writeObject-和readObject-方法" class="headerlink" title="重写writeObject()和readObject()方法"></a>重写writeObject()和readObject()方法</h2><p>如果不是特别坚持使用<code>Externalizable</code>接口，那么还有一种方法。我们可以实现<code>Serializable</code>接口，并添加<code>writeObject()</code>和<code>readObject()</code>方法。这样一旦对象被序列化或者被反序列化还原，就会自动地分别调用这两个方法，而不是使用默认的序列化机制。（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/SerialCtl.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SerialCtl.java</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCtl</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String a;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String b;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SerialCtl</span><span class="params">(String aa, String bb)</span> </span>&#123;</div><div class="line">		a = <span class="string">"Not Transient: "</span> + aa;</div><div class="line">		b = <span class="string">"Transient: "</span> + bb;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> a + <span class="string">" "</span> + b;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 自定义该方法，这里要注意方法时private</div><div class="line">	 * 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了它自己的writeObject()。</div><div class="line">	 * 如果是这样，就跳过正常的序列化过程并调用它的writeObject()</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> stream</div><div class="line">	 * <span class="doctag">@throws</span> IOException</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		stream.defaultWriteObject(); <span class="comment">// 执行默认的writeObject()</span></div><div class="line">		stream.writeObject(b); <span class="comment">// transient字段需要明确保存和</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		stream.defaultReadObject(); <span class="comment">// 执行默认的readObject()</span></div><div class="line">		b = (String) stream.readObject(); <span class="comment">// transient字段需要明确恢复</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		SerialCtl sc = <span class="keyword">new</span> SerialCtl(<span class="string">"Test1"</span>, <span class="string">"Test2"</span>);</div><div class="line">		System.out.println(<span class="string">"Before:\n"</span> + sc);</div><div class="line">		ByteArrayOutputStream buf = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(buf);</div><div class="line">		o.writeObject(sc);</div><div class="line">		<span class="comment">// Now get it back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf.toByteArray()));</div><div class="line">		SerialCtl sc2 = (SerialCtl) in.readObject();</div><div class="line">		System.out.println(<span class="string">"After:\n"</span> + sc2);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">* Before:</div><div class="line">* Not Transient: Test1 Transient: Test2</div><div class="line">* After:</div><div class="line">* Not Transient: Test1 Transient: Test2</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>上述的例子中，非transient字段由<code>defaultReadObject</code>保存，而transient字段必须在程序中明确保存和恢复。</p>
<h2 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h2><p>前面我们也已经提到过，静态变量是不会被序列化的，这里我们通过一个例子来看一下（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StaticTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id=<span class="number">10</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</div><div class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/static.out"</span>));</div><div class="line">			o.writeObject(<span class="keyword">new</span> StaticTest());</div><div class="line">			o.close();</div><div class="line">			StaticTest.id=<span class="number">0</span>;</div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/static.out"</span>));</div><div class="line">			StaticTest staticTest = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				staticTest = (StaticTest) in.readObject();</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(staticTest.id);</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* output:</div><div class="line">* 0</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>程序输出的结果为修改之后的结果，正如我们前面所述一样，对象序列化时并不会序列化静态变量，这一点可以这样理解：对象序列化是序列化对象的状态，而静态变量是类变量，也就是类的状态。因此，<strong>对象序列化并不保存静态变量</strong>。</p>
<h2 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h2><p>这里我们通过一个例子来看一下Java序列化机制的存储规则，主要是多次写入同一个对象的情况（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StoreTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/store.out"</span>));</div><div class="line">			Person person=<span class="keyword">new</span> Person(<span class="string">"matt1"</span>,<span class="number">20</span>,Gender.MALE);</div><div class="line">			o.writeObject(person);</div><div class="line">			person.setAge(<span class="number">22</span>);</div><div class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</div><div class="line">			o.writeObject(person);</div><div class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</div><div class="line">			o.close();</div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/store.out"</span>));</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Person person1= (Person) in.readObject();</div><div class="line">				System.out.println(person1.getAge());</div><div class="line">				Person person2= (Person) in.readObject();</div><div class="line">				System.out.println(person2.getAge());</div><div class="line">				System.out.println(person1==person2);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Output:</div><div class="line">* 232</div><div class="line">* 237</div><div class="line">* 20</div><div class="line">* 20</div><div class="line">* true</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>在上述示例中，对于同一个对象，在修改完年龄值后又重新将该实例对象序列化到文件。通过运行的结果我们可以发现：</p>
<ul>
<li>第二次将对象序列化到文件之后，文件的大小只增加了5个字节的大小；</li>
<li>第二次序列化的对象年龄值已经修改为22，但是从反序列化的结果来看，该实例对象的年龄值并未改变。</li>
</ul>
<p>大家是不是感觉到非常的奇怪，通过下面的两点解释之后，大家可能就会明白这其中的原因了：</p>
<ol>
<li>因为写入的是同一个对象，Java序列化机制为了节省磁盘空间，当写入文件的为同一个对象时，并不会将对象的内容再次进行存储，而只是再次存储一份引用，上面增加的5个字节的存储空间就是新增的引用和一些控制信息的空间，从反序列化的结果也可以看出，两个引用指向的是同一个对象；</li>
<li>虽然第二次存储时将年龄修改为22，但是因为Java序列化机制在第二次序列化同一个对象时，并保存具体的数据，只是保存了第一次的引用，所以反序列化时，得到的对象都是第一次序列化的对象。</li>
</ol>
<h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>这里可以可以参考<a href="http://ych0108.iteye.com/blog/2256640" target="_blank" rel="external">Java中序列化的serialVersionUID作用</a>一文。</p>
<p>这里我们就简单说一下序列化ID的作用：</p>
<p><code>serialVersionUID</code>用来表明类的不同版本间的兼容性。它有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的<code>serialVersionUID</code>；而在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的<code>serialVersionUID</code>。</li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置<code>serialVersionUID</code>，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了<code>serialVersionUID</code>，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10058164.html" target="_blank" rel="external">Java编程思想 第4版</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="external">Java序列化的高级认识</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文主要是对Java序列化学习的一些总结，一来是方便自己以后查阅，二来是希望通过本文能给他人带来一些帮助。&lt;/p&gt;
&lt;h1 
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java容器学习</title>
    <link href="http://wangzzu.github.io/2016/05/13/java-collection/"/>
    <id>http://wangzzu.github.io/2016/05/13/java-collection/</id>
    <published>2016-05-13T07:35:39.000Z</published>
    <updated>2016-11-19T09:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java的容器类，在程序中经常被用，而且也是在面试中经常被问到的部分，笔者近段就被问到过n次了，所以这里就根据网上的一些资料，并结合着openJDK的源码对这些容器类好好总结一下。</p>
<h1 id="Java中的容器"><a href="#Java中的容器" class="headerlink" title="Java中的容器"></a>Java中的容器</h1><p>在Java（以JDK1.7为例）中，如果一个程序包含固定数量的且生命周期已知的对象，那么我们可以使用数组来保存这些对象。但是一般情况下，我们在写程序时不知道需要保存多少个对象，对于这种情况，Java的实用类库中提供了一套相当完整的容器类来解决这个问题，其中基本的类型是：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ol>
<p>这些容器类也称为集合类。</p>
<p>对于它们之间的联系：我是这样理解的，首先Map是一个K-V对的集合（关联数组）：</p>
<ol>
<li>key的集合组成了一个Set，因为key是不允许重复的，且Map不会保存key的插入顺序，所以key可组成一个set；</li>
<li>value的集合组成了一个List，因为value是完全可以重复的，Map会根据key的值来获取value，这些value（如果当key是int型时）就组成了一个List（当然List并不是根据Map实现的）。</li>
</ol>
<p>上面的三种集合类只是提供了三个基本的接口，实际使用的集合类主要还是在它们的子类，下面这个图比较清楚地介绍了这三种容器类的常用子类（图片来自<a href="http://stackoverflow.com/questions/3317381/what-is-the-difference-between-collection-and-list-in-java" target="_blank" rel="external">StackOverFlow</a>）</p>
<p><img src="/images/java/collection.png" alt="collection"></p>
<blockquote>
<p>注：图片并没有把所有的继承与接口实现全部表示出来，只是列出了主要的部分，比如：<code>class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code>，而<code>class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set</code>，而<code>AbstractCollection&lt;E&gt; implements Collection</code>，全部的继承与接口实现机制比较复杂，这里只画出了它们的主要部分，这样方便我们看到这些集合类之间的联系与区别。</p>
</blockquote>
<p>对于集合类的分析，这里我们主要从以下几个部分去分析：</p>
<ol>
<li>原理：底层如何实现；</li>
<li>性能：分析这个集合类在具体操作上的复杂度<ul>
<li>插入：插入是如何实现的，性能如何；</li>
<li>删除：删除是如何实现的，性能如何；</li>
<li>读取：读取是如何实现的，性能如何；</li>
</ul>
</li>
<li>其他：比如集合类存储对象时，HashMap里需要重写<code>hash()</code>和<code>equals()</code>等性质。</li>
</ol>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>首先这里先介绍一下List集合类，List集合存储的是对象的引用或者基本数据类型，而且存储都是<strong>有序</strong>的，并且<strong>可以重复</strong>。下面分别介绍三种常见的List类。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/ArrayList.java" target="_blank" rel="external">ArrayList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认的数组长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// transient关键字主要是用于定制序列化方面</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">	<span class="comment">// 知道数组长度的情况下初始化数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 动态增加数组的长度，每次动态增加(oldCapacity &gt;&gt; 1)</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 获取元素，先检查index是否在范围，然后直接以数组的方式取出</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 修改给定位置的一个元素值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        E oldValue = elementData(index);</div><div class="line">        elementData[index] = element;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   	<span class="comment">// 在list的最后添加一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在给定位置添加一个元素（随机插入），这时候需要将该位置后面的所有元素移位</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line"></div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 移出给定位置的一个元素（随机删除），这时候也需要将该位置后面的所有元素移位</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 移出第一个符合要求的元素（需要从最前面开始遍历list）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对代码的分析，下面总结一下ArrayList（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/ArrayListTest.java" target="_blank" rel="external">测试代码</a>）：</p>
<ul>
<li>原理：基于<strong>数组</strong>来实现（顺序存储的线性表）</li>
<li>特点：<ol>
<li>动态数组，每次插入时都会检查数组长度是否够用，不够用时需要进行扩大，每次会将数组的长度增加$\frac{N}{2}$，也就是新建一个数组，然后将原来数组的元素拷贝进去；</li>
<li>ArrayList是List接口的可变数组的实现；</li>
<li>非同步；</li>
<li>添加、删除操作时，每次都需要把该索引右边的数组整体移动，性能较差，所以ArrayList更擅长随机访问数组，但是在数组中间进行插入或删除元素时较慢；</li>
<li>内部实现时，使用了<code>transient</code>修饰数组，这保证系统序列化ArrayList对象时不会直接序列化<code>elementData</code>数组，而是通过ArrayList提供的<code>writeObject</code>、<code>readObject</code>方法定制序列化。</li>
</ol>
</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Vector.java" target="_blank" rel="external">Vector</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Object[] elementData;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement; <span class="comment">// 数组动态增加时的步长</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化list，可以设置步长</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list最后添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">        elementData[elementCount++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在给定位置添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        insertElementAt(element, index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 随机插入元素的实际操作方法，这里也需要移动整个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (index &gt; elementCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</div><div class="line">        &#125;</div><div class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</div><div class="line">        elementData[index] = obj;</div><div class="line">        elementCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除给定位置的元素，也需要整体移动数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取给定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (E) elementData[index];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Vector与ArrayLis很相似，ArrayList与Vector的大部分方法都是相同，只是Vector添加了<code>synchronized</code>，也就是说，Vector是ArrayList的线程安全版本，但是在序列化方面，ArrayList比Vector更安全。</p>
<ul>
<li>原理：基于<strong>数组</strong>实现</li>
<li>特点：<ol>
<li>同步的（方法大都是<code>synchronized</code>的）；</li>
<li>每次扩大时可以通过参数设置扩大的步长;</li>
<li>对于Vector，没有使用<code>transient</code>修饰数组，而且Vector只提供了一个<code>writeObject</code>方法，并未完全实现定制序列化。</li>
</ol>
</li>
</ul>
<p>它有一个子类为Stack（线程安全），对于栈，不要求线程安全时，可以使用<code>ArrayDeque</code>实现。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 指向第一个节点</span></div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 指向最后一个节点</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素e添加到list的头部</span></div><div class="line"></div><div class="line">    <span class="comment">//调用上一个私有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        linkFirst(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素添加到list的尾部</span></div><div class="line"></div><div class="line">    <span class="comment">// 在节点succ前添加一个元素e</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert succ != null;</span></div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">        succ.prev = newNode;</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pred.next = newNode;</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除头节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除尾节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list尾部添加元素的实际操作</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">        last = newNode;</div><div class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            l.next = newNode;</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list最后面添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        linkLast(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给定位置添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        checkPositionIndex(index);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index == size)</div><div class="line">            linkLast(element);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkBefore(element, node(index)); <span class="comment">//调用这个方法</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除给定的节点</span></div><div class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert x != null;</span></div><div class="line">        <span class="keyword">final</span> E element = x.item;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        x.item = <span class="keyword">null</span>;</div><div class="line">        size--;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据索引返回该位置的Node（这个方法会经常调用，通过遍历的方法找到该位置）</span></div><div class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">            Node&lt;E&gt; x = first;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">                x = x.next;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;E&gt; x = last;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">                x = x.prev;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除指定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        checkElementIndex(index);</div><div class="line">        <span class="keyword">return</span> unlink(node(index));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回指定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        checkElementIndex(index);</div><div class="line">        <span class="keyword">return</span> node(index).item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：基于<strong>双向链表</strong>实现的（链式存储的线性表）</li>
<li>特点：<ol>
<li>在获取元素的索引时，需要去<strong>遍历</strong>链表来获取索引（也就是<code>node()</code>方法）。</li>
<li>它的插入和删除操作比ArrayList更加高效（主要是对于List中间的删除或添加，因为ArrayList需要整体移动右边数组），也正是由于它是基于链表实现的，所以随机访问的效率要比ArrayList差。</li>
<li>非同步；</li>
<li>实现了List和Deque接口，既可以做双向链表使用，又可以做队列使用，还可以做栈使用;</li>
<li>也可以进行定制序列化。</li>
</ol>
</li>
</ul>
<blockquote>
<p>Deque接口是双端队列，既可以作为栈也可以作为队列。</p>
</blockquote>
<p>关于LinkedList，笔者做一个test，使用LinkedList分别做链表、队列和栈，参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/LinkedListTest.java" target="_blank" rel="external">测试代码</a>。</p>
<blockquote>
<p>Notice: <strong>fail-fast 机制</strong>是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件（<code>ConcurrentModificationException</code>）。fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用 fail-fast机制的集合，建议使用<code>java.util.concurrent</code>包下的类去取代<code>java.util</code>包下的类。</p>
</blockquote>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map一种经常用的容器类型，它存储的是K-V键值对。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>先讲一下最常用的HashMap吧，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashMap.java" target="_blank" rel="external">HashMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认的长度，这里是16，要求必须是2的次方</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认的负载因子</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// map中的长度</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="comment">// 根据给定大小和负载因子初始化map</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = initialCapacity;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// 添加KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">            inflateTable(threshold);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// key相等（hash值还有实际值相等）时，替换value</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i); <span class="comment">// 将&lt;key, value&gt;添加到i索引处</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将KV对添加到给定位置的Entry链上</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">            bucketIndex = indexFor(hash, table.length);</div><div class="line">        &#125;</div><div class="line">        createEntry(hash, key, value, bucketIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key获取相应的value值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key找到给KV对象</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key删除该元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际删除该Entry链元素的实际操作</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        Entry&lt;K,V&gt; prev = table[i];</div><div class="line">        Entry&lt;K,V&gt; e = prev;</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                modCount++;</div><div class="line">                size--;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    table[i] = next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.next = next;</div><div class="line">                e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">            &#125;</div><div class="line">            prev = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Google上找到了一张关于关于HashMap数据存储图，如下所示</p>
<p><img src="/images/java/hashmap.png" alt="hashmap"></p>
<ul>
<li>原理： 基于<strong>拉链法的散列表</strong>（数组和链表的结合），数组的每个元素都是一个链表的引用，对象的存储位置跟key的hash值有关。</li>
<li>特点：<ol>
<li>允许存放null键和null值；</li>
<li>HashMap数组的长度总是2的n次方（这样才能高效地利用数组空间的存储）；</li>
<li>当key的hash值相同，而值不同时，会添加到链表里，key值相同时，就会覆盖原kv对的value值；</li>
<li><code>java.util.HashMap</code>不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出<code>ConcurrentModificationException</code>，这就是所谓fail-fast策略；</li>
<li>HashMap在底层吧K-V当成一个整体进行处理，这个整体就是一个Entry对象。</li>
</ol>
</li>
<li>缺点： Hashmap数据有可能出现分布不均匀的情况这样就会影响查询效率，这跟HashCode算法和具体数据有关系，一般需要重写HashCode算法。</li>
<li>性能<ol>
<li>负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的总容量(initialCapacity)，当loadFactor达到指定值或者0.75时候，HashMap的总容量自动扩展一倍，以此类推。</li>
<li>负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</li>
<li>负载因子是对时间和空间成本上的一种折衷。增大负载因袭可以减少Hash表所占用的内存空间，但会增加查询时间，而查询是HashMap中对频繁的操作；减少负载因子会提高数据查询的性能，但会增加Hash表所占用的内存空间。</li>
</ol>
</li>
</ul>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Hashtable.java" target="_blank" rel="external">Hashtable</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">    <span class="comment">// 创建Hashtable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">            initialCapacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">        initHashSeedAsNeeded(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认是11，与有所HashMap不同</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 查看是否包含某个KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key查找KV对的value值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 能分配的最大数组长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 增加数组的长度</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">        Entry&lt;K,V&gt;[] oldMap = table;</div><div class="line"></div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            newCapacity = MAX_ARRAY_SIZE;</div><div class="line">        &#125;</div><div class="line">        Entry&lt;K,V&gt;[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">        <span class="keyword">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);</div><div class="line"></div><div class="line">        table = newMap;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = old;</div><div class="line">                old = old.next;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                    e.hash = hash(e.key);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">                e.next = newMap[index];</div><div class="line">                newMap[index] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加元素，与HashMap类似</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除元素，如果该key不存在，则返回null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                modCount++;</div><div class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">                    prev.next = e.next;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tab[index] = e.next;</div><div class="line">                &#125;</div><div class="line">                count--;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：数组+链表（与HashMap一样）</li>
<li>特点：<ol>
<li>和HashMap一样，Hashtable也是一个基于拉链法实现的散列表，它存储的内容是键值对；</li>
<li>Hashtable继承于Dictionary类，实现了Map, Cloneable, java.io.Serializable接口；</li>
<li>线程安全；</li>
<li>比较老的类，命名也没有遵循现在Java的驼峰法；</li>
<li>Hashtable的key和value都不允许为null；</li>
</ol>
</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123; <span class="comment">// 继承HashMap</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header; <span class="comment">// 头元素</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">// 设置迭代顺序，可以设置插入顺序（false）或者访问顺序（true）</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(m);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        header.before = header.after = header;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际上调用HashMap的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        e.recordAccess(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap的数据的存储方式如下图所示（图片来自<a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="external">LinkedHashMap</a>）：</p>
<p><img src="/images/java/linkedhashmap.png" alt="LinkedHashMap"></p>
<blockquote>
<p>Note：途中蓝色箭头的指针是<code>Entry</code>对象的<code>next</code>指针，而黑色箭头的指针是双向链表的<code>before</code>和<code>after</code>指针。</p>
</blockquote>
<ul>
<li>原理：数组+双向链表（有before、after两个指针，所以可以保留插入或访问顺序）</li>
<li>特点：<ol>
<li>LinkedHashMap是HashMap的一个子类，它<strong>保留插入的顺序</strong>， 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap；</li>
<li>LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的<strong>双向链接列表</strong>。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序；</li>
<li>非同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步；</li>
<li>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序；</li>
<li>如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表；</li>
<li>底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性；</li>
<li>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序；</li>
<li>LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序；</li>
<li>允许使用null值和null键；</li>
</ol>
</li>
</ul>
<p>关于迭代顺序可以参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/LinkedHashMapTest.java" target="_blank" rel="external">测试代码</a></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>对于线程安全的情况，在不考虑性能问题的时候，我们的解决方案有Hashtable或者Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个hash表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。 但是Java为我们提供了封装好的线程安全的集合类，这些类在<code>java.util.concurrent</code>包内，这里我们介绍一个常用的map子类——ConcurrentHashMap。</p>
<p>源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/concurrent/ConcurrentHashMap.java" target="_blank" rel="external">ConcurrentHashMap</a>，这里就不再介绍 ConcurrentHashMap的源码了。</p>
<p>先看一下ConcurrentHashMap的结构，如下图所示</p>
<p><img src="/images/java/concurrenthashmap.png" alt="concurrenthashmap"></p>
<p>在ConcurrentHashMap内有几个重要的内部类分别是：</p>
<ol>
<li><code>HashEntry</code>类：用来封装散列映射表中的键值对，HashEntry的学习可以类比着 HashMap中的Entry。我们的存储键值对的过程中，散列的时候如果发生“碰撞”，将采用<strong>拉链法</strong>来处理碰撞：把碰撞的 HashEntry 对象链接成一个链表；</li>
<li><code>Segment</code>类：Segment 的类定义为<code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</code>，其继承于 ReentrantLock类，从而使得 Segment对象可以充当锁的角色。Segment中包含HashEntry的数组，其可以守护其包含的若干个桶（HashEntry的数组）。Segment 在某些意义上有点类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</li>
</ol>
<ul>
<li>原理：数组+链表，每个数组元素是一个类似于HashMap结构的segment，每个segment又是一个数组和链表的形式，这样在对某个segment操作时，就可以锁住该segment，不影响对其他segment的操作。</li>
<li>特点：<ol>
<li>ConcurrentHashMap的实现是依赖于Java内存模型；</li>
<li>本质也是数组和链表，ConcurrentHashMap数据结构为一个Segment数组，Segment的数据结构为HashEntry的数组，而HashEntry存的是我们的键值对，可以构成链表，默认的Segment是16个，通过key的hash值与16取余确定在哪个桶。</li>
<li>ConcurrentHashMap的结构中包含的Segment的数组，在默认的并发级别会创建包含16个Segment对象的数组。</li>
<li>执行put方法的时候，会需要<strong>加锁</strong>来完成，在put操作时锁定的是一个Segment而不是整个ConcurrentHashMap。</li>
<li>ConcurrentHashMap不允许空值。该方法首先有一个Segment的引用s，然后会通过hash()方法对key进行计算，得到哈希值；继而通过调用Segment的put(K key, int hash, V value, boolean onlyIfAbsent)方法进行存储操作。</li>
<li>在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</li>
</ol>
</li>
</ul>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ol>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeMap.java" target="_blank" rel="external">TreeMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">// 比较器，不设置时使用key的自然顺序</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        comparator = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以设置比较器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.comparator = comparator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        comparator = <span class="keyword">null</span>;</div><div class="line">        putAll(m);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        comparator = m.comparator();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 插入方法，这个是红黑树中非常重要的方法，根据定制的比较器将插入的元素放在合适的位置</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; t = root;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">            size = <span class="number">1</span>;</div><div class="line">            modCount++;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cmp;</div><div class="line">        Entry&lt;K,V&gt; parent;</div><div class="line">        <span class="comment">// split comparator and comparable paths</span></div><div class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                parent = t;</div><div class="line">                cmp = cpr.compare(key, t.key);</div><div class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                    t = t.left;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                    t = t.right;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> t.setValue(value);</div><div class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                parent = t;</div><div class="line">                cmp = k.compareTo(t.key);</div><div class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                    t = t.left;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                    t = t.right;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> t.setValue(value);</div><div class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            parent.left = e;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            parent.right = e;</div><div class="line">        fixAfterInsertion(e);</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        V oldValue = p.value;</div><div class="line">        deleteEntry(p);</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key找到对应的Entry对象，熟悉二叉树的人应该很熟悉这里的结构</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 很多话方法都会调用这个比较方法（这个方法设置为了final，是不允许修改的）</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</div><div class="line">            : comparator.compare((K)k1, (K)k2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>特点：<ol>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的；</li>
<li>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合；</li>
<li>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合；</li>
<li>TreeMap 实现了Cloneable接口，意味着它能被克隆；</li>
<li>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化；</li>
<li>TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的；</li>
<li>可以重写<code>comparable</code>。</li>
</ol>
</li>
<li>性能：<ol>
<li>因为底层是使用红黑树保存集合中的Entry对象，这也就意味着TreeMap对于添加元素、取出元素的性能要比HashMap低。当TreeMap添加元素时，需要通过循环找到新增Entry的插入位置，因此比较耗性能；当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，也比较耗性能；</li>
<li>TreeMap的优势在于：TreeMap中的所有Entry都是按key根据指定排序规则（可以根据重写的<code>comparable</code>定制排序规则）操持有序状态。</li>
</ol>
</li>
</ul>
<p>这里我做了一个测试，使用TreeMapTest（及其自定义排序形式）与HashMap做一下对比（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/TreeMapTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.TreeMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 5/13/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">		HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">		treeMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		treeMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		treeMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		treeMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator tree = treeMap.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"TreeMap:"</span>);</div><div class="line">		<span class="keyword">while</span> (tree.hasNext()) &#123;</div><div class="line">			Object key = tree.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap.get(key));</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">		TreeMap&lt;String,String&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;String,String&gt;(<span class="keyword">new</span> Comparator()&#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				String a = (String)o1;</div><div class="line">				String b = (String)o2;</div><div class="line">				<span class="keyword">return</span> -a.compareTo(b);</div><div class="line">			&#125;&#125;);</div><div class="line">		treeMap1.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		treeMap1.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		treeMap1.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		treeMap1.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator tree1 = treeMap1.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"\nTreeMap（根据value排序）:"</span>);</div><div class="line">		<span class="keyword">while</span> (tree1.hasNext()) &#123;</div><div class="line">			Object key = tree1.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap1.get(key));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		hashMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		hashMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		hashMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		hashMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator hash = hashMap.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"\nHashMap:"</span>);</div><div class="line">		<span class="keyword">while</span> (hash.hasNext()) &#123;</div><div class="line">			Object key = hash.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + hashMap.get(key));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Output:</div><div class="line">* TreeMap:</div><div class="line">* a wm0</div><div class="line">* b wm1</div><div class="line">* c wm2</div><div class="line">* d wm3</div><div class="line">*</div><div class="line">* TreeMap（根据value排序）:</div><div class="line">* d wm3</div><div class="line">* c wm2</div><div class="line">* b wm1</div><div class="line">* a wm0</div><div class="line">*</div><div class="line">* HashMap:</div><div class="line">* d wm3</div><div class="line">* b wm1</div><div class="line">* c wm2</div><div class="line">* a wm0</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>下面开始介绍Set了，Set是不保存重复元素的集合。当保存对象引用，一般情况下，对象需要重写<code>equals()</code>和<code>hashCode()</code>方法，不重写的话，就会使用对应Map（HashMap，TreeMap）的判断方法。</p>
<p>因为Set集合类的底层实现大都与前面的类似，所以下面会介绍稍微简洁一些。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>先介绍一下HashSet，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashSet.java" target="_blank" rel="external">HashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// 使用HashMap实现</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">// map中默认的value值</span></div><div class="line"></div><div class="line">    <span class="comment">// 构造方法都是借助与HashMap实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 感觉这个应该是老方法，构造对象时是无法使用这个方法的</span></div><div class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加元素，这个方法本质上还是调用了HashMap的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.containsKey(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码中，我们可以看到，HashSet的实现其实非常简单，他只是封装了一个HashMap对象来存储所有的集合元素。所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储了一个<code>PRESENT</code>，它是一个静态的Object对象。</p>
<ul>
<li>原理：HashSet底层使用HashMap来保存所有元素（value出存储了一个静态的Object对象）。</li>
<li>特点：<ol>
<li>HashSet实现了Set接口，它不允许集合中有重复的值;</li>
<li>HashSet的随机读取和写入还是很快的，同样也会出现与HashMap一样的问题，即有可能出现数据不均匀的情况；</li>
<li>重写<code>equals()</code>和<code>hashCode()</code>方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象;</li>
<li>当向Set添加元素时，如果与Set中的某一个元素比较时，当<code>equals()</code>比较返回true和<code>hashCode()</code>的返回值相等时，此时，元素就会添加失败（并不会覆盖Set中的元素，因为在HashMap中，遇到这种情况，只是覆盖value，不会覆盖key，而HashSet是基于HashMap实现的，所以元素也并不会被覆盖，只是会添加失败）；</li>
</ol>
</li>
</ul>
<p>下面我们看一个三个测试用例，来说明使用HashSet存储对象引用时，重写<code>equals()</code>和<code>hashCode()</code>方法的重要性。</p>
<p>Test1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name=name;</div><div class="line">		<span class="keyword">this</span>.age=age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Output: false</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Test2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name=name;</div><div class="line">		<span class="keyword">this</span>.age=age;</div><div class="line">	&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</div><div class="line">			Person per = (Person) o;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age == per.age &amp;&amp; <span class="keyword">this</span>.name.equals(per.name);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 因为两个对象的hash值不同，这样就会当作两个对象来处理。</div><div class="line">* Output: false</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Test3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</div><div class="line">			Person per = (Person) o;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> name.hashCode();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写的equals和hashCode方法的返回值必须保持一致，当两个类的hashCode()返回值相同时，</div><div class="line">* 它们通过equals()方法的比较也应该相同。</div><div class="line">* Output: true</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>还是先看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedHashSet.java" target="_blank" rel="external">LinkedHashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 实际上是调用了HashSet中的default方法（该方法只能在包内或同一个文件内部调用），实际使用LinkedHashMap实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：继承于HashSet、又基于LinkedHashMap来实现。</li>
<li>特点：<ol>
<li>是一个Set的实现，所以它其中存的肯定不是键值对，而是值；</li>
<li>与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双向链接列表。 此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序；</li>
<li>非同步。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步；</li>
<li>继承于HashSet、又基于LinkedHashMap（父类HashSet实现时专门为其提供了一个LinkedHashMap的构造方法）来实现的。</li>
</ol>
</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeSet.java" target="_blank" rel="external">TreeSet</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</div><div class="line">        <span class="keyword">this</span>.m = m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(s.comparator());</div><div class="line">        addAll(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上面的源码可知，TreeSet底层采用一个<code>NavigableMap</code>来保存TreeSet集合的元素。但实际上，由于<code>NavigableMap</code>只是一个接口，因此底层依然是使用了TreeMap来包含Set集合中的所有元素。TreeSet里绝大多数方法都是直接使用TreeMap的方法来实现的，因此在上面的源码只列出简单的TreeSet的构造方法。</p>
<ul>
<li>原理：基于TreeMap实现的。</li>
<li>特点：TreeSet中的所有元素总是根据指定排序规则保存有序状态（可以自定义TreeSet的排序规则）。</li>
</ul>
<p>下面给一个例子（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/set/TreeSetTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.TreeSet;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 5/13/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">		treeSet.add(<span class="string">"wm0"</span>);</div><div class="line">		treeSet.add(<span class="string">"wm1"</span>);</div><div class="line">		treeSet.add(<span class="string">"matt0"</span>);</div><div class="line">		treeSet.add(<span class="string">"matt1"</span>);</div><div class="line">		Iterator tree=treeSet.iterator();</div><div class="line">		System.out.println(<span class="string">"HashSet(默认排序规则):"</span>);</div><div class="line">		<span class="keyword">while</span> (tree.hasNext())&#123;</div><div class="line">			System.out.println(tree.next());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		TreeSet&lt;String&gt; treeSet1 = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator()&#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				String a = (String)o1;</div><div class="line">				String b = (String)o2;</div><div class="line">				<span class="keyword">return</span> -a.compareTo(b);</div><div class="line">			&#125;&#125;);</div><div class="line">		treeSet1.add(<span class="string">"wm0"</span>);</div><div class="line">		treeSet1.add(<span class="string">"wm1"</span>);</div><div class="line">		treeSet1.add(<span class="string">"matt0"</span>);</div><div class="line">		treeSet1.add(<span class="string">"matt1"</span>);</div><div class="line">		System.out.println(<span class="string">"\nHashSet(向反的默认排序规则):"</span>);</div><div class="line">		Iterator tree1=treeSet1.iterator();</div><div class="line">		<span class="keyword">while</span> (tree1.hasNext())&#123;</div><div class="line">			System.out.println(tree1.next());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* HashSet(默认排序规则):</div><div class="line">* matt0</div><div class="line">* matt1</div><div class="line">* wm0</div><div class="line">* wm1</div><div class="line">*</div><div class="line">* HashSet(向反的默认排序规则):</div><div class="line">* wm1</div><div class="line">* wm0</div><div class="line">* matt1</div><div class="line">* matt0</div><div class="line">* /</div></pre></td></tr></table></figure>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><p>这里理出一些常见的面试题，大部分题并未给出准确的回答，大家可以根据前面的分析自行总结。</p>
<ol>
<li>ArrayList VS Vector</li>
<li>ArrayList VS LinkedList<ul>
<li>ArrayList和LinkedList是两个集合 类，用于存储一系列的对象引用(references)。一般大家都知道ArrayList和LinkedList的大致区别：</li>
</ul>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要进行遍历。</li>
<li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动部分数据。</li>
</ol>
</li>
<li>说你知道的几个Java集合类：list、set、queue、map实现类。<ul>
<li>Map接口<br>映射。主要存储一组组具有映射关系的数据，映射关系主要用key/value的键值对形式表示，一组键值对构成了Map的内部类Entry，所以可以把Map当做由Entry构成的集合。</li>
<li>List接口<br>表。这个表可以是数组实现的ArrayList，也可以是链表实现的LinkedList。比较古老的实现是Vector，现在不推荐使用，包括它的子类Stack，尽管它是线程安全的。List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。</li>
<li>Queue接口<br>模拟”队列”这种数据结构</li>
<li>Set 接口<br>Set是只有Key值，value值为NULL的一个特殊的Map。 只能通过iterator访问元素。</li>
</ul>
</li>
<li>Java中的队列都有哪些，有什么区别。</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高？</li>
<li>HashMap与HashTable的区别？<ol>
<li>继承的父类不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap，它们都实现了Map接口。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现；</li>
<li>key和value是否允许出现null值。HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException；</li>
<li>线程安全不同，Hashtable中的几乎所有的public的方法都是synchronized的，而有些方法也是在内部通过synchronized代码块来实现。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理；</li>
<li>是否提供contains方法，HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同；</li>
<li>内部实现使用的数组初始化和扩容方式不同，HashTable中hash数组默认大小是11，增加的方式是 $old*2+1$，HashMap中hash数组的默认大小是16，而且一定是2的指数；</li>
<li>两个遍历方式的内部实现上不同，Hashtable、HashMap都使用了 Iterator，Hashtable还保留了Enumeration的方式 ；</li>
<li>hash值不同，哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。</li>
</ol>
</li>
<li>HashMap冲突很厉害，最差性能，你会怎么解决?从$O(n)$提升到$\log{n}$。</li>
<li>HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</li>
<li>Hash冲突怎么办？哪些解决散列冲突的方法？<ol>
<li>基于<strong>拉链法</strong>的散列表</li>
</ol>
<ul>
<li>原理：数组+链表（HashMap的实现方式）</li>
<li>特点：</li>
</ul>
<ol>
<li>方法：一，根据散列值查找相应的链表；二，沿着链表查找相应的键；</li>
<li>性能：对于一张含有M条链表和N个键的散列表中，未命中查找和插入操所需的比较次数都为$~\frac{N}{M}$。</li>
<li>基于<strong>线性探测法</strong>的散列表</li>
</ol>
<ul>
<li>原理：用大小为M的<strong>数组</strong>保存N个键值对（$M&gt;N$）。利用空位，也称为开放地址散列表。</li>
<li>特点：当发生碰撞时，直接检查散列表的下一个位置（索引值加1），会有三种结果：</li>
</ul>
<ol>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ol>
<ul>
<li>缺点：进行删除操作时，删除键右边的所有键（连在一起）需要重新插入散列表。</li>
</ul>
</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写。</li>
<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现。</li>
<li>常用的hash算法有哪些？<ul>
<li>除法hash：求余；</li>
<li>乘法hash；</li>
</ul>
</li>
<li>什么是一致性哈希？（参考<a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="external">五分钟理解一致性Hash算法</a>）<br>为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题。<br>判定哈希算法好坏的四个定义：<ol>
<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用；</li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。；</li>
<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性；</li>
<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷；<br>在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点：<strong>虚拟节点</strong>（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列.</li>
</ol>
</li>
<li>ReHash<br>ReHash的过程其实是空间和时间的双重重大损失，ReHash的过程其实就是一个动态扩容的过程，而哈希表的扩容是个空间和时间消耗都非常惊人的内部操作。<ol>
<li>原来当我们对哈希结构的容器进行扩容时，散列表内部要重新new一个更大的数组，然后把原来数组的内容拷贝到新数组，并进行重新散列；</li>
<li>new出来的这个更大的新数组容量有多大也是一门学问，一般来说，新数组的大小会设置成原数组双倍大小的相近的一个素数</li>
</ol>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/" target="_blank" rel="external">Java集合学习指南</a></li>
<li><a href="http://www.cnblogs.com/leesf456/tag/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">Java集合框架学习</a></li>
<li><a href="http://item.jd.com/10064252.html" target="_blank" rel="external">突破Java程序员基本功的16课</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的容器类，在程序中经常被用，而且也是在面试中经常被问到的部分，笔者近段就被问到过n次了，所以这里就根据网上的一些资料，并结合着openJDK的源码对这些容器类好好总结一下。&lt;/p&gt;
&lt;h1 id=&quot;Java中的容器&quot;&gt;&lt;a href=&quot;#Java中的容器&quot; clas
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中对象的内存使用学习</title>
    <link href="http://wangzzu.github.io/2016/05/07/java-object-memory/"/>
    <id>http://wangzzu.github.io/2016/05/07/java-object-memory/</id>
    <published>2016-05-07T08:33:22.000Z</published>
    <updated>2016-11-19T09:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容来自《算法 第四版》，上次看这一部分的时候应该是一年前了，不过因为昨天在面试中，被问到String对象在内存是如何存储，虽然之前看过这方面的内容，对这还有一点模糊印象，但终究没想起来，所以就想再看一下，顺便写成博客，方便以后查看。</p>
<p>本文主要介绍在Java中，对象、数组、字符串在内存是如何存储的，它们需要占用多少内存。</p>
<h1 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h1><p>要想知道一个对象使用的内存量，需要将所有实例变量使用的内存与对象本身的开销（一般是16个字节）相加。这些开销包括一个指向对象的类的引用、垃圾收集信息以及同步信息。另外，一般内存的使用都会被填充为8个字节（64位计算机中的机器字）的倍数。如下图所示，对于一个<code>Integer</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/integer.png" alt="int"></p>
<p>一个<code>Integer</code>对象会使用24字节（16个字节的对象开销，4个字节用于保存它的int值以及4个填充字节）。</p>
<p>一个<code>Date</code>对象（如下图）需要使用32字节：16个字节的对象开销，3个int实例变量各需4个字节，以及4个填充字节。</p>
<p><img src="/images/2016-05-07-java-object-mem/date.png" alt="date"></p>
<p>对象的引用一般都是一个内存地址，因此会使用8个字节。</p>
<p>例如对于一个<code>Counter</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/counter.png" alt="counter"></p>
<p>它需要32字节：16个字节的对象开销，8个字节用于它的String型实例变量（<strong>一个引用</strong>），4字节用于int实例变量，以及4个填充字节。</p>
<p>当我们说明一个引用所占的内存时，我们会单独说它所指向的对象所占用的内存，因此，这个内存使用总量并没有包含String对象所使用的内存。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在java中，数组一般被实现为对象，它们一般都会因为记录长度而需要额外的内存。</p>
<p>一个原始数据类型的数组一般需要24字节的头信息（如下）和保存值所需的引用。</p>
<ol>
<li>16个字节的对象开销；</li>
<li>4个字节用于保存长度；</li>
<li>4个填充字节。</li>
</ol>
<p>下面分别介绍一下<code>int[]</code>、<code>double[]</code>、对象数组和二维数组的内存占用情况。</p>
<p><img src="/images/2016-05-07-java-object-mem/array.png" alt="array"></p>
<h2 id="int值的数组"><a href="#int值的数组" class="headerlink" title="int值的数组"></a>int值的数组</h2><p>一个含有N个int值的数组需要使用$24+4N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="double值的数组"><a href="#double值的数组" class="headerlink" title="double值的数组"></a>double值的数组</h2><p>一个含有N个double值的数组需要使用$24+8N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h2><p>一个对象的数组就是一个对象的引用的数组，所以我们应该在对象所需的内存之外再加上引用所需的内存。例如，对于一个含有N个<code>Date</code>对象的数组需要使用24字节（头信息）加上$8N$字节（所有的引用）加上每个对象的32字节，总共$24+40N$。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>对于二维数组而言，它就是一个数组的数组（每个数组都是一个对象）。例如：一个$M*N$的double类型的二维数组需要使用24字节（头信息）加上$8M$字节（所有元素数组的引用）加上$24M$字节（所有元素的开销）加上$8MN$字节（$M$个长度为$N$的double类型的数组），总和共$8MN+32M+24$字节。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>一个String对象</p>
<p><img src="/images/2016-05-07-java-object-mem/string.png" alt="string"></p>
<p>String的标准实现含有4个<strong>实例变量</strong>：</p>
<ul>
<li>一个指向字符数组的引用（8字节）；</li>
<li>三个int值（4个字节）<ol>
<li>第一个int值：字符数组中的偏移量；</li>
<li>第二个int值：一个计数器，也就是字符串的长度，以上图为例，对象所表示的字符串由<code>value[offset]</code>到<code>value[offset+count-1]</code>中的字符组成；</li>
<li>第三个int值：散列值。</li>
</ol>
</li>
</ul>
<p>因此，每个String对象都会使用40字节（16字节表示对象，三个int实例变量各需4个字节，加上数组引用的8个字节和4个填充字节）。这是除字符数组之外字符所需的内存空间，所有字符所需的内存需要另记，因为String的char数组常常是在多个字符串之间共享的。因为String对象是不可变的，这种设计使String的实现能够在多个对象都含有相同的<code>value[]</code>数组时节省内存。</p>
<h1 id="字符串的值和子字符串"><a href="#字符串的值和子字符串" class="headerlink" title="字符串的值和子字符串"></a>字符串的值和子字符串</h1><p>字符串和子字符串的例子如下所示：</p>
<p><img src="/images/2016-05-07-java-object-mem/substring.png" alt="substring"></p>
<p>一个长度为N的String对象一般需要使用40字节（String对象本身）加上$24+2N$字节（字符数组），总共$64+2N$字节。但在处理字符串时经常会和子字符串打交道，所以Java对字符串的表示希望能够避免复制字符串中的字符。</p>
<p>当调用<code>substring()</code>方法时，就创建了一个新的String对象（40字节），但它仍然重用了相同的<code>value[]</code>数组，因此该字符串的子字符串只会使用40字节的内存。含有原始字符串的字符数组的别名存在于子字符串中，字符串对象的偏移量和长度域标记了子字符串的位置。</p>
<p>这些基础机制能够有效地帮助我们估计大量程序对内存的使用情况，但是很多复杂的因素仍然会使这个任务变得困难，这就得看一下JVM方面的书籍了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11098789.html" target="_blank" rel="external">算法 第四版</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的内容来自《算法 第四版》，上次看这一部分的时候应该是一年前了，不过因为昨天在面试中，被问到String对象在内存是如何存储，虽然之前看过这方面的内容，对这还有一点模糊印象，但终究没想起来，所以就想再看一下，顺便写成博客，方便以后查看。&lt;/p&gt;
&lt;p&gt;本文主要介绍在Ja
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Google Java Style</title>
    <link href="http://wangzzu.github.io/2016/04/22/google-java-style/"/>
    <id>http://wangzzu.github.io/2016/04/22/google-java-style/</id>
    <published>2016-04-22T01:31:43.000Z</published>
    <updated>2016-11-19T09:02:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>这份文档是Google Java编程风格规范的定义。在平时编写代码时应该养成一个良好的习惯，按照这个标准去编写容易维护的代码。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。</p>
<h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>源文件编码格式为：<strong>UTF-8</strong>。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(<code>0x20</code>，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="特殊转义序列"><a href="#特殊转义序列" class="headerlink" title="特殊转义序列"></a>特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(<code>\b</code>,<code>\t</code>,<code>\n</code>, <code>\f</code>, <code>\r</code>,<code>&quot;</code>,<code>&#39;</code>及<code>\</code>)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p>
<h3 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如<code>∞</code>)，还是使用等价的Unicode转义符(比如<code>\u221e</code>)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含（按顺序地）：</p>
<ol>
<li>许可证版权信息（如果需要的情况下）；</li>
<li>package语句；</li>
<li>import语句；</li>
<li>一个顶级类（只有一个）；</li>
</ol>
<p><em>以上每个部分用一个空行隔开。</em></p>
<h2 id="许可证或版权信息"><a href="#许可证或版权信息" class="headerlink" title="许可证或版权信息"></a>许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h2><p><strong>package语句不换行</strong>，列限制并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><ul>
<li>import<strong>不要使用通配符</strong>，不要出现类似这样的import语句：<code>import java.util.*</code>；</li>
<li>import语句<strong>不要换行</strong>，每个import语句独立成行；</li>
<li>顺序与间距：import语句分为以下几组，按照这个顺序，每组由一个空行分隔。<ol>
<li>所有的静态类导入独立成组；</li>
<li><code>com.google</code> imports；</li>
<li>第三的包。每个包为一组，字典序，如<code>andriod</code>，<code>com</code>，<code>junit</code>，<code>org</code>，<code>sun</code>.</li>
<li><code>java</code> imports;</li>
<li><code>javax</code> imports.</li>
</ol>
</li>
</ul>
<p>组内不空行，按字典序排序。</p>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><h3 id="只有一个顶级类声明"><a href="#只有一个顶级类声明" class="headerlink" title="只有一个顶级类声明"></a>只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>
<p>例如：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>
<h3 id="类成员顺序"><a href="#类成员顺序" class="headerlink" title="类成员顺序"></a>类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以<strong>某种逻辑</strong>去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h3 id="重载：永不分离"><a href="#重载：永不分离" class="headerlink" title="重载：永不分离"></a>重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><h3 id="使用大括号"><a href="#使用大括号" class="headerlink" title="使用大括号"></a>使用大括号</h3><p>当大括号与<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>语句一起使用，即使只有一条语句（或者是空），也应该把大括号写上。</p>
<h3 id="非空块"><a href="#非空块" class="headerlink" title="非空块"></a>非空块</h3><p>对于非空块和块状结构，主要有以下几个原则：</p>
<ul>
<li>在左大括号前不换行；</li>
<li>左大括号后换行；</li>
<li>右大括号前换行；</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//示例</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (condition()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                something();</div><div class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</div><div class="line">                recover();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="空块"><a href="#空块" class="headerlink" title="空块"></a>空块</h3><p>这里主要有两种情况：</p>
<ul>
<li>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行；</li>
</ul>
<ul>
<li>但是也有例外的情况：如果它是一个多块语句的一部分(<code>if/else</code>或 <code>try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不换行</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="块缩进：2个空格"><a href="#块缩进：2个空格" class="headerlink" title="块缩进：2个空格"></a>块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加<strong>2个空格</strong>，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。（不过一般情况大家用的都是4个，这个的话看个人喜好，感觉只要统一就可以了）</p>
<h2 id="一行一个语句"><a href="#一行一个语句" class="headerlink" title="一行一个语句"></a>一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="列限制：80或100"><a href="#列限制：80或100" class="headerlink" title="列限制：80或100"></a>列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ul>
<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考);</li>
<li><code>package</code>和<code>import</code>语句;</li>
<li>注释中那些可能被剪切并粘贴到shell中的命令行.</li>
</ul>
<h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(<strong>80或100</strong>个字符)而被分为多行，我们称之为<strong>自动换行</strong>(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h3 id="从哪里断开"><a href="#从哪里断开" class="headerlink" title="从哪里断开"></a>从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ul>
<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
<li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ul>
<h3 id="自动换行时缩进至少-4个空格"><a href="#自动换行时缩进至少-4个空格" class="headerlink" title="自动换行时缩进至少+4个空格"></a>自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><h3 id="垂直空白"><a href="#垂直空白" class="headerlink" title="垂直空白"></a>垂直空白</h3><p>以下情况需要使用<strong>一个空行</strong>：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<br>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>
<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>
<h3 id="水平空白"><a href="#水平空白" class="headerlink" title="水平空白"></a>水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和<code>Javadoc</code>用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
<li>在任何左大括号前(<code>{</code>)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
<li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
<li><code>catch</code>块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
<li><code>foreach</code>语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则<strong>双斜杠(//)两边都要空格</strong>。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li><p>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</p>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
</li>
</ol>
<h3 id="水平对齐：不做要求"><a href="#水平对齐：不做要求" class="headerlink" title="水平对齐：不做要求"></a>水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 未对齐</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></div><div class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></div><div class="line"><span class="comment">// 对齐</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// permitted, but future edits</span></div><div class="line"><span class="keyword">private</span> Color color; <span class="comment">// may leave it unaligned</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h2 id="用小括号来限定组：推荐"><a href="#用小括号来限定组：推荐" class="headerlink" title="用小括号来限定组：推荐"></a>用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。（把所有优先级表全部记下来是比较困难的）</p>
<h2 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="每次只声明一个变量"><a href="#每次只声明一个变量" class="headerlink" title="每次只声明一个变量"></a>每次只声明一个变量</h4><p><strong>不要使用组合声明</strong>，比如<code>int a, b</code>;。</p>
<h4 id="局部变量需要时才声明，并尽快进行初始化"><a href="#局部变量需要时才声明，并尽快进行初始化" class="headerlink" title="局部变量需要时才声明，并尽快进行初始化"></a>局部变量需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组初始化：可写成块状结构"><a href="#数组初始化：可写成块状结构" class="headerlink" title="数组初始化：可写成块状结构"></a>数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>,</div><div class="line">     <span class="number">1</span>,</div><div class="line">     <span class="number">2</span>,</div><div class="line">     <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>, <span class="number">1</span>,</div><div class="line">     <span class="number">2</span>, <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<h4 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>与其它块状结构一致，<code>switch</code>块中的内容缩进为2个空格。</p>
<p>每个<code>switch</code>标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h4 id="Fall-through：注释"><a href="#Fall-through：注释" class="headerlink" title="Fall-through：注释"></a>Fall-through：注释</h4><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (input) &#123;</div><div class="line">     <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">     <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">         prepareOneOrTwo();</div><div class="line">         <span class="comment">// fall through</span></div><div class="line">     <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">         handleOneTwoOrThree();</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">     <span class="keyword">default</span>:</div><div class="line">         handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="default的情况要写出来"><a href="#default的情况要写出来" class="headerlink" title="default的情况要写出来"></a>default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>
<h3 id="注解-Annotations"><a href="#注解-Annotations" class="headerlink" title="注解(Annotations)"></a>注解(<code>Annotations</code>)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解<strong>独占一行</strong>。这些换行不属于自动换行，因此缩进级别不变。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="块注释风格"><a href="#块注释风格" class="headerlink" title="块注释风格"></a>块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* This is // And so /* Or you can</div><div class="line">* okay. // is this. * even do this. */</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
<h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>类和成员的<code>modifiers</code>如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></div></pre></td></tr></table></figure>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="对所有标识符都通用的规则"><a href="#对所有标识符都通用的规则" class="headerlink" title="对所有标识符都通用的规则"></a>对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>,<code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>
<h2 id="标识符类型的规则"><a href="#标识符类型的规则" class="headerlink" title="标识符类型的规则"></a>标识符类型的规则</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>包名<strong>全部小写</strong>，连续的单词只是<strong>简单地连接</strong>起来，不使用下划线。</p>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，<strong>全部字母大写，用下划线分隔单词</strong>。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态<code>final</code>字段，但不是所有静态<code>final</code>字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Constants</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>); <span class="comment">// because Joiner is immutable</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line"><span class="comment">// Not constants</span></div><div class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</div><div class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="非常量字段名"><a href="#非常量字段名" class="headerlink" title="非常量字段名"></a>非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="局部变量名"><a href="#局部变量名" class="headerlink" title="局部变量名"></a>局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是<code>final</code>和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="类型变量名"><a href="#类型变量名" class="headerlink" title="类型变量名"></a>类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h2 id="驼峰式命名法-CamelCase"><a href="#驼峰式命名法-CamelCase" class="headerlink" title="驼峰式命名法(CamelCase)"></a>驼峰式命名法(<code>CamelCase</code>)</h2><p>驼峰式命名法：</p>
<ol>
<li>大驼峰式命名法(<code>UpperCamelCase</code>);</li>
<li>小驼峰式命名法(<code>lowerCamelCase</code>)。</li>
</ol>
<p>有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ol>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ol>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Prose form Correct Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="string">"XML HTTP request"</span> XmlHttpRequest XMLHTTPRequest</div><div class="line"><span class="string">"new customer ID"</span> newCustomerId newCustomerID</div><div class="line"><span class="string">"inner stopwatch"</span> innerStopwatch innerStopWatch</div><div class="line"><span class="string">"supports IPv6 on iOS?"</span> supportsIpv6OnIos supportsIPv6OnIOS</div><div class="line"><span class="string">"YouTube importer"</span> YouTubeImporter</div><div class="line">YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>
</blockquote>
<h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="Override：能用则用"><a href="#Override：能用则用" class="headerlink" title="@Override：能用则用"></a><code>@Override</code>：能用则用</h2><p>只要是合法的，就把<code>@Override</code>注解给用上。</p>
<h2 id="捕获的异常：不能忽视"><a href="#捕获的异常：不能忽视" class="headerlink" title="捕获的异常：不能忽视"></a>捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>
<p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     <span class="keyword">int</span> i = Integer.parseInt(response);</div><div class="line">     <span class="keyword">return</span> handleNumericResponse(i);</div><div class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</div><div class="line">     <span class="comment">// it's not numeric; that's fine, just continue</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> handleTextResponse(response);</div></pre></td></tr></table></figure>
<blockquote>
<p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     emptyStack.pop();</div><div class="line">     fail();</div><div class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态成员：使用类进行调用"><a href="#静态成员：使用类进行调用" class="headerlink" title="静态成员：使用类进行调用"></a>静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); <span class="comment">// good</span></div><div class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></div></pre></td></tr></table></figure>
<h2 id="Finalizers-禁用"><a href="#Finalizers-禁用" class="headerlink" title="Finalizers: 禁用"></a><code>Finalizers</code>: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Multiple lines of Javadoc text are written here,</div><div class="line">* wrapped normally...</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></div></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="Javadoc标记"><a href="#Javadoc标记" class="headerlink" title="Javadoc标记"></a>Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="摘要片段"><a href="#摘要片段" class="headerlink" title="摘要片段"></a>摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="哪里需要使用Javadoc"><a href="#哪里需要使用Javadoc" class="headerlink" title="哪里需要使用Javadoc"></a>哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个<code>public</code>和<code>protected</code>成员处使用Javadoc，以下是一些例外：</p>
<h3 id="例外：不言自明的方法"><a href="#例外：不言自明的方法" class="headerlink" title="例外：不言自明的方法"></a>例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
</blockquote>
<h3 id="例外：重写"><a href="#例外：重写" class="headerlink" title="例外：重写"></a>例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p>
<h3 id="可选的Javadoc"><a href="#可选的Javadoc" class="headerlink" title="可选的Javadoc"></a>可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Java Style</a></li>
<li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Style编程指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这份文档是Google Java编程风格规范的定义。在平时编写代码时应该养成一个良好的习惯，按照这个标准去编写容易维护的代码。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。&lt;/p&gt;
&lt;h1 id=&quot;源文件基础&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://wangzzu.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>postgres安装</title>
    <link href="http://wangzzu.github.io/2016/04/14/postgres-install/"/>
    <id>http://wangzzu.github.io/2016/04/14/postgres-install/</id>
    <published>2016-04-14T14:33:22.000Z</published>
    <updated>2016-11-19T09:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下在linux（CentOS7.1）下postgres的安装，后续的一篇博文会着重的介绍一下SQL操作。</p>
<p>注：</p>
<ul>
<li>#：超级用户提示符</li>
<li>$：普通用户提示符</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install postgresql</div><div class="line">$ sudo yum install pgadmin3</div><div class="line"></div><div class="line">$ su postgres <span class="comment">#切换psql用户下</span></div><div class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></div></pre></td></tr></table></figure>
<p>修改用户postgres密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo passwd postgres <span class="comment">#重置新密码</span></div></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /var/lib/pgsql/data      #创建pgsql的数据库目录</div><div class="line"># cd /var/lib/pgsql</div><div class="line"># chown postgres.postgres data     #改变目录的所属用户用组</div><div class="line"># su postgres                     #切换到postgres，不然初始化不了</div><div class="line"></div><div class="line">initdb -E UTF-8 -D /var/lib/pgsql/data --locale=en_US.UTF-8 -U postgres -W  #在postgres下，初始化数据库(初始化过程中，需要输入root密码)</div></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件，修改postgresql.conf的目的是修改连接权限；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># vim /var/lib/pgsql/data/postgresql.conf</span></div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listen_addresses = <span class="string">'*'</span>     <span class="comment">#监听所有ip的连接，默认是本机 ip，当然也可以设置局域网ip</span></div><div class="line">port = 5432             <span class="comment">#这个不开也行，默认就是5432端口</span></div></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/pg_hba.conf</code>文件，修改pg_hba.conf的目的是设置谁才可以操作数据服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /var/lib/pgsql/data/pg_hba.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD</span></div><div class="line"><span class="comment"># "local" is for Unix domain socket connections only</span></div><div class="line"><span class="built_in">local</span>   all         all                               trust</div><div class="line"><span class="comment"># IPv4 local connections:</span></div><div class="line">host    all         all         127.0.0.1/32          <span class="literal">true</span></div><div class="line">host    all         all         0.0.0.0/0             <span class="literal">true</span>   <span class="comment">#这一行我加的，所有IP和用户，密码对都可以连接</span></div><div class="line"><span class="comment"># IPv6 local connections:</span></div><div class="line">host    all         all         ::1/128               <span class="literal">true</span></div></pre></td></tr></table></figure>
<h1 id="psql使用"><a href="#psql使用" class="headerlink" title="psql使用"></a>psql使用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># systemctl start postgresql.service</div><div class="line"># or</div><div class="line"># service postgresql start</div></pre></td></tr></table></figure>
<p>但是出现了一个问题：</p>
<p><img src="/images/2016-04-14-postgresql/1.png" alt="startFailed"></p>
<p>使用<code>systemctl status postgresql.service</code>查看日志信息：</p>
<p><img src="/images/2016-04-14-postgresql/fail.png" alt="fail"></p>
<p>检查：</p>
<ul>
<li><p>配置防火墙，在<code>/etc/sysconfig/iptables</code>中添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT //postgresql的端口是5432</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</div></pre></td></tr></table></figure>
</li>
<li><p>然后设置<code>systemctl enable postgresql.service</code> 来设置<code>/usr/lib/systemd/system/postgresql.service</code>文件。</p>
</li>
</ul>
<p>成功启动的psql如下所示：</p>
<p><img src="/images/2016-04-14-postgresql/status.png" alt="status"></p>
<p>通过<code>netstat -tpnl | grep 5432</code>来查看5432端口的情况。</p>
<p><img src="/images/2016-04-14-postgresql/port.png" alt="port"></p>
<h2 id="添加用户和数据库"><a href="#添加用户和数据库" class="headerlink" title="添加用户和数据库"></a>添加用户和数据库</h2><p>推荐两个学习的网站：</p>
<ul>
<li><a href="http://developer.51cto.com/art/201401/426437.htm" target="_blank" rel="external">psql学习网站</a></li>
<li><a href="http://www.yiibai.com/html/postgresql/" target="_blank" rel="external">psql教程</a></li>
</ul>
<p>首先，在linux下进入到<code>postgres</code>用户名下，然后进入到postgres的控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># su postgres</div><div class="line">psql</div></pre></td></tr></table></figure>
<p>这样就进入了<strong>数据库的控制台</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#不要忘记每句话后的";"，建立数据库用户时，首先linux系统下要有user用户(adduser user )，然后才可以再把user用户指定为数据库的用户。</span></div><div class="line"></div><div class="line">CREATE USER matt WITH PASSWORD <span class="string">'123456'</span>;<span class="comment">#创建数据库用户matt，并设置密码</span></div><div class="line"></div><div class="line">CREATE DATABASE bank OWNER matt;<span class="comment">#创建数据库bank，并指定该数据库的所有者为matt</span></div><div class="line"></div><div class="line">GRANT ALL PRIVILEGES ON DATABASE bank to matt;<span class="comment">#将test数据库的所有权限都赋给用户matt，否则用户matt只能登陆控制台，没有任何数据库操作权限</span></div><div class="line"></div><div class="line">\q <span class="comment">#退出控制台（ctrl+D）</span></div></pre></td></tr></table></figure>
<p>控制台命令：</p>
<ul>
<li><strong>\h</strong>：查看SQL命令的解释，比如\h select。</li>
<li><strong>\?</strong>：查看psql命令列表。</li>
<li><strong>\l</strong>：列出所有数据库。</li>
<li><strong>\c [database_name]</strong>：连接其他数据库。</li>
<li><strong>\d</strong>：列出当前数据库的所有表格。</li>
<li><strong>\d [table_name]</strong>：列出某一张表格的结构。</li>
<li><strong>\du</strong>：列出所有用户。</li>
<li><strong>\e</strong>：打开文本编辑器。</li>
<li><strong>\conninfo</strong>：列出当前数据库和连接的信息</li>
</ul>
<h2 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">psql -U matt <span class="_">-d</span> bank -h 127.0.0.1 -p 5432<span class="comment">#上面命令的参数含义如下：-U指定用户，-d指定数据库，-h指定服务器，-p指定端口。</span></div><div class="line"><span class="comment"># or</span></div><div class="line">psql -U matt <span class="_">-d</span> bank</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 建立四张表，不要忘记最后面的“；”号</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(customer_name <span class="built_in">char</span>(<span class="number">20</span>), customer_street <span class="built_in">char</span>(<span class="number">30</span>), customer_city <span class="built_in">char</span>(<span class="number">30</span>), primary <span class="keyword">key</span>(customer_name));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> branch(branch_name <span class="built_in">char</span>(<span class="number">15</span>), branch_city <span class="built_in">char</span>(<span class="number">30</span>), assets <span class="built_in">numeric</span>(<span class="number">16</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(branch_name));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(account_number <span class="built_in">char</span>(<span class="number">10</span>), branch_name <span class="built_in">char</span>(<span class="number">15</span>), balance <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(account_number));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> depositor(customer_name <span class="built_in">char</span>(<span class="number">20</span>), account_number <span class="built_in">char</span>(<span class="number">10</span>), primary <span class="keyword">key</span>(customer_name, account_number));</div></pre></td></tr></table></figure>
<p>其他的SQL命令会后续的博客中详细介绍。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="连接数据库失败"><a href="#连接数据库失败" class="headerlink" title="连接数据库失败"></a>连接数据库失败</h2><p>错误为<code>org.postgresql.util.PSQLException: FATAL: password authentication failed for user &quot;postgres&quot;</code>。<br>打开Postgresql安装目录下的data文件夹，找到pg_hba.conf文件并打开。修改认证方式，将md5改为trust，然后保存。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TYPE DATABASE USER CIDR-ADDRESS METHOD</span></div><div class="line"><span class="comment"># IPv4 local connections:</span></div><div class="line">host all all 127.0.0.1/32 trust<span class="comment">#md5改为trust</span></div><div class="line">host all all 0.0.0.0/0 trust</div></pre></td></tr></table></figure>
<p>参考<a href="http://blog.chinaunix.net/uid-26149100-id-3189230.html" target="_blank" rel="external">Postgresql常见问题</a>。</p>
<h2 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h2><p>有可能是电脑的端口5432的TCP/IP允许没有开启。</p>
<h2 id="JAVA接口"><a href="#JAVA接口" class="headerlink" title="JAVA接口"></a>JAVA接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">table_insert</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">         Connection c = <span class="keyword">null</span>;</div><div class="line">         Statement stmt = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">         <span class="keyword">long</span> time= <span class="number">201503292255L</span>;</div><div class="line">         <span class="keyword">int</span> client_id=<span class="number">4</span>;</div><div class="line">         <span class="keyword">int</span> server_id=<span class="number">3</span>;</div><div class="line">         <span class="keyword">int</span> server_location=<span class="number">110000</span>;</div><div class="line">         String WebName=<span class="string">"other"</span>;</div><div class="line">         <span class="keyword">int</span> count=<span class="number">1000</span>;</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             Class.forName(<span class="string">"org.postgresql.Driver"</span>);</div><div class="line">             c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://192.168.81.136:5432/postgres"</span>,<span class="string">"postgres"</span>,<span class="string">"psql"</span>);</div><div class="line">             c.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">             System.out.println(<span class="string">"Opened database successfully"</span>);</div><div class="line"></div><div class="line">             stmt = c.createStatement();</div><div class="line"></div><div class="line">             <span class="comment">//String sql = "INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( 201503292255, 1, 3, 110000,'others', 2);";</span></div><div class="line"></div><div class="line">             <span class="comment">//String sql="INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( "+time+", "+client_id+", "+server_id+", "+server_location+", '"+WebName+"'"+", "+count+");";</span></div><div class="line"></div><div class="line">             String sql=<span class="string">"UPDATE traffic SET count="</span>+count+<span class="string">" WHERE time="</span>+time+<span class="string">" AND client_id="</span>+client_id+<span class="string">" AND server_id="</span>+server_id+<span class="string">" AND server_location="</span>+server_location+<span class="string">" AND web_name= '"</span>+WebName+<span class="string">"';"</span>;</div><div class="line">             stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">             stmt.close();<span class="comment">//必须从要有对应关闭数据库的操作，否则会出现问题</span></div><div class="line">             c.commit();</div><div class="line">             <span class="comment">//c.close();</span></div><div class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">             System.err.println( e.getClass().getName()+<span class="string">": "</span>+ e.getMessage() );</div><div class="line">             System.exit(<span class="number">0</span>);</div><div class="line">         &#125;</div><div class="line">         System.out.println(<span class="string">"Records created successfully"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里必须要有数据库关闭的操作。</p>
<h2 id="连接数过多"><a href="#连接数过多" class="headerlink" title="连接数过多"></a>连接数过多</h2><p><code>So many clients alreay！</code>.<br>查看的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--控制台下输入</span></div><div class="line"></div><div class="line"><span class="comment">--当前总共正在使用的连接数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> pg_stat_activity;</div><div class="line"><span class="comment">--显示系统允许的最大连接数</span></div><div class="line"><span class="keyword">show</span> max_connections;</div><div class="line"><span class="comment">--显示系统保留的用户数</span></div><div class="line"><span class="keyword">show</span> superuser_reserved_connections ;</div></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件的<code>max_connections</code>，默认为100.但是更多的时候需要考虑的是为什么数据库的连接会那么多，一般情况下是自己的程序出错了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://blog.51yip.com/pgsql/1520.html" target="_blank" rel="external">Postgres安装介绍</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一下在linux（CentOS7.1）下postgres的安装，后续的一篇博文会着重的介绍一下SQL操作。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;#：超级用户提示符&lt;/li&gt;
&lt;li&gt;$：普通用户提示符&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="database" scheme="http://wangzzu.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper之学习笔记</title>
    <link href="http://wangzzu.github.io/2016/04/13/zookeeper-learn/"/>
    <id>http://wangzzu.github.io/2016/04/13/zookeeper-learn/</id>
    <published>2016-04-13T01:20:28.000Z</published>
    <updated>2016-11-19T09:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper的重要性及应用的广泛性，这里就不再叙述了，本文是学习<a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南</a>的基础上进行的总结，当然本文大部分内容来自此书，中间会穿插一些个人的理解。本文主要分以下几块进行详述。</p>
<blockquote>
<ul>
<li>ZooKeeper介绍</li>
<li>Zookeeper安装与运行</li>
<li>ZooKeeper组成员关系</li>
<li>ZooKeeper服务</li>
<li>ZooKeeper应用</li>
</ul>
</blockquote>
<h1 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h1><p><a href="https://zookeeper.apache.org/" target="_blank" rel="external">官网</a>对其介绍的原话如下：</p>
<blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.</p>
</blockquote>
<p>总结一下就是，Zookeeper分布式服务框架是一个用来解决分布式应用中经常遇到的一些数据管理问题（如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等）的中央服务。</p>
<p>对于一个分布式系统最困难的事情之一就是如何处理<strong>部分失败</strong>（partial failure）。当一条message在网络中的两个节点之间传送时，如果出现了网络错误，发送者无法知道接收者是否已经接收到了这条message。接收者有可能在发生错误之前收到这个message，也有可能没有收到，还有可能接收者已经挂掉。发送者获得真实情况的一般解决方案就是：重新连接接收者，然后发起询问。这就是部分失败：即我们甚至不知道一个操作是否已经完成。</p>
<p>Zookeeper正是为了解决这个问题而应运而生的，当然Zookeeper并不能完全根除部分失败，当然它也不会隐藏这部分的失败。ZooKeeper具有以下几个特点：</p>
<ul>
<li>简单：它的核心是一个精简的文件系统，它提供一些简单的操作和一些额外的抽象操作；</li>
<li>富有表现力：ZooKeeper可以用于实现多种协议和数据结构；</li>
<li>高可用性：可避免单点故障；</li>
<li>采用耦合交互方式：在交互过程中，参与者不需要彼此了解，进程在不了解其他进程的情况下就能够彼此发现并进行交互；</li>
<li>是一个资源库：它是一个开源共享存储库，能使程序员免于编写这类通用的协议。</li>
<li>高性能：对于写操作而言，Zookeeper的基准测试吞吐量已经超过每秒10000个操作，对于常规的读操作，吞吐量更高。</li>
</ul>
<h1 id="Zookeeper的安装与运行"><a href="#Zookeeper的安装与运行" class="headerlink" title="Zookeeper的安装与运行"></a>Zookeeper的安装与运行</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="external">Zookeeper镜像上</a>下载Zookeeper安装包（这里以<code>zookeeper-3.4.6.tar.gz</code>为例）。这里给出一般Zookeeper的安装与运行的方法，很多实际生成环境中，我们都是使用CDH集成的Zookeeper，这样的话安装与运行就完全可以通过图形化界面操作了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解压</span></div><div class="line">tar -zxvf zookeeper-3.4.6.tar.gz -C /opt</div><div class="line"><span class="comment"># 复制配置文件</span></div><div class="line">cp /opt/zookeeper/zoo_sample.cfg /opt/zookeeper/zoo.cfg</div></pre></td></tr></table></figure>
<p>修改配置文件<code>zoo.cfg</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dataDir=/opt/zookeeper/data</div><div class="line">dataLogDir=/opt/zookeeper/logs</div><div class="line">clientPort=2181</div><div class="line">tickTime=2000</div><div class="line">initLimit=5</div><div class="line">syncLimit=2</div><div class="line">server.1=zookeeper1:2888:3888</div><div class="line">server.2=zookeeper2:2888:3888</div><div class="line">server.3=zookeeper3:2888:3888</div></pre></td></tr></table></figure>
<p>首先需要在<code>dataDir</code>目录下，新建一个名为<code>myid</code>的文件，这个文件的作用是指定这个服务器的ID，服务器ID在集合体中是唯一的，并且取值范围在1到255之间。下面再分别介绍一下其他几个参数的意义：</p>
<ul>
<li>dataDir：数据目录；</li>
<li>dataLogDir：日志目录；</li>
<li>clientPort：客户端连接端口；</li>
<li>tickTime：Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳（它也是Zookeeper中的基本时间单位）；</li>
<li>initLimit：设定了允许所有follower（下面会介绍）与leader进行连接并同步的时间，它是tickTime的整数倍；</li>
<li>syncLimit：设定了一个follower与leader进行同步的时间，也是tickTime的整数倍；</li>
<li>server.n=hostname:port1:port2：n的值就是服务器的ID，port1是follower用来连接leader的端口，port2是用于leader选举。总结起来就是，2181用于客户端连接，对于leader来说，2888端口用于follower连接，3888端口用于leader选举阶段的其他服务器连接。</li>
</ul>
<h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2><p>启动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh start</div></pre></td></tr></table></figure>
<p>停止：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh stop</div></pre></td></tr></table></figure>
<h1 id="ZooKeeper组成员关系"><a href="#ZooKeeper组成员关系" class="headerlink" title="ZooKeeper组成员关系"></a>ZooKeeper组成员关系</h1><p>Zookeeper是一个具有高可用性的高性能协调服务。</p>
<h2 id="组成员关系"><a href="#组成员关系" class="headerlink" title="组成员关系"></a>组成员关系</h2><p>Zookeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，但是这个文件系统中没有文件和目录，而是统一使用节点（node）的概念，成为<strong>znode</strong>。znode既可以作为保存数据的容器（如：文件），也可以作为保存其他znode的容器（如：目录）。所有的znode构成一个层次化的命名空间。一种自然的建立组成员列表的方式就是利用这个层次结构，如下图所示，首先创建一个以组名（<code>/zk</code>）为节点的znode作为父节点，然后以组成员（<code>/zk/node1</code>、<code>/zk/node2</code>、<code>/zk/node3</code>）为节点名来创建作为子节点的znode。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/group.png" alt="group"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>本例通过一个小项目来介绍Zookeeper的API使用。工程项目参见<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/groupexample" target="_blank" rel="external">ZooKeeperGroupExample</a>.</p>
<p>这里是使用maven建立的工程，pom文件中jar包的依赖内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5-cdh5.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h3><p>本程序是在Zookeeper中新建表示组的znode，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateGroup</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">	<span class="keyword">private</span> ZooKeeper zk;</div><div class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		zk = <span class="keyword">new</span> ZooKeeper(hosts, SESSION_TIMEOUT, <span class="keyword">this</span>);</div><div class="line">		connectedSignal.await();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</div><div class="line">			connectedSignal.countDown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName;</div><div class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		System.out.println(<span class="string">"CreateGroup: Created"</span> + createdPath);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		zk.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		CreateGroup createGroup = <span class="keyword">new</span> CreateGroup();</div><div class="line">		createGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		createGroup.create(args[<span class="number">1</span>]);</div><div class="line">		createGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序的主要接口有：</p>
<ul>
<li><code>new ZooKeeper()</code>:实例化一个新的Zookeeper类的对象，这个类负责维护客户端和Zookeeper服务之间的联系。它有三个参数<ol>
<li>Zookeeper服务的主机地址（可指定端口，默认是2181）；</li>
<li>以毫秒为单位的会话超时参数；</li>
<li>一个<code>Watcher</code>对象的实例，<code>Watcher</code>对象接收来自Zookeeper的回调，以获得各种事件的通知。</li>
</ol>
</li>
<li><code>zk.create()</code>:创建一个新的Zookeeper的znode。它有四个参数：<ol>
<li>路径（字符串表示）；</li>
<li>znode的内容（字节数组，本例中都使用null值）；</li>
<li>ACL（访问控制列表）；</li>
<li>创建znode的类型，有短暂和持久两种。</li>
</ol>
</li>
</ul>
<p>当一个Zookeeper实例新建时，会启动一个线程连接到Zookeeper服务，它对构造函数是立即返回的，因此在新建的Zookeeper对象之前一定要等待其与Zookeeper服务之间连接成功。这里使用<code>CountDownLatch</code>来阻止使用的Zookeeper对象。当客户端与Zookeeper建立连接之后，<code>Watcher</code>的<code>process()</code>方法会被调用，参数表示一个连接的事件。在接收到一个连接事件（以<code>Watcher.Event.KeeperState</code>的枚举类型值<code>SyncConnected</code>来表示）时，我们通过调用<code>CountDownLatch</code>的<code>countDown()</code>方法来递减它的计数器。锁存器（latch）被创建时带有一个值为1的计数器，用于表示它在释放所有线程之前需要发生的事件数。在调用一次<code>countDown()</code>方法之后，计数器的值变为0，则<code>await()</code>方法返回。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.CreateGroup zkIP matt</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CreateGroup: Created/matt</div></pre></td></tr></table></figure>
<h3 id="创建组成员"><a href="#创建组成员" class="headerlink" title="创建组成员"></a>创建组成员</h3><p>下面我们编写一个用于注册组成员的程序，每个组成员将作为一个程序运行，并且加入到组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于等待建立与Zookeeper连接的辅助类</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT=<span class="number">5000</span>;</div><div class="line">	<span class="keyword">protected</span> ZooKeeper zk;</div><div class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</div><div class="line">		zk=<span class="keyword">new</span> ZooKeeper(hosts,SESSION_TIMEOUT,<span class="keyword">this</span>);</div><div class="line">		connectedSignal.await();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(event.getState()== Event.KeeperState.SyncConnected)&#123;</div><div class="line">			connectedSignal.countDown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span>  InterruptedException</span>&#123;</div><div class="line">		zk.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码与<code>CreateGroup</code>的很类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于将组成员加入到组中</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(String groupName, String memberName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName + <span class="string">"/"</span> + memberName;</div><div class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		System.out.println(<span class="string">"Created "</span> + createdPath);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		JoinGroup joinGroup = <span class="keyword">new</span> JoinGroup();</div><div class="line">		joinGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		joinGroup.join(args[<span class="number">1</span>], args[<span class="number">2</span>]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>CreateMode.PERSISTENT</code>也可以设置为<code>CreateMode.EPHEMERAL</code>，当设置为<code>EPHEMERAL</code>时，也就意味着这个znode是一个短暂的znode，一旦关闭客户端，子节点的znode就会从父节点的znode中删除。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm1</div><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm2</div><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm3</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Created /matt/wm1</div><div class="line">Created /matt/wm2</div><div class="line">Created /matt/wm3</div></pre></td></tr></table></figure>
<h3 id="列出组成员"><a href="#列出组成员" class="headerlink" title="列出组成员"></a>列出组成员</h3><p>这段程序的目标是，在给出Zookeeper地址和父节点znode的情况下，列出该父节点znode的子节点znode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;String&gt; children = zk.getChildren(path, <span class="keyword">false</span>);</div><div class="line">			<span class="keyword">if</span> (children.isEmpty()) &#123;</div><div class="line">				System.out.printf(<span class="string">"No members in group %s\n"</span>, groupName);</div><div class="line">				System.exit(<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> (String child : children) &#123;</div><div class="line">				System.out.println(child);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</div><div class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		ListGroup listGroup = <span class="keyword">new</span> ListGroup();</div><div class="line">		listGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		listGroup.list(args[<span class="number">1</span>]);</div><div class="line">		listGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是调用了<code>zk.getChildren()</code>来打印出一个znode的子节点列表，调用参数为该znode的路径和设为false的观察标志。如果在一个znode上设置了观察标志，那么一旦该znode的状态改变，关联的观察（<code>Watcher</code>）会被触发。在这里我们没有使用观察，但是在查看一个znode的子节点时，也可以设置观察，让应用程序接收到组成员加入、退出和组被删除的有关通知。</p>
<p><code>KeeperException.NoNodeException</code>代表了组znode不存在的异常。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.ListGroup 192.168.80.23 matt</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wm1</div><div class="line">wm2</div><div class="line">wm3</div></pre></td></tr></table></figure>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p>这里给出一个删除znode的程序，它需要支持一级目录的递归删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException,InterruptedException</span>&#123;</div><div class="line">		String path=<span class="string">"/"</span>+groupName;</div><div class="line"></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			List&lt;String&gt; children=zk.getChildren(path,<span class="keyword">false</span>);</div><div class="line">			<span class="keyword">for</span>(String child: children)&#123;</div><div class="line">				zk.delete(path+<span class="string">"/"</span>+child,-<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">			zk.delete(path,-<span class="number">1</span>);</div><div class="line">		&#125;<span class="keyword">catch</span> (KeeperException.NoNodeException e)&#123;</div><div class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		DeleteGroup deleteGroup=<span class="keyword">new</span> DeleteGroup();</div><div class="line">		deleteGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		deleteGroup.delete(args[<span class="number">1</span>]);</div><div class="line">		deleteGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zookeeper对象提供了<code>delete()</code>的方法，该方法有两个参数：</p>
<ol>
<li>路径；</li>
<li>版本号：如果所提供的版本号与znode的版本号一致，则Zookeeper会删除这个znode，这是一种乐观枷锁方式，使客户端能够检测出对znode的修改冲突，这里将版本号设置为-1，可以绕过这个版本检测机制，不管znode的版本号是什么而直接将其删除。</li>
</ol>
<p>Zookeeper不支持递归的删除操作，所以在删除父节点之前必须删除其子节点。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.DeleteGroup 192.168.80.23 matt</div></pre></td></tr></table></figure>
<p>通过Zookeeper客户端看到的变化如下图（处理过之后的图）所示：</p>
<p><img src="/images/2016-04-13-zookeeper-learn/zk.png" alt="zk"></p>
<h1 id="ZooKeeper服务"><a href="#ZooKeeper服务" class="headerlink" title="ZooKeeper服务"></a>ZooKeeper服务</h1><p>这里主要通过数据模型、操作、实现、一致性、会话和状态来介绍。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Zookeeper维护着一个树形层次结构，树中的节点被称为znode。znode可以用与存储数据，并且有一个与之关联的ACL。</p>
<ol>
<li>Zookeeper被设计用来协调服务（通常是小数据文件），而不是用于大容量数据存储，因此一个znode能存储的数据被限制在1MB以内；</li>
<li>znode的数据访问具有<strong>原子性</strong>：客户端在读取一个znode数据时，要么读取到所有的数据，要么读操作失败，不会只读到部分数据。同样，写操作将替换znode存储的所有数据（Zookeeper不支持添加操作）；</li>
<li>znode通过路径被引用：Zookeeper中使用的路径必须是绝对路径，而且所有的路径必须是规范的，即每条路径只有唯一的一种表示方式，不支持路径解析；</li>
<li>Zookeeper的路径与URI不同，前者在Java API中通过（<code>java.lang.String</code>）来使用，而后者通过Hadoop <code>Path</code>类（或<code>java.net.URI</code>）来使用。</li>
</ol>
<h3 id="短暂znode"><a href="#短暂znode" class="headerlink" title="短暂znode"></a>短暂znode</h3><p>znode有两种类型，znode的类型在创建时确定并且之后不能再修改。</p>
<ol>
<li>短暂的：在创建短暂znode的客户端会话结束时，Zookeeper会将该短暂znode删除（短暂的znode不能有子节点）；<br>应用：对于那些需要知道特定时刻有哪些分布式资源可用的应用来说，使用短暂znode是一种理想的选择。</li>
<li>持久的：持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除。</li>
</ol>
<h3 id="顺序号"><a href="#顺序号" class="headerlink" title="顺序号"></a>顺序号</h3><ul>
<li>概念<ul>
<li>顺序（sequential）znode是指名称中包含ZooKeeper指定顺序号的znode。</li>
</ul>
</li>
<li>设置<ul>
<li>如果在创建znode时设置了顺序标识，那么该znode名称之后便会附加一个值，这个值由一个单调递增的<strong>计数器</strong>（由父节点维护）所添加的。</li>
</ul>
</li>
<li>举例<ul>
<li>如果一个客户端请求创建一个名为<code>/a/b-</code>的顺序znode，则所创建znode的名字可能是<code>/a/b-3</code>。如果稍后，另外一个名为<code>/a/b-</code>的顺序znode被创建，计数器会给出一个更大的值来保证znode名称的唯一性，例如：<code>/a/b-5</code>。在 Java 的 API 中，顺序 znode 的实际路径会作为 create() 调用的返回值被传回到客户端。</li>
</ul>
</li>
<li>应用<ul>
<li>在一个分布式系统中，顺序号可以被用于为所有的时间进行全局排序，这样客户端就可以通过顺序号来推断事件的顺序。今后的共享锁就是利用该原理。</li>
</ul>
</li>
</ul>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>znode以某种方式发生变化时，<strong>观察</strong>（Watch）机制可以让客户端得到通知。可以针对Zookeeper服务的操作来设置观察，该服务的其他操作可以触发观察。</p>
<p>注意：</p>
<ul>
<li>观察只触发一次，为了得到多次收到通知，客户端需要重新注册所需的观察。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>如下表，Zookeeper中有9种基本操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>创建一个 znode （必须要有父节点）</td>
</tr>
<tr>
<td>delete</td>
<td>删除一个 znode （该 znode不能有任何子节点）</td>
</tr>
<tr>
<td>exists</td>
<td>测试一个 znode 是否存在并且查询它的元数据</td>
</tr>
<tr>
<td>getACL,setACL</td>
<td>获取/设置一个 znode 的 ACL</td>
</tr>
<tr>
<td>getChildren</td>
<td>获取一个 znode 的子节点列表</td>
</tr>
<tr>
<td>getData，setData</td>
<td>获取/设置一个 znode 所保存的数据</td>
</tr>
<tr>
<td>sync</td>
<td>将客户端的 znode 视图与 Zookeeper 同步</td>
</tr>
</tbody>
</table>
<p>Zookeeper 中的更新操作时有条件的，在使用<code>delete</code>或<code>setData</code>操作时必须提供被更新 znode 的版本号（可以通过 exists 操作获得）。如果版本号不匹配，则更新操作会失败。更新操作时非阻塞操作，因此一个更新失败的客户端（由于其他进程同时在更新同一个 znode）可以决定是否重试，或执行其他操作，并不会因此而阻塞其他进程的执行。</p>
<p>虽然 Zookeeper 可以被看作是一个文件系统，但出于简单性的需求，有一些文件系统的基本操作被它摒弃了。由于 Zookeeper 中的文件较小并且总是被整体读写，因此没有必要提供打开、关闭或查找操作。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>对于 Zookeeper 客户端来说，主要由两种语言绑定 (binging) 可以使用：Java 和 C；当然也可以使用 Perl、Python 和 REST 的 contrib 绑定。对于每一种绑定语言来说，在执行操作时都可以选择同步执行或异步执行（提供两种不同的API）。</p>
<p>同步API与异步API的区别：</p>
<ul>
<li>同步API：使用同步API每个线程都会阻塞进程，知道该操作返回；</li>
<li>异步API：允许以流水线方式处理请求，这在某些情况下可以提供更好的吞吐量。</li>
</ul>
<h3 id="观察触发器"><a href="#观察触发器" class="headerlink" title="观察触发器"></a>观察触发器</h3><p>在<code>exists</code>、<code>getChildren</code>和<code>getData</code>这些读操作上可以设置观察，这些观察可以被写操作<code>create</code>、<code>delete</code>和<code>setData</code> 触发。ACL 相关的操作不参与触发任何观察。当一个观察被触发时会产生一个观察事件，这个观察和触发它的操作共同决定着观察事件的类型。</p>
<ul>
<li>当所观察的znode被创建子节点、删除或其他数据更新时，设置在<code>exists</code>操作上的观察将会被触发。</li>
<li>当所观察的znode被删除或其更新时，设置在<code>getData</code>上的观察将会被触发，创建znode不会触发<code>getData</code>上的观察，因为getData操作成功执行的前提是znode必须已经在。</li>
<li>当所观察的znode的一个子节点被创建或删除时，或观察的znode自己被删时，设置在<code>getChildren</code>操作上的观察将会被触发。</li>
</ul>
<p>设置监视器的操作及对应的触发器</p>
<p><img src="/images/2016-04-13-zookeeper-learn/watch.png" alt="watch"></p>
<ul>
<li>NodeCreated:节点创建事件；</li>
<li>NodeDeleted：代表znode被删除事件；</li>
<li>NodeDataChanged：节点数据改变事件；</li>
<li>NodeChildrenChanged：节点的子节点改变事件；</li>
</ul>
<p>注意：</p>
<ul>
<li>对于NodeCreated和NodeDeleted事件，可以通过路径来判断哪一个节点被创建或删除；</li>
<li>对于NodeChildrenChanged事件，需要重新调用<code>getChildren</code>来获取新的子节点列表来判断哪一个子节点被修改；</li>
<li>对于NodeDataChanged事件，需要调用<code>getData</code>来获取最新的数据；</li>
<li>对于上述第二、三种情况，从收到观察事件到执行操作期间，znode的状态可能会发生变化。</li>
</ul>
<h3 id="ACL-列表"><a href="#ACL-列表" class="headerlink" title="ACL 列表"></a>ACL 列表</h3><p>每个 znode 被创建时都会有一个 ACL 列表，用于决定谁可以对它执行何种操作。ACL 依赖于 Zookeeper 的客户端身份验证机制。Zookeeper 提供了一下几种身份验证方式：</p>
<ul>
<li>digest ：通过用户名和密码来识别客户端；</li>
<li>host：通过客户端的主机名（hostname）来识别客户端；</li>
<li>ip : 通过客户端的 IP 地址来识别客户端。</li>
</ul>
<p>在建议一个 Zookeeper 会话之后，客户端可以对自己进行身份验证。虽然 znode 的 ACL 列表会要求所有的客户端是经过验证的，但 Zookeeper 的身份验证过程却是可选的，客户端必须自己进行身份验证来支持对 znode 的访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用digest模式（用户和密码）进行身份验证</span></div><div class="line">zk.addAuthInfo(<span class="string">"digest"</span>,<span class="string">"tom:secret"</span>.getBytes());</div><div class="line"></div><div class="line"><span class="comment">//给域example.com下的客户端对某个znode的读权限，可以使用host模式、example.com的ID和READ权限在该znode上设置一个ACL</span></div><div class="line"><span class="keyword">new</span> ACL(Perms.READ,<span class="keyword">new</span> Id(<span class="string">"host"</span>,<span class="string">"example.com"</span>));</div></pre></td></tr></table></figure>
<p>ACL权限如下表：</p>
<table>
<thead>
<tr>
<th>ACL权限</th>
<th>允许的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>create（子节点）</td>
</tr>
<tr>
<td>READ</td>
<td>getChildren/getData</td>
</tr>
<tr>
<td>WRITE</td>
<td>setData</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（子节点）</td>
</tr>
<tr>
<td>ADMIN</td>
<td>setACL</td>
</tr>
</tbody>
</table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里先介绍一下Zookeeper在实际环境中使用时两种不同的运行模式：</p>
<ol>
<li>独立模式（standalone mode）<ul>
<li>只有一个ZooKeeper服务器，这种模式比较简单，适用于测试环境，但是不能保证高可用性和恢复性；</li>
</ul>
</li>
<li>复制模式（replicated mode）<ul>
<li>运行于一个计算机集群上，这个计算机集群被称为一个”集合体“（ensemble）,ZooKeeper通过复制模式来实现高可用性，只要集合体中有半数以上的机器处于可用状态，他就可以提供服务；</li>
<li>对于一个有5个节点的集合体中，最多可以容忍两台机器出现故障，这里要注意的是对于6个节点的集合体也是只能够容忍2台机器出现故障。</li>
</ul>
</li>
</ol>
<p>ZooKeeper要做的事情就是：确保对znode树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p>
<p>Zookeeper使用了<strong>Zab协议</strong>，该协议包括两个可以无限重复的阶段：</p>
<ol>
<li>阶段1：leader选举<ul>
<li>集合体中的所有机器通过一个选择过程来选出一台被称为“领导者”（leader）的机器，其他的机器被称为”跟随者“（follower）。一旦半数以上（或指定数量）的follower已经将其状态与leader同步，则标明这个阶段已经完成。</li>
</ul>
</li>
<li>阶段2: 原子广播<ol>
<li>所有的写请求都会被转发给leader，再由leader将更新广播给follwer；</li>
<li>当半数以上的follower已经将修改持久化之后，leader才会提交这个更新，然后客户端才会收到一个更新成功的响应。</li>
<li>这个用来打成共识的协议被设计成具有原子性，因此每个修改要么成功要么失败。</li>
</ol>
</li>
</ol>
<p>注意：</p>
<ul>
<li>如果leader出现故障，其余的机器会选出另外一个leader，并和新的leader继续提供服务。之后，如果之前的leader恢复正常，它就变成了一个follower（leader选举工程很快，根据<a href="http://zookeeper.apache.org/doc/current/zookeeperOver" target="_blank" rel="external">目前的结果</a>，大概只需要200ms）；</li>
<li>在更新内存中的znode树之前，集合体中的所有机器都会被先将更新写入磁盘。</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>理解 Zookeeper 的实现基础有助于理解其服务所提供的一致性保证。在集合体中所使用的术语leader和follower是恰当的，它们表名了一点，即一个follower可能滞后于leader几个更新。这也表名了一个现实情况，在一个修改被提交之前，只需要集合体中半数以上机器已经将该修改持久化即可。对 Zookeeper 来说，理想的情况就是将客户端都连接到与leader状态一致的服务器上，每个客户端都有连接到leader，但客户端对此无法控制，甚至它自己都无法知道是否连接到leader。参见下图</p>
<p><img src="/images/2016-04-13-zookeeper-learn/service.png" alt="service"></p>
<p>每一个对 znode 树的更新都被赋予一个全局唯一的 ID，称为<strong>zxid</strong> （代表 “Zookeeper Transaction ID”）。Zookeeper决定了分布式系统中的顺序，它对所有的更新进行排序，如果 zxid z1 小于 z2，则 z1 一定发生在 z2 之前。</p>
<p>在 Zookeeper 的设计中，以下几点考虑保证了数据的一致性。</p>
<ol>
<li>顺序一致性<ul>
<li>来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将 znode z 的值更新为 a，在之后的操作中，它又将 z 的值更新为 b ，则没有客户端能够在看到 z 的值是 b 之后再看到值 a（如果没有其他对于 z 的更新）。</li>
</ul>
</li>
<li>原子性<ul>
<li>更新要么成功，要么失败，不会存在部分成功或失败的结果。如果失败了，则不会有客户端看到这个更新的结果。</li>
</ul>
</li>
<li>单一系统映像<ul>
<li>一个客户端无论连接到具体哪一台服务器上，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。当一台服务器出故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有状态滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器将状态赶上故障服务器。</li>
</ul>
</li>
<li>持久性（可靠性）<ul>
<li>一个更改一旦成功，其结果就会被持久化并且不会被撤。这表明更新不会受到服务器故障的影响。</li>
</ul>
</li>
<li>及时性<ul>
<li>任何客户端所看到的系统视图的滞后都是有限的，不会超过几十秒，这意味着与其允许一个客户端看到非常陈旧的数据，还不如将服务器关闭，强迫该客户端连接到到一个状态较新的服务器。</li>
</ul>
</li>
</ol>
<p>由于性能的原因，所有的读操作都是从 Zookeeper 服务器的内存获得数据，它们不参与写操作的全局排序。如果客户端之间通过 Zookeeper 之外的机制进行通信，则客户端可能会发现它们所看到的 Zookeeper 状态是不一致的。</p>
<p>可以使用<code>sync</code>操作，保证任何后续的操作都在服务器的<code>sync</code>操作完成之后才执行。客户端使用<code>sync</code>操作来使自己保持最新的状态。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>每个 Zookeeper 客户端的配置中都包括集合体中服务器的列表。在启动时，客户端会尝试连接到列表中的一台服务器。如果连接失败，它会尝试连接另一台服务器，以此类推，直到成功与一台服务器建立连接或因为所有 Zookeeper 服务器都不可用而失败。</p>
<p>一旦客户端与一台 Zookeeper 服务器建立连接，这台服务器就会为该客户端创建一个新的会话。每个会话都会有一个超时的时间设置，这个设置由创建会话的应用来设定。如果服务器在超过时间段内没有收到任何请求，则相应的会话会过期。一旦一个会话已经过期，就无法重新被打开，并且任何与该会话相关联的短暂 znode 都会丢失。会话通常会长期存在，而会话过期则是一种比较罕见的事件，但对于应用来说，如何处理会话过期仍是非常重要的。</p>
<p>只要一个会话空闲超过一定时间，都可以通过客户端发送 ping 请求（也称为心跳）来保持会话不过期。（ping 请求是由 Zookeeper 的客户端库自动发送，因此在你的代码中不需要考虑如何维护会话）。这个时间长度的设置应当足够低，以便能够检测出服务器故障（由读超时体现），并且能够在会话超时的时间段内重新连接到另外一台服务器。</p>
<p>Zookeeper 客户端可以自动地进行故障切换，切换至另一台 Zookeeper 服务器，并且关键的是，在另一台服务器接替故障服务器之后，所有的会话（和相关的短暂 znode）仍然是有效的。</p>
<p>在故障切换过程中，应用程序将收到断开连接和连接至服务的通知。当客户端断开连接时，观察通知将无法发送；但是当客户端成功恢复连接后，这些延迟的通知还会被发送。当然，在客户端重新连接至另一台服务器的过程中，如果应用程序试图执行一个操作，这个操作将会失败。这充分说明在真实的 Zookeeper 应用中处理连接丢失异常的重要性。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在 Zookeeper 中有几个时间参数。<strong>滴答 (tickTime)</strong> 参数定义了 ZooKeeper 中的基本时间周期。</p>
<p>其他设置都是根据 滴答 (tickTime) 参数来定义的，或至少受它的限制。例如，会话超时 (session timeout) 参数的值不可以小于 2 个 滴答 (tickTime) 并且不可以大于 20 个 滴答 (tickTime)。如果你试图将会话超时参数设置在这个范围之外，它将会被自动修改到这个范围之内。</p>
<p>通常将 滴答 (tickTime) 参数设置为 2 秒 (2000毫秒)，对应于允许的会话超时范围是 4 到 40 秒。在选择会话超时设置时有几点需要考虑。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>ZooKeeper 对象在其生命周期中会经历几种不同的状态，如下图。你可以在任何时刻通过 <code>getState()</code> 方法来查询对象的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">getState</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>Status被定义为代表Zookeeper对象在不同状态的枚举类型值（一个Zookeeper的实例在一个时刻只能处于一种状态）。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/status.png" alt="status"></p>
<ul>
<li>一个新建的Zookeeper实例处于<code>CONNECTING</code>状态。</li>
<li>一旦建立连接，他就会进入<code>CONNECTED</code>状态。</li>
<li>一个对象在进入<code>CONNECTED</code>状态时，观察对象会收到一个<code>WatchedEvent</code>通知，其中<code>KeeperState</code>的值是<code>SyncConnected</code>。</li>
<li>Zookeeper实例可以断开，然后重新连接到Zookeeper服务，此时它的状态就在<code>CONNECTED</code>和<code>CONNECTING</code>之间转换。</li>
<li>如果<code>close()</code>方法被调用或出现会话超时，Zookeeper实例就会转换到第三个状态<code>CLOSED</code>。一旦处于<code>CLOSED</code>状态，Zookeeper对象就不再被认为是活跃的，并且不能再用。</li>
</ul>
<p>Zookeeper的观察对象有两个作用：</p>
<ul>
<li>它可以用来获得Zookeeper状态变化的相关通知；</li>
<li>它还可以用来获得znode变化的相关通知。</li>
</ul>
<h1 id="ZooKeeper应用"><a href="#ZooKeeper应用" class="headerlink" title="ZooKeeper应用"></a>ZooKeeper应用</h1><h2 id="配置服务示例"><a href="#配置服务示例" class="headerlink" title="配置服务示例"></a>配置服务示例</h2><p>配置服务是分布式系统应用所需要的基本服务之一，它可以使集群中的机器共享配置信息中的那些公共部分。也就是说，Zookeeper可以作为一个具有高可用性的配置服务存储器，允许分布式应用的参与者检索和更新配置文件。</p>
<p>这里我们编写这样一个应用示例（完整代码参考<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/updateexample" target="_blank" rel="external">Zookeeper Update Example</a>），这里有两个假设来简化我们的示例：</p>
<ol>
<li>所需存储的配置数据是字符串，关键字是znode的路径，因此我们在znode上存储了一个键值对；</li>
<li>在任何时候只有一个客户端会执行更新操作。</li>
</ol>
<p>首先我们在<code>ActiveKeyValueStore</code>的类中编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groupexample.ConnectionWatcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveKeyValueStore</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String path, String value)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		Stat stat = zk.exists(path, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</div><div class="line">			zk.create(path, value.getBytes(CHARSET), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			zk.setData(path, value.getBytes(CHARSET), -<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">(String path, Watcher watcher)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] data = zk.getData(path, watcher, <span class="keyword">null</span><span class="comment">/*stat*/</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(data, CHARSET);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面有两个关键方法：</p>
<ul>
<li><code>write()</code>：将一个关键字及其值写入Zookeeper；</li>
<li><code>read()</code>：读取Zookeeper中的配置属性。</li>
</ul>
<p>Zookeeper的<code>getData()</code>方法有三个参数：</p>
<ol>
<li>路径；</li>
<li>一个观察对象；</li>
<li>一个Stat对象.</li>
</ol>
<p>其中，Stat对象由<code>getData()</code>方法返回的值填充，用来将信息传回给调用者，通过这个方法，调用者可以获得一个znode的数据和元数据，但在本例中，由于我们对元数据不感兴趣，因此将Stat参数设为null。</p>
<p>下面我们编写一个用于更新配置属性值的类<code>ConfigUpdater</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigUpdater</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/matt"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</div><div class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigUpdater</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</div><div class="line">		store.connect(hosts);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			String value = random.nextInt(<span class="number">100</span>) + <span class="string">" "</span>;</div><div class="line">			store.write(PATH, value);</div><div class="line">			System.out.printf(<span class="string">"Set %s to %s \n"</span>, PATH, value);</div><div class="line">			TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		ConfigUpdater configUpdater=<span class="keyword">new</span> ConfigUpdater(args[<span class="number">0</span>]);</div><div class="line">		configUpdater.run();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>run()</code>方法在随机时间将随机值更新到<code>/matt</code>znode中。</p>
<p>下面我们通过一个<code>ConfigWatcher</code>类初始化一个实例，然后在<code>dirplayConfig()</code>方法中调用<code>read()</code>显示它所读取到的配置信息的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigWatcher</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</div><div class="line">		store.connect(hosts);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayConfig</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		String value = store.read(ConfigUpdater.PATH, <span class="keyword">this</span>);</div><div class="line">		System.out.printf(<span class="string">"Read %s as %s.\n"</span>, ConfigUpdater.PATH, value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				displayConfig();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				System.out.println(<span class="string">"Interrupted. exiting."</span>);</div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">				System.out.printf(<span class="string">"KeeperException: %s. Exiting.\n"</span>, e);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		ConfigWatcher configWatcher = <span class="keyword">new</span> ConfigWatcher(args[<span class="number">0</span>]);</div><div class="line">		configWatcher.displayConfig();</div><div class="line"></div><div class="line">		Thread.sleep(Long.MAX_VALUE);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 两个控制台分别运行以下命令</span></div><div class="line">java -cp zookeeperexample.jar updateexample.ConfigUpdater zkIP</div><div class="line">java -cp zookeeperexample.jar updateexample.ConfigWatcher zkIp</div></pre></td></tr></table></figure>
<p>这里要注意<code>ConfigWatcher</code>只能收到最近的一个更新，而不是收到所有的更新，每当<code>ConfigWatcher</code>调用时，就会收到最近的一个更新。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在前面的两个例子，我们经常会看到<code>InterruptedException</code>和<code>KeeperException</code>这两种类型的异常，下面，我们就详细讲述一下。</p>
<h3 id="InterruptedException异常"><a href="#InterruptedException异常" class="headerlink" title="InterruptedException异常"></a>InterruptedException异常</h3><p>如果操作被中断，则会有一个<code>InterruptedException</code>异常。在Java中，有一个取消阻塞方法的标准机制，即针对存在阻塞方法的线程调用<code>interrupt()</code>。一个成功的取消操作将产生一个<code>InterruptedException</code>异常。Zookeeper也遵循这一机制，因此你可以使用这种方法来取消一个Zookeeper操作。使用了Zookeeper的类或者库时，通常就会传播<code>InterruptedException</code>异常，使客户端取消它们的操作。</p>
<p><code>InterruptedException</code>异常并不意味着故障，只是表明相应的操作被取消了而已。</p>
<h3 id="KeeperException异常"><a href="#KeeperException异常" class="headerlink" title="KeeperException异常"></a>KeeperException异常</h3><p>如果ZooKeeper服务器发出一个错误信号或与服务器存在通信问题，抛出的则是<code>KeeperException</code>异常。</p>
<ul>
<li>针对不同的错误情况，<code>KeeperException</code>异常存在不同的子类。<br>例如:　<code>KeeperException.NoNodeException</code>是<code>KeeperException</code>的一个子类，如果你试图针对一个不存在的znode执行操作，抛出的则是该异常。</li>
<li>每一个<code>KeeperException</code>异常的子类都对应一个关于错误类型信息的代码。<br>例如:　<code>KeeperException.NoNodeException</code>异常的代码是<code>KeeperException.Code.NONODE</code>.</li>
</ul>
<p>有两种方法被用来处理<code>KeeperException</code>异常：</p>
<ol>
<li>捕捉<code>KeeperException</code>异常，并且通过检测它的代码来决定采取何种补救措施；</li>
<li>另一种是捕捉等价的<code>KeeperException</code>子类，并且在每段捕捉代码中执行相应的操作。</li>
</ol>
<p>KeeperException异常分为三大类</p>
<h4 id="1-状态异常"><a href="#1-状态异常" class="headerlink" title="1.状态异常"></a>1.状态异常</h4><p>当一个操作因不能被应用于znode树而导致失败时，就会出现状态异常。状态异常产生的原因通常是在同一时间有另外一个进程正在修改znode。例如，如果一个znode先被另外一个进程更新了，根据版本号执行<code>setData()</code>操作的进程就会失败，并收到一个<code>KeeperException.BadVersionException</code>异常，这是因为版本号不匹配。程序员通常都知道这种冲突总是存在的，也都会编写代码来进行处理。</p>
<p>一些状态异常会指出程序中的错误，例如<code>KeeperException.NoChildrenForEphemeralsException</code>异常，试图在短暂znode下创建子节点时就会抛出该异常。</p>
<h4 id="2-可恢复异常"><a href="#2-可恢复异常" class="headerlink" title="2.可恢复异常"></a>2.可恢复异常</h4><p>可恢复的异常是指那些应用程序能够在同一个ZooKeeper会话中恢复的异常。一个可恢复的异常是通过<code>KeeperException.ConnectionLossException</code>来表示的，它意味着已经丢失了与ZooKeeper的连接。ZooKeeper会尝试重新连接，并且在大多数情况下重新连接会成功，并确保会话是完整的。</p>
<p>但是ZooKeeper不能判断与<code>KeeperException.ConnectionLossException</code>异常相关的操作是否成功执行。这种情况就是部分失败的一个例子。这时程序员有责任来解决这种不确定性，并且根据应用的情况来采取适当的操作。在这一点上，就需要对<strong>幂等(idempotent)操作</strong>和<strong>非幂等(Nonidempotent)操作</strong>进行区分。</p>
<ul>
<li>幂等操作:指那些一次或多次执行都会产生相同结果的操作，例如读请求或无条件执行的<code>setData</code>操作。对于幂等操作，只需要简单地进行重试即可。</li>
<li>非幂等操作:就不能盲目地进行重试，因为它们多次执行的结果与一次执行是完全不同的。程序可以通过在znode的路径和它的数据中编码信息来检测是否非幂等操怍的更新已经完成。</li>
</ul>
<h4 id="3-不可恢复的异常"><a href="#3-不可恢复的异常" class="headerlink" title="3.不可恢复的异常"></a>3.不可恢复的异常</h4><p>在某些情况下，ZooKeeper会话会失效——也许因为超时或因为会话被关闭，两种情况下都会收到<code>KeeperException.SessionExpiredException</code>异常，或因为身份验证失败，<code>KeeperException.AuthFailedException</code>异常。无论上述哪种情况，所有与会话相关联的短暂znode都将丢失，因此应用程序需要在重新连接到ZooKeeper之前重建它的状态。</p>
<p>到这里，对Zookeeper的主要内容已经讲述差不多了，希望对大家能有所帮助。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南第二版</a></li>
<li><a href="https://zookeeper.apache.org/" target="_blank" rel="external">Apache Zookeeper</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index" target="_blank" rel="external">ZooKeeper WIKI</a></li>
<li><a href="http://zookeeper.apache.org/doc/current/index.html" target="_blank" rel="external">ZooKeeper 3.4Documentation</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zookeeper的重要性及应用的广泛性，这里就不再叙述了，本文是学习&lt;a href=&quot;https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055Q
    
    </summary>
    
      <category term="技术" scheme="http://wangzzu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zookeeper" scheme="http://wangzzu.github.io/tags/zookeeper/"/>
    
  </entry>
  
</feed>
