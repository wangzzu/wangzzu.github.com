<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>JVM学习——java 内存区域与内存溢出分析 | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM学习——java 内存区域与内存溢出分析</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">王蒙</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM学习——java 内存区域与内存溢出分析</h1><div class="post-meta">Sep 7, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">5,790</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2016/09/07/jvm-basic1/" href="/2016/09/07/jvm-basic1/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区"><span class="toc-number">2.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-number">2.2.</span> <span class="toc-text">Java虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量表"><span class="toc-number">2.2.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常情况"><span class="toc-number">2.2.2.</span> <span class="toc-text">异常情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java堆"><span class="toc-number">2.4.</span> <span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池-Runtime-Constant-Pool"><span class="toc-number">2.6.</span> <span class="toc-text">运行时常量池 Runtime Constant Pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存-Direct-Memory"><span class="toc-number">2.7.</span> <span class="toc-text">直接内存 Direct Memory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HotSpot虚拟机对象解密"><span class="toc-number">3.</span> <span class="toc-text">HotSpot虚拟机对象解密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的创建"><span class="toc-number">3.1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建过程"><span class="toc-number">3.1.1.</span> <span class="toc-text">创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆内存分配方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">堆内存分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-number">3.1.3.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">3.2.</span> <span class="toc-text">对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象头"><span class="toc-number">3.2.1.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例数据"><span class="toc-number">3.2.2.</span> <span class="toc-text">实例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对齐填充"><span class="toc-number">3.2.3.</span> <span class="toc-text">对齐填充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的访问定位"><span class="toc-number">3.3.</span> <span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#句柄访问"><span class="toc-number">3.3.1.</span> <span class="toc-text">句柄访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接地址访问"><span class="toc-number">3.3.2.</span> <span class="toc-text">直接地址访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OOM-调试"><span class="toc-number">4.</span> <span class="toc-text">OOM 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-堆溢出"><span class="toc-number">4.1.</span> <span class="toc-text">Java 堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">4.1.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例异常分析"><span class="toc-number">4.1.2.</span> <span class="toc-text">示例异常分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈和本地方法栈溢出"><span class="toc-number">4.2.</span> <span class="toc-text">虚拟机栈和本地方法栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例分析"><span class="toc-number">4.2.2.</span> <span class="toc-text">示例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区和运行时常量池异常"><span class="toc-number">4.3.</span> <span class="toc-text">方法区和运行时常量池异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#示例-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>本文主要是对《深入理解java虚拟机 第二版》第二章部分做的总结，文章中大部分内容都来自这章内容，之所以记录到博客，是想通过这个过程加深自己的理解，并且方便以后遇到相关问题之后进行查阅。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>Java 虚拟机所管理的内存包括以下几个运行时数据区域，如下图所示。</p>
<p><img src="/images/java/jvm/jvm.png" alt="jvm"></p>
<ul>
<li>线程间共享区域：方法区和堆；</li>
<li>线程间私有区域：虚拟机栈、本地方法栈和程序计数器。</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>特点：</p>
<ol>
<li>它是一块较小的内存空间，可以看出当前线程所执行的字节码的行号指示器；</li>
<li>字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都要靠它完成；</li>
<li>每个线程都有一个自己的计数器，线程之间的计数器互不影响；</li>
<li>JVM多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的；</li>
<li>执行Native方法时，计数器不起作用，职位空缺（null）；</li>
<li>此区域是唯一没有规定OOM的区域。</li>
</ol>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frmae）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表存放了编译期可知的基本数据类型（boolean、byte、char、shot、int、float、long、double）、对象引用（reference 类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>其中，long、double因为长度为64bit，会占用两个Slot，其余的数据类型只占用一个。由此可知局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>虚拟机栈中可能会出现两种异常情况：</p>
<ol>
<li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度.</li>
<li><code>OutOfMemoryError</code>：虚拟机栈动态扩展内存时，无法申请到足够的内存.</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈作用很相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java Heap 是 jvm 所管理的内存中最大的区域。Java Heap 是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例和数组都在这里分配内存。</p>
<p>Java Heap 是垃圾收集器管理的主要区域，也叫做 GC 堆。其可细分为新生代和老年代，而新生代又可分为Eden 空间、From Survivor 空间和 To Survivor 空间。</p>
<p>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code> 和<code>-Xms</code>控制）。但如果在堆中没有内存完成实例分配，并且也无法再扩展时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>其中，<code>-Xmn</code> 用来控制新生代内存的大小。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>特点</p>
<ol>
<li>线程间共享的内存区域；</li>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li>
<li>当方法区无法满足内存的分配需求时，将抛出 <code>OutOfMemoryError</code> 异常；</li>
</ol>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池 Runtime Constant Pool"></a>运行时常量池 Runtime Constant Pool</h2><p>特点</p>
<ol>
<li>属于方法区的一部分，</li>
<li>保存Class文件中描述的符号引用和各种字面量.</li>
<li>因为是方法区的一部分，所以会受到方法区内存的限制，当常量池无法再申请到内存时，抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h2 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存 Direct Memory"></a>直接内存 Direct Memory</h2><ol>
<li>直接内存不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也可能会出现 <code>OutOfMemoryError</code> 异常；</li>
<li>在 JDK 1.4 中新加入了 NIO（<code>New Input/Output</code>），引入 <code>Channel</code> 和 <code>Buffer</code> 的 I/O 方式，它可以用 <code>native</code> 方法申请堆外内存，然后通过 JVM 堆中的 <code>DirectByteBuffer</code> 对象操作这块内存，在一些场景下可以显著提高性能（零拷贝）；</li>
<li>虽然本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。开发者在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h1 id="HotSpot虚拟机对象解密"><a href="#HotSpot虚拟机对象解密" class="headerlink" title="HotSpot虚拟机对象解密"></a>HotSpot虚拟机对象解密</h1><p>在了解了JVM 内存的概况之后，这里再介绍一下这些虚拟机内存中的数据的其它细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样设计细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。这里我们以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，深入学习 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java 是一门面向对象的编程语言，在 Java 中无时无刻都有对象被创建出来。在语言层次上，创建对象（例如克隆、反序列化）通常只是一个 <code>new</code> 关键字而已，本小节主要讨论一下对与一个普通的 Java 对象（不包括数组和 Class 对象等）创建的过程是怎样的？</p>
<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>当虚拟机遇到一条 <code>new</code> 指令时，虚拟机会进行以下步骤创建对象。</p>
<ol>
<li>将先去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行响应的类加载过程（这部分本文暂时不涉及）；</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来；</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（这步操作保证了对象的实例字段在 Java 代码中可以不赋初值就可以直接使用）；</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象的对象头（Object Header）之中。</li>
</ol>
<p>这些步骤结束之后，对于虚拟机来说，一个新的对象已经产生了，但是从 Java 角度来看，对象创建才刚刚开始，还没有对对象进行初始化操作。</p>
<h3 id="堆内存分配方法"><a href="#堆内存分配方法" class="headerlink" title="堆内存分配方法"></a>堆内存分配方法</h3><p>从上节的第二步中可以看到，虚拟机为新生对象分配内存，相当于把一块固定大小的内存从 Java 堆中划分出来。</p>
<ol>
<li>我们假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式叫做<strong>指针碰撞</strong>（Bump the Pointer）；</li>
<li>如果 Java 堆中的内存不是完整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>空闲列表</strong>（Free List）。</li>
</ol>
<p>选择哪种分配方式由 Java 堆是否完整决定，而 Java 堆是否完整又由所采用的垃圾收集器是否带有<strong>压缩整理</strong>功能决定。</p>
<ul>
<li>在使用 Serial、ParNew 等带有 Compact 过程的收集器时，系统采用的分配算法是指针碰撞；</li>
<li>而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用的是空闲列表。</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在JVM 中，对象创建是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现在给对象 A 分配内存时，指针还没来得及修改，对象 B 又同时使用原来的指针分配内存的情况。对于这个问题，有两种解决方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用 <strong>CAS</strong> 配上失败重试的方式更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 <code>-XX:+/-UseTLAB</code> 参数来设定。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别是32bit 和64bit，官方称为”Mark Word”。</p>
<blockquote>
<p>注：对象需要存储的运行时数据很多，其实已经超出了32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，因此，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>
</blockquote>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。另外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据才是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFilds 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java 堆会先划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="/images/java/jvm/getobject1.png" alt="getobject1"></p>
<p>通过句柄访问的最大好处 reference 中存储的是稳定的句柄地址，在对象被移动（gc 时移动对象非常普遍）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
<h3 id="直接地址访问"><a href="#直接地址访问" class="headerlink" title="直接地址访问"></a>直接地址访问</h3><p>使用直接地址访问时，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p><img src="/images/java/jvm/getobject2.png" alt="getobject2"></p>
<p>使用直接指针访问方式的最大好处就是速度更快，节省了一次指针定位的开销，HotSpot 也是这是使用这种方式实现的。</p>
<h1 id="OOM-调试"><a href="#OOM-调试" class="headerlink" title="OOM 调试"></a>OOM 调试</h1><p>根据前面的介绍，我们知道在 JVM 中，除了程序计数器之后，虚拟机内存的其他几个区域都有发生 OOM 异常的可能，本节会通过一些示例来验证异常发生的场景以及讲述一下如何进行调试。</p>
<h2 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h2><p>Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子中，我们限制 Java 堆的大小为5MB，不可扩展（将堆的最小值 <code>-Xms</code> 参数与最大值 <code>-Xmx</code> 参数设置为一样即可）。JVM 参数设置为 <code>-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError</code>，程序代码如下（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/heap/HeapOOMTest.java" target="_blank" rel="external">HeapOOMTest</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOMTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_NAME = <span class="string">"matt"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_AGE = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = DEFAULT_NAME;</span><br><span class="line">            <span class="keyword">this</span>.age = DEFAULT_AGE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            persons.add(<span class="keyword">new</span> Person());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid9479.hprof ...</span><br><span class="line">Heap dump file created [11824236 bytes <span class="keyword">in</span> 0.092 secs]</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:2245)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:2219)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:242)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:440)</span><br><span class="line">	at heap.HeapOOMTest.main(HeapOOMTest.java:47)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br></pre></td></tr></table></figure>
<h3 id="示例异常分析"><a href="#示例异常分析" class="headerlink" title="示例异常分析"></a>示例异常分析</h3><p>Java 堆内存的 OOM 异常是实际应用中常见的内存异常情况。当出现 Java 堆内存溢出时，会报错误信息 <code>java.lang.OutOfMemoryError</code>，会跟着进一步提示 <code>Java heap space</code>。</p>
<p>出现这个异常之后，首先需要确定内存中的数据是否是必要，也就是要先分清楚是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<ol>
<li>如果是内存泄露，可进一步通过工具查看泄露对象到 GC Roots 的引用链。于是就能找到对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的，这样就就可以定位出泄露代码的位置；</li>
<li>如果不是内存泄露，需要检查一下虚拟机的参数（<code>-Xmx</code> 与 <code>-Xms</code>），与物理机内存对比看是否还可以调大，然后再检查一下代码，是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>由于在 HotSpot 虚拟机中并不区分虚拟机栈而本地方法栈。因此，对于 HotSpot 来说，虽然 <code>-Xoss</code> 参数（设置本地方法栈大小）存在，但实际上无效的，栈容量只由 <code>-Xss</code> 参数设定。对于虚拟机栈和本地方法栈，在 Java 虚拟机中描述了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<blockquote>
<p>注：这里有一个问题，当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是针对同一件事情两种描述。</p>
</blockquote>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>对单线程的情况，尝试一下两种方法都是获得 <code>StackOverflowError</code> 异常（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/stack/StackTest1.java" target="_blank" rel="external">StackTest1</a>）</p>
<ul>
<li>使用<code>-Xss</code>参数减少栈内存容量。结果：抛出 <code>StackOverflowError</code> 异常，异常出现时输出的栈深度相应减少；</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出 <code>StackOverflowError</code> 异常时输出的堆栈深度相应减少。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss256k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        StackTest1 stackTest1=<span class="keyword">new</span> StackTest1();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackTest1.stackLeak();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length: "</span>+stackTest1.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">	at stack.StackTest1.stackLeak(StackTest1.java:9)</span><br><span class="line">stack length: 1868</span><br><span class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</span><br><span class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>根据上面的测试结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是  <code>StackOverflowError</code> 异常。</p>
<h2 id="方法区和运行时常量池异常"><a href="#方法区和运行时常量池异常" class="headerlink" title="方法区和运行时常量池异常"></a>方法区和运行时常量池异常</h2><p>运行时常量池是方法区的一部分。可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 来限制方法区的大小，从而间接限制其中常量池的容量。下面的例子主要讲述一下方法区异常的示例。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，我们的思路是运行时产生大量的类去填满方法区，知道溢出。在我们的示例中，我们借助 CGLib 直接操作字节码运行时生成了大量的动态类（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/methodarea/JavaMethodAreaOOM.java" target="_blank" rel="external">JavaMethodAreaOOM</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">    Dumping heap to java_pid10480.hprof ...</span><br><span class="line">    Heap dump file created [10685765 bytes <span class="keyword">in</span> 0.086 secs]</span><br><span class="line">    Exception <span class="keyword">in</span> thread <span class="string">"main"</span></span><br><span class="line">    Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler <span class="keyword">in</span> thread <span class="string">"main"</span></span><br></pre></td></tr></table></figure>
<p>方法区溢出</p>
<ul>
<li>方法区存储类信息，当类过多时，就会导致方法区溢出.</li>
<li>实际应用中，主流框架如Spring、Hibernate（CGLIB）、JSP、OSGi等会动态生成大量Class；而类被回收的判定条件是非常苛刻的.</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1472975542&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">深入理解java虚拟机</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-vm/" target="_blank" rel="external">深入理解java虚拟机 | 极客学院</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2016/09/07/jvm-basic1/" data-id="ck3bgdvwy00666wjgh3ioypfo" class="article-share-link">分享到</a><div class="copyright"><a href="http://matt33.com/copyright/">博客版权说明</a></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/jvm/">jvm</a></div><div class="post-nav"><a href="/2016/09/18/jvm-basic2/" class="pre">JVM 学习——垃圾收集器与内存分配策略</a><a href="/2016/08/31/database-transaction/" class="next">数据库事务性（MySQL 存储引擎及索引结构）</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2016/09/07/jvm-basic1/';
var disqus_title = 'JVM学习——java 内存区域与内存溢出分析';
var disqus_url = 'http://matt33.com/2016/09/07/jvm-basic1/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/flink-learn-start-1/">Apache Flink 初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/paper-chandy-lamport/">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/paper-flink-snapshot/">Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/19/paper-ray1/">Paper 阅读: Real-Time Machine Learning: The Missing Pieces</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/apache-calcite-planner/">Apache Calcite 优化器详解（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/bk-store-realize/">BookKeeper 原理浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/effective-learning/">如何高效学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/04/kafka-transaction/">Kafka Exactly-Once 之事务性实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/kafka-idempotent/">Kafka 事务性之幂等性实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>