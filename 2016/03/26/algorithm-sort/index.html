<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>排序算法总结 | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">排序算法总结</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">王蒙</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">排序算法总结</h1><div class="post-meta">Mar 26, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">5,359</span><span> 字</span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2016/03/26/algorithm-sort/" href="/2016/03/26/algorithm-sort/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#性能评估指标"><span class="toc-number">1.</span> <span class="toc-text">性能评估指标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#选择排序"><span class="toc-number">2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤"><span class="toc-number">2.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">2.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析"><span class="toc-number">2.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插入排序"><span class="toc-number">3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-1"><span class="toc-number">3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-1"><span class="toc-number">3.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-1"><span class="toc-number">3.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-1"><span class="toc-number">3.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#希尔排序"><span class="toc-number">4.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-2"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-2"><span class="toc-number">4.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-2"><span class="toc-number">4.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-2"><span class="toc-number">4.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#冒泡排序"><span class="toc-number">5.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-3"><span class="toc-number">5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-3"><span class="toc-number">5.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-3"><span class="toc-number">5.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#归并排序"><span class="toc-number">6.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原地归并排序"><span class="toc-number">6.1.</span> <span class="toc-text">原地归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">6.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤-4"><span class="toc-number">6.1.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-4"><span class="toc-number">6.1.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自顶向下"><span class="toc-number">6.2.</span> <span class="toc-text">自顶向下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-4"><span class="toc-number">6.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤-5"><span class="toc-number">6.2.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-5"><span class="toc-number">6.2.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能分析-3"><span class="toc-number">6.2.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自低向上"><span class="toc-number">6.3.</span> <span class="toc-text">自低向上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-5"><span class="toc-number">6.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤-6"><span class="toc-number">6.3.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-6"><span class="toc-number">6.3.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能分析-4"><span class="toc-number">6.3.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#快速排序"><span class="toc-number">7.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-6"><span class="toc-number">7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-7"><span class="toc-number">7.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-7"><span class="toc-number">7.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-5"><span class="toc-number">7.4.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快排算法改进"><span class="toc-number">7.5.</span> <span class="toc-text">快排算法改进</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆排序"><span class="toc-number">8.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-7"><span class="toc-number">8.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-8"><span class="toc-number">8.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-6"><span class="toc-number">8.3.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计数排序"><span class="toc-number">9.</span> <span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-8"><span class="toc-number">9.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-8"><span class="toc-number">9.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-9"><span class="toc-number">9.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-7"><span class="toc-number">9.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基数排序（Radix-Sort）"><span class="toc-number">10.</span> <span class="toc-text">基数排序（Radix Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-9"><span class="toc-number">10.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-9"><span class="toc-number">10.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-10"><span class="toc-number">10.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-8"><span class="toc-number">10.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桶排序"><span class="toc-number">11.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-10"><span class="toc-number">11.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤-10"><span class="toc-number">11.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-11"><span class="toc-number">11.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能分析-9"><span class="toc-number">11.4.</span> <span class="toc-text">性能分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法性能总结"><span class="toc-number">12.</span> <span class="toc-text">算法性能总结</span></a></li></ol></div></div><div class="post-content"><p>排序算法是算法中基础的部分，也是面试中经常被问到的地方。因此，根据对《算法》和《算法导论》关于这部分的学习，做一下总结，以后再遇到排序方面的问题就可以直接看一下博文就行了（文中算法用java实现）。</p>
<ul>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>冒泡排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
<h1 id="性能评估指标"><a href="#性能评估指标" class="headerlink" title="性能评估指标"></a>性能评估指标</h1><ol>
<li>运行时间：<strong>排序的成本模型</strong>：在研究排序算法时，需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。</li>
<li>额外的内存使用：排序算法分为两种：除了函数调用的栈和固定数目的实例变量之外无需额外内存的<code>原地排序算法</code>，以及需要额外内存空间存储另一份数组副本的其他排序算法。</li>
</ol>
<p>代码中使用基本方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    Comparable tmp = a[i];</div><div class="line">    a[i] = a[j];</div><div class="line">    a[j] = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</div><div class="line">        System.out.print(a[i] + <span class="string">" "</span>)</div><div class="line">    System.out.println();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//默认按升序排列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>先找到数组中最小的那个元素；</li>
<li>将它和数组中第一个元素交换位置（如果第一个元素是自己，和自己交换）；</li>
<li>在剩下的数组中找到最小的元素，将它和第二个元素交换位置，以此类推。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (less(a[j], a[min]))</div><div class="line">                min = j;</div><div class="line">        &#125;</div><div class="line">        exch(a, i, min);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Selection.java" target="_blank" rel="external">Selection.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之选择排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Selection_sort_animation.gif" alt="selection_sort"></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>对于长度为$N$的数组，选择排序需要大约$\frac{N^2}{2}$次比较和$N$次交换；</li>
<li>最好的情况：已经有序，交换$0$次；</li>
<li>最坏的情况：逆序，交换$N-1$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>运行时间与输入无关，即使对于一个有序数组，依然需要扫描全部元素而且运行时间与随机数组一样；</li>
<li>数据移动是最少的。交换次数与数组大小成线性关系。</li>
</ol>
</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span>(less(a[j], a[j - <span class="number">1</span>]))</div><div class="line">                exch(a, j, j - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Insertion.java" target="_blank" rel="external">Insertion.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Insertion_sort_animation.gif" alt="Insertion_sort"></p>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>平均来说，插入排序的复杂度为$O(n^2)$;</li>
<li>最好的情况：已经有序，只需要比较操作$N-1$次即可；</li>
<li>最坏的情况：逆序，需要比较$\frac{N*(N-1)}{2}$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>插入排序很适合部分有序的数组和规模较小的数组；</li>
<li>插入排序不适合对于数据量比较大的排序应用.</li>
</ol>
</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>也称为递减增量排序算法，它是对插入排序的一种快速算法，插入排序相当于$h=1$的情况。（希尔排序的思想是使数组中任意间隔为h的元素都是有序的）</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位。</li>
</ol>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><p>算法最重要的部分是<strong>步长</strong>，当步长为1时就是插入排序。</p>
<ol>
<li>最开始以一定的步长进行排序；</li>
<li>然后会继续以一定步长进行排序；</li>
<li>最终算法以步长为1进行排序。</li>
</ol>
<p>当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>步长的设置，影响着希尔排序算法的复杂度，具体可参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>，这里给出一个步长序列与复杂度的关系表：</p>
<p><img src="/images/2016-03-26-sort/shell.png" alt="shell"></p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</div><div class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</div><div class="line">                exch(a, j, j - h);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        h = h / <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Shell.java" target="_blank" rel="external">Shell.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Sorting_shellsort_anim.gif" alt="shellsort"></p>
<h2 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：参见上表</li>
<li>特点：<ol>
<li>排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。</li>
</ol>
</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序是一种简单的排序算法。它每次去从开始去比较两个元素，如果顺序错误就交换过来，当比较到最后一个元素时，就会把最小（最大）的元素找出来；然后在重复比较，前面已经找到的就不再参与比较。元素越小（大）的元素会经过交换慢慢“浮”到数列顶端。</p>
<h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N=a.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</div><div class="line">                exch(a,i,i-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        N--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Bubble.java" target="_blank" rel="external">Bubble.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Bubble_sort_animation.gif" alt="Bubble_sort"></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原地归并排序"><a href="#原地归并排序" class="headerlink" title="原地归并排序"></a>原地归并排序</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>对两个有序数组进行归并。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><p>原地归并排序主要是对于有序数组而言，这里只需要额外申请一段数据空间，来进行合并数组即可（迭代法）。</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//迭代法(第一个有序数组为lo~mid，第二个有序数组为mid+1~hi)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = lo;</div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</div><div class="line">        aux[k] = a[k];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; mid)</div><div class="line">            a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)</div><div class="line">            a[k] = aux[i++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))</div><div class="line">            a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            a[k] = aux[i++];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>首先要知道原地归并排序算法，这个是将两个有序的数组归并到一个数组中，然后使用递归算法，每次都对对并一半的数据（直到把数据间隔减少到1为止，从上往下切分）进行归并排序，这样就是递归地调用归并排序。</p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列分成两部分，然后对部分分别进行归并；</li>
<li>再将这部分分成两部分进行归并；</li>
<li>重复步骤2，直到把每部分分成为大小为1的数组。</li>
</ol>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">    sort(a, lo, mid);</div><div class="line">    sort(a, mid + <span class="number">1</span>, hi);</div><div class="line">    merge(a, lo, mid, hi);<span class="comment">// 归并两个有序数组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li>对于长度为N的任意数组，自顶向下的归并排序需要$\frac{N\lg{N}}{2} $至$N\lg{N}$次比较；</li>
<li>对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组$6NlgN$次。</li>
</ol>
<ul>
<li>缺点：其辅助数组所使用的额外空间和N的大小成正比。</li>
</ul>
<h2 id="自低向上"><a href="#自低向上" class="headerlink" title="自低向上"></a>自低向上</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>从最下面的长度为1数组开始往上进行合并，直到最后数组变成两个有序数组，再进行最后依次合并。</p>
<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列每相邻两个数字进行归并操作，形成$ \lfloor\frac{n}{2}\rfloor$个序列，排序后每个序列包含两个元素；</li>
<li>将上述序列再次归并，形成$\lfloor\frac{n}{4}\rfloor$个序列，每个序列包含四个元素；</li>
<li>重复步骤2，直到所有元素排序完毕。</li>
</ol>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz)</div><div class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li>对于长度为N的任意数组，自低向上的归并排序需要$\frac{N\lg{N}}{2}$至$N\lg{N}$次比较，最多需要访问数组$6N\lg{N}$次。</li>
<li>与自顶向下是相同的，只是顺序不同而已。</li>
</ol>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>分治思想，将数组分成两个子数组，独自进行排序。最简单的递归切分：指针i从数组的最左端开始扫描直到找到一个大于等于它的元素，指针j从数组的最右端开始扫描直到找到一个小于等于它的元素，然后交换它们的位置，直到指针相遇。</p>
<p>注意：</p>
<ol>
<li>终止循环：一个常见的错误就是没有考虑到数组中可能包含和切分元素的值相同的其他元素。</li>
</ol>
<h2 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素;</li>
<li>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大;</li>
<li>此时基准元素在其排好序后的正确位置;</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ol>
<h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> l = low;</div><div class="line">    <span class="keyword">int</span> h = high;</div><div class="line">    Comparable key = a[l];</div><div class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</div><div class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(key, a[h]))</div><div class="line">            h--;</div><div class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</div><div class="line">            exch(a, l, h);</div><div class="line">            l++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(a[l], key))</div><div class="line">            l++;</div><div class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</div><div class="line">            exch(a, l, h);</div><div class="line">            h--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (l &gt; low)</div><div class="line">        sort(a, low, l - <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (h &lt; high)</div><div class="line">        sort(a, l + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Quick.java" target="_blank" rel="external">Quick.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E9.81.B8.E6.93.87.E7.9A.84.E9.97.9C.E9.80.A3.E6.80.A7" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Sorting_quicksort_anim.gif" alt="quick_sort"></p>
<h2 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h2><ol>
<li>快速排序的内循环会用一个递增的索引将数组元素和一个定值进行比较，其他的几种排序还需要再内循环中移动元素；</li>
<li>它的比较次数较少；</li>
<li>排序的效率取决于切分的效果，而不是切分元素的值，最好的效果是每次都能将数组对半分，在切分不平衡时，程序就会变得比较低效；</li>
<li>对于长度为N的无重复数组排序，快速排序平均需要～$2N\ln{N}$次比较（以及$\frac{1}{6}$次交换）；</li>
<li>快速排序最多需要约$\frac{n^2}{2}$次比较，随机打乱数组可以预防这种情况（当切分时，每次两个子数组之一为空才会出现这种情况）；</li>
<li>三向切分：主要对于有大量元素相等的情况。</li>
</ol>
<h2 id="快排算法改进"><a href="#快排算法改进" class="headerlink" title="快排算法改进"></a>快排算法改进</h2><ol>
<li>小数组时（$h_i&lt;lo+M$），切换到插入排序。对于小数组，快排比插入排序要慢；</li>
<li>三取样切分。使用子数组的一小部分的中位数来切分数组，这样做得到切分效果更好，但是代价是需要计算中位数；</li>
<li>三向切分，主要是对于有重复元素的情况下，将数组切分为三部分，分别是小于，等于和大于切分元素的数组元素。</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>先构造一个最大堆（最小堆），然后将根节点的最大值（最小值）与最后一位交换，再对第一位进行下沉（上浮）操作，依次类推（下次与倒数第二位进行交换），最后得到的数组即为有序数组。</p>
<p>最大堆的特点：</p>
<ol>
<li>一棵大小为$N$的完全二叉树的高度为不小于的$\lg{N}$最小整数；</li>
<li>当一棵二叉树的每个节点都大于等于它的两个子节点时，被称为<strong>堆有序</strong>；</li>
<li>根节点是最大的节点；</li>
<li>对于节点$i$，左移一位算出$2i$节点（即为左子节点），左移一位并在低位加1得到$2i+1$节点（右子节点），右移一位得到$\lfloor\frac{i}{2}\rfloor$（父节点）。</li>
</ol>
<h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] pq)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> N = pq.length;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</div><div class="line">			sink(pq, k, N);</div><div class="line">		<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">			exch(pq, <span class="number">1</span>, N);</div><div class="line">			N--;</div><div class="line">			sink(pq, <span class="number">1</span>, N);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) &#123;</div><div class="line">				<span class="keyword">if</span> (j &lt; N &amp;&amp; less(pq, j, j + <span class="number">1</span>))</div><div class="line">					j++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (!less(pq, k, j))</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			exch(pq, k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Comparable swap = pq[i - <span class="number">1</span>];</div><div class="line">		pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</div><div class="line">		pq[j - <span class="number">1</span>] = swap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Heap.java" target="_blank" rel="external">Heap.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="/images/2016-03-26-sort/Sorting_heapsort_anim.gif" alt="heap_sort"></p>
<h2 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>构造堆的时间复杂度为$O(n)$；</li>
<li>堆排序的时间复杂度为$O(n\lg{n})$;</li>
</ol>
</li>
<li>特点：<ol>
<li>排序算法使用的是最大堆，最小堆通常用于优先队列（当然也可以反过来）；</li>
<li>将一个数组构造为一个最大堆时，使用递归循环通过下沉（<code>sink</code>方法）将所有有子节点的父节点下沉到给定位置，它的时间复杂度为<code>O(n)</code>；</li>
<li>最大优先队列的一个典型应用就是共享计算机系统中的作业调度。</li>
</ol>
</li>
</ul>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>对于每个输入元素x，确定小于x的元素个数，利用这个信息可以直接把x放在输出数组中的位置上了。</p>
<h2 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h2><p>参考<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">CountingSort</a>，其步骤为：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从$C$中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第$C(i)$项，每放一个元素就将$C(i)$减去1。</li>
</ol>
<h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</div><div class="line">	<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</div><div class="line">	<span class="keyword">int</span> min = a[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> max = a[<span class="number">0</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</div><div class="line">		<span class="keyword">if</span> (i &gt; max)</div><div class="line">			max = i;</div><div class="line">		<span class="keyword">if</span> (i &lt; min)</div><div class="line">			min = i;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> size = max - min + <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">		c[a[i] - min]++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c.length; i++) &#123;</div><div class="line">		c[i] = c[i] + c[i - <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		b[--c[a[i] - min]] = a[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/CountingSort.java" target="_blank" rel="external">CountingSort.java</a></p>
<h2 id="性能分析-7"><a href="#性能分析-7" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>时间复杂度为O(k+n).</li>
</ol>
</li>
<li>特点：<ol>
<li>用运算确定次序，而非比较来确定；</li>
<li><strong>稳定</strong>：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。</li>
</ol>
</li>
</ul>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序直到最高位排序完成以后，数列就变成了一个有序序列。</p>
<h2 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h2><p>对于$n$个$d$位数，每个数位有k个可能的取值（比如十进制数每位有10个可能的取值）。</p>
<ol>
<li>先按最低位对数进行排序（可以是计数排序）；</li>
<li>再次低位进行排序</li>
<li>重复第2步，直到最后一步按照最高位进行排序。</li>
</ol>
<p>从最低位开始排序，保证排序算法的稳定性（如果遇到该位数值相同的话，就按输入顺序）。可以参考<a href="http://baike.baidu.com/view/1170573.htm#1" target="_blank" rel="external">百度百科之基数排序</a>中例子。</p>
<h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">// d最大值多少位</span></div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> m = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span>[][] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</div><div class="line">	<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">	<span class="keyword">while</span> (m &lt;= d) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</div><div class="line">			<span class="keyword">int</span> lsd = (i / n) % <span class="number">10</span>;</div><div class="line">			tmp[lsd][num[lsd]] = i;</div><div class="line">			num[lsd]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (num[i] != <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; j++) &#123;</div><div class="line">					a[index] = tmp[i][j];</div><div class="line">					index++;</div><div class="line">				&#125;</div><div class="line">				num[i] = <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		n *= <span class="number">10</span>;</div><div class="line">		index = <span class="number">0</span>;</div><div class="line">		m++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/RadixSort.java" target="_blank" rel="external">RadixSort.java</a></p>
<h2 id="性能分析-8"><a href="#性能分析-8" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>使用稳定排序方法耗时$O(k+n)$，那么就可以在$O(d*(k+n))$时间内将这些数排好序。</li>
</ol>
</li>
<li>特点：<ol>
<li>基数排序利用的计数排序不是原址排序，而快排是原址排序。</li>
</ol>
</li>
</ul>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>也即是箱排序。</p>
<h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><p>将数组分到有限数量的桶子里。每个桶子再个别排序。</p>
<h2 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>设置一个合适数量的数组作为空桶子；</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子里；</li>
<li>对每个不是空桶子进行排序；</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>排序效果如下图所示（原图来自<a href="http://baike.baidu.com/link?url=0bNJEspxIkXRmUyeUSZPfOG5N2YcfhFT00DXysI-k0IVGq7IkaGxs1ronj3iQasuVTLrEvIY3A_POP3V8eTWma" target="_blank" rel="external">百度百科之桶排序</a>）</p>
<p><img src="/images/2016-03-26-sort/bucketSort.jpg" alt="bucket_sort"></p>
<h2 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> n = a.length;</div><div class="line">	<span class="keyword">int</span> bask[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];</div><div class="line">	<span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">		max = max &gt; (Integer.toString(a[i]).length()) ? max : (Integer.toString(a[i]).length());</div><div class="line">	&#125;</div><div class="line">	String str;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">			str = <span class="string">""</span>;</div><div class="line">			<span class="keyword">if</span> (Integer.toString(a[j]).length() &lt; max) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max - Integer.toString(a[j]).length(); k++)</div><div class="line">					str += <span class="string">"0"</span>;</div><div class="line">			&#125;</div><div class="line">			str += Integer.toString(a[j]);</div><div class="line">			bask[str.charAt(i) - <span class="string">'0'</span>][index[str.charAt(i) - <span class="string">'0'</span>]++] = a[j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index[j]; k++) &#123;</div><div class="line">				a[pos++] = bask[j][k];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</div><div class="line">			index[x] = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/BucketSort.java" target="_blank" rel="external">BucketSort.java</a></p>
<h2 id="性能分析-9"><a href="#性能分析-9" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>平均时间复杂度为 $O(k+n)$；</li>
<li>最差时间复杂度：$O(n^2)$;</li>
<li>最差空间复杂度：$O(k*n)$；</li>
</ol>
</li>
<li>特点：<ol>
<li>感觉相当于先进行hash，然后再进行排序，这种思想在海量数据排序中经常会使用到。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="算法性能总结"><a href="#算法性能总结" class="headerlink" title="算法性能总结"></a>算法性能总结</h1><table>
<thead>
<tr>
<th>算法名称</th>
<th>平均时间复杂度</th>
<th>最坏情况时间复杂度</th>
<th>最好情况时间复杂度</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n\lg{n})$ ~ $O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^{1.3})$</td>
<td>$ O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$ O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自底向上归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$O(n\lg{n}) $</td>
<td>$ O(n) $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$ O(n\lg{n}) $</td>
<td>$O(n)  $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n^2)$</td>
<td>$O(nlgn)$</td>
<td>$O(\lg{n})$ ~ $O(n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}$)</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$ O(n+k) $</td>
<td></td>
<td></td>
<td>$O(n + k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(k*n)$</td>
<td></td>
<td></td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n^2)$</td>
<td></td>
<td></td>
<td>$ O(k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?ie=UTF8&amp;qid=1458988861&amp;sr=8-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法 第四版》</a></li>
<li><a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY/ref=sr_1_3?ie=UTF8&amp;qid=1458988861&amp;sr=8-3&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法导论 第三版》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科之排序</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2016/03/26/algorithm-sort/" data-id="cjgkol27u002v5uagnrwpffps" class="article-share-link">分享到</a><div class="copyright"><a href="http://matt33.com/copyright/">博客版权说明</a></div><div class="tags"><a href="/tags/algorithm/">algorithm</a></div><div class="post-nav"><a href="/2016/03/30/hexo-set/" class="pre">从Jekyll转向Hexo</a><a href="/2016/03/22/java-learn/" class="next">Java工程师成神之路【转】</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2016/03/26/algorithm-sort/';
var disqus_title = '排序算法总结';
var disqus_url = 'http://matt33.com/2016/03/26/algorithm-sort/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/29/kafka-replica-fetcher-thread/">Kafka 源码解析之副本同步机制实现（十四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/kafka-server-handle-fetch-request/">Kafka 源码解析之 Server 端如何处理 Fetch 请求（十三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/kafka-server-handle-produce-request/">Kafka 源码解析之 Server 端如何处理 Produce 请求（十二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/kafka-log-manager/">Kafka 源码解析之日志管理（十一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/04/linux-mmap/">操作系统之共享对象学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/server-group-coordinator/">Kafka 源码解析之 GroupCoordinator 详解（十）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/consumer-two-summary/">Kafka 源码解析之 Consumer 两种 commit 机制和 partition 分配机制（九）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/18/consumer-subscribe/">Kafka 源码解析之 Consumer 两种订阅模式（八）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/consumer-pollonce/">Kafka 源码解析之 Consumer Poll 模型（七）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/consumer-join-group/">Kafka 源码解析之 Consumer 如何加入一个 Group（六）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>