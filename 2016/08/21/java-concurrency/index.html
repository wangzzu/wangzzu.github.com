<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="本文主要是根据华黎的《大型网站系统与Java中间件实践》和 Jason 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。
多线程编程对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。
三个核心概念原子性与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发学习">
<meta property="og:url" content="http://wangzzu.github.io/2016/08/21/java-concurrency/index.html">
<meta property="og:site_name" content="Matt's Blog">
<meta property="og:description" content="本文主要是根据华黎的《大型网站系统与Java中间件实践》和 Jason 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。
多线程编程对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。
三个核心概念原子性与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）">
<meta property="og:updated_time" content="2016-08-21T09:19:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 并发学习">
<meta name="twitter:description" content="本文主要是根据华黎的《大型网站系统与Java中间件实践》和 Jason 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。
多线程编程对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。
三个核心概念原子性与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Java 并发学习 | Matt's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=55364149";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1256517224&web_id=1256517224" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Matt's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">wangzzu</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-book fa-fw"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java 并发学习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-21T16:49:56+08:00" content="2016-08-21">
              2016-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/21/java-concurrency/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/21/java-concurrency/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          
	  
              <span>&nbsp; | &nbsp;
                   <span id="busuanzi_value_page_pv" ></span>次阅读
              </span>    
          

          

          
          
             <span id="/2016/08/21/java-concurrency/" class="leancloud_visitors" data-flag-title="Java 并发学习">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文主要是根据华黎的《大型网站系统与Java中间件实践》和 <a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason</a> 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。</p>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。</p>
<h2 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）要么全部执行，要么全部都不执行。</p>
<p>关于原子性，最经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作技术——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p>
<h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</p>
<p>以下面这段代码为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>; <span class="comment">// 语句1</span></span><br><span class="line"><span class="keyword">long</span> counter = <span class="number">0L</span>; <span class="comment">// 语句2</span></span><br><span class="line">counter = <span class="number">1</span>; <span class="comment">// 语句3</span></span><br><span class="line">started = <span class="keyword">true</span>; <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure>
<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p>
<h2 id="Java如何解决多线程并发问题"><a href="#Java如何解决多线程并发问题" class="headerlink" title="Java如何解决多线程并发问题"></a>Java如何解决多线程并发问题</h2><p>上面已经提出了这三个核心的概念，在 Java 多线程中，我们会经常遇到这三个概念引发的多线程并发问题，下面讲述一下 Java 如果解决这些问题。</p>
<h3 id="Java如何保证原子性"><a href="#Java如何保证原子性" class="headerlink" title="Java如何保证原子性"></a>Java如何保证原子性</h3><h4 id="锁和同步"><a href="#锁和同步" class="headerlink" title="锁和同步"></a>锁和同步</h4><p>常用的保证Java操作原子性的工具是<strong>锁</strong>和<strong>同步方法</strong>（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    i = j + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (anyObject)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    i = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。（这一部分会后面详细讲述）</p>
<h4 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h4><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。<code>AtomicInteger</code>使用方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; numThreads; b++) &#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; iteration; a++) &#123;</span><br><span class="line">      atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java如何保证可见性"><a href="#Java如何保证可见性" class="headerlink" title="Java如何保证可见性"></a>Java如何保证可见性</h3><p>Java提供了<code>volatile</code>关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<h3 id="Java如何保证顺序性"><a href="#Java如何保证顺序性" class="headerlink" title="Java如何保证顺序性"></a>Java如何保证顺序性</h3><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<p>Java中可通过<code>volatile</code>在一定程序上保证顺序性，另外还可以通过<code>synchronized</code>和锁来保证顺序性。</p>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为<strong>happens-before原则</strong>隐式的保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<h3 id="happens-before原则（先行发生原则）"><a href="#happens-before原则（先行发生原则）" class="headerlink" title="happens-before原则（先行发生原则）"></a>happens-before原则（先行发生原则）</h3><ul>
<li>传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性</li>
<li>锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li>
<li>volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作</li>
<li>程序次序规则：一个线程内，按照代码顺序执行</li>
<li>线程启动规则：Thread对象的start()方法先发生于此线程的其它动作</li>
<li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li>
<li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取</li>
<li>对象终结规则：一个对象构造先于它的finalize发生</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>多核时代，面向多核编程就非常重要了，基于 java 的并发和多线程开发非常重要。与其每次需要时都创建线程相比，线程池可以降低创建线程的开销，线程池在线程执行结束后进行的是回收操作，而不是真正的销毁线程。</p>
<p>线程池的好处：</p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行；</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by matt on 16/8/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPoolTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(count));</span><br><span class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    list.add(random.nextInt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadPoolExecutor.awaitTermination(<span class="number">1</span>,TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ThreadPool demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    list.add(random.nextInt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Thread demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">10000</span>;</span><br><span class="line">        threadPoolTest(count);</span><br><span class="line">        threadTest(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 66</span><br><span class="line">10000</span><br><span class="line">Thread demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 1333</span><br><span class="line">10000</span><br></pre></td></tr></table></figure>
<p>从例子中，可以直接地看到，使用线程池能极大地提高程序的运行速度。</p>
<p>两种方式差别在于，使用线程池的方式是复用线程的，而不使用线程池的方式是每次都要创建线程的。不使用线程时消耗时间过多，主要是由于创建线程的开销占整个时间的比例比较大。还有另外两种线程池：</p>
<ul>
<li>newFixedThreadPool创建一个指定工作线程数量的线程池（固定数量的线程 ）。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li>
<li>newCachedThreadPool创建一个可缓存的线程池（线程数量根据任务数量动态变化 ）。这种类型的线程池特点是：<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>该方法返回的线程池是没有线程上限的，因为没有办法去控制总体的线程数量，而每个线程都是消耗内存的，这可能会导致过多的内存被占用。</li>
</ul>
</li>
<li>newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</li>
<li>newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</li>
</ul>
<p>关于线程池内部原理部门可以看一下这两篇文章，未来也会把主要内容总结到博客里面</p>
<ul>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19243889" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（1）</a></li>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19283171" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（2）</a></li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>每个Java对象都可以用做一个实现同步的互斥锁，这些锁被称为内置锁。线程进入同步代码块或方法时自动获得内置锁，退出同步代码块或方法时自动释放该内置锁。进入同步代码块或者同步方法是获得内置锁的唯一途径。</p>
<h2 id="实例同步方法"><a href="#实例同步方法" class="headerlink" title="实例同步方法"></a>实例同步方法</h2><p>synchronized用于修饰实例方法（非静态方法）时，执行该方法需要获得的是该类实例对象的内置锁（同一个类的不同实例拥有不同的内置锁）。如果多个实例方法都被synchronized修饰，则当多个线程调用同一实例的不同同步方法（或者同一方法）时，需要竞争锁。但当调用的是不同实例的方法时，并不需要竞争锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>foo1()</code> 和 <code>foo2()</code>是 <code>SynchronizedDemo1</code> 的两个成员方法，在多线程编程中，调用同一个对象的 <code>foo1()</code> 或者 <code>foo2()</code>是互斥的，这是针对同一个对象的多线程方法调用互斥。</p>
<h2 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h2><p>synchronized用于修饰静态方法时，执行该方法需要获得的是该类的class对象的内置锁（一个类只有唯一一个class对象）。调用同一个类的不同静态同步方法时会产生锁竞争。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>foo3()</code> 和 <code>foo4()</code>是 <code>SynchronizedDemo2</code> 类的两个静态方法。在不同的线程中，这两个方法的调用是互斥的，不仅它们之间，任何两个不同线程之间的调用也是互斥的。</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>synchronized用于修饰代码块时，进入同步代码块需要获得synchronized关键字后面括号内的对象（可以是实例对象也可以是class对象）的内置锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo6</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(SynchronizedDemo3.class)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>synchronized(this)</code>与<code>SynchronizedDemo3</code>中加<code>synchronized</code>的成员方法是互斥的，而<code>synchronized(SynchronizedDemo3.class)</code>与<code>SynchronizedDemo3</code>加<code>synchronized</code>的静态方法是互斥的。</p>
<p><code>synchronized</code>用于修饰代码块会更加灵活，因为其后的参数可以是任意对象。</p>
<h2 id="synchronized使用总结"><a href="#synchronized使用总结" class="headerlink" title="synchronized使用总结"></a>synchronized使用总结</h2><p>锁的使用是为了操作临界资源的正确性，而往往一个方法中并非所有的代码都操作临界资源。换句话说，方法中的代码往往并不都需要同步。此时建议不使用同步方法，而使用同步代码块，只对操作临界资源的代码，也即需要同步的代码加锁。这样做的好处是，当一个线程在执行同步代码块时，其它线程仍然可以执行该方法内同步代码块以外的部分，充分发挥多线程并发的优势，从而相较于同步整个方法而言提升性能。</p>
<p>释放Java内置锁的唯一方式是synchronized方法或者代码块执行结束。若某一线程在synchronized方法或代码块内发生死锁，则对应的内置锁无法释放，其它线程也无法获取该内置锁（即进入跟该内置锁相关的synchronized方法或者代码块）。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock是<code>java.util.concurrent.locks</code>中的一个类，是从 JDK5开始加入的，与 synchronized 用法类似，不过它需要显式地进行 unlock。Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。使用synchronized的地方一定可以用ReentrantLock代替。</p>
<p>重入锁需要显示请求获取锁，并显示释放锁。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，一般建议将释放锁操作放在finally块里，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  renentrantLock.lock();</span><br><span class="line">  <span class="comment">// 用户操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  renentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）还提供了其它获取锁的方法以实现不同的效果。</p>
<ol>
<li><code>lockInterruptibly()</code>：该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。与lock方法不同的是，在阻塞期间，如果当前线程被打断（interrupt）则该方法抛出<code>InterruptedException</code>。该方法提供了一种解除死锁的途径。</li>
<li><code>tryLock()</code>：该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。</li>
<li><code>tryLock(long time, TimeUnit unit)</code>：该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：1）若该时间内锁可用，则获得锁，并返回true；2）若等待期间当前线程被打断，则抛出InterruptedException；3）若等待时间结束仍未获得锁，则返回false。</li>
</ol>
<p>重入锁可定义为公平锁或非公平锁，默认实现为非公平锁。</p>
<ol>
<li>公平锁是指多个线程获取锁被阻塞的情况下，锁变为可用时，最新申请锁的线程获得锁。可通过在重入锁（RenentrantLock）的构造方法中传入true构建公平锁，如<code>Lock lock = new RenentrantLock(true)</code>；</li>
<li>非公平锁是指多个线程等待锁的情况下，锁变为可用状态时，哪个线程获得锁是随机的。synchonized相当于非公平锁。可通过在重入锁的构造方法中传入false或者使用无参构造方法构建非公平锁。效率相对高一点。</li>
</ol>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><p>这个主要用于读多写少并且读不需要互斥的场景，这样场景使用读写锁会比使用全部互斥的锁性能高出很多，<code>ReentrantReadWriteLock</code>通过<code>readLock()</code>和<code>writeLock()</code>两个方法获取读锁和写锁。</p>
<p>实际上，<code>ReadWriteLock</code>接口并非继承自Lock接口，<code>ReentrantReadWriteLock</code>也只实现了<code>ReadWriteLock</code>接口而未实现Lock接口。<code>ReadLock()</code>和<code>WriteLock()</code>，是<code>ReentrantReadWriteLock</code>类的静态内部类，它们实现了Lock接口。</p>
<p>一个<code>ReentrantReadWriteLock</code>实例包含一个<code>ReentrantReadWriteLock.ReadLock</code>实例和一个<code>ReentrantReadWriteLock.WriteLock</code>实例。通过<code>readLock()</code>和<code>writeLock()</code>方法可分别获得读锁实例和写锁实例，并通过Lock接口提供的获取锁方法获得对应的锁。</p>
<p>读写锁的锁定规则如下：</p>
<ul>
<li>获得读锁后，其它线程可获得读锁而不能获取写锁</li>
<li>获得写锁后，其它线程既不能获得读锁也不能获得写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      readWriteLock.readLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 started with read lock"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 ended"</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      readWriteLock.readLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 started with read lock"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 ended"</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      Lock lock = readWriteLock.writeLock();</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 started with write lock"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 ended"</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sat Jun 18 21:33:46 CST 2016  Thread 1 started with <span class="built_in">read</span> lock</span><br><span class="line">Sat Jun 18 21:33:46 CST 2016  Thread 2 started with <span class="built_in">read</span> lock</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 2 ended</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 1 ended</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 3 started with write lock</span><br><span class="line">Sat Jun 18 21:33:50 CST 2016  Thread 3 ended</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果可见，thread 1和thread 2都只需获得读锁，因此它们可以并行执行。而thread 3因为需要获取写锁，必须等到thread 1和thread 2释放锁后才能获得锁。</p>
<h1 id="volatitle"><a href="#volatitle" class="headerlink" title="volatitle"></a>volatitle</h1><p><code>synchronized</code>保证了一个线程中变量的可见性，而<code>volatile</code>则是保证了所修饰变量的可见性（可见性可以参考前面所述）。<code>volatile</code>是轻量级的实现变量可见性的方法，其具体使用也很简单。</p>
<p>对于同一个变量线程间的可见性与多个线程中操作互斥是两件事情，操作互斥是提供了操作整体的原子性，下面通过一个例子来看。</p>
<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>对于读操作来说，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getI3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>getI1()</code>：该方法调用获取的是当前线程中的副本，这个值不一定是最新的值；</li>
<li><code>getI2()</code>：因为 i2 是被<code>volatile</code>修饰，因此对于 JVM 来说，这个变量不会又线程的本地副本，只会放在主存中，所以得到的值一定是最新的；</li>
<li><code>getI3()</code>：因为有<code>synchronized</code>关键字修饰，保证了线程的本地副本与主存的同步，所以也会得到最新的值。</li>
</ol>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>再对比一下它们的写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i1 = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i2 = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setI3</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>setI1()</code>：当前线程调用之后会得到最新的 i1 值，而另外的线程获取不一定可以立刻看到最新而值；</li>
<li><code>setI2()</code>：可以立刻在其他线程看到新的值，因为<code>volatile</code>保证了只有一份主存中的数据；</li>
<li><code>setI3()</code>：调用后必须在<code>synchronized</code>修饰的方法或代码中读取 i3 的值才可以看到最新值，因为<code>synchronized</code>不仅会把当前线程修改的本地副本同步给主存，还会从主存读取数据更新本地副本。</li>
</ol>
<h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>因为<code>volatile</code>只是保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量。</p>
<p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(isRunning) &#123;</span><br><span class="line">      someOperation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  isRunning = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用<code>stop()</code>方法将<code>isRunning</code>设置为<code>false</code>，循环也不一定会立即结束。可以通过<code>volatile</code>关键字，保证<code>while</code>循环及时得到<code>isRunning</code>最新的状态从而及时停止循环，结束线程。</p>
<h1 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h1><p>在 JDK5 中增加了<code>java.util.concurrent.atomic</code>包，这个包是一些以<code>Atomic</code>开头的类，这些类主要提供一些相关的原子操作。</p>
<p>以<code>AtomicInteger</code>为例来看一个多线程计数器的场景，场景很简单，就是让多个线程都对计数器进行加1操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            counter = counter + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            counter = counter - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在采用了<code>AtomicInteger</code>之后，代码就会变成下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用<code>AtomicInteger</code>之后代码变得简洁了，更重要的是性能得到了提升，而且还比较明显的提升，原因是<code>AtomicInteger</code>内部通过 JNI 的方式使用了硬件支持的 CAS 指令。</p>
<h1 id="wait、notify-和-notifyAll"><a href="#wait、notify-和-notifyAll" class="headerlink" title="wait、notify 和 notifyAll"></a>wait、notify 和 notifyAll</h1><p>wait、notify 和 notifyAll 是 java Object 对象上的三个方法，也就是所有的Java类都可以调用这三个方法。</p>
<p>在多线程情况下，可以把某个对象作为事件对象，通过这个对象的 wait、notify 和 notifyAll方法来完成线程间的状态通知，三个方法的作用如下：</p>
<ul>
<li>wait：是当前线程进行等待；</li>
<li>notify：是唤醒同一个对象 wait 方法的线程，但是只是唤醒一个等待线程；</li>
<li>notifyAll：是唤醒同一个对象 wait 方法的线程，唤醒所有的等待线程。</li>
</ul>
<p>注意：</p>
<p>wait方法需要释放锁，前提条件是它已经持有锁。所以wait和notify（或者<code>notifyAll</code>）方法都必须被包裹在<code>synchronized</code>语句块中，并且<code>synchronized</code>后锁的对象应该与调用<code>wait</code>方法的对象一样。否则抛出<code>IllegalMonitorStateException</code>.</p>
<p>wait 与 sleep 的区别</p>
<ul>
<li>wait：它是在当前线程持有 wait 对象锁的情况下，暂时放弃锁，并让出 CPU 资源，并积极等待其它线程调用同一对象的 notify 或者 notifyAll 方法。换言之，即使notify被调用，但只要锁没有被释放，原等待线程因为未获得锁仍然无法继续执行。</li>
<li>sleep：它告诉操作系统至少指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>是<code>java.util.concurrent</code>包中的一个类，<code>CountDownLatch</code>主要提供的机制是当多个线程达到了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己后续的工作。需要注意的是，等待线程可以是多个，即 CountDownLatch 是可以唤醒多个等待的线程的。达到自己预期状态的线程会调用<code>CountDownLatch</code>的<code>countDown</code>方法，而等待线程会调用<code>CountDownLatch</code>的<code>wait</code>方法。</p>
<p>如果<code>CountDownLatch</code>初始化的 count 值为1，那么这就变成了单一事件了，即由一个线程来通知其他线程，效果等同于对象的<code>wait</code>和<code>notifyAll</code>。count 值大于1是常用的方式，目的是让多个线程达到各自的预期状态，变为一个事件进行通知，线程则继续自己的行为。</p>
<h3 id="CountDownLatch适用场景"><a href="#CountDownLatch适用场景" class="headerlink" title="CountDownLatch适用场景"></a>CountDownLatch适用场景</h3><p>Java多线程编程中经常会碰到这样一种场景——某个线程需要等待一个或多个线程操作结束（或达到某种状态）才开始执行。比如开发一个并发测试工具时，主线程需要等到所有测试线程均执行完成再开始统计总共耗费的时间，此时可以通过<code>CountDownLatch</code>轻松实现。</p>
<h3 id="CountDownLatch实例"><a href="#CountDownLatch实例" class="headerlink" title="CountDownLatch实例"></a>CountDownLatch实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> countdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalThread = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"started"</span>));</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        countDown.countDown();</span><br><span class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDown.await();</span><br><span class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"Total time : %sms"</span>, (stop - start)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tue Aug 09 14:44:19 CST 2016	Thread 0 started</span><br><span class="line">Tue Aug 09 14:44:19 CST 2016	Thread 2 started</span><br><span class="line">Tue Aug 09 14:44:19 CST 2016	Thread 1 started</span><br><span class="line">Tue Aug 09 14:44:20 CST 2016	Thread 2 ended</span><br><span class="line">Tue Aug 09 14:44:20 CST 2016	Thread 1 ended</span><br><span class="line">Tue Aug 09 14:44:20 CST 2016	Thread 0 ended</span><br><span class="line">Total time : 1029ms</span><br></pre></td></tr></table></figure>
<p>可以看到，主线程等待所有3个线程都执行结束后才开始执行。</p>
<h3 id="CountDownLatch主要接口分析"><a href="#CountDownLatch主要接口分析" class="headerlink" title="CountDownLatch主要接口分析"></a>CountDownLatch主要接口分析</h3><p>CountDownLatch工作原理相对简单，可以简单看成一个倒计时器，在构造方法中指定初始值，每次调用countDown()方法时讲计数器减1，而await()会等待计数器变为0。CountDownLatch关键接口如下</p>
<ul>
<li>countDown() 如果当前计数器的值大于1，则将其减1；若当前值为1，则将其置为0并唤醒所有通过await等待的线程；若当前值为0，则什么也不做直接返回。</li>
<li>await() 等待计数器的值为0，若计数器的值为0则该方法返回；若等待期间该线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为0，若在指定时间内计数器的值变为0，则该方法返回true；若指定时间内计数器的值仍未变为0，则返回false；若指定时间内计数器的值变为0之前当前线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>getCount() 读取当前计数器的值，一般用于调试或者测试。</li>
</ul>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="CyclicBarrier适用场景"><a href="#CyclicBarrier适用场景" class="headerlink" title="CyclicBarrier适用场景"></a>CyclicBarrier适用场景</h3><p>CyclicBarrier，从字面理解是指循环屏障，CyclicBarrier可以在构造时指定需要在屏障前执行await的个数，所有对await的调用都会等待，只到调用await的次数达到预定指，所有等待都会立即被唤醒。</p>
<p>从使用场景上来说，CyclicBarrier是让多个线程互相等待某一事件的发生，然后同时被唤醒。而上文讲的CountDownLatch是让某一线程等待多个线程的状态，然后该线程被唤醒。</p>
<h3 id="CyclicBarrier实例"><a href="#CyclicBarrier实例" class="headerlink" title="CyclicBarrier实例"></a>CyclicBarrier实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cyclicbarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">" is waiting"</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4  is waiting</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0  is waiting</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3  is waiting</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2  is waiting</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1  is waiting</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4 ended</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1 ended</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2 ended</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0 ended</span><br><span class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3 ended</span><br></pre></td></tr></table></figure></p>
<p>从执行结果可以看到，每个线程都不会在其它所有线程执行<code>await()</code>方法前继续执行，而等所有线程都执行<code>await()</code>方法后所有线程的等待都被唤醒从而继续执行。</p>
<h3 id="CyclicBarrier主要接口分析"><a href="#CyclicBarrier主要接口分析" class="headerlink" title="CyclicBarrier主要接口分析"></a>CyclicBarrier主要接口分析</h3><p>CyclicBarrier提供的关键方法如下</p>
<ul>
<li>await()：等待其它参与方的到来（调用await()）。如果当前调用是最后一个调用，则唤醒所有其它的线程的等待并且如果在构造CyclicBarrier时指定了action，当前线程会去执行该action，然后该方法返回该线程调用await的次序（getParties()-1说明该线程是第一个调用await的，0说明该线程是最后一个执行await的），接着该线程继续执行await后的代码；如果该调用不是最后一个调用，则阻塞等待；如果等待过程中，当前线程被中断，则抛出InterruptedException；如果等待过程中，其它等待的线程被中断，或者其它线程等待超时，或者该barrier被reset，或者当前线程在执行barrier构造时注册的action时因为抛出异常而失败，则抛出BrokenBarrierException。</li>
<li>await(long timeout, TimeUnit unit)：与await()唯一的不同点在于设置了等待超时时间，等待超时时会抛出TimeoutException。</li>
<li>reset()：该方法会将该barrier重置为它的初始状态，并使得所有对该barrier的await调用抛出BrokenBarrierException。</li>
</ul>
<h3 id="CountDownLatch-与-CyclicBarrier"><a href="#CountDownLatch-与-CyclicBarrier" class="headerlink" title="CountDownLatch 与 CyclicBarrier"></a>CountDownLatch 与 CyclicBarrier</h3><p><code>CountDownLatch</code> 与 <code>CyclicBarrier</code> 都是用于多个线程间的协调，二者的一个差别是：</p>
<ol>
<li><code>CountDownLatch</code>：它是在多个线程都进行了<code>latch.countDown</code>后才会触发事件，唤醒<code>await</code>在 latch 上的线程，而执行<code>countDown</code>的线程，执行完<code>countDown</code>后继续进行自己的工作，也就是说，<code>countDown</code>的线程会继续执行，而唤醒的是<code>await</code>的线程；</li>
<li><code>CyclicBarrier</code>：它是一个栅栏，用于同步所有调用<code>await</code>方法的线程，并且等待所有线程都到了<code>await</code>方法时，这些线程才一起返回继续各自的工作，因为使用<code>CyclicBarrier</code>的线程都会阻塞在<code>await</code>方法上，所以在线程池中使用<code>CyclicBarrier</code>时要特别小心，如果线程池的线程数过少，那么很容易发生死锁。</li>
</ol>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="Phaser适用场景"><a href="#Phaser适用场景" class="headerlink" title="Phaser适用场景"></a>Phaser适用场景</h3><p><code>CountDownLatch</code>和<code>CyclicBarrier</code>都是JDK 1.5引入的，而<code>Phaser</code>是JDK 1.7引入的。<code>Phaser</code>的功能与<code>CountDownLatch</code>和<code>CyclicBarrier</code>有部分重叠，同时也提供了更丰富的语义和更灵活的用法。</p>
<p><code>Phaser</code>顾名思义，与<strong>阶段</strong>相关。<code>Phaser</code>比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。</p>
<h3 id="Phaser实例"><a href="#Phaser实例" class="headerlink" title="Phaser实例"></a>Phaser实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> phaser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parties = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> phases = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(parties) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"====== Phase : "</span> + phase + <span class="string">" ======"</span>);</span><br><span class="line">                <span class="keyword">return</span> registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i;</span><br><span class="line">            <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"Thread %s, phase %s"</span>, threadId, phase));</span><br><span class="line">                        phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread 1, phase 0</span><br><span class="line">Thread 2, phase 0</span><br><span class="line">Thread 0, phase 0</span><br><span class="line">====== Phase : 0 ======</span><br><span class="line">Thread 0, phase 1</span><br><span class="line">Thread 2, phase 1</span><br><span class="line">Thread 1, phase 1</span><br><span class="line">====== Phase : 1 ======</span><br><span class="line">Thread 1, phase 2</span><br><span class="line">Thread 2, phase 2</span><br><span class="line">Thread 0, phase 2</span><br><span class="line">====== Phase : 2 ======</span><br><span class="line">Thread 1, phase 3</span><br><span class="line">Thread 2, phase 3</span><br><span class="line">Thread 0, phase 3</span><br><span class="line">====== Phase : 3 ======</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，多个线程必须等到其它线程的同一阶段的任务全部完成才能进行到下一个阶段，并且每当完成某一阶段任务时，Phaser都会执行其onAdvance方法。</p>
<h3 id="Phaser主要接口分析"><a href="#Phaser主要接口分析" class="headerlink" title="Phaser主要接口分析"></a>Phaser主要接口分析</h3><p>Phaser主要接口如下</p>
<ul>
<li>arriveAndAwaitAdvance()：当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从0开始），同时其它线程的该方法也返回下一个阶段的序号。</li>
<li>arriveAndDeregister()：该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser会在后文中讲到），并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。</li>
<li>arrive()：该方法不作任何等待，直接返回下一阶段的序号。</li>
<li>awaitAdvance(int phase)：该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。该阶段数一般由arrive()方法或者arriveAndDeregister()方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前Phaser已经被终止）。</li>
<li>awaitAdvanceInterruptibly(int phase)：效果与awaitAdvance(int phase)相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出InterruptedException。</li>
<li>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)：效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException。</li>
<li>bulkRegister(int parties)：注册多个party。如果当前phaser已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该Phaser会被注册到其父Phaser中。</li>
<li>forceTermination()：强制让该Phaser进入终止状态。已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。</li>
</ul>
<h1 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h1><p>信号量维护一个许可集，构造时需要传入参数，总数就是控制并发的数量，在执行可通过<code>acquire()</code>获取许可（如果acquire 成功返回，Semaphore 可用的信号量就会减少一个，若无可用许可acquire 就会阻塞，等待有 release 释放信号后，acquire 才会得到信号并返回），通过<code>release()</code>释放许可，从而可能唤醒一个阻塞等待许可的线程。</p>
<p>与互斥锁类似，信号量限制了同一时间访问临界资源的线程的个数，并且信号量也分<strong>公平信号量</strong>与<strong>非公平信号量</strong>。而不同的是，互斥锁保证同一时间只会有一个线程访问临界资源，而信号量可以允许同一时间多个线程访问特定资源。所以信号量并不能保证原子性。</p>
<p>信号量的一个典型使用场景是限制系统访问量。每个请求进来后，处理之前都通过<code>acquire</code>获取许可，若获取许可成功则处理该请求，若获取失败则等待处理或者直接不处理该请求。</p>
<h2 id="信号量的使用方法"><a href="#信号量的使用方法" class="headerlink" title="信号量的使用方法"></a>信号量的使用方法</h2><ul>
<li>acquire(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前可用许可数少于permits指定的个数，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，则抛出InterruptedException；</li>
<li>acquire()：等价于acquire(1)；</li>
<li>acquireUninterruptibly(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前许可数少于permits，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，继续等待可用许可数大于等于permits，并且获取成功后设置线程中断状态；</li>
<li>acquireUninterruptibly()：等价于acquireUninterruptibly(1)；</li>
<li>drainPermits()：获取所有可用许可，并返回获取到的许可个数，该方法不阻塞；</li>
<li>tryAcquire(int permits)：尝试获取permits个可用许可，如果当前许可个数大于等于permits，则返回true并且可用许可数减permits；否则返回false并且可用许可数不变；</li>
<li>tryAcquire()：等价于tryAcquire(1)；</li>
<li>tryAcquire(int permits, long timeout, TimeUnit unit)：尝试获取permits（必须为非负数）个许可，若在指定时间内获取成功则返回true并且可用许可数减permits；若指定时间内当前线程被中断，则抛出InterruptedException；若指定时间内可用许可数均小于permits，则返回false；</li>
<li>tryAcquire(long timeout, TimeUnit unit)：等价于tryAcquire(1, long timeout, TimeUnit unit)；</li>
<li>release(int permits)：释放permits个许可，该方法不阻塞并且某线程调用release方法前并不需要先调用acquire方法；</li>
<li>release()：等价于release(1)。</li>
</ul>
<blockquote>
<p>注意：与<code>wait/notify</code>和<code>await/signal</code>不同，<code>acquire/release</code>完全与锁无关，因此<code>acquire</code>等待过程中，可用许可满足要求时<code>acquire</code>可立即返回，而不用像锁的<code>wait</code>和条件变量的<code>await</code>那样重新获取锁才能返回。或者可以理解成，只要可用许可满足需求，就已经获得了锁。</p>
</blockquote>
<p>如果<code>Semaphore</code>管理的信号量只有1个，那么就是互斥锁了；如果多于1个信号量，则主要用于控制并发数。</p>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p><code>Exchanger</code>从名字上来看，就是交换的意思，<code>Exchanger</code>用于在两个线程之间进行数据交换，线程会阻塞在Exchanger的<code>exchange</code>方法上，直到另外一个线程也到了同一个Exchanger的<code>exchange</code>方法时，二者进行交换，然后两个线程会继续执行自身相关的代码。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">                list.add(<span class="number">1</span>);</span><br><span class="line">                list.add(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list = exchanger.exchange(list);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"Thread1"</span> + list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</span><br><span class="line">                list.add(<span class="number">4</span>);</span><br><span class="line">                list.add(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list=exchanger.exchange(list);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"Thread2"</span> + list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread2[1, 2]</span><br><span class="line">Thread1[4, 5]</span><br></pre></td></tr></table></figure>
<h1 id="Future-和-Future-Task"><a href="#Future-和-Future-Task" class="headerlink" title="Future 和 Future Task"></a>Future 和 Future Task</h1><p><code>Future</code>是一个接口，<code>Future Task</code>是一个具体实现类。</p>
<p>在实际开发的环境中，我们经常会遇到这样一种场景中，在一个函数中我们调用了一个函数，正常情况下，程序会在理阻塞，知道调用函数返回结果，而很多情况下返回的结果我们并不会马上使用，这样的话就浪费很多时间。我们期待的情况是：调用函数后马上返回，然后继续向下执行，等需要用数据时再来用，或者说再来等待这个数据，具体的实现方式有两种方式，一个是用<code>Future</code>，一个是用回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;HashMap&gt; future = getDataFromRemote2();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">HashMap data = (HashMap) future.get();</span><br></pre></td></tr></table></figure>
<p>可以看到，我们调用的方式返回的是一个 Future 对象，然后接着进行自己的处理，后面通过<code>future.get()</code>来获得真正的返回值。也就说，在调用了<code>getDataFromRemote2</code>后，就已经启动了对远程计算结果的获取，同时自己的线程还在继续处理，直到需要时再获取数据。我们先看一下<code>getDataFromRemote2</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Future&lt;HashMap&gt; <span class="title">getDataFromRemote2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> threadPool.submit(<span class="keyword">new</span> Callback&lt;HashMap&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> HashMap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			returngetDataFromRemote();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getDataFromRemote()</code>方法是从远程获取一些计算结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashMap <span class="title">getDataFromRemote</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>getDataFromRemote2</code>中使用了<code>getDataFromRemote</code>来完成具体操作，并且使用到了线程池，把任务添加到线程池中，把 Future 对象返回出去。我们调用了<code>getDataFromRemote2</code>的线程，然后回来继续下面的执行，而背后是另外的线程在进行远程调用及等待的工作。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>参考<a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a>。调用回调函数的函数这里称作中间函数，而调用中间函数的函数我们成为起始函数。回调函数是作为函数的参数传入到中间函数中，中间函数在运行时，在需要调用这个函数的地方就调用回调函数，并将结果返回给中间函数，中间函数再把处理后的结果返回给起始函数。</p>
<p>回调实际上有两种：阻塞式回调和延迟式回调。</p>
<ul>
<li>阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；</li>
<li>延迟式回调里，回调函数的调用有可能是在起始函数返回之后。</li>
</ul>
<p>一般使用的回调函数都是阻塞式回调，而延迟式回调通常牵扯到多线程。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11449803.html" target="_blank" rel="external">大型网站系统与 Java 中间件实践</a></li>
<li><a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason的博客：java 并发部分</a></li>
<li><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a></li>
</ul>

      
    </div>

    <div>
      
        
<div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton", disable="enable", onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}", style="cursor: pointer; border: 0; outline: 0; border-radius: 100%; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0px; text-shadow: none">
    <span onmouseover="this.style.color='rgb(236,96,0)';this.style.background='rgb(204,204,204)'" onMouseOut="this.style.color='#fff';this.style.background='rgb(236,96,0)'" style="display: inline-block; width: 70px; height: 70px; border-radius: 100%; line-height: 81px; color: #fff; font: 400 35px/75px 'microsofty'; background: rgb(236,96,0)">赏</span>
  </button>
  <div id="QR" style="display: none;">
    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/pay/weixinpay.jpg" alt="Matt WeChat Pay" style="width: 200px; max-width: 100%; display: inline-block"/>
        <p>微信打赏</p>
      </div>
    
    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/pay/alipay.jpg" alt="Matt Alipay" style="width: 200px; max-width: 100%; display: inline-block"/>
        <p>支付宝打赏</p>
      </div>
    
  </div>
<div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/29/sasl-plain-kafka/" rel="next" title="Kafka 0.10.0 SASL/PLAIN身份认证及权限实现">
                <i class="fa fa-chevron-left"></i> Kafka 0.10.0 SASL/PLAIN身份认证及权限实现
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/08/21/java-concurrency/"
     data-title="Java 并发学习"
     data-content=""
     data-url="http://wangzzu.github.io/2016/08/21/java-concurrency/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/21/java-concurrency/"
           data-title="Java 并发学习" data-url="http://wangzzu.github.io/2016/08/21/java-concurrency/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/face.png"
               alt="Matt" />
          <p class="site-author-name" itemprop="name">Matt</p>
          <p class="site-description motion-element" itemprop="description">与一群有趣的人，做一些有趣的事.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangzzu" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wangzzu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wangzzu" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程编程"><span class="nav-number">1.</span> <span class="nav-text">多线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三个核心概念"><span class="nav-number">1.1.</span> <span class="nav-text">三个核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">1.1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性"><span class="nav-number">1.1.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序性"><span class="nav-number">1.1.3.</span> <span class="nav-text">顺序性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java如何解决多线程并发问题"><span class="nav-number">1.2.</span> <span class="nav-text">Java如何解决多线程并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java如何保证原子性"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java如何保证原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锁和同步"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">锁和同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS（compare-and-swap）"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">CAS（compare and swap）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java如何保证可见性"><span class="nav-number">1.2.2.</span> <span class="nav-text">Java如何保证可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java如何保证顺序性"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java如何保证顺序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before原则（先行发生原则）"><span class="nav-number">1.2.4.</span> <span class="nav-text">happens-before原则（先行发生原则）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程池"><span class="nav-number">2.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized"><span class="nav-number">3.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实例同步方法"><span class="nav-number">3.1.</span> <span class="nav-text">实例同步方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态同步方法"><span class="nav-number">3.2.</span> <span class="nav-text">静态同步方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步代码块"><span class="nav-number">3.3.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized使用总结"><span class="nav-number">3.4.</span> <span class="nav-text">synchronized使用总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">4.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock-读写锁"><span class="nav-number">4.1.</span> <span class="nav-text">ReentrantReadWriteLock 读写锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatitle"><span class="nav-number">5.</span> <span class="nav-text">volatitle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读"><span class="nav-number">5.1.</span> <span class="nav-text">读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写"><span class="nav-number">5.2.</span> <span class="nav-text">写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile适用场景"><span class="nav-number">5.3.</span> <span class="nav-text">volatile适用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Atomics"><span class="nav-number">6.</span> <span class="nav-text">Atomics</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#wait、notify-和-notifyAll"><span class="nav-number">7.</span> <span class="nav-text">wait、notify 和 notifyAll</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程间通信"><span class="nav-number">8.</span> <span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">8.1.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch适用场景"><span class="nav-number">8.1.1.</span> <span class="nav-text">CountDownLatch适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch实例"><span class="nav-number">8.1.2.</span> <span class="nav-text">CountDownLatch实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch主要接口分析"><span class="nav-number">8.1.3.</span> <span class="nav-text">CountDownLatch主要接口分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">8.2.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier适用场景"><span class="nav-number">8.2.1.</span> <span class="nav-text">CyclicBarrier适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier实例"><span class="nav-number">8.2.2.</span> <span class="nav-text">CyclicBarrier实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier主要接口分析"><span class="nav-number">8.2.3.</span> <span class="nav-text">CyclicBarrier主要接口分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-与-CyclicBarrier"><span class="nav-number">8.2.4.</span> <span class="nav-text">CountDownLatch 与 CyclicBarrier</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Phaser"><span class="nav-number">8.3.</span> <span class="nav-text">Phaser</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser适用场景"><span class="nav-number">8.3.1.</span> <span class="nav-text">Phaser适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser实例"><span class="nav-number">8.3.2.</span> <span class="nav-text">Phaser实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser主要接口分析"><span class="nav-number">8.3.3.</span> <span class="nav-text">Phaser主要接口分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#信号量-Semaphore"><span class="nav-number">9.</span> <span class="nav-text">信号量 Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量的使用方法"><span class="nav-number">9.1.</span> <span class="nav-text">信号量的使用方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exchanger"><span class="nav-number">10.</span> <span class="nav-text">Exchanger</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">10.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Future-和-Future-Task"><span class="nav-number">11.</span> <span class="nav-text">Future 和 Future Task</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回调函数"><span class="nav-number">12.</span> <span class="nav-text">回调函数</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Matt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴





      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/vendors/jquery-scrollintoview/jquery.scrollintoview.min.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wangzzu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  1

<!-- MathJax Start -->
<!-- MathJax documentation: http://docs.mathjax.org/en/latest/index.html -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {  // tex2jax preprocessor
      inlineMath: [ ['$','$'] ],  // delimiters for in-line math
      displayMath: [ ['$$','$$'] ],  // delimiters for displayed equations
      processEscapes: true,  // enable \$ to represent a single dollar sign
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']  // MathJax will not process contents inside these tags 
    },
    TeX: {  // TeX/LaTeX input processor
      equationNumbers: { autoNumber: "AMS" },  // only number those equations in specific AMSmath environments
      extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]  // introduce AMS extensions and suppress generating error messages 
    },
    "HTML-CSS": {  // HTML-CSS output processor (this is the default output of MathJax)
      scale: 110,  // The scaling factor of math with respect to the surrounding text
      linebreaks: { automatic: true } // automatically breaks the line if necessary
    },
    SVG: {  // SVG output processor
      scale: 110,  // The scaling factor of math with respect to the surrounding text
      linebreaks: { automatic: true } // automatically breaks the line if necessary
    },
    menuSettings: {  // settings for the mathematics contextual menu
      zoom: "Hover"  // set equation zooming to be triggered by a single mouse click
    }
  });
 
  MathJax.Hub.Queue(function() { // Fix <code> tags after MathJax finishes running, this is a hack to overcome a shortcoming of Markdown
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">  // link to the MathJax CDN
</script>
<!-- MathJax End -->

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  
</body>
</html>
