<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Flink Master 详解 | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink Master 详解</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">王蒙</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink Master 详解</h1><div class="post-meta">Dec 23, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">5,290</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2019/12/23/flink-master-5/" href="/2019/12/23/flink-master-5/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink-Master-简介"><span class="toc-number">1.</span> <span class="toc-text">Flink Master 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Master-启动整体流程"><span class="toc-number">2.</span> <span class="toc-text">Master 启动整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initializeServices"><span class="toc-number">2.1.</span> <span class="toc-text">initializeServices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-DispatcherResourceManagerComponent"><span class="toc-number">2.2.</span> <span class="toc-text">create DispatcherResourceManagerComponent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Master-各个服务详解"><span class="toc-number">3.</span> <span class="toc-text">Master 各个服务详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatcher"><span class="toc-number">3.1.</span> <span class="toc-text">Dispatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceManager"><span class="toc-number">3.2.</span> <span class="toc-text">ResourceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SlotManager"><span class="toc-number">3.2.1.</span> <span class="toc-text">SlotManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他服务"><span class="toc-number">3.3.</span> <span class="toc-text">其他服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小节"><span class="toc-number">4.</span> <span class="toc-text">小节</span></a></li></ol></div></div><div class="post-content"><p>本篇文章是 <strong>Flink 系列</strong> 的第五篇，从这篇开始会向大家介绍一下 Flink Runtime 中涉及到的分布式调度相关的内容。Flink 本身也是 Master/Slave 架构（当前的架构是在 <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077" target="_blank" rel="external">FLIP-6 - Flink Deployment and Process Model - Standalone, Yarn, Mesos, Kubernetes, etc</a> 中实现的），这个 Master 节点就类似于 Storm 中 Nimbus 节点，它负责整个集群的一些协调工作，Flink 中 Master 节点主要包含三大组件：Flink Resource Manager、Flink Dispatcher 以及为每个运行的 Job 创建一个 JobManager 服务，本篇文章主要给大家介绍一下 Flink 中 Master 节点相关内容。</p>
<p>这里要说明的一点是：通常我们认为 Flink 集群的 master 节点就是 JobManager，slave 节点就是 TaskManager 或者 TaskExecutor（见：<a href="https://ci.apache.org/projects/flink/flink-docs-master/concepts/runtime.html" target="_blank" rel="external">Distributed Runtime Environment</a>），这本身是没有什么问题的。但这里需要强调一下，在本文中集群的 Master 节点暂时就叫做 Master 节点，而负责每个作业调度的服务，这里叫做 JobManager/JobMaster（现在源码的实现中对应的类是 JobMaster）。集群的 Master 节点的工作范围与 JobManager 的工作范围还是有所不同的，而且 Master 节点的其中一项工作职责就是为每个提交的作业创建一个 JobManager 对象，用来处理这个作业相关协调工作，比如：task 的调度、Checkpoint 的触发及失败恢复等，JobManager 的内容将会在下篇文章单独讲述，本文主要聚焦 Master 节点除 JobManager 之外的工作。</p>
<h2 id="Flink-Master-简介"><a href="#Flink-Master-简介" class="headerlink" title="Flink Master 简介"></a>Flink Master 简介</h2><p>Flink 的 Master 节点包含了三个组件: Dispatcher、ResourceManager 和 JobManager。其中:</p>
<ol>
<li><strong>Dispatcher</strong>: 负责接收用户提供的作业，并且负责为这个新提交的作业拉起一个新的 JobManager 服务；</li>
<li><strong>ResourceManager</strong>: 负责资源的管理，在整个 Flink 集群中只有一个 ResourceManager，资源相关的内容都由这个服务负责；</li>
<li><strong>JobManager</strong>: 负责管理具体某个作业的执行，在一个 Flink 集群中可能有多个作业同时执行，每个作业都会有自己的 JobManager 服务。</li>
</ol>
<p><img src="/images/flink/1-3.png" alt="Flink 的架构图（来自官网）"></p>
<p>根据上面的 Flink 的架构图（等把 runtime 的内容介绍完，届时会画一张更细的 Flink 的架构图，现在先以官方的图来看），当用户开始提交一个作业，首先会将用户编写的代码转化为一个 JobGraph（参考这个系列前面的文章），在这个过程中，它会进行一些检查或优化相关的工作（比如：检查配置，把可以 Chain 在一起算子 Chain 在一起）。然后，Client 再将生成的 JobGraph 提交到集群中执行。此时有两种情况（对于两种不同类型的集群）：</p>
<ol>
<li>类似于 Standalone 这种 Session 模式（对于 YARN 模式来说），这种情况下 Client 可以直接与 Dispatcher 建立连接并提交作业；</li>
<li>是 Per-Job 模式，这种情况下 Client 首先向资源管理系统 （如 Yarn）申请资源来启动 ApplicationMaster，然后再向 ApplicationMaster 中的 Dispatcher 提交作业。</li>
</ol>
<p>当作业到 Dispatcher 后，Dispatcher 会首先启动一个 JobManager 服务，然后 JobManager 会向 ResourceManager 申请资源来启动作业中具体的任务。ResourceManager 选择到空闲的 Slot （<a href="http://matt33.com/2019/11/23/flink-learn-start-1/#Flink-%E6%9E%B6%E6%9E%84">Flink 架构-基本概念</a>）之后，就会通知相应的 TM 将该 Slot 分配给指定的 JobManager。</p>
<h2 id="Master-启动整体流程"><a href="#Master-启动整体流程" class="headerlink" title="Master 启动整体流程"></a>Master 启动整体流程</h2><p>Flink 集群 Master 节点在初始化时，会先调用 ClusterEntrypoint 的 <code>runClusterEntrypoint()</code> 方法启动集群，其整体流程如下图所示：</p>
<p><img src="/images/flink/5-flink-master.png" alt="Flink Master 启动的整体流程"></p>
<p>上图流程中 <code>runCluster()</code> 方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClusterEntrypoint.java</span></span><br><span class="line"><span class="comment">//note: run cluster real start-point</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runCluster</span><span class="params">(Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">//note: 首先会初始化相关的服务(这里会涉及到一系列的服务)</span></span><br><span class="line">        initializeServices(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write host information into configuration</span></span><br><span class="line">        configuration.setString(JobManagerOptions.ADDRESS, commonRpcService.getAddress());</span><br><span class="line">        configuration.setInteger(JobManagerOptions.PORT, commonRpcService.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DispatcherResourceManagerComponentFactory&lt;?&gt; dispatcherResourceManagerComponentFactory = createDispatcherResourceManagerComponentFactory(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建 DispatcherResourceManagerComponent 对象（前面初始化的服务，都在这里使用了）</span></span><br><span class="line">        clusterComponent = dispatcherResourceManagerComponentFactory.create(</span><br><span class="line">            configuration,</span><br><span class="line">            commonRpcService,</span><br><span class="line">            haServices,</span><br><span class="line">            blobServer,</span><br><span class="line">            heartbeatServices,</span><br><span class="line">            metricRegistry,</span><br><span class="line">            archivedExecutionGraphStore,</span><br><span class="line">            <span class="keyword">new</span> RpcMetricQueryServiceRetriever(metricRegistry.getMetricQueryServiceRpcService()),</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        clusterComponent.getShutDownFuture().whenComplete(</span><br><span class="line">            (ApplicationStatus applicationStatus, Throwable throwable) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//note: 抛出异常的情况下</span></span><br><span class="line">                    shutDownAsync(</span><br><span class="line">                        ApplicationStatus.UNKNOWN,</span><br><span class="line">                        ExceptionUtils.stringifyException(throwable),</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This is the general shutdown path. If a separate more specific shutdown was</span></span><br><span class="line">                    <span class="comment">// already triggered, this will do nothing</span></span><br><span class="line">                    shutDownAsync(</span><br><span class="line">                        applicationStatus,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要分为下面两个步骤：</p>
<ol>
<li><code>initializeServices()</code>: 初始化相关的服务，都是 Master 节点将会使用到的一些服务；</li>
<li><code>create DispatcherResourceManagerComponent</code>: 这里会创建一个 <code>DispatcherResourceManagerComponent</code> 对象，这个对象在创建的时候会启动 <code>Dispatcher</code> 和 <code>ResourceManager</code> 服务。</li>
</ol>
<p>下面来详细看下具体实现。</p>
<h3 id="initializeServices"><a href="#initializeServices" class="headerlink" title="initializeServices"></a>initializeServices</h3><p><code>initializeServices()</code> 初始化一些基本的服务，具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClusterEntrypoint.java</span></span><br><span class="line"><span class="comment">//note: 初始化相关的服务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeServices</span><span class="params">(Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">"Initializing cluster services."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">final</span> String bindAddress = configuration.getString(JobManagerOptions.ADDRESS);</span><br><span class="line">        <span class="keyword">final</span> String portRange = getRPCPortRange(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建 RPC 服务</span></span><br><span class="line">        commonRpcService = createRpcService(configuration, bindAddress, portRange);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the configuration used to create the high availability services</span></span><br><span class="line">        <span class="comment">//note: 根据当前创建的 RPC 服务信息做相关的配置（之前设置的端口可能是一个 range）</span></span><br><span class="line">        configuration.setString(JobManagerOptions.ADDRESS, commonRpcService.getAddress());</span><br><span class="line">        configuration.setInteger(JobManagerOptions.PORT, commonRpcService.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 用于 IO 的线程池</span></span><br><span class="line">        ioExecutor = Executors.newFixedThreadPool(</span><br><span class="line">            Hardware.getNumberCPUCores(),</span><br><span class="line">            <span class="keyword">new</span> ExecutorThreadFactory(<span class="string">"cluster-io"</span>));</span><br><span class="line">        <span class="comment">//note: HA service（跟用户配置有关，可以是 NONE、ZooKeeper 也可以自定义的类）</span></span><br><span class="line">        haServices = createHaServices(configuration, ioExecutor);</span><br><span class="line">        <span class="comment">//note: 初始化 Blob Server</span></span><br><span class="line">        blobServer = <span class="keyword">new</span> BlobServer(configuration, haServices.createBlobStore());</span><br><span class="line">        blobServer.start();</span><br><span class="line">        <span class="comment">//note: heartbeat service</span></span><br><span class="line">        heartbeatServices = createHeartbeatServices(configuration);</span><br><span class="line">        <span class="comment">//note: metrics reporter</span></span><br><span class="line">        metricRegistry = createMetricRegistry(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建了一个 Flink 内部的 metrics rpc service</span></span><br><span class="line">        <span class="keyword">final</span> RpcService metricQueryServiceRpcService = MetricUtils.startMetricsRpcService(configuration, bindAddress);</span><br><span class="line">        <span class="comment">//note: start MetricQueryService</span></span><br><span class="line">        metricRegistry.startQueryService(metricQueryServiceRpcService, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建一个 ArchivedExecutionGraphStore 对象，用于存储用户作业的物理 graph</span></span><br><span class="line">        archivedExecutionGraphStore = createSerializableExecutionGraphStore(configuration, commonRpcService.getScheduledExecutor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述流程涉及到服务有：</p>
<ol>
<li>RpcService: 创建一个 rpc 服务；</li>
<li>HighAvailabilityServices: HA service 相关的实现，它的作用有很多，比如：处理 ResourceManager 的 leader 选举、JobManager leader 的选举等；</li>
<li>BlobServer: 主要管理一些大文件的上传等，比如用户作业的 jar 包、TM 上传 log 文件等（Blob 是指二进制大对象也就是英文 Binary Large Object 的缩写）；</li>
<li>HeartbeatServices: 初始化一个心跳服务；</li>
<li>MetricRegistryImpl: metrics 相关的服务；</li>
<li>ArchivedExecutionGraphStore: 存储 execution graph 的服务，默认有两种实现，<code>MemoryArchivedExecutionGraphStore</code> 主要是在内存中缓存，<code>FileArchivedExecutionGraphStore</code> 会持久化到文件系统，也会在内存中缓存。</li>
</ol>
<p>这些服务都会在前面第二步创建 <code>DispatcherResourceManagerComponent</code> 对象时使用到。</p>
<h3 id="create-DispatcherResourceManagerComponent"><a href="#create-DispatcherResourceManagerComponent" class="headerlink" title="create DispatcherResourceManagerComponent"></a>create DispatcherResourceManagerComponent</h3><p>创建 <code>DispatcherResourceManagerComponent</code> 对象的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractDispatcherResourceManagerComponentFactory.java</span></span><br><span class="line"><span class="comment">//note: 创建 DispatcherResourceManagerComponent 对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatcherResourceManagerComponent&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">        RpcService rpcService,</span></span></span><br><span class="line"><span class="function"><span class="params">        HighAvailabilityServices highAvailabilityServices,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlobServer blobServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        HeartbeatServices heartbeatServices,</span></span></span><br><span class="line"><span class="function"><span class="params">        MetricRegistry metricRegistry,</span></span></span><br><span class="line"><span class="function"><span class="params">        ArchivedExecutionGraphStore archivedExecutionGraphStore,</span></span></span><br><span class="line"><span class="function"><span class="params">        MetricQueryServiceRetriever metricQueryServiceRetriever,</span></span></span><br><span class="line"><span class="function"><span class="params">        FatalErrorHandler fatalErrorHandler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    LeaderRetrievalService dispatcherLeaderRetrievalService = <span class="keyword">null</span>;</span><br><span class="line">    LeaderRetrievalService resourceManagerRetrievalService = <span class="keyword">null</span>;</span><br><span class="line">    WebMonitorEndpoint&lt;U&gt; webMonitorEndpoint = <span class="keyword">null</span>;</span><br><span class="line">    ResourceManager&lt;?&gt; resourceManager = <span class="keyword">null</span>;</span><br><span class="line">    JobManagerMetricGroup jobManagerMetricGroup = <span class="keyword">null</span>;</span><br><span class="line">    T dispatcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//note: 用于 Dispatcher leader 选举</span></span><br><span class="line">        dispatcherLeaderRetrievalService = highAvailabilityServices.getDispatcherLeaderRetriever();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 用于 Resource Manager leader 选举（对于使用 zk 的 HA 模式来说，与上面的区别是使用的路径不同）</span></span><br><span class="line">        resourceManagerRetrievalService = highAvailabilityServices.getResourceManagerLeaderRetriever();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: Dispatcher 的 Gateway</span></span><br><span class="line">        <span class="keyword">final</span> LeaderGatewayRetriever&lt;DispatcherGateway&gt; dispatcherGatewayRetriever = <span class="keyword">new</span> RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">            rpcService,</span><br><span class="line">            DispatcherGateway.class,</span><br><span class="line">            DispatcherId::fromUuid,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            Time.milliseconds(<span class="number">50L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: ResourceManager 的 Gateway</span></span><br><span class="line">        <span class="keyword">final</span> LeaderGatewayRetriever&lt;ResourceManagerGateway&gt; resourceManagerGatewayRetriever = <span class="keyword">new</span> RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">            rpcService,</span><br><span class="line">            ResourceManagerGateway.class,</span><br><span class="line">            ResourceManagerId::fromUuid,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            Time.milliseconds(<span class="number">50L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 它主要使用 web 前端的 rest 接口调用</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executor = WebMonitorEndpoint.createExecutorService(</span><br><span class="line">            configuration.getInteger(RestOptions.SERVER_NUM_THREADS),</span><br><span class="line">            configuration.getInteger(RestOptions.SERVER_THREAD_PRIORITY),</span><br><span class="line">            <span class="string">"DispatcherRestEndpoint"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: metrics Fetcher</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL);</span><br><span class="line">        <span class="keyword">final</span> MetricFetcher metricFetcher = updateInterval == <span class="number">0</span></span><br><span class="line">            ? VoidMetricFetcher.INSTANCE</span><br><span class="line">            : MetricFetcherImpl.fromConfiguration(</span><br><span class="line">                configuration,</span><br><span class="line">                metricQueryServiceRetriever,</span><br><span class="line">                dispatcherGatewayRetriever,</span><br><span class="line">                executor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: standalone 模式下，这里创建的是 DispatcherRestEndpoint 对象</span></span><br><span class="line">        webMonitorEndpoint = restEndpointFactory.createRestEndpoint(</span><br><span class="line">            configuration,</span><br><span class="line">            dispatcherGatewayRetriever,</span><br><span class="line">            resourceManagerGatewayRetriever,</span><br><span class="line">            blobServer,</span><br><span class="line">            executor,</span><br><span class="line">            metricFetcher,</span><br><span class="line">            highAvailabilityServices.getWebMonitorLeaderElectionService(),</span><br><span class="line">            fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 启动 DispatcherRestEndpoint</span></span><br><span class="line">        log.debug(<span class="string">"Sarting Dispatcher REST endptoint."</span>);</span><br><span class="line">        webMonitorEndpoint.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String hostname = getHostname(rpcService);</span><br><span class="line"></span><br><span class="line">        jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(</span><br><span class="line">            metricRegistry,</span><br><span class="line">            hostname,</span><br><span class="line">            ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建 ResourceManager 对象（StandAlone 模式，这里创建的是 StandaloneResourceManager 对象）</span></span><br><span class="line">        resourceManager = resourceManagerFactory.createResourceManager(</span><br><span class="line">            configuration,</span><br><span class="line">            ResourceID.generate(),</span><br><span class="line">            rpcService,</span><br><span class="line">            highAvailabilityServices,</span><br><span class="line">            heartbeatServices,</span><br><span class="line">            metricRegistry,</span><br><span class="line">            fatalErrorHandler,</span><br><span class="line">            <span class="keyword">new</span> ClusterInformation(hostname, blobServer.getPort()),</span><br><span class="line">            webMonitorEndpoint.getRestBaseUrl(),</span><br><span class="line">            jobManagerMetricGroup);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> HistoryServerArchivist historyServerArchivist = HistoryServerArchivist.createHistoryServerArchivist(configuration, webMonitorEndpoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建 dispatcher 对象（StandAlone 模式下，创建的是 StandaloneDispatcher 对象）</span></span><br><span class="line">        dispatcher = dispatcherFactory.createDispatcher(</span><br><span class="line">            configuration,</span><br><span class="line">            rpcService,</span><br><span class="line">            highAvailabilityServices,</span><br><span class="line">            resourceManagerGatewayRetriever,</span><br><span class="line">            blobServer,</span><br><span class="line">            heartbeatServices,</span><br><span class="line">            jobManagerMetricGroup,</span><br><span class="line">            metricRegistry.getMetricQueryServiceGatewayRpcAddress(),</span><br><span class="line">            archivedExecutionGraphStore,</span><br><span class="line">            fatalErrorHandler,</span><br><span class="line">            historyServerArchivist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 启动 ResourceManager</span></span><br><span class="line">        log.debug(<span class="string">"Starting ResourceManager."</span>);</span><br><span class="line">        resourceManager.start();</span><br><span class="line">        resourceManagerRetrievalService.start(resourceManagerGatewayRetriever); <span class="comment">//note: 监听 leader</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 启动 Dispatcher</span></span><br><span class="line">        log.debug(<span class="string">"Starting Dispatcher."</span>);</span><br><span class="line">        dispatcher.start();</span><br><span class="line">        dispatcherLeaderRetrievalService.start(dispatcherGatewayRetriever);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createDispatcherResourceManagerComponent(</span><br><span class="line">            dispatcher,</span><br><span class="line">            resourceManager,</span><br><span class="line">            dispatcherLeaderRetrievalService,</span><br><span class="line">            resourceManagerRetrievalService,</span><br><span class="line">            webMonitorEndpoint,</span><br><span class="line">            jobManagerMetricGroup);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="comment">//note: 清除前面启动的所有服务的组件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法实现中，Master 中的两个重要服务就是在这里初始化并启动的：</p>
<ol>
<li><code>Dispatcher</code>: 初始化并启动这个服务，如果 JM 启动了 HA 模式，这里会竞选 leader，只有是 leader 的 <code>Dispatcher</code> 才会真正对外提供服务（参考前面图中的流程）；</li>
<li><code>ResourceManager</code>: 这个跟 <code>Dispatcher</code> 有点类似。</li>
</ol>
<h2 id="Master-各个服务详解"><a href="#Master-各个服务详解" class="headerlink" title="Master 各个服务详解"></a>Master 各个服务详解</h2><p>这里，我们来详细看下 Master 使用到各个服务组件，并做下详细的介绍。</p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><strong>Dispatcher</strong> 主要是用于作业的提交、并把它们持久化、为作业创建对应的 JobManager 等，Client 端提交的 JobGraph 就是提交给了 Dispatcher 服务，这里先看一下一个 Dispatcher 对象被选举为 leader 后是如何初始化的，如果当前的 Dispatcher 被选举为 leader，则会调用其 <code>grantLeadership()</code> 方法，该方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback method when current resourceManager is granted leadership.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note: 如果当前的 dispatcher 是 leader 的情况下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLeaderSessionID unique leadershipID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantLeadership</span><span class="params">(<span class="keyword">final</span> UUID newLeaderSessionID)</span> </span>&#123;</span><br><span class="line">    runAsyncWithoutFencing(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"Dispatcher &#123;&#125; was granted leadership with fencing token &#123;&#125;"</span>, getAddress(), newLeaderSessionID);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//note: 通过 recoverJobs() 方法先从 job graph store 中恢复所有的 jobs</span></span><br><span class="line">            <span class="keyword">final</span> CompletableFuture&lt;Collection&lt;JobGraph&gt;&gt; recoveredJobsFuture = recoveryOperation.thenApplyAsync(</span><br><span class="line">                FunctionUtils.uncheckedFunction(ignored -&gt; recoverJobs()),</span><br><span class="line">                getRpcService().getExecutor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//note: 通过 tryAcceptLeadershipAndRunJobs() 调用 runJob 启动前面的每一个 job</span></span><br><span class="line">            <span class="keyword">final</span> CompletableFuture&lt;Boolean&gt; fencingTokenFuture = recoveredJobsFuture.thenComposeAsync(</span><br><span class="line">                (Collection&lt;JobGraph&gt; recoveredJobs) -&gt; tryAcceptLeadershipAndRunJobs(newLeaderSessionID, recoveredJobs),</span><br><span class="line">                getUnfencedMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> CompletableFuture&lt;Void&gt; confirmationFuture = fencingTokenFuture.thenCombineAsync(</span><br><span class="line">                recoveredJobsFuture,</span><br><span class="line">                BiFunctionWithException.unchecked((Boolean confirmLeadership, Collection&lt;JobGraph&gt; recoveredJobs) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (confirmLeadership) &#123;</span><br><span class="line">                        <span class="comment">//note: 如果是 leader，并且前面两步都完成的话，就会走到这里</span></span><br><span class="line">                        leaderElectionService.confirmLeaderSessionID(newLeaderSessionID);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (JobGraph recoveredJob : recoveredJobs) &#123;</span><br><span class="line">                            <span class="comment">//note: 从 job graph store 中删除这些作业相关的 state</span></span><br><span class="line">                            submittedJobGraphStore.releaseJobGraph(recoveredJob.getJobID());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">                getRpcService().getExecutor());</span><br><span class="line"></span><br><span class="line">            confirmationFuture.whenComplete(</span><br><span class="line">                (Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        onFatalError(</span><br><span class="line">                            <span class="keyword">new</span> DispatcherException(</span><br><span class="line">                                String.format(<span class="string">"Failed to take leadership with session id %s."</span>, newLeaderSessionID),</span><br><span class="line">                                (ExceptionUtils.stripCompletionException(throwable))));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            recoveryOperation = confirmationFuture;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dispatcher 被选举为 leader 后，它主要的操作步骤如下：</p>
<ol>
<li><code>recoverJobs()</code>: 先从 job graph store 恢复所有作业的 JobGraph；</li>
<li><code>tryAcceptLeadershipAndRunJobs()</code>: 启动前面恢复的每个作业，这里要说明的是，目前看到的 1.9 的实现，这里会将前面所有的作业都会重启，我在看的时候是有点懵逼的，这个 HA 有点伪 HA，相当于 leader 切换之后，作业就必须要得重启恢复，这个代价是有点大的，不过也看到社区有改进的计划（<a href="https://issues.apache.org/jira/browse/FLINK-10333" target="_blank" rel="external">FLINK-10333</a> 这个进度有点慢）；</li>
</ol>
<p>我们这里再详细看下 Dispatcher 对外提供了哪些 API 实现（这些接口主要还是 <code>DispatcherGateway</code> 中必须要实现的接口），通过这些 API，其实就很容易看出它到底对外提供了哪些功能，提供的 API 有：</p>
<ol>
<li><code>listJobs()</code>: 列出当前提交的作业列表；</li>
<li><code>submitJob()</code>: 向集群提交作业；</li>
<li><code>getBlobServerPort()</code>: 返回 blob server 的端口；</li>
<li><code>requestJob()</code>: 根据 jobId 请求一个作业的 ArchivedExecutionGraph（它是这个作业  ExecutionGraph 序列化后的形式）；</li>
<li><code>disposeSavepoint()</code>: 清理指定路径的 savepoint 状态信息；</li>
<li><code>cancelJob()</code>: 取消一个指定的作业；</li>
<li><code>requestClusterOverview()</code>: 请求这个集群的全局信息，比如：集群有多少个 slot，有多少可用的 slot，有多少个作业等等；</li>
<li><code>requestMultipleJobDetails()</code>: 返回当前集群正在执行的作业详情，返回对象是 JobDetails 列表；</li>
<li><code>requestJobStatus()</code>: 请求一个作业的作业状态（返回的类型是 <code>JobStatus</code>）； </li>
<li><code>requestOperatorBackPressureStats()</code>: 请求一个 Operator 返回的状态信息； </li>
<li><code>requestJobResult()</code>: 请求一个 job 的 <code>JobResult</code>；</li>
<li><code>requestMetricQueryServiceAddresses()</code>: 请求 MetricQueryService 的地址；</li>
<li><code>requestTaskManagerMetricQueryServiceAddresses()</code>: 请求 TaskManager 的 MetricQueryService 的地址；</li>
<li><code>triggerSavepoint()</code>: 使用指定的目录触发一个 savepoint；</li>
<li><code>stopWithSavepoint()</code>: 停止当前正在做的 savepoint；</li>
<li><code>shutDownCluster()</code>: 关闭集群；</li>
</ol>
<p>通过 Dispatcher 提供的 API 可以看出，Dispatcher 服务主要有功能有：</p>
<ol>
<li>提交/取消作业；</li>
<li>触发/取消/清理 一个作业的 savepoint；</li>
<li>作业状态/列表查询；</li>
</ol>
<p>Dispatcher 这里主要处理的还是 Job 相关的请求，对外提供了统一的接口。</p>
<h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>ResourceManager 从名字就可以看出，它主要是资源管理相关的服务，如果其被选举为 leader，实现如下，它会清除缓存中的数据，然后启动 SlotManager 服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceManager.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback method when current resourceManager is granted leadership.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：如果当前的 resourceManager 被选举为 leader 的话，就执行这个方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLeaderSessionID unique leadershipID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantLeadership</span><span class="params">(<span class="keyword">final</span> UUID newLeaderSessionID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//note: tryAcceptLeadership() 清除之前 leader 的信息，这里会重新初始化 leader 相关的信息，并启动 SlotManager 服务</span></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Boolean&gt; acceptLeadershipFuture = clearStateFuture</span><br><span class="line">        .thenComposeAsync((ignored) -&gt; tryAcceptLeadership(newLeaderSessionID), getUnfencedMainThreadExecutor());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Void&gt; confirmationFuture = acceptLeadershipFuture.thenAcceptAsync(</span><br><span class="line">        (acceptLeadership) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (acceptLeadership) &#123;</span><br><span class="line">                <span class="comment">// confirming the leader session ID might be blocking,</span></span><br><span class="line">                leaderElectionService.confirmLeaderSessionID(newLeaderSessionID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        getRpcService().getExecutor());</span><br><span class="line"></span><br><span class="line">    confirmationFuture.whenComplete(</span><br><span class="line">        (Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                onFatalError(ExceptionUtils.stripCompletionException(throwable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Boolean&gt; <span class="title">tryAcceptLeadership</span><span class="params">(<span class="keyword">final</span> UUID newLeaderSessionID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaderElectionService.hasLeadership(newLeaderSessionID)) &#123;</span><br><span class="line">        <span class="keyword">final</span> ResourceManagerId newResourceManagerId = ResourceManagerId.fromUuid(newLeaderSessionID);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"ResourceManager &#123;&#125; was granted leadership with fencing token &#123;&#125;"</span>, getAddress(), newResourceManagerId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the state if we've been the leader before</span></span><br><span class="line">        <span class="comment">//note: 清除之前的状态</span></span><br><span class="line">        <span class="keyword">if</span> (getFencingToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clearStateInternal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setFencingToken(newResourceManagerId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 本节点启动 leader 服务</span></span><br><span class="line">        startServicesOnLeadership();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prepareLeadershipAsync().thenApply(ignored -&gt; <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startServicesOnLeadership</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//note: 启动心跳服务</span></span><br><span class="line">    startHeartbeatServices();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//note: 启动 slotManager</span></span><br><span class="line">    slotManager.start(getFencingToken(), getMainThreadExecutor(), <span class="keyword">new</span> ResourceActionsImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也来看下 ResourceManager 对外提供的 API（<code>ResourceManagerGateway</code> 相关方法的实现）：</p>
<ol>
<li><code>registerJobManager()</code>: 在 ResourceManager 中注册一个 <code>JobManager</code> 对象，一个作业启动后，JobManager 初始化后会调用这个方法；</li>
<li><code>registerTaskExecutor()</code>: 在 ResourceManager 中注册一个 <code>TaskExecutor</code>（<code>TaskExecutor</code> 实际上就是一个 TaskManager），当一个 TaskManager 启动后，会主动向 ResourceManager 注册；</li>
<li><code>sendSlotReport()</code>: TM 向 ResourceManager 发送 <code>SlotReport</code>（<code>SlotReport</code> 包含了这个 TaskExecutor 的所有 slot 状态信息，比如：哪些 slot 是可用的、哪些 slot 是已经被分配的、被分配的 slot 分配到哪些 Job 上了等）；</li>
<li><code>heartbeatFromTaskManager()</code>: 向 ResourceManager 发送来自 TM 的心跳信息；</li>
<li><code>heartbeatFromJobManager()</code>: 向 ResourceManager 发送来自 JM 的心跳信息；</li>
<li><code>disconnectTaskManager()</code>: TM 向 ResourceManager 发送一个断开连接的请求；</li>
<li><code>disconnectJobManager()</code>: JM 向 ResourceManager 发送一个断开连接的请求；</li>
<li><code>requestSlot()</code>: JM 向 ResourceManager 请求 slot 资源；</li>
<li><code>cancelSlotRequest()</code>: JM 向 ResourceManager 发送一个取消 slot 申请的请求；</li>
<li><code>notifySlotAvailable()</code>: TM 向 ResourceManager 发送一个请求，通知 ResourceManager 某个 slot 现在可用了（TM 端某个 slot 的资源被释放，可以再进行分配了）；</li>
<li><code>deregisterApplication()</code>: 向资源管理系统（比如：yarn、mesos）申请关闭当前的 Flink 集群，一般是在关闭集群的时候调用的；</li>
<li><code>requestTaskManagerInfo()</code>: 请求当前注册到 ResourceManager 的 TM 的详细信息（返回的类型是 <code>TaskManagerInfo</code>，可以请求的是全部的 TM 列表，也可以是根据某个 <code>ResourceID</code> 请求某个具体的 TM）；</li>
<li><code>requestResourceOverview()</code>: 向 ResourceManager 请求资源概况，返回的类型是 <code>ResourceOverview</code>，它包括注册的 TM 数量、注册的 slot 数、可用的 slot 数等；</li>
<li><code>requestTaskManagerMetricQueryServiceAddresses()</code>: 请求 TM MetricQueryService 的地址信息；</li>
<li><code>requestTaskManagerFileUpload()</code>: 向 TM 发送一个文件上传的请求，这里上传的是 TM 的 LOG/STDOUT 类型的文件，文件会上传到 Blob Server，这里会拿到一个 BlobKey（Blobkey 实际上是文件名的一部分，通过 BlobKey 可以确定这个文件的物理位置信息）；</li>
</ol>
<p>从上面的 API 列表中，可以看出 ResourceManager 的主要功能是：</p>
<ol>
<li>JobManager/TaskManager 资源的注册/心跳监控/连接断开的处理；</li>
<li>处理/取消 JM 资源（slot）的申请；</li>
<li>提供资源信息查询；</li>
<li>向 TM 发送请求，触发其 LOG/STDOUT 文件上传到 BlobServer；</li>
</ol>
<p>ResourceManager 在启动的时候，也会启动一个 SlotManager 服务，TM 相关的 slot 资源都是在 SlotManager 中维护的。</p>
<h4 id="SlotManager"><a href="#SlotManager" class="headerlink" title="SlotManager"></a>SlotManager</h4><p>SlotManager 会维护所有从 TaskManager 注册过来的 slot（包括它们的分配情况）以及所有 pending 的 SlotRequest（所有的 slot 请求都会先放到 pending 列表中，然后再去判断是否可以满足其资源需求）。只要有新的 slot 注册或者旧的 slot 资源释放，SlotManager 都会检测 pending SlotRequest 列表，检查是否有 SlotRequest 可以满足，如果可以满足，就会将资源分配给这个 SlotRequest；如果没有足够可用的 slot，SlotManager 会尝试着申请新的资源（比如：申请一个 worker 启动）。</p>
<p>当然，为了资源及时释放和避免资源浪费，空转的 task manager（它当前已经分配的 slot 并未使用）和 pending slot request 在 timeout 之后将会分别触发它们的释放和失败（对应的方法实现是 <code>checkTaskManagerTimeouts()</code> 和 <code>checkSlotRequestTimeouts()</code>）。</p>
<p>SlotManager 对外的提供的 API 如下（<code>SlotManager</code> 中必须要实现的接口，实现类是 <code>SlotManagerImpl</code>）：</p>
<ol>
<li><code>getNumberRegisteredSlots()</code>: 获取注册的 slot 的总数量；</li>
<li><code>getNumberRegisteredSlotsOf()</code>: 获取某个 TM 注册的 slot 的数量；</li>
<li><code>getNumberFreeSlots()</code>: 获取当前可用的（还未分配的 slot） slot 的数量；</li>
<li><code>getNumberFreeSlotsOf()</code>: 获取某个 TM 当前可用的 slot 的数量；</li>
<li><code>getNumberPendingTaskManagerSlots()</code>: 获取 <code>pendingSlots</code> 中 slot 的数量（<code>pendingSlots</code> 记录的是 SlotManager 主动去向资源管理系统申请的资源，该系统在一些情况下会新启动 worker 来创建资源，但这些slot 还没有主动汇报过来，就会暂时先放到 <code>pendingSlots</code> 中，如果 TM 过来注册的话，该 slot 就会从 pendingSlots 中移除，存储到其他对象中）；</li>
<li><code>getNumberPendingSlotRequests()</code>: 获取 <code>pendingSlotRequests</code> 列表的数量，这个集合中存储的是收到的、还没分配的 SlotRequest 列表，当一个 SlotRequest 发送过来之后，会先存储到这个集合中，当分配完成后，才会从这个集合中移除；</li>
<li><code>registerSlotRequest()</code>: JM 发送一个 slot 请求（这里是 ResourceManager 通过 <code>requestSlot()</code> 接口调用的）；</li>
<li><code>unregisterSlotRequest()</code>: 取消或移除一个正在排队（可能已经在处理中）的 SlotRequest；</li>
<li><code>registerTaskManager()</code>: 注册一个 TM，这里会将 TM 中所有的 slot 注册过来，等待后面分配；</li>
<li><code>unregisterTaskManager()</code>: 取消一个 TM 的注册（比如：关闭的时候可能会调用），这里会将这个 TM 上所有的 slot 都移除，会先从缓存中移除，然后再通知 JM 这个 slot 分配失败；</li>
<li><code>reportSlotStatus()</code>: TM 汇报当前 slot 分配的情况，SlotManager 会将其更新到自己的缓存中；</li>
<li><code>freeSlot()</code>: 释放一个指定的 slot，如果这个 slot 之前已经被分配出去了，这里会更新其状态，将其状态改为 <code>FREE</code>；</li>
<li><code>setFailUnfulfillableRequest()</code>: 遍历 <code>pendingSlotRequests</code> 列表，如果这些 slot 请求现在还分配不到合适的资源，这里会将其设置为 fail，会通知 JM slot 分配失败。</li>
</ol>
<p>同样，从上面的 API 列表中，总结一下 SlotManager 的功能：</p>
<ol>
<li>提供 slot 相关的信息查询；</li>
<li>处理/取消 JM 发送的 SlotRequest；</li>
<li>注册/取消 一个 TM（该 TM 涉及到的所有 slot 都会被注册或取消）；</li>
<li>Slot 资源的释放；</li>
</ol>
<h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>Master 除了上面的服务，还启动了其他的服务，这里简单列一下：</p>
<ol>
<li><code>BlobServer</code>: 它是 Flink 用来管理二进制大文件的服务，Flink JobManager 中启动的 BlobServer 负责监听请求并派发线程去处理（这个将会在下篇文章中讲述）；</li>
<li><code>JobManager</code>: Dispatcher 会为每个作业创建一个 JobManager 对象，它用来处理这个作业相关的协调工作，比如：task 的调度、Checkpoint 的触发及失败恢复等（这个也会在下篇文章中讲述）；</li>
<li><code>HA service</code>: Flink HA 的实现目前是依赖了 ZK，使用 <code>curator</code> 这个包来实现的，有兴趣的可以看下 <a href="https://www.cnblogs.com/francisYoung/p/5464789.html" target="_blank" rel="external">Curator leader 选举(一)</a> 这篇文章。</li>
</ol>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>到这里，终于就把 Flink Master 相关内容的一部分梳理完了，这里简单总结一下：</p>
<ol>
<li><strong>Dispatcher</strong>: 负责接收用户提供的作业，并且负责为这个新提交的作业拉起一个新的 JobManager 组件，它主要还是处理 Job 相关的请求，对外提供了统一的接口抽象；</li>
<li><strong>ResourceManager</strong>: 负责资源的管理，所有资源相关的请求都是 ResourceManager 中处理的；</li>
<li><strong>JobManager</strong>: 负责管理具体作业的执行；</li>
</ol>
<p>Flink Master 这部分的抽象还是比较好的，三大组件各司其职。当然还有一些需要改善的地方，比如：为什么不抽象一个 Master 类，然后把这些子服务全都放到 Master 类里，这样代码看起来会清晰舒服很多，现在的代码对初学者其实并不友好。</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/internals/job_scheduling.html" target="_blank" rel="external">Jobs and Scheduling</a>；</li>
<li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077" target="_blank" rel="external">FLIP-6 - Flink Deployment and Process Model - Standalone, Yarn, Mesos, Kubernetes, etc</a>；</li>
<li><a href="https://mp.weixin.qq.com/s/TBzzGTNFTzVLjFQdzz-LuQ" target="_blank" rel="external">Apache Flink 进阶（一）：Runtime 核心机制剖析</a>；</li>
<li><a href="https://zhuanlan.zhihu.com/p/89537466?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1052584028930203648" target="_blank" rel="external">FLINK 高可用服务概览与改造</a>;</li>
<li><a href="http://chenyuzhao.me/2017/02/08/jobmanager%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/" target="_blank" rel="external">Flink JobManager 基本组件</a>；</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2019/12/23/flink-master-5/" data-id="ck4imvxqa009g5zzaa6hhji01" class="article-share-link">分享到</a><div class="copyright"><a href="http://matt33.com/copyright/">博客版权说明</a></div><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a href="/2019/12/19/flink-execution-graph-4/" class="next">Flink 如何生成 ExecutionGraph</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2019/12/23/flink-master-5/';
var disqus_title = 'Flink Master 详解';
var disqus_url = 'http://matt33.com/2019/12/23/flink-master-5/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/flink-master-5/">Flink Master 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/flink-execution-graph-4/">Flink 如何生成 ExecutionGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/flink-job-graph-3/">Flink Streaming 作业如何转化为 JobGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/08/flink-stream-graph-2/">Flink DataStream API 概述及作业如何转换为 StreamGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/flink-learn-start-1/">Apache Flink 初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/paper-chandy-lamport/">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/paper-flink-snapshot/">Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/19/paper-ray1/">Paper 阅读: Real-Time Machine Learning: The Missing Pieces</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/apache-calcite-planner/">Apache Calcite 优化器详解（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>