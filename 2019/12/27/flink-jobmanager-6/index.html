<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Flink JobManager 详解 | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flink JobManager 详解</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">柳年思水</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Flink JobManager 详解</h1><div class="post-meta">Dec 27, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">6,186</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2019/12/27/flink-jobmanager-6/" href="/2019/12/27/flink-jobmanager-6/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JobManager-简介"><span class="toc-number">1.</span> <span class="toc-text">JobManager 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JobManager-详解"><span class="toc-number">2.</span> <span class="toc-text">JobManager 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JobMaster-的-API-概述"><span class="toc-number">2.1.</span> <span class="toc-text">JobMaster 的 API 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SlotPool"><span class="toc-number">2.2.</span> <span class="toc-text">SlotPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LegacyScheduler"><span class="toc-number">2.3.</span> <span class="toc-text">LegacyScheduler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作业调度的详细流程"><span class="toc-number">3.</span> <span class="toc-text">作业调度的详细流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何给-ExecutionVertex-分配-slot"><span class="toc-number">3.1.</span> <span class="toc-text">如何给 ExecutionVertex 分配 slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配时如何选择最优的-TM-列表"><span class="toc-number">3.2.</span> <span class="toc-text">分配时如何选择最优的 TM 列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优的-slot-分配算法"><span class="toc-number">3.3.</span> <span class="toc-text">最优的 slot 分配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocateSharedSlot-VS-allocateSingleSlot"><span class="toc-number">3.4.</span> <span class="toc-text">allocateSharedSlot VS allocateSingleSlot</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="post-content"><p>本篇文章是 <strong>Flink 系列</strong> 的第六篇，紧接着上篇文章，本篇主要讲述 Flink Master 中另一个组件 —— JobManager（在源码中对应的实现类是 <code>JobMaster</code>）。每个作业在启动后，Dispatcher 都会为这个作业创建一个 JobManager 对象，用来做这个作业相关的协调工作，比如：调度这个作业的 task、触发 Checkpoint 以及作业的容错恢复等。另外，本篇文章也将会看下一个作业在生成 ExecutionGraph 之后是如何在集群中调度起来的。</p>
<p>从之前文章的介绍中，我们已经知道 JobManager 其实就是一个作业的 master 服务，主要负责自己作业相关的协调工作，包括：向 ResourceManager 申请 Slot 资源来调度相应的 task 任务、定时触发作业的 checkpoint 和手动 savepoint 的触发、以及作业的容错恢复，这些流程将会在后面的系列文章中介绍（这些流程涉及到的组件比较多，需要等待后面把 TaskManager 及 Flink 的调度模型讲述完再回头来看），本文会从 JobManager 是如何初始化的、JobManager 有哪些组件以及分别提供了哪些功能这两块来讲述。</p>
<h2 id="JobManager-简介"><a href="#JobManager-简介" class="headerlink" title="JobManager 简介"></a>JobManager 简介</h2><p>当用户向 Flink 集群提交一个作业后，Dispatcher 在收到 Client 端提交的 JobGraph 后，会为这个作业创建一个 JobManager 对象（对应的是 JobMaster 类），如下图所示：</p>
<p><img src="/images/flink/4-job-start.png" alt="一个新作业提交后的处理流程"></p>
<p>JobManager 在初始化时，会创建 <code>LegacyScheduler</code> 对象，而 <code>LegacyScheduler</code> 在初始化时会将这个作业的 JobGraph 转化为 ExecutionGraph。在JobManager 启动后，就会开始给这个作业的 task 申请相应的资源、开始调度执行这个作业。</p>
<h2 id="JobManager-详解"><a href="#JobManager-详解" class="headerlink" title="JobManager 详解"></a>JobManager 详解</h2><p>JobMaster 在实现中，也依赖了很多的服务，其中最重要的是 <code>SchedulerNG</code> 和 <code>SlotPool</code>，JobMaster 对外提供的接口实现中大都是使用前面这两个服务的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JobMaster.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMaster</span> <span class="keyword">extends</span> <span class="title">FencedRpcEndpoint</span>&lt;<span class="title">JobMasterId</span>&gt; <span class="keyword">implements</span> <span class="title">JobMasterGateway</span>, <span class="title">JobMasterService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LegacyScheduler: 用于调度作业的 ExecutionGraph</span></span><br><span class="line">    <span class="keyword">private</span> SchedulerNG schedulerNG;</span><br><span class="line">    <span class="comment">// SlotPoolImpl: 从名字也能看出它主要处理 slot 相关的内容，在 JM 这边的一个抽象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SlotPool slotPool;</span><br><span class="line">    <span class="comment">// HA 服务，这里主要用于监控 RM leader，如果 RM Leader 有变化，这里会与新的 leader 建立连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HighAvailabilityServices highAvailabilityServices;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面这些都是创建上面 SchedulerNG（即 LegacyScheduler）需要使用到的服务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 用于将数据上传到 BlobServer，这里上传的主要是 JobInformation 和 TaskInformation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlobWriter blobWriter;</span><br><span class="line">    <span class="comment">// 作业的 JobGraph 信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobGraph jobGraph;</span><br><span class="line">    <span class="comment">// SchedulerImpl: 它也是一个调度器，将 slot 分配给对应的 task，它会调用 SlotPool 的相关接口（它里面有一个 slotSelectionStrategy 对象，用来决定一个 slot 分配的最佳算法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="comment">// 用于注册 Intermediate result partition，在作业调度的时候会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShuffleMaster&lt;?&gt; shuffleMaster;</span><br><span class="line">    <span class="comment">// 用于追踪 Intermediate result partition 的服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PartitionTracker partitionTracker;</span><br><span class="line">    <span class="comment">// --------- BackPressure --------</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BackPressureStatsTracker backPressureStatsTracker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JobMaster 中涉及到重要组件如下图所示：</p>
<p><img src="/images/flink/6-job-manager.png" alt="JobMaster 中的组件组成"></p>
<p>JobMaster 主要有两个服务:</p>
<ol>
<li><code>LegacyScheduler</code>: ExecutionGraph 相关的调度都是在这里实现的，它类似更深层的抽象，封装了 ExecutionGraph 和 BackPressureStatsTracker，JobMaster 不直接去调用 ExecutionGraph 和 BackPressureStatsTracker 的相关方法，都是通过 <code>LegacyScheduler</code> 间接去调用；</li>
<li><code>SlotPool</code>: 它是 JobMaster 管理其 slot 的服务，它负责向 RM 申请/释放 slot 资源，并维护其相应的 slot 信息。</li>
</ol>
<p>从前面的图中可以看出，如果 <code>LegacyScheduler</code> 想调用 <code>CheckpointCoordinator</code> 的方法，比如 <code>LegacyScheduler</code> 的 <code>triggerSavepoint()</code> 方法，它是需要先通过 <code>executionGraph</code> 的 <code>getCheckpointCoordinator()</code> 方法拿到 <code>CheckpointCoordinator</code>，然后再调用 <code>CheckpointCoordinator</code> 的 <code>triggerSavepoint()</code> 方法来触发这个作业的 savepoint。</p>
<h3 id="JobMaster-的-API-概述"><a href="#JobMaster-的-API-概述" class="headerlink" title="JobMaster 的 API 概述"></a>JobMaster 的 API 概述</h3><p>目前 JobMaster 对外提供的 API 列表如下（主要还是 <code>JobMasterGateway</code> 接口对应的实现）：</p>
<ol>
<li><code>cancel()</code>: 取消当前正在执行的作业，如果作业还在调度，会执行停止，如果作业正在运行的话，它会向对应的 TM 发送取消 task 的请求（<code>cancelTask()</code> 请求）；</li>
<li><code>updateTaskExecutionState()</code>: 更新某个 task 的状态信息，这个是 TM 主动向 JM 发送的更新请求；</li>
<li><code>requestNextInputSplit()</code>: Source ExecutionJobVertex 请求 next InputSlipt，这个一般是针对批处理读取而言，有兴趣的可以看下 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-27%3A+Refactor+Source+Interface" target="_blank" rel="external">FLIP-27: Refactor Source Interface</a>，这里是社区计划对 Source 做的改进，未来会将批和流统一到一起；</li>
<li><code>requestPartitionState()</code>: 获取指定 Result Partition 对应生产者 JobVertex 的执行状态；</li>
<li><code>scheduleOrUpdateConsumers()</code>: TM 通知 JM 对应的 Result Partition 的数据已经可用，每个 ExecutionVertex 的每个 ResultPartition 都会调用一次这个方法（可能是在第一次生产数据时调用或者所有数据已经就绪时调用）；</li>
<li><code>disconnectTaskManager()</code>: TM 心跳超时或者作业取消时，会调用这个方法，JM 会释放这个 TM 上的所有 slot 资源；</li>
<li><code>acknowledgeCheckpoint()</code>: 当一个 Task 做完 snapshot 后，通过这个接口通知 JM，JM 再做相应的处理，如果这个 checkpoint 所有的 task 都已经 ack 了，那就意味着这个 checkpoint 完成了；</li>
<li><code>declineCheckpoint()</code>: TM 向 JM 发送这个消息，告诉 JM 的 Checkpoint Coordinator 这个 checkpoint request 没有响应，比如：TM 触发 checkpoint 失败，然后 Checkpoint Coordinator 就会知道这个 checkpoint 处理失败了，再做相应的处理；</li>
<li><code>requestKvStateLocation()</code>: 请求某个注册过 registrationName 对应的 KvState 的位置信息；</li>
<li><code>notifyKvStateRegistered()</code>: 当注册一个 KvState 的时候，会调用这个方法，一些 operator 在初始化的时候会调用这个方法注册一个 KvState；</li>
<li><code>notifyKvStateUnregistered()</code>: 取消一个 KVState 的注册，这里是在 operator 关闭 state backend 时调用的（比如：operator 的生命周期结束了，就会调用这个方法）；</li>
<li><code>offerSlots()</code>: TM 通知 JM 其上分配到的 slot 列表；</li>
<li><code>failSlot()</code>: 如果 TM 分配 slot 失败（情况可能很多，比如：slot 分配时状态转移失败等），将会通过这个接口告知 JM；</li>
<li><code>registerTaskManager()</code>: 向这个 JM 注册 TM，JM 会将 TM 注册到 SlotPool 中（只有注册过的 TM 的 Slot 才被认为是有效的，才可以做相应的分配），并且会通过心跳监控对应的 TM；</li>
<li><code>disconnectResourceManager()</code>: 与 ResourceManager 断开连接，这个是有三种情况会触发，JM 与 ResourceManager 心跳超时、作业取消、重连 RM 时会断开连接（比如：RM leader 切换、RM 的心跳超时）；</li>
<li><code>heartbeatFromTaskManager()</code>: TM 向 JM 发送心跳信息；</li>
<li><code>heartbeatFromResourceManager()</code>: JM 向 ResourceManager 发送一个心跳信息，ResourceManager 只会监听 JM 是否超时；</li>
<li><code>requestJobDetails()</code>: 请求这个作业的 <code>JobDetails</code>（作业的概况信息，比如：作业执行了多长时间、作业状态等）；</li>
<li><code>requestJobStatus()</code>: 请求这个作业的执行状态 <code>JobStatus</code>；</li>
<li><code>requestJob()</code>: 请求这个作业的 <code>ArchivedExecutionGraph</code>（它是 <code>ExecutionGraph</code> 序列化之后的结果）；</li>
<li><code>triggerSavepoint()</code>: 对这个作业触发一次 savepoint；</li>
<li><code>stopWithSavepoint()</code>: 停止作业前触发一次 savepoint（触发情况是：用户手动停止作业时指定一个 savepoint 路径，这样的话，会在停止前做一次 savepoint）；</li>
<li><code>requestOperatorBackPressureStats()</code>: 汇报某个 operator 反压的情况；</li>
<li><code>notifyAllocationFailure()</code>: 如果 RM 分配 slot 失败的话，将会通过这个接口通知 JM；</li>
</ol>
<p>这里可以看到有部分接口的方法是在跟 RM 通信使用的，所以在 RM 的接口中也可以看到对应的方法。另外，JobMaster 上面这些方法在实现时基本都是在调用 <code>LegacyScheduler</code> 或 <code>SlotPool</code> 的具体实现方法来实现的。</p>
<h3 id="SlotPool"><a href="#SlotPool" class="headerlink" title="SlotPool"></a>SlotPool</h3><p>SlotPool 是为当前作业的 slot 请求而服务的，它会向 ResourceManager 请求 slot 资源；SlotPool 会维护请求到的 slot 列表信息（即使 ResourceManager 挂掉了，SlotPool 也可以使用当前作业空闲的 slot 资源进行分配），而如果一个 slot 不再使用的话，即使作业在运行，也是可以释放掉的（所有的 slot 都是通过 <code>AllocationID</code> 来区分的）。</p>
<p>目前 SlotPool 提供的 API 列表如下：</p>
<ol>
<li><code>connectToResourceManager()</code>: SlotPool 与 ResourceManager 建立连接，之后 SlotPool 就可以向 ResourceManager 请求 slot 资源了；</li>
<li><code>disconnectResourceManage()</code>: SlotPool 与 ResourceManager 断开连接，这个方法被调用后，SlotPool 就不能从 ResourceManager 请求 slot 资源了，并且所有正在排队等待的 Slot Request 都被取消；</li>
<li><code>allocateAvailableSlot()</code>: 将指定的 Slot Request 分配到指定的 slot 上，这里只是记录其对应关系（哪个 slot 对应哪个 slot 请求）；</li>
<li><code>releaseSlot()</code>: 释放一个 slot； </li>
<li><code>requestNewAllocatedSlot()</code>: 从 RM 请求一个新的 slot 资源分配，申请到的 slot 之后也会添加到 SlotPool 中；</li>
<li><code>requestNewAllocatedBatchSlot()</code>: 上面的方法是 Stream 类型，这里是 batch 类型，但向 RM 申请的时候，这里并没有区别，只是为了做相应的标识；</li>
<li><code>getAvailableSlotsInformation()</code>: 获取当前可用的 slot 列表；</li>
<li><code>failAllocation()</code>: 分配失败，并释放相应的 slot，可能是因为请求超时由 JM 触发或者 TM 分配失败；</li>
<li><code>registerTaskManager()</code>: 注册 TM，这里会记录一下注册过来的 TM，只能向注册过来的 TM 分配 slot；</li>
<li><code>releaseTaskManager()</code>: 注销 TM，这个 TM 相关的 slot 都会被释放，task 将会被取消，SlotPool 会通知相应的 TM 释放其 slot；</li>
<li><code>createAllocatedSlotReport()</code>: 汇报指定 TM 上的 slot 分配情况；</li>
</ol>
<p>通过上面 SlotPool 对外提供的 API 列表，可以看到其相关方法都是跟 Slot 相关的，整体可以分为下面几部分：</p>
<ol>
<li>与 ResourceManager 建立/取消 连接；</li>
<li>注册/注销 TM，这里只是记录注册过 TM 列表，只有是注册过的 TM 才允许使用其上面的 slot 资源；</li>
<li>向 ResourceManager 请求 slot 资源；</li>
<li>分配/释放 slot，这里只是更新其状态信息，并不做实质的操作。</li>
</ol>
<p>SlotPool 这里，更多只是维护一个状态信息，以及与 ResourceManager（请求 slot 资源）和 TM（释放对应的 slot）做一些交互工作，它对这些功能做了相应的封装，方便 JobMaster 来调用。</p>
<h3 id="LegacyScheduler"><a href="#LegacyScheduler" class="headerlink" title="LegacyScheduler"></a>LegacyScheduler</h3><p>如前面所述，LegacyScheduler 其实是对 <code>ExecutionGraph</code> 和 <code>BackPressureStatsTracker</code> 方法的一个抽象，它还负责为作业创建对应的 ExecutionGraph 以及对这个作业进行调度。关于 LegacyScheduler 提供的 API 这里就不再展开，有兴趣的可以直接看下源码，它提供的大部分 API 都是在 JobMaster 的 API 列表中，因为 JobMaster 的很多方法实现本身就是调用 LegacyScheduler 对应的方法。</p>
<h2 id="作业调度的详细流程"><a href="#作业调度的详细流程" class="headerlink" title="作业调度的详细流程"></a>作业调度的详细流程</h2><p>有了前面的讲述，这里看下一个新提交的作业，JobMaster 是如何调度起来的。当 JobMaster 调用 LegacyScheduler 的 <code>startScheduling()</code> 方法后，就会开始对这个作业进行相应的调度，申请对应的 slot，并部署 task，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LegacyScheduler.java</span></span><br><span class="line"><span class="comment">//note: ExecutionGraph 开始调度</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScheduling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//note: 启动这个线程</span></span><br><span class="line">    mainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//note: 调度这个 graph</span></span><br><span class="line">        executionGraph.scheduleForExecution();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        executionGraph.failGlobal(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个作业开始调度后详细流程如下图所示（其中比较核心方法已经标成黄颜色）：</p>
<p><img src="/images/flink/6-job-schedule.png" alt="一个作业调度的详细流程"></p>
<p>ExecutionGraph 通过 <code>scheduleForExecution()</code> 方法对这个作业调度执行，其方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/note: 把 CREATED 状态转换为 RUNNING 状态，并做相应的调度，如果有异常这里会抛出</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleForExecution</span><span class="params">()</span> <span class="keyword">throws</span> JobException </span>&#123;</span><br><span class="line"></span><br><span class="line">    assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentGlobalModVersion = globalModVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//note: 先将作业状态转移为 RUNNING</span></span><br><span class="line">    <span class="keyword">if</span> (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 这里会真正调度相应的 Execution Graph</span></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Void&gt; newSchedulingFuture = SchedulingUtils.schedule(</span><br><span class="line">            scheduleMode,</span><br><span class="line">            getAllExecutionVertices(),</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state == JobStatus.RUNNING &amp;&amp; currentGlobalModVersion == globalModVersion) &#123;</span><br><span class="line">            schedulingFuture = newSchedulingFuture;</span><br><span class="line">            <span class="comment">//note: 前面调度完成后，如果最后的结果有异常，这里会做相应的处理</span></span><br><span class="line">            newSchedulingFuture.whenComplete(</span><br><span class="line">                (Void ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(strippedThrowable <span class="keyword">instanceof</span> CancellationException)) &#123;</span><br><span class="line">                            <span class="comment">// only fail if the scheduling future was not canceled</span></span><br><span class="line">                            failGlobal(strippedThrowable);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newSchedulingFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Job may only be scheduled from state "</span> + JobStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合前面图中的流程，接下来，看下这个作业在 SchedulingUtils 中是如何调度的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SchedulingUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScheduleMode scheduleMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Iterable&lt;ExecutionVertex&gt; vertices,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ExecutionGraph executionGraph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (scheduleMode) &#123;</span><br><span class="line">        <span class="comment">// LAZY 的意思是：是有上游数据就绪后，下游的 task 才能调度，这个主要是批场景会用到，流不能走这个模式</span></span><br><span class="line">        <span class="keyword">case</span> LAZY_FROM_SOURCES:</span><br><span class="line">        <span class="keyword">case</span> LAZY_FROM_SOURCES_WITH_BATCH_SLOT_REQUEST:</span><br><span class="line">            <span class="keyword">return</span> scheduleLazy(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流默认的是这个调度模式</span></span><br><span class="line">        <span class="keyword">case</span> EAGER:</span><br><span class="line">            <span class="keyword">return</span> scheduleEager(vertices, executionGraph);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Schedule mode %s is invalid."</span>, scheduleMode));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedule vertices eagerly. That means all vertices will be scheduled at once.</span></span><br><span class="line"><span class="comment"> * note: 所有的节点会被同时调度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vertices Topologically sorted vertices to schedule.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executionGraph The graph the given vertices belong to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">scheduleEager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Iterable&lt;ExecutionVertex&gt; vertices,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ExecutionGraph executionGraph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    executionGraph.assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">    checkState(executionGraph.getState() == JobStatus.RUNNING, <span class="string">"job is not running currently"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important: reserve all the space we need up front.</span></span><br><span class="line">    <span class="comment">// that way we do not have any operation that can fail between allocating the slots</span></span><br><span class="line">    <span class="comment">// and adding them to the list. If we had a failure in between there, that would</span></span><br><span class="line">    <span class="comment">// cause the slots to get lost</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// collecting all the slots may resize and fail in that operation without slots getting lost</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;CompletableFuture&lt;Execution&gt;&gt; allAllocationFutures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SlotProviderStrategy slotProviderStrategy = executionGraph.getSlotProviderStrategy();</span><br><span class="line">    <span class="keyword">final</span> Set&lt;AllocationID&gt; allPreviousAllocationIds = Collections.unmodifiableSet(</span><br><span class="line">        computePriorAllocationIdsIfRequiredByScheduling(vertices, slotProviderStrategy.asSlotProvider()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the slots (obtain all their futures)</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutionVertex ev : vertices) &#123;</span><br><span class="line">        <span class="comment">// these calls are not blocking, they only return futures</span></span><br><span class="line">        <span class="comment">//note: 给每个 Execution 分配相应的资源</span></span><br><span class="line">        CompletableFuture&lt;Execution&gt; allocationFuture = ev.getCurrentExecutionAttempt().allocateResourcesForExecution(</span><br><span class="line">            slotProviderStrategy,</span><br><span class="line">            LocationPreferenceConstraint.ALL,</span><br><span class="line">            allPreviousAllocationIds);</span><br><span class="line"></span><br><span class="line">        allAllocationFutures.add(allocationFuture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this future is complete once all slot futures are complete.</span></span><br><span class="line">    <span class="comment">// the future fails once one slot future fails.</span></span><br><span class="line">    <span class="keyword">final</span> ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allAllocationsFuture.thenAccept(</span><br><span class="line">        (Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (Execution execution : executionsToDeploy) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//note: 部署每个 Execution</span></span><br><span class="line">                    execution.deploy();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(</span><br><span class="line">                        <span class="keyword">new</span> FlinkException(</span><br><span class="line">                            String.format(<span class="string">"Could not deploy execution %s."</span>, execution),</span><br><span class="line">                            t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Generate a more specific failure message for the eager scheduling</span></span><br><span class="line">        .exceptionally(</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于对于流作业来说，它默认的调度模式（<code>ScheduleMode</code>）是 <code>ScheduleMode.EAGER</code>，也就是说，所有 task 会同时调度起来，上面的代码里也可以看到调度的时候有两个主要方法：</p>
<ol>
<li><code>allocateResourcesForExecution()</code>: 它的作用是给这个 Execution 分配资源，获取要分配的 slot（它还会向 ShuffleMaster 注册 produced partition，这个 shuffle 部分内容后面文章再讲述，这里就不展开了）；</li>
<li><code>deploy()</code>: 这个方法会直接向 TM 提交这个 task 任务；</li>
</ol>
<p>这里，主要展开一下 <code>allocateResourcesForExecution()</code> 方法的实现，<code>deploy()</code> 的实现将会在后面 TaskManager 这篇文章中讲述。</p>
<h3 id="如何给-ExecutionVertex-分配-slot"><a href="#如何给-ExecutionVertex-分配-slot" class="headerlink" title="如何给 ExecutionVertex 分配 slot"></a>如何给 ExecutionVertex 分配 slot</h3><p>通过前面的代码，我们知道，<code>allocateResourcesForExecution()</code> 方法会给每一个 ExecutionVertex 分配一个 slot，而它具体是如何分配的，这个流程是在 Execution 的 <code>allocateAndAssignSlotForExecution()</code> 方法中实现的，代码如下如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates and assigns a slot obtained from the slot provider to the execution.</span></span><br><span class="line"><span class="comment"> * note: 从 slot provider 获取一个 slot，将任务分配到这个 slot 上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slotProviderStrategy to obtain a new slot from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locationPreferenceConstraint constraint for the location preferences</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.</span></span><br><span class="line"><span class="comment"> *                                                 Can be empty if the allocation ids are not required for scheduling.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Future which is completed with the allocated slot once it has been assigned</span></span><br><span class="line"><span class="comment"> *          or with an exception if an error occurred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;LogicalSlot&gt; <span class="title">allocateAndAssignSlotForExecution</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SlotProviderStrategy slotProviderStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">        LocationPreferenceConstraint locationPreferenceConstraint,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(slotProviderStrategy);</span><br><span class="line"></span><br><span class="line">    assertRunningInJobMasterMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//note: 获取这个 vertex 的相关信息</span></span><br><span class="line">    <span class="keyword">final</span> SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();</span><br><span class="line">    <span class="keyword">final</span> CoLocationConstraint locationConstraint = vertex.getLocationConstraint();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    <span class="comment">//note: 做相应的检查</span></span><br><span class="line">    <span class="keyword">if</span> (locationConstraint != <span class="keyword">null</span> &amp;&amp; sharingGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Trying to schedule with co-location constraint but without slot sharing allowed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this method only works if the execution is in the state 'CREATED'</span></span><br><span class="line">    <span class="comment">//note: 这个只会在 CREATED 下工作</span></span><br><span class="line">    <span class="keyword">if</span> (transitionState(CREATED, SCHEDULED)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SlotSharingGroupId slotSharingGroupId = sharingGroup != <span class="keyword">null</span> ? sharingGroup.getSlotSharingGroupId() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 创建一个 ScheduledUnit 对象（跟 sharingGroup/locationConstraint 都有关系）</span></span><br><span class="line">        ScheduledUnit toSchedule = locationConstraint == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">new</span> ScheduledUnit(<span class="keyword">this</span>, slotSharingGroupId) :</span><br><span class="line">                <span class="keyword">new</span> ScheduledUnit(<span class="keyword">this</span>, slotSharingGroupId, locationConstraint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to extract previous allocation ids, if applicable, so that we can reschedule to the same slot</span></span><br><span class="line">        <span class="comment">//note: 如果能找到之前调度的 AllocationID，会尽量先重新调度在同一个 slot 上</span></span><br><span class="line">        ExecutionVertex executionVertex = getVertex();</span><br><span class="line">        AllocationID lastAllocation = executionVertex.getLatestPriorAllocation();</span><br><span class="line"></span><br><span class="line">        Collection&lt;AllocationID&gt; previousAllocationIDs =</span><br><span class="line">            lastAllocation != <span class="keyword">null</span> ? Collections.singletonList(lastAllocation) : Collections.emptyList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the preferred locations</span></span><br><span class="line">        <span class="comment">//note: 这里先根据 state 和上游数据的输入节点获取这个 Task Execution 的最佳 TM location</span></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; preferredLocationsFuture =</span><br><span class="line">            calculatePreferredLocations(locationPreferenceConstraint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SlotRequestId slotRequestId = <span class="keyword">new</span> SlotRequestId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//note: 根据指定的需求分配这个 slot</span></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;LogicalSlot&gt; logicalSlotFuture =</span><br><span class="line">            preferredLocationsFuture.thenCompose(</span><br><span class="line">                (Collection&lt;TaskManagerLocation&gt; preferredLocations) -&gt;</span><br><span class="line">                    slotProviderStrategy.allocateSlot(</span><br><span class="line">                        slotRequestId,</span><br><span class="line">                        toSchedule,</span><br><span class="line">                        <span class="keyword">new</span> SlotProfile(</span><br><span class="line">                            vertex.getResourceProfile(),</span><br><span class="line">                            preferredLocations,</span><br><span class="line">                            previousAllocationIDs,</span><br><span class="line">                            allPreviousExecutionGraphAllocationIds)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register call back to cancel slot request in case that the execution gets canceled</span></span><br><span class="line">        releaseFuture.whenComplete(</span><br><span class="line">            (Object ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (logicalSlotFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">                    slotProviderStrategy.cancelSlotRequest(</span><br><span class="line">                        slotRequestId,</span><br><span class="line">                        slotSharingGroupId,</span><br><span class="line">                        <span class="keyword">new</span> FlinkException(<span class="string">"Execution "</span> + <span class="keyword">this</span> + <span class="string">" was released."</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This forces calls to the slot pool back into the main thread, for normal and exceptional completion</span></span><br><span class="line">        <span class="comment">//note: 返回 LogicalSlot</span></span><br><span class="line">        <span class="keyword">return</span> logicalSlotFuture.handle(</span><br><span class="line">            (LogicalSlot logicalSlot, Throwable failure) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(failure);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tryAssignResource(logicalSlot)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> logicalSlot;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// release the slot</span></span><br><span class="line">                    logicalSlot.releaseSlot(<span class="keyword">new</span> FlinkException(<span class="string">"Could not assign logical slot to execution "</span> + <span class="keyword">this</span> + <span class="string">'.'</span>));</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(</span><br><span class="line">                        <span class="keyword">new</span> FlinkException(</span><br><span class="line">                            <span class="string">"Could not assign slot "</span> + logicalSlot + <span class="string">" to execution "</span> + <span class="keyword">this</span> + <span class="string">" because it has already been assigned "</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// call race, already deployed, or already done</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalExecutionStateException(<span class="keyword">this</span>, CREATED, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，简单总结一下上面这个方法的流程：</p>
<ol>
<li>状态转换，将这个 Execution 的状态（<code>ExecutionState</code>）从 <code>CREATED</code> 转为 <code>SCHEDULED</code> 状态；</li>
<li>根据是否是一个有状态的 operator 以及它上游输入节点位置，来计算一个最佳的 TM 位置列表（<code>TaskManagerLocation</code>）列表；</li>
<li>如果这个 Execution 之前有调度记录，也就是说，这次由 failover 导致的重启，这里会拿到上次调度的 TM 位置信息；</li>
<li>根据 2、3 拿到 TM 位置信息，去调用 SlotProviderStrategy 的 <code>allocateSlot()</code> 获取要分配的 slot。</li>
</ol>
<p>在 SchedulerImpl 去分配 slot 的时候，其实是会分两种情况的：</p>
<ol>
<li><code>allocateSingleSlot()</code>: 如果对应的 task 节点没有设置 SlotSharingGroup，会直接走这个方法，就不会考虑 share group 的情况，直接给这个 task 分配对应的 slot；</li>
<li><code>allocateSharedSlot()</code>: 如果对应的 task 节点有设置 SlotSharingGroup，就会走到这个方法，在分配 slot 的时候，考虑的因素就会多一些。</li>
</ol>
<h3 id="分配时如何选择最优的-TM-列表"><a href="#分配时如何选择最优的-TM-列表" class="headerlink" title="分配时如何选择最优的 TM 列表"></a>分配时如何选择最优的 TM 列表</h3><p>这里，我们先来看下如何给这个 slot 选择一个最佳的 TM 列表，具体的方法实现是在 <code>Execution</code> 中的 <code>calculatePreferredLocations()</code> 方法中实现的，其具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execution.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculates the preferred locations based on the location preference constraint.</span></span><br><span class="line"><span class="comment"> * note: 根据 LocationPreferenceConstraint 策略计算前置输入节点的 TaskManagerLocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locationPreferenceConstraint constraint for the location preference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Future containing the collection of preferred locations. This might not be completed if not all inputs</span></span><br><span class="line"><span class="comment"> *      have been a resource assigned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) &#123;</span><br><span class="line">    <span class="comment">//note: 获取一个最佳分配的 TM location 集合</span></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; preferredLocationFutures = getVertex().getPreferredLocations();</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; preferredLocationsFuture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(locationPreferenceConstraint) &#123;</span><br><span class="line">        <span class="keyword">case</span> ALL:</span><br><span class="line">            <span class="comment">//note: 默认是 ALL，就是前面拿到的列表，这里都可以使用</span></span><br><span class="line">            preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ANY:</span><br><span class="line">            <span class="comment">//note: 遍历所有 input，先获取已经完成 assign 的 input 列表</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;TaskManagerLocation&gt; completedTaskManagerLocations = <span class="keyword">new</span> ArrayList&lt;&gt;(preferredLocationFutures.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (CompletableFuture&lt;TaskManagerLocation&gt; preferredLocationFuture : preferredLocationFutures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preferredLocationFuture.isDone() &amp;&amp; !preferredLocationFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">                    <span class="comment">//note: 在这个 future 完成（没有异常的情况下），这里会使用这个 taskManagerLocation 对象</span></span><br><span class="line">                    <span class="keyword">final</span> TaskManagerLocation taskManagerLocation = preferredLocationFuture.getNow(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (taskManagerLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> FlinkRuntimeException(<span class="string">"TaskManagerLocationFuture was completed with null. This indicates a programming bug."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    completedTaskManagerLocations.add(taskManagerLocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            preferredLocationsFuture = CompletableFuture.completedFuture(completedTaskManagerLocations);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown LocationPreferenceConstraint "</span> + locationPreferenceConstraint + <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> preferredLocationsFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的实现可以看出，这里是先通过 <code>ExecutionVertex</code> 的 <code>getPreferredLocations()</code> 方法获取一个 TaskManagerLocation 列表，然后再根据 <code>LocationPreferenceConstraint</code> 的模式做过滤，如果是 <code>ALL</code>，那么前面拿到的所有列表都会直接返回，而如果是 <code>ANY</code>，只会把那些已经分配好的 input 节点的 <code>TaskManagerLocation</code> 返回。</p>
<p>这里，看下 <code>ExecutionVertex</code> 的 <code>getPreferredLocations()</code> 方法的实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecutionVertex.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the overall preferred execution location for this vertex's current execution.</span></span><br><span class="line"><span class="comment"> * The preference is determined as follows:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;If the task execution has state to load (from a checkpoint), then the location preference</span></span><br><span class="line"><span class="comment"> *         is the location of the previous execution (if there is a previous execution attempt).</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;If the task execution has no state or no previous location, then the location preference</span></span><br><span class="line"><span class="comment"> *         is based on the task's inputs.</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * note: 如果这个 task Execution 是从 checkpoint 加载的状态，那么这个 location preference 就是之前执行的状态；</span></span><br><span class="line"><span class="comment"> * note: 如果这个 task Execution 没有状态信息或之前的 location 记录，这个 location preference 依赖于 task 的输入；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;These rules should result in the following behavior:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note: 1. 无状态 task 总是基于与输入共享的方式调度；</span></span><br><span class="line"><span class="comment"> * note: 2. 有状态 task 基于与输入共享的方式来初始化他们最开始的调度；</span></span><br><span class="line"><span class="comment"> * note: 3. 有状态 task 的重复执行会尽量与他们的 state 共享执行；</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;Stateless tasks are always scheduled based on co-location with inputs.</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;Stateful tasks are on their initial attempt executed based on co-location with inputs.</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;Repeated executions of stateful tasks try to co-locate the execution with its state.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; getPreferredLocations() &#123;</span><br><span class="line">    Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; basedOnState = getPreferredLocationsBasedOnState();</span><br><span class="line">    <span class="keyword">return</span> basedOnState != <span class="keyword">null</span> ? basedOnState : getPreferredLocationsBasedOnInputs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the preferred location to execute the current task execution attempt, based on the state that the execution attempt will resume.</span></span><br><span class="line"><span class="comment"> * note: 根据这个 Execution 试图恢复的状态来获取当前 task execution 的首选位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; getPreferredLocationsBasedOnState() &#123;</span><br><span class="line">    TaskManagerLocation priorLocation;</span><br><span class="line">    <span class="keyword">if</span> (currentExecution.getTaskRestore() != <span class="keyword">null</span> &amp;&amp; (priorLocation = getLatestPriorLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(CompletableFuture.completedFuture(priorLocation));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单介绍一下其处理逻辑：</p>
<ol>
<li>如果这个作业是从 Checkpoint 恢复的话，这里会根据它之前的状态信息获取上次的位置信息，直接返回这个位置信息；</li>
<li>另一种情况是，根据这个 ExecutionVertex 的 <code>inputEdges</code>，获取其上游 ExecutionVertex 的位置信息列表，但是如果这个列表的数目超过阈值（默认是 8），就会直接返回 null（上游过于分散，再根据 input 位置信息去分配就没有太大意义了）。</li>
</ol>
<p>可以看出，在选取最优的 TaskManagerLocation 列表时，主要是根据 state 和 input 的位置信息来判断，会优先选择 state，也就是上次 checkpoint 中记录的位置。</p>
<h3 id="最优的-slot-分配算法"><a href="#最优的-slot-分配算法" class="headerlink" title="最优的 slot 分配算法"></a>最优的 slot 分配算法</h3><p>在上面选择了最优的 TaskManagerLocation 列表后，这里来看下如何给 task 选择具体的 slot，这个是在 <code>SlotSelectionStrategy</code> 中的 <code>selectBestSlotForProfile()</code> 方法中做的，目前 <code>SlotSelectionStrategy</code> 有两个实现类：<code>PreviousAllocationSlotSelectionStrategy</code> 和 <code>LocationPreferenceSlotSelectionStrategy</code>，这个是在 <code>state.backend.local-recovery</code> 参数中配置的，默认是 false，选择的是 <code>PreviousAllocationSlotSelectionStrategy</code>，如果配置为 true，那么就会选择 <code>PreviousAllocationSlotSelectionStrategy</code>，这部分的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSchedulerFactory.java</span></span><br><span class="line"><span class="meta">@Nonnull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SlotSelectionStrategy <span class="title">selectSlotSelectionStrategy</span><span class="params">(@Nonnull Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 state.backend.local-recover 配置选择</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getBoolean(CheckpointingOptions.LOCAL_RECOVERY)) &#123;</span><br><span class="line">        <span class="keyword">return</span> PreviousAllocationSlotSelectionStrategy.INSTANCE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LocationPreferenceSlotSelectionStrategy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分别看下这两个实现类的 <code>selectBestSlotForProfile()</code> 的实现逻辑：</p>
<ol>
<li><code>PreviousAllocationSlotSelectionStrategy</code>: 它会根据上次的分配记录，如果这个位置刚好在 SlotPool 的可用列表里，这里就会直接选这个 slot，否则会走到 <code>LocationPreferenceSlotSelectionStrategy</code> 的处理逻辑；</li>
<li><code>LocationPreferenceSlotSelectionStrategy</code>: 这个是对可用的 slot 列表做打分，选择分数最高的（分数相同的话，会选择第一个），如果 slot 在前面得到的最优 <code>TaskManagerLocation</code> 列表中，分数就会比较高。</li>
</ol>
<h3 id="allocateSharedSlot-VS-allocateSingleSlot"><a href="#allocateSharedSlot-VS-allocateSingleSlot" class="headerlink" title="allocateSharedSlot VS allocateSingleSlot"></a>allocateSharedSlot VS allocateSingleSlot</h3><p>在分配 slot 时，这里分为两种情况：</p>
<ol>
<li><code>allocateSingleSlot()</code>: 如果没有设置 SlotSharingGroup 将会走到这个方法，直接给这个 SlotRequestId 分配一个 slot，具体选择哪个 slot 就是上面的逻辑；</li>
<li><code>allocateSharedSlot()</code>: 而如果设置了 SlotSharingGroup 就会走到这里，先根据 <code>SlotSharingGroupId</code> 获取或创建对应的 <code>SlotSharingManager</code>，然后创建（或者根据 <code>SlotSharingGroup</code> 获取）一个的 <code>MultiTaskSlot</code>（每个 <code>SlotSharingGroup</code> 会对应一个 <code>MultiTaskSlot</code> 对象），这里再将这个 task 分配到这个 <code>MultiTaskSlot</code> 上（这个只是简单介绍，后面在调度模型文章中，将会详细讲述）。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，Flink JobManager 的大部分内容已经讲述完了，还有一些小点会在后面的系列文章中再给大家讲述。这里总结一下，JobManager 主要是为一个具体的作业而服务的，它负责这个作业每个 task 的调度、checkpoint/savepoint（后面 checkpoint 的文章中会详述其流程）的触发以及容错恢复，它有两个非常重点的服务组件 —— <code>LegacyScheduler</code> 和 <code>SlotPool</code>，其中：</p>
<ol>
<li><code>LegacyScheduler</code>: 它封装了作业的 <code>ExecutionGraph</code> 以及 <code>BackPressureStatsTracker</code> 中的接口，它会负责这个作业具体调度、savepoint 触发等工作；</li>
<li><code>SlotPool</code>: 它主要负责这个作业 slot 相关的内容，像与 ResourceManager 通信、分配或释放 slot 资源等工作。</li>
</ol>
<p>文章的后半部分，又总结了一个作业是如何调度起来的，首先是分配 slot，最后是通过 <code>deploy()</code> 接口向 TM 提交这个 task，本文着重关注了 slot 的分配，task 的部署将会在下节的 TaskManager 详解中给大家介绍。</p>
<hr>
<p>参考</p>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/internals/job_scheduling.html" target="_blank" rel="external">Jobs and Scheduling</a>；</li>
<li><a href="https://www.cnblogs.com/andyhe/p/10633692.html" target="_blank" rel="external">Flink架构分析之资源分配</a>；</li>
<li><a href="http://chenyuzhao.me/2017/02/08/jobmanager%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/" target="_blank" rel="external">Flink JobManager 基本组件</a>；</li>
<li><a href="https://mp.weixin.qq.com/s/TBzzGTNFTzVLjFQdzz-LuQ" target="_blank" rel="external">Apache Flink 进阶（一）：Runtime 核心机制剖析</a>；</li>
</ul>
</div><div class="copyright"><h2 id="版权说明"><a href="#版权说明" title="版权说明" class="headerlink">版权说明</a></h2><p><strong><big><a href="http://matt33.com/copyright/">博客版权说明</a></big></strong></p><p>所有文章以 <strong><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external">知识共享署名 4.0 国际许可协议 </a></strong>进行授权，转载时请注明原文链接</p></div><div class="weixin"><h2 id="公众号"><a href="#公众号" title="公众号" class="headerlink">公众号</a></h2><p>个人公众号（柳年思水）已经上线，最新文章会同步在公众号发布，欢迎大家关注~</p><p></p><p><img src="/images/wangm92-3.png" style="text-align:center" width="600"></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2019/12/27/flink-jobmanager-6/" data-id="ck99be5c000asi3fyjyc50r0u" class="article-share-link">分享到</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a href="/2020/03/15/flink-taskmanager-7/" class="pre">Flink TaskManager 详解（一）</a><a href="/2019/12/23/flink-master-5/" class="next">Flink Master 详解</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2019/12/27/flink-jobmanager-6/';
var disqus_title = 'Flink JobManager 详解';
var disqus_url = 'http://matt33.com/2019/12/27/flink-jobmanager-6/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/cpu-branch-predictor/">浅谈 CPU 分支预测技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/flink-task-mailbox/">Flink 基于 MailBox 实现的 StreamTask 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/flink-taskmanager-7/">Flink TaskManager 详解（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/flink-jobmanager-6/">Flink JobManager 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/flink-master-5/">Flink Master 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/20/flink-execution-graph-4/">Flink 如何生成 ExecutionGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/flink-job-graph-3/">Flink Streaming 作业如何转化为 JobGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/08/flink-stream-graph-2/">Flink DataStream API 概述及作业如何转换为 StreamGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/flink-learn-start-1/">Apache Flink 初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/paper-chandy-lamport/">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>