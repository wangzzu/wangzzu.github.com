<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">王蒙</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow</h1><div class="post-meta">Oct 20, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">3,270</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2019/10/20/paper-flink-snapshot/" href="/2019/10/20/paper-flink-snapshot/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-number">1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#业内现状"><span class="toc-number">2.</span> <span class="toc-text">业内现状</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案：Asynchronous-Barrier-Snapshot（ABS）"><span class="toc-number">3.</span> <span class="toc-text">解决方案：Asynchronous Barrier Snapshot（ABS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-Definition"><span class="toc-number">3.1.</span> <span class="toc-text">Problem Definition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABS-for-Acyclic-Dataflows：非环-dataflow-中的-ABS-实现"><span class="toc-number">3.2.</span> <span class="toc-text">ABS for Acyclic Dataflows：非环 dataflow 中的 ABS 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABS-for-Cyclic-Dataflows：有环-dataflow-中的-ABS-实现"><span class="toc-number">3.3.</span> <span class="toc-text">ABS for Cyclic Dataflows：有环 dataflow 中的 ABS 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Failure-Recovery"><span class="toc-number">3.4.</span> <span class="toc-text">Failure Recovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能测试"><span class="toc-number">3.5.</span> <span class="toc-text">性能测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>本篇文章是对 <a href="https://arxiv.org/pdf/1506.08603.pdf" target="_blank" rel="external">Lightweight Asynchronous Snapshots for Distributed Dataflow</a> 的一个总结，从文章题目也可以看出文章的主题 —— 分布式 dataflow 的轻量级异步 snapshot 算法，它是 Flink 团队在 2015 年发表的论文，主要讲述了对于 Streaming System 如何做 snapshot 的，它选取的是 Chandy-Lamport 算法（论文见 <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Determining-Global-States-of-a-Distributed-System.pdf" target="_blank" rel="external"> Distributed Snapshots: Determining Global States of Distributed Systems</a>），关于这个算法后面会单独一篇文章来总结。在 <a href="https://arxiv.org/pdf/1506.08603.pdf" target="_blank" rel="external">Lightweight Asynchronous Snapshots for Distributed Dataflow</a> 这篇论文中，作者更多向我们表达的是 Chandy-Lamport 算法如何在 Flink 中落地的以及如何解决分布式 dataflow 做 snapshot 时遇到的痛点。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>分布式有状态的流处理允许在云上部署和执行大规模的流数据计算，并且要求低延迟和高吞吐。这种模式一个比较大的挑战，就是其容错能力，能够应对潜在的 failure。当前业内的方案都是依赖<strong>周期性地全局状态的 snapshot </strong> 做 failure recovery。但这种方案有两个非常大的缺陷：</p>
<ol>
<li>它们在做 snapshot 时会影响当前计算（目前的算法都是同步 snapshot）；</li>
<li>它们在当前 Operator State 中会把未处理和正在传输过程中的 record 做为 snapshot 的一部分持久化，这会导致 snapshot 非常大，记录了很多其实并不需要的数据。</li>
</ol>
<p>本篇论文中提出了一个新的  global consistent snapshot 算法 —— <strong>Asynchronous Barrier Snapshot（ABS）</strong>，它是一个轻量级的算法，非常适合现代 dataflow 系统，数据存储空间占用也非常小（论文原话是 <code>Our solution provides asynchronous state snapshots with low space costs that contain only operator states in acyclic execution topologies.</code>）。另外，这个算法不会影响作业计算，性能开销比较小。</p>
<h2 id="业内现状"><a href="#业内现状" class="headerlink" title="业内现状"></a>业内现状</h2><p>在过去的几十年中，关于连续处理系统的 recovery 机制，工业界和学术界提出了很多种解决办法，如：<a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Determining-Global-States-of-a-Distributed-System.pdf" target="_blank" rel="external"> Distributed Snapshots: Determining Global States of Distributed Systems</a>） 和 <a href="http://sigops.org/s/conferences/sosp/2013/papers/p439-murray.pdf" target="_blank" rel="external">Naiad: A Timely Dataflow System</a>。有一些系统如  Discretized Streams 和 Comet 会把连续处理当作 无状态的分布式批处理计算 来做状态恢复；对于有状态的 dataflow 系统，如：Naiad、SDGs、Piccolo 和 SEEP，它们是我们的主要关注点，它们使用 checkpoint 获取全局一致的 snapshot 来做故障恢复。</p>
<p>关于 <strong>consistent global snapshot</strong> 的问题，自从在 Chandy 和 Lamport 的论文中提出来后，过去二十多年一直在被广泛地研究。全局 snapshot 理论上反映了作业执行的总体状态以及 operator 实例的可能状态。对于全局一致性 snapshot 算法，Naiad 中提出了一个简单但代价非常高昂的实现方案：</p>
<ol>
<li>第一步，先停止计算；</li>
<li>第二步，开始做 snapshot；</li>
<li>第三步，如果 snapshot 完成了，每个 task 再恢复之前的计算。</li>
</ol>
<p>这个实现方案对吞吐和空间占用都有很大的影响，它并不是一个很好的方案。另一个实现方案，就是 Chandy-Lamport 算法，当前它已经应用在很多的系统中，<strong>它是异步地执行快照，并且要求上游数据源可以回溯</strong>（也就是要求数据源能够自己备份）。它是通过在数据流中发送 marker 来实现，marker 会触发 operator 和 state 的 snapshot。但这种算法还需要额外的存储空间用于上游数据量恢复，数据流的重新计算也会导致恢复时间较长（主要还是原生算法会对一些 record 也做相应的 snapshot，这会导致存储空间占用过高以及恢复时间过长）。本论文中提出的方案扩展了原生的 Chandy-Lamport 算法，但对于无环 graph 它不会备份未处理及通道中正在传输的 record，对于有环的 graph，它也只需要很少量的 record 备份。</p>
<h2 id="解决方案：Asynchronous-Barrier-Snapshot（ABS）"><a href="#解决方案：Asynchronous-Barrier-Snapshot（ABS）" class="headerlink" title="解决方案：Asynchronous Barrier Snapshot（ABS）"></a>解决方案：Asynchronous Barrier Snapshot（ABS）</h2><p>因为这个算法的实现本身就是为了解决 <a href="https://flink.apache.org/" target="_blank" rel="external">Apache Flink</a> 的容错问题，论文中的描述也是以 Flink 系统为例，所以想要搞明白这个算法还是需要一些 Flink 的基础，本文中，我们就不再对 Flink 展开了。这里只简单介绍一下，有兴趣的可以看下官网资料，Flink 是一个可用于 Streaming 和 Batch 处理的大数据处理引擎，它本身的设计也是深受 Google DataFlow 模型的影响，可以说 Flink 是开源系统中最接近 DataFlow 思想的一个计算引擎。另外，Flink 的作业，在提交的时候都会被翻译成一个有向无环图（DAG），对于 Flink Master 来说，提交过来的作业都是一个 graph。</p>
<h3 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h3><p>这里，我们这样定义一个 global snapshot（它需要包含所有的状态信息，这样才能保证 failover 之后能够正确恢复状态）：</p>
<p>$G^*=(T^*, E^*)$</p>
<p>它代表一个 execution graph $G = (T, E)$ 的一个全局快照，$T^*$ 代表所有 task 状态的集合，$E^*$ 代表所有 edge 状态的集合。也就是说：</p>
<ol>
<li>$∀t ∈ T, s_t^∗ ∈ T^∗$，$T^*$ 会包含所有 Operator 的状态；</li>
<li>$E^*$ 会包含所有 channel 状态的集合，$e^*$ 会包含 $e$ 中正在传输的所有 record。</li>
</ol>
<p>为了能够保证 recovery 后正确恢复状态信息，对于每个 $G^*$，都需要保证以下两个特性：</p>
<ol>
<li>Termination：snapshot 能够在一定的时间内完成；</li>
<li>Feasibility：它表示这个 snapshot 是有意义的，也就是说在 snapshot 期间尽管计算没有停止，也不会有任何信息丢失。</li>
</ol>
<h3 id="ABS-for-Acyclic-Dataflows：非环-dataflow-中的-ABS-实现"><a href="#ABS-for-Acyclic-Dataflows：非环-dataflow-中的-ABS-实现" class="headerlink" title="ABS for Acyclic Dataflows：非环 dataflow 中的 ABS 实现"></a>ABS for Acyclic Dataflows：非环 dataflow 中的 ABS 实现</h3><p>这里先看下在无环 dataflow 中 ABS 是如何实现的，因为 Flink 只支持有向无环图，所以这个就是 Flink checkpoint 的实现方案。</p>
<p>当把一个作业的执行逻辑划分为多个 stage 时，做 snapshot 不存储 channel 中的 state 是完全有可能的。如果一个 operator 已经完成了对输入的所有计算，并且数据已经完全输出出去，那么只对 operator 的 state 做 snapshot 就可以达到我们的要求。</p>
<p>具体的实现就是：每个阶段的输入数据都会被周期性地插入一些特殊标记 —— <strong>barrier</strong>，这些 barrier 会推送到整个 dataflow 中直到 sink 节点（dataflow 中结束节点，它没有下游输出），每个 task 如果收到输入所有的 barrier 就开始做相应的 snapshot。这个算法的实现是有以下假设的：</p>
<ol>
<li>网络传输是可靠的、可以做到 FIFO 传输，并且可以实现 <code>blocked</code> 和 <code>unblocked</code>，如果一个通道是 <code>blocked</code>，它会把这个通道接收到的所有数据缓存起来先不发送，直接收到 <code>unblocked</code> 的信号才会发送；</li>
<li>Task 可以在其对应的 channel 触发以下三种操作：<code>blocked</code>、<code>unblocked</code> 和 <code>send</code> msgs，<code>Broadcasting</code> msgs 表示的是向下游所有的 channel 发送数据；</li>
<li>对于 source 节点来说，输入节点被抽象为 <code>Nil</code> 输入通道（一个虚拟通道）。</li>
</ol>
<p>这个算法的伪代码如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 1 Asynchronous Barrier Snapshotting for Acyclic Execution Graphs</span></span><br><span class="line">1: upon event &lt;Init | input_channels, output_channels, fun, init_statei&gt; <span class="keyword">do</span></span><br><span class="line">2:     state := init_state; blocked_inputs := 0;</span><br><span class="line">3:     inputs := input_channels;</span><br><span class="line">4:     out_puts := output_channels; udf := fun;</span><br><span class="line">5:</span><br><span class="line">6: upon event &lt;receive | input, &lt;barrier&gt;&gt; <span class="keyword">do</span></span><br><span class="line">7:     <span class="keyword">if</span> input != Nil <span class="keyword">then</span> <span class="comment"># 非 source 节点收到 barrier 时，会先阻塞当前 channel</span></span><br><span class="line">8:         blocked_inputs := blocked_inputs ∪</span><br><span class="line">&#123;input&#125;;</span><br><span class="line">9:         trigger &#123;block | input&#125;;</span><br><span class="line">10:     <span class="keyword">if</span> blocked_inputs = inputs <span class="keyword">then</span> <span class="comment"># 只有所有的 input 都收到 barrier</span></span><br><span class="line">11:         blocked_inputs := 0;</span><br><span class="line">12:         broadcast &#123;send | outputs, &lt;barrier&gt;&gt;; <span class="comment"># 把 barrier 广播到下游所有节点</span></span><br><span class="line">13:         trigger &#123;snapshot | state&#125;; <span class="comment"># 触发 snapshot</span></span><br><span class="line">14:         <span class="keyword">for</span> each inputs as input <span class="comment"># unblock 所有 blocked 的通道</span></span><br><span class="line">15:             trigger &lt;unblock | input&gt;;</span><br><span class="line">16:</span><br><span class="line">17:</span><br><span class="line">18: upon event &lt;receive | input, msg&gt; <span class="keyword">do</span> <span class="comment"># 非常 barrier 的数据处理</span></span><br><span class="line">19:     &#123;state1 ,out_records&#125; := udf(msg, state);</span><br><span class="line">20:     state := state1;</span><br><span class="line">21:     <span class="keyword">for</span> each out_records as &#123;out_put, out_record&#125;</span><br><span class="line">22:         trigger &lt;send | output, out record&gt;;</span><br><span class="line">23:</span><br><span class="line">24:</span><br></pre></td></tr></table></figure>
<p>dataflow graph 执行图如下所示：</p>
<p><img src="/images/paper/abs-1.png" alt="Asynchronous barrier snapshots for acyclic graphs"></p>
<p>ABS 算法的执行流程如下：</p>
<ol>
<li>中心协调器周期性地在所有输入端插入 barrier；</li>
<li>当一个 source 节点接收到 barrier 时，它对当前的状态做下 snapshot，并且 broadcast barrier 到所有的下游节点（如上图中的 a 子图）；</li>
<li>当一个非 source 节点从它的输入通道中接收到一个 barrier 时，它会 block 当前的 channel 直到接收该节点所有输入端发送的 barrier（如上图中的 b 子图以及代码第 9 行）；</li>
<li>当从所有输入 channel 都接收到 barrier 之后，这个 task 会对当前状态做一个 snapshot，并且 broadcast 这个 barrier 到所有的输出端（如上图中的 c 子图以及代码第 12-13 行）；</li>
<li>最后，这个 task 会 unblock 它所有的输入 channel，继续进行计算（如上图中的 d 子图以及代码第 15 行）。</li>
</ol>
<p>根据前面所示，我们知道，当前一个完整的 snapshot $G^* = (T^*, E^*)$，其 $E^* =0$，Operator 中的 state 信息就是完整的 snapshot。</p>
<p>对于 Termination 要求，它依赖于 channel 的可靠性以及 graph 的无环性；对于 Feasibility 要求，它依赖于 channel 的 FIFO 特性。只要这些是可以满足的，那么这两个要求就是可以满足的。</p>
<h3 id="ABS-for-Cyclic-Dataflows：有环-dataflow-中的-ABS-实现"><a href="#ABS-for-Cyclic-Dataflows：有环-dataflow-中的-ABS-实现" class="headerlink" title="ABS for Cyclic Dataflows：有环 dataflow 中的 ABS 实现"></a>ABS for Cyclic Dataflows：有环 dataflow 中的 ABS 实现</h3><p>前面分析完无环的情况，接下来再来看看有环的情况，当前的 ABS 算法稍微做些改造也是可以处理有环的情况。根据前面的介绍，有环带来的最大问题是：</p>
<ol>
<li>死锁，一个 task 可能会不断收到 barrier，导致 snapshot 无法在可预期的时间内完成；</li>
<li>当然，有环还会导致另外一个问题，就是数据可能没有记录到 snapshot 中，会导致准确性有误；</li>
</ol>
<p>对于有环的情况，论文是在不引入额外 channel block 的情况下扩展了原来的算法，这里就不再列出伪代码了，有兴趣的可以看下论文，这里以下图为例简单介绍一下：</p>
<ol>
<li>对于有 back-edge 输入的节点（后边节点做输入的情况）来说，一旦它所有正常的输入 channel 都收到了这个 barrier，它会先对本地状态做本地 copy（下图 b）；</li>
<li>从这个时间点开始，这个节点会将从 back-edge channel 接收到的所有数据记录下来直到接收到了相应的 barrier（下图 c），第一步 copy 的状态及第二步记录的数据都会作为 snapshot 的一部分。</li>
</ol>
<p><img src="/images/paper/abs-2.png" alt="Asynchronous barrier snapshots for cyclic graphs"></p>
<p>按照改进后的算法，是可以避免死锁的，这样的话 Termination 的要求是可以满足的；Feasibility 的特性依然是依赖于 channel 的 FIFO 来保证，snapshot 中每个 task state 都会包含该 task 在收到前置节点 barrier 之后的状态，对于有后置节点输入的 task 来说，它会把从后置节点接收到的数据记录下来，只会 copy 非常少量的数据。</p>
<h3 id="Failure-Recovery"><a href="#Failure-Recovery" class="headerlink" title="Failure Recovery"></a>Failure Recovery</h3><p>论文还简单介绍了 Flink 是如何做 failover 恢复的，有了前面的全局一致 snapshot 算法，failover 做起来就简单很多。在 Flink 中，还支持  partial graph recovery，对于失败的 task，只需要恢复它的上游即可，并不需要全局恢复。为了在内部实现 exactly-once，通过给数据进行编号来避免重复数据。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>性能对比了本文提出的 ABS 算法以及 Naiad 中提出的全局同步 snapshot 算法，测试 case 选择了一个有 6 个 operator 的作业，它有三个地方会进行网络 shuffle，这样可以尽量增大 ABS 算法 channel block 带来的影响（如下图 5）。实验中，输入端会模拟 1 百万测试数据，operator 的状态信息主要包括按 key 聚合的中间结果以及 offset 信息，下图的纵坐标是作业运行时间，baseline 表示的是不开启 snapshot 时的性能，在这里做对比使用。</p>
<p><img src="/images/paper/abs-3.png" alt="性能测试结果"></p>
<p>如上图 6，可以看到，当 snapshot 时间间隔非常小，同步的 snapshot 性能非常差，因为它在做 snapshot 会阻塞计算，时间都花费在 snapshot 上了，而 ABS 算法的实验结果就好了很多。如上图 7，集群节点及作业并行度从 5 逐渐增加到 40，可以看到 ABS 算法的性能还很稳定的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇论文是工业界对 Chandy-Lamport 算法实践后做的改进优化，将 Chandy-Lamport 算法在 Flink 的 global consistent snapshot 中落地，这篇论文还是非常值得读一下的，看下 Flink 在解决这个问题的时候是怎么去做的，论文的优化点其实并不是很大，一是把同步变成异步，二是从尽量减小存储空间占用的点出发，最后发现只存储 operator 状态不存储 edge 状态也是完全可以的，而且实践起来的效果确实证明比当时其他系统的算法要好。</p>
<hr>
<p>参考</p>
<ol>
<li><a href="https://arxiv.org/pdf/1506.08603.pdf" target="_blank" rel="external">Lightweight Asynchronous Snapshots for Distributed Dataflow</a>；</li>
<li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Determining-Global-States-of-a-Distributed-System.pdf" target="_blank" rel="external"> Distributed Snapshots: Determining Global States of Distributed Systems</a>）；</li>
<li><a href="http://sigops.org/s/conferences/sosp/2013/papers/p439-murray.pdf" target="_blank" rel="external">Naiad: A Timely Dataflow System</a>；</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2019/10/20/paper-flink-snapshot/" data-id="ck3wirbk70054o7za86qe5csy" class="article-share-link">分享到</a><div class="copyright"><a href="http://matt33.com/copyright/">博客版权说明</a></div><div class="tags"><a href="/tags/paper/">paper</a></div><div class="post-nav"><a href="/2019/10/27/paper-chandy-lamport/" class="pre">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a><a href="/2019/10/19/paper-ray1/" class="next">Paper 阅读: Real-Time Machine Learning: The Missing Pieces</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2019/10/20/paper-flink-snapshot/';
var disqus_title = 'Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow';
var disqus_url = 'http://matt33.com/2019/10/20/paper-flink-snapshot/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/08/flink-stream-graph-2/">Flink DataStream API 概述及 StreamGraph 如何转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/flink-learn-start-1/">Apache Flink 初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/paper-chandy-lamport/">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/paper-flink-snapshot/">Paper 阅读: Lightweight Asynchronous Snapshots for Distributed Dataflow</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/19/paper-ray1/">Paper 阅读: Real-Time Machine Learning: The Missing Pieces</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/apache-calcite-planner/">Apache Calcite 优化器详解（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/bk-store-realize/">BookKeeper 原理浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/effective-learning/">如何高效学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/04/kafka-transaction/">Kafka Exactly-Once 之事务性实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>