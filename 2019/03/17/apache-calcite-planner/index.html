<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Apache Calcite 优化器详解（二） | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Apache Calcite 优化器详解（二）</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">柳年思水</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Apache Calcite 优化器详解（二）</h1><div class="post-meta">Mar 17, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">14,017</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2019/03/17/apache-calcite-planner/" href="/2019/03/17/apache-calcite-planner/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是查询优化器"><span class="toc-number">1.</span> <span class="toc-text">什么是查询优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于规则优化（RBO）"><span class="toc-number">1.1.</span> <span class="toc-text">基于规则优化（RBO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于成本优化（CBO）"><span class="toc-number">1.2.</span> <span class="toc-text">基于成本优化（CBO）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优化规则"><span class="toc-number">2.</span> <span class="toc-text">优化规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#谓词下推（Predicate-Pushdown）"><span class="toc-number">2.1.</span> <span class="toc-text">谓词下推（Predicate Pushdown）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量折叠（Constant-Folding）"><span class="toc-number">2.2.</span> <span class="toc-text">常量折叠（Constant Folding）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列裁剪（Column-Pruning）"><span class="toc-number">2.3.</span> <span class="toc-text">列裁剪（Column Pruning）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Calcite-中的优化器实现"><span class="toc-number">3.</span> <span class="toc-text">Calcite 中的优化器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HepPlanner"><span class="toc-number">3.1.</span> <span class="toc-text">HepPlanner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HepPlanner-中的基本概念"><span class="toc-number">3.1.1.</span> <span class="toc-text">HepPlanner 中的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HepRelVertex"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">HepRelVertex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HepInstruction"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">HepInstruction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HepPlanner-处理流程"><span class="toc-number">3.1.2.</span> <span class="toc-text">HepPlanner 处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-初始化-HepProgram"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1. 初始化 HepProgram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HepPlanner-setRoot（RelNode-–-gt-Graph）"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2. HepPlanner.setRoot（RelNode –> Graph）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HepPlanner-findBestExp-规则优化"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">3. HepPlanner findBestExp 规则优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考"><span class="toc-number">3.1.3.</span> <span class="toc-text">思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-为什么要把-RelNode-转换-HepRelVertex-进行优化？带来的收益在哪里？"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1. 为什么要把 RelNode 转换 HepRelVertex 进行优化？带来的收益在哪里？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VolcanoPlanner"><span class="toc-number">3.2.</span> <span class="toc-text">VolcanoPlanner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VolcanoPlanner-中的基本概念"><span class="toc-number">3.2.1.</span> <span class="toc-text">VolcanoPlanner 中的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RelSet"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">RelSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RelSubset"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">RelSubset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RuleMatch"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">RuleMatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#importance"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">importance</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RelSubset-的-importance"><span class="toc-number">3.2.1.4.1.</span> <span class="toc-text">RelSubset 的 importance</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RuleMatch-的-importance"><span class="toc-number">3.2.1.4.2.</span> <span class="toc-text">RuleMatch 的 importance</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VolcanoPlanner-处理流程"><span class="toc-number">3.2.2.</span> <span class="toc-text">VolcanoPlanner 处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-VolcanoPlanner-初始化"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1. VolcanoPlanner 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RelNode-changeTraits"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2. RelNode changeTraits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-VolcanoPlanner-setRoot"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3. VolcanoPlanner setRoot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-VolcanoPlanner-findBestExp"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">4. VolcanoPlanner findBestExp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一些思考"><span class="toc-number">3.2.3.</span> <span class="toc-text">一些思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-初始化-RuleQueue-时，添加的-one-useless-rule-name-有什么用？"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">1. 初始化 RuleQueue 时，添加的 one useless rule name 有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-四个-phase-实际上只用了-1个阶段，为什么要设置4个阶段？"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2. 四个 phase 实际上只用了 1个阶段，为什么要设置4个阶段？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>紧接上篇文章<a href="http://matt33.com/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a>，这里是 Calcite 系列文章的第二篇，后面还会有文章讲述 Calcite 的实践（包括：如何开发用于 SQL 优化的 Rule）。本篇文章主要介绍 Apache Calcite 优化器部分的内容，会先简单介绍一下 RBO 和 CBO 模型，之后详细讲述 Calcite 关于这两个优化器的实现 —— HepPlanner 和 VolcanoPlanner，文章内容都是个人的一些理解，由于也是刚接触这块，理解有偏差的地方，欢迎指正。</p>
<h1 id="什么是查询优化器"><a href="#什么是查询优化器" class="headerlink" title="什么是查询优化器"></a>什么是查询优化器</h1><p>查询优化器是传统数据库的核心模块，也是大数据计算引擎的核心模块，开源大数据引擎如 Impala、Presto、Drill、HAWQ、 Spark、Hive 等都有自己的查询优化器。Calcite 就是从 Hive 的优化器演化而来的。</p>
<p>优化器的作用：将解析器生成的关系代数表达式转换成执行计划，供执行引擎执行，在这个过程中，会应用一些规则优化，以帮助生成更高效的执行计划。</p>
<blockquote>
<p>关于 Volcano 模型和 Cascades 模型的内容，建议看下相关的论文，这个是 Calcite 优化器的理论基础，代码只是把这个模型落地实现而已。 </p>
</blockquote>
<h2 id="基于规则优化（RBO）"><a href="#基于规则优化（RBO）" class="headerlink" title="基于规则优化（RBO）"></a>基于规则优化（RBO）</h2><p>基于规则的优化器（Rule-Based Optimizer，RBO）：根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会变成另外一个关系表达式，同时原有表达式会被裁剪掉，经过一系列转换后生成最终的执行计划。</p>
<p>RBO 中包含了一套有着严格顺序的优化规则，同样一条 SQL，无论读取的表中数据是怎么样的，最后生成的执行计划都是一样的。同时，在 RBO 中 SQL 写法的不同很有可能影响最终的执行计划，从而影响执行计划的性能。</p>
<h2 id="基于成本优化（CBO）"><a href="#基于成本优化（CBO）" class="headerlink" title="基于成本优化（CBO）"></a>基于成本优化（CBO）</h2><p>基于代价的优化器(Cost-Based Optimizer，CBO)：根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后 CBO 会根据统计信息和代价模型 (Cost Model) 计算每个执行计划的 Cost，从中挑选 Cost 最小的执行计划。</p>
<p>由上可知，CBO 中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响 CBO 选择最优计划。 从上述描述可知，CBO 是优于 RBO 的，原因是 RBO 是一种只认规则，对数据不敏感的呆板的优化器，而在实际过程中，数据往往是有变化的，通过 RBO 生成的执行计划很有可能不是最优的。事实上目前各大数据库和大数据计算引擎都倾向于使用 CBO，但是对于流式计算引擎来说，使用 CBO 还是有很大难度的，因为并不能提前预知数据量等信息，这会极大地影响优化效果，CBO 主要还是应用在离线的场景。</p>
<h1 id="优化规则"><a href="#优化规则" class="headerlink" title="优化规则"></a>优化规则</h1><p>无论是 RBO，还是 CBO 都包含了一系列优化规则，这些优化规则可以对关系表达式进行等价转换，常见的优化规则包含：</p>
<ol>
<li>谓词下推 Predicate Pushdown</li>
<li>常量折叠 Constant Folding</li>
<li>列裁剪 Column Pruning</li>
<li>其他</li>
</ol>
<p>在 Calcite 的代码里，有一个测试类（<code>org.apache.calcite.test.RelOptRulesTest</code>）汇集了对目前内置所有 Rules 的测试 case，这个测试类可以方便我们了解各个 Rule 的作用。在这里有下面一条 SQL，通过这条语句来说明一下上面介绍的这三种规则。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">10</span> + <span class="number">30</span>, users.name, users.age</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">join</span> jobs <span class="keyword">on</span> users.id= user.id</span><br><span class="line"><span class="keyword">where</span> users.age &gt; <span class="number">30</span> <span class="keyword">and</span> jobs.id&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="谓词下推（Predicate-Pushdown）"><a href="#谓词下推（Predicate-Pushdown）" class="headerlink" title="谓词下推（Predicate Pushdown）"></a>谓词下推（Predicate Pushdown）</h2><p>关于谓词下推，它主要还是从关系型数据库借鉴而来，关系型数据中将谓词下推到外部数据库用以减少数据传输；属于逻辑优化，优化器将谓词过滤下推到数据源，使物理执行跳过无关数据。最常见的例子就是 join 与 filter 操作一起出现时，提前执行 filter 操作以减少处理的数据量，将 filter 操作下推，以上面例子为例，示意图如下（对应 Calcite 中的 <code>FilterJoinRule.FilterIntoJoinRule.FILTER_ON_JOIN</code> Rule）：</p>
<p><img src="/images/calcite/6-filter-pushdown.png" alt="Filter操作下推前后的对比"></p>
<p>在进行 join 前进行相应的过滤操作，可以极大地减少参加 join 的数据量。</p>
<h2 id="常量折叠（Constant-Folding）"><a href="#常量折叠（Constant-Folding）" class="headerlink" title="常量折叠（Constant Folding）"></a>常量折叠（Constant Folding）</h2><p>常量折叠也是常见的优化策略，这个比较简单、也很好理解，可以看下 <a href="http://blog.caoxudong.info/blog/2013/10/23/compiler_optimizations_constant_folding" target="_blank" rel="external">编译器优化 – 常量折叠</a> 这篇文章，基本不用动脑筋就能理解，对于我们这里的示例，有一个常量表达式 <code>10 + 30</code>，如果不进行常量折叠，那么每行数据都需要进行计算，进行常量折叠后的结果如下图所示（ 对应 Calcite 中的 <code>ReduceExpressionsRule.PROJECT_INSTANCE</code> Rule）：</p>
<p><img src="/images/calcite/7-constant.png" alt="常量折叠前后的对比"></p>
<h2 id="列裁剪（Column-Pruning）"><a href="#列裁剪（Column-Pruning）" class="headerlink" title="列裁剪（Column Pruning）"></a>列裁剪（Column Pruning）</h2><p>列裁剪也是一个经典的优化规则，在本示例中对于jobs 表来说，并不需要扫描它的所有列值，而只需要列值 id，所以在扫描 jobs 之后需要将其他列进行裁剪，只留下列 id。这个优化带来的好处很明显，大幅度减少了网络 IO、内存数据量的消耗。裁剪前后的示意图如下（不过并没有找到 Calcite 对应的 Rule）：</p>
<p><img src="/images/calcite/8-pruning.png" alt="列裁剪前后的对比"></p>
<h1 id="Calcite-中的优化器实现"><a href="#Calcite-中的优化器实现" class="headerlink" title="Calcite 中的优化器实现"></a>Calcite 中的优化器实现</h1><p>有了前面的基础后，这里来看下 Calcite 中优化器的实现，RelOptPlanner 是 Calcite 中优化器的基类，其子类实现如下图所示：</p>
<p><img src="/images/calcite/9-RelOptPlanner.png" alt="RelOptPlanner"></p>
<p>Calcite 中关于优化器提供了两种实现：</p>
<ol>
<li>HepPlanner：就是前面 RBO 的实现，它是一个启发式的优化器，按照规则进行匹配，直到达到次数限制（match 次数限制）或者遍历一遍后不再出现 rule match 的情况才算完成；</li>
<li>VolcanoPlanner：就是前面 CBO 的实现，它会一直迭代 rules，直到找到 cost 最小的 paln。</li>
</ol>
<blockquote>
<p>前面提到过像calcite这类查询优化器最核心的两个问题之一是怎么把优化规则应用到关系代数相关的RelNode Tree上。所以在阅读calicite的代码时就得带着这个问题去看看它的实现过程，然后才能判断它的代码实现得是否优雅。<br>calcite的每种规则实现类(RelOptRule的子类)都会声明自己应用在哪种RelNode子类上，每个RelNode子类其实都可以看成是一种operator(中文常翻译成算子)。<br>VolcanoPlanner就是优化器，用的是动态规划算法，在创建VolcanoPlanner的实例后，通过calcite的标准jdbc接口执行sql时，默认会给这个VolcanoPlanner的实例注册将近90条优化规则(还不算常量折叠这种最常见的优化)，所以看代码时，知道什么时候注册可用的优化规则是第一步(调用VolcanoPlanner.addRule实现)，这一步比较简单。<br>接下来就是如何筛选规则了，当把语法树转成RelNode Tree后是没有必要把前面注册的90条优化规则都用上的，所以需要有个筛选的过程，因为每种规则是有应用范围的，按RelNode Tree的不同节点类型就可以筛选出实际需要用到的优化规则了。这一步说起来很简单，但在calcite的代码实现里是相当复杂的，也是非常关键的一步，是从调用VolcanoPlanner.setRoot方法开始间接触发的，如果只是静态的看代码不跑起来跟踪调试多半摸不清它的核心流程的。筛选出来的优化规则会封装成VolcanoRuleMatch，然后扔到RuleQueue里，而这个RuleQueue正是接下来执行动态规划算法要用到的核心类。筛选规则这一步的代码实现很晦涩。<br>第三步才到VolcanoPlanner.findBestExp，本质上就是一个动态规划算法的实现，但是最值得关注的还是怎么用第二步筛选出来的规则对RelNode Tree进行变换，变换后的形式还是一棵RelNode Tree，最常见的是把LogicalXXX开头的RelNode子类换成了EnumerableXXX或BindableXXX，总而言之，看看具体优化规则的实现就对了，都是繁琐的体力活。<br>一个优化器，理解了上面所说的三步基本上就抓住重点了。<br>—— 来自【zhh-4096 】的微博</p>
</blockquote>
<p>下面详细讲述一下这两种 planner 在 Calcite 内部的具体实现。</p>
<h2 id="HepPlanner"><a href="#HepPlanner" class="headerlink" title="HepPlanner"></a>HepPlanner</h2><p>使用 HepPlanner 实现的完整代码见 <a href="https://github.com/wangzzu/program-example/blob/master/calcite-example/src/main/java/com/matt/test/calcite/sql/SqlHepTest.java" target="_blank" rel="external">SqlHepTest</a>。</p>
<h3 id="HepPlanner-中的基本概念"><a href="#HepPlanner-中的基本概念" class="headerlink" title="HepPlanner 中的基本概念"></a>HepPlanner 中的基本概念</h3><p>这里先看下 HepPlanner 的一些基本概念，对于后面的理解很有帮助。</p>
<h4 id="HepRelVertex"><a href="#HepRelVertex" class="headerlink" title="HepRelVertex"></a>HepRelVertex</h4><p>HepRelVertex 是对 RelNode 进行了简单封装。HepPlanner 中的所有节点都是 HepRelVertex，每个 HepRelVertex 都指向了一个真正的 RelNode 节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.calcite.plan.hep.HepRelVertex</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HepRelVertex wraps a real &#123;<span class="doctag">@link</span> RelNode&#125; as a vertex in a DAG representing</span></span><br><span class="line"><span class="comment"> * the entire query expression.</span></span><br><span class="line"><span class="comment"> * note：HepRelVertex 将一个 RelNode 封装为一个 DAG 中的 vertex（DAG 代表整个 query expression）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HepRelVertex</span> <span class="keyword">extends</span> <span class="title">AbstractRelNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">//~ Instance fields --------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Wrapped rel currently chosen for implementation of expression.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> RelNode currentRel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HepInstruction"><a href="#HepInstruction" class="headerlink" title="HepInstruction"></a>HepInstruction</h4><p>HepInstruction 是 HepPlanner 对一些内容的封装，具体的子类实现比较多，其中 RuleInstance 是 HepPlanner 中对 Rule 的一个封装，注册的 Rule 最后都会转换为这种形式。</p>
<blockquote>
<p>HepInstruction represents one instruction in a HepProgram. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepInstruction</span></span><br><span class="line"><span class="comment">/** Instruction that executes a given rule. */</span></span><br><span class="line"><span class="comment">//note: 执行指定 rule 的 Instruction</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleInstance</span> <span class="keyword">extends</span> <span class="title">HepInstruction</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Description to look for, or null if rule specified explicitly.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String ruleDescription;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Explicitly specified rule, or rule looked up by planner from</span></span><br><span class="line"><span class="comment">   * description.</span></span><br><span class="line"><span class="comment">   * note：设置其 Rule</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RelOptRule rule;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">boolean</span> clearCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!clearCache) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ruleDescription != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Look up anew each run.</span></span><br><span class="line">      rule = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(HepPlanner planner)</span> </span>&#123;</span><br><span class="line">    planner.executeInstruction(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HepPlanner-处理流程"><a href="#HepPlanner-处理流程" class="headerlink" title="HepPlanner 处理流程"></a>HepPlanner 处理流程</h3><p>下面这个示例是上篇文章（<a href="http://matt33.com/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a>）的示例，通过这段代码来看下 HepPlanner 的内部实现机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HepProgramBuilder builder = <span class="keyword">new</span> HepProgramBuilder();</span><br><span class="line">builder.addRuleInstance(FilterJoinRule.FilterIntoJoinRule.FILTER_ON_JOIN); <span class="comment">//note: 添加 rule</span></span><br><span class="line">HepPlanner hepPlanner = <span class="keyword">new</span> HepPlanner(builder.build());</span><br><span class="line">hepPlanner.setRoot(relNode);</span><br><span class="line">relNode = hepPlanner.findBestExp();</span><br></pre></td></tr></table></figure>
<p>上面的代码总共分为三步：</p>
<ol>
<li>初始化 HepProgram 对象；</li>
<li>初始化 HepPlanner 对象，并通过 <code>setRoot()</code> 方法将 RelNode 树转换成 HepPlanner 内部使用的 Graph；</li>
<li>通过 <code>findBestExp()</code> 找到最优的 plan，规则的匹配都是在这里进行。</li>
</ol>
<h4 id="1-初始化-HepProgram"><a href="#1-初始化-HepProgram" class="headerlink" title="1. 初始化 HepProgram"></a>1. 初始化 HepProgram</h4><p>这几步代码实现没有太多需要介绍的地方，先初始化 HepProgramBuilder 也是为了后面初始化 HepProgram 做准备，HepProgramBuilder 主要也就是提供了一些配置设置和添加规则的方法等，常用的方法如下：</p>
<ol>
<li><code>addRuleInstance()</code>：注册相应的规则；</li>
<li><code>addRuleCollection()</code>：这里是注册一个规则集合，先把规则放在一个集合里，再注册整个集合，如果规则多的话，一般是这种方式；</li>
<li><code>addMatchLimit()</code>：设置 MatchLimit，这个 rule match 次数的最大限制；</li>
</ol>
<p>HepProgram 这个类对于后面 HepPlanner 的优化很重要，它定义 Rule 匹配的顺序，默认按【深度优先】顺序，它可以提供以下几种（见 HepMatchOrder 类）：</p>
<ol>
<li><strong>ARBITRARY</strong>：按任意顺序匹配（因为它是有效的，而且大部分的 Rule 并不关心匹配顺序）；</li>
<li><strong>BOTTOM_UP</strong>：自下而上，先从子节点开始匹配；</li>
<li><strong>TOP_DOWN</strong>：自上而下，先从父节点开始匹配；</li>
<li><strong>DEPTH_FIRST</strong>：深度优先匹配，某些情况下比 ARBITRARY 高效（为了避免新的 vertex 产生后又从 root 节点开始匹配）。</li>
</ol>
<p>这个匹配顺序到底是什么呢？对于规则集合 rules，HepPlanner 的算法是：从一个节点开始，跟 rules 的所有 Rule 进行匹配，匹配上就进行转换操作，这个节点操作完，再进行下一个节点，这里的匹配顺序就是指的<strong>节点遍历顺序</strong>（这种方式的优劣，我们下面再说）。</p>
<h4 id="2-HepPlanner-setRoot（RelNode-–-gt-Graph）"><a href="#2-HepPlanner-setRoot（RelNode-–-gt-Graph）" class="headerlink" title="2. HepPlanner.setRoot（RelNode –&gt; Graph）"></a>2. HepPlanner.setRoot（RelNode –&gt; Graph）</h4><p>先看下 <code>setRoot()</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(RelNode rel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//note: 将 RelNode 转换为 DAG 表示</span></span><br><span class="line">  root = addRelToGraph(rel);</span><br><span class="line">  <span class="comment">//note: 仅仅是在 trace 日志中输出 Graph 信息</span></span><br><span class="line">  dumpGraph();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HepPlanner 会先将所有 relNode tree 转化为 HepRelVertex，这时就构建了一个 Graph：将所有的 elNode 节点使用 Vertex 表示，Gragh 会记录每个 HepRelVertex 的 input 信息，这样就是构成了一张 graph。</p>
<p>在真正的实现时，递归逐渐将每个 relNode 转换为 HepRelVertex，并在 <code>graph</code> 中记录相关的信息，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="comment">//note: 根据 RelNode 构建一个 Graph</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HepRelVertex <span class="title">addRelToGraph</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RelNode rel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if a transformation already produced a reference</span></span><br><span class="line">  <span class="comment">// to an existing vertex.</span></span><br><span class="line">  <span class="comment">//note: 检查这个 rel 是否在 graph 中转换了</span></span><br><span class="line">  <span class="keyword">if</span> (graph.vertexSet().contains(rel)) &#123;</span><br><span class="line">    <span class="keyword">return</span> (HepRelVertex) rel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recursively add children, replacing this rel's inputs</span></span><br><span class="line">  <span class="comment">// with corresponding child vertices.</span></span><br><span class="line">  <span class="comment">//note: 递归地增加子节点，使用子节点相关的 vertices 代替 rel 的 input</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;RelNode&gt; inputs = rel.getInputs();</span><br><span class="line">  <span class="keyword">final</span> List&lt;RelNode&gt; newInputs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (RelNode input1 : inputs) &#123;</span><br><span class="line">    HepRelVertex childVertex = addRelToGraph(input1); <span class="comment">//note: 递归进行转换</span></span><br><span class="line">    newInputs.add(childVertex); <span class="comment">//note: 每个 HepRelVertex 只记录其 Input</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!Util.equalShallow(inputs, newInputs)) &#123; <span class="comment">//note: 不相等的情况下</span></span><br><span class="line">    RelNode oldRel = rel;</span><br><span class="line">    rel = rel.copy(rel.getTraitSet(), newInputs);</span><br><span class="line">    onCopy(oldRel, rel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Compute digest first time we add to DAG,</span></span><br><span class="line">  <span class="comment">// otherwise can't get equivVertex for common sub-expression</span></span><br><span class="line">  <span class="comment">//note: 计算 relNode 的 digest</span></span><br><span class="line">  <span class="comment">//note: Digest 的意思是：</span></span><br><span class="line">  <span class="comment">//note: A short description of this relational expression's type, inputs, and</span></span><br><span class="line">  <span class="comment">//note: other properties. The string uniquely identifies the node; another node</span></span><br><span class="line">  <span class="comment">//note: is equivalent if and only if it has the same value.</span></span><br><span class="line">  rel.recomputeDigest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// try to find equivalent rel only if DAG is allowed</span></span><br><span class="line">  <span class="comment">//note: 如果允许 DAG 的话，检查是否有一个等价的 HepRelVertex，有的话直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!noDag) &#123;</span><br><span class="line">    <span class="comment">// Now, check if an equivalent vertex already exists in graph.</span></span><br><span class="line">    String digest = rel.getDigest();</span><br><span class="line">    HepRelVertex equivVertex = mapDigestToVertex.get(digest);</span><br><span class="line">    <span class="keyword">if</span> (equivVertex != <span class="keyword">null</span>) &#123; <span class="comment">//note: 已经存在</span></span><br><span class="line">      <span class="comment">// Use existing vertex.</span></span><br><span class="line">      <span class="keyword">return</span> equivVertex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No equivalence:  create a new vertex to represent this rel.</span></span><br><span class="line">  <span class="comment">//note: 创建一个 vertex 代替 rel</span></span><br><span class="line">  HepRelVertex newVertex = <span class="keyword">new</span> HepRelVertex(rel);</span><br><span class="line">  graph.addVertex(newVertex); <span class="comment">//note: 记录 Vertex</span></span><br><span class="line">  updateVertex(newVertex, rel);<span class="comment">//note: 更新相关的缓存，比如 mapDigestToVertex map</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (RelNode input : rel.getInputs()) &#123; <span class="comment">//note: 设置 Edge</span></span><br><span class="line">    graph.addEdge(newVertex, (HepRelVertex) input);<span class="comment">//note: 记录与整个 Vertex 先关的 input</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nTransformations++;</span><br><span class="line">  <span class="keyword">return</span> newVertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里 HepPlanner 需要的 gragh 已经构建完成，通过 DEBUG 方式也能看到此时 HepPlanner root 变量的内容：</p>
<p><img src="/images/calcite/10-calcite.png" alt="Root 转换之后的内容"></p>
<h4 id="3-HepPlanner-findBestExp-规则优化"><a href="#3-HepPlanner-findBestExp-规则优化" class="headerlink" title="3. HepPlanner findBestExp 规则优化"></a>3. HepPlanner findBestExp 规则优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="comment">// implement RelOptPlanner</span></span><br><span class="line"><span class="comment">//note: 优化器的核心，匹配规则进行优化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RelNode <span class="title">findBestExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> root != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 运行 HepProgram 算法(按 HepProgram 中的 instructions 进行相应的优化)</span></span><br><span class="line">  executeProgram(mainProgram);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get rid of everything except what's in the final plan.</span></span><br><span class="line">  <span class="comment">//note: 垃圾收集</span></span><br><span class="line">  collectGarbage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buildFinalPlan(root); <span class="comment">//note: 返回最后的结果，还是以 RelNode 表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的实现是在 <code>executeProgram()</code> 方法中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeProgram</span><span class="params">(HepProgram program)</span> </span>&#123;</span><br><span class="line">  HepProgram savedProgram = currentProgram; <span class="comment">//note: 保留当前的 Program</span></span><br><span class="line">  currentProgram = program;</span><br><span class="line">  currentProgram.initialize(program == mainProgram);<span class="comment">//note: 如果是在同一个 Program 的话，保留上次 cache</span></span><br><span class="line">  <span class="keyword">for</span> (HepInstruction instruction : currentProgram.instructions) &#123;</span><br><span class="line">    instruction.execute(<span class="keyword">this</span>); <span class="comment">//note: 按 Rule 进行优化(会调用 executeInstruction 方法)</span></span><br><span class="line">    <span class="keyword">int</span> delta = nTransformations - nTransformationsLastGC;</span><br><span class="line">    <span class="keyword">if</span> (delta &gt; graphSizeLastGC) &#123;</span><br><span class="line">      <span class="comment">// The number of transformations performed since the last</span></span><br><span class="line">      <span class="comment">// garbage collection is greater than the number of vertices in</span></span><br><span class="line">      <span class="comment">// the graph at that time.  That means there should be a</span></span><br><span class="line">      <span class="comment">// reasonable amount of garbage to collect now.  We do it this</span></span><br><span class="line">      <span class="comment">// way to amortize garbage collection cost over multiple</span></span><br><span class="line">      <span class="comment">// instructions, while keeping the highwater memory usage</span></span><br><span class="line">      <span class="comment">// proportional to the graph size.</span></span><br><span class="line">      <span class="comment">//note: 进行转换的次数已经大于 DAG Graph 中的顶点数，这就意味着已经产生大量垃圾需要进行清理</span></span><br><span class="line">      collectGarbage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  currentProgram = savedProgram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会遍历 HepProgram 中 instructions（记录注册的所有 HepInstruction），然后根据 instruction 的类型执行相应的 <code>executeInstruction()</code> 方法，如果instruction 是 <code>HepInstruction.MatchLimit</code> 类型，会执行 <code>executeInstruction(HepInstruction.MatchLimit instruction)</code> 方法，这个方法就是初始化 matchLimit 变量。对于 <code>HepInstruction.RuleInstance</code> 类型的 instruction 会执行下面的方法（前面的示例注册规则使用的是 <code>addRuleInstance()</code> 方法，所以返回的 rules 只有一个规则，如果注册规则的时候使用的是 <code>addRuleCollection()</code> 方法注册一个规则集合的话，这里会返回的 rules 就是那个规则集合）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="comment">//note: 执行相应的 RuleInstance</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeInstruction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HepInstruction.RuleInstance instruction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (skippingGroup()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instruction.rule == <span class="keyword">null</span>) &#123;<span class="comment">//note: 如果 rule 为 null，那么就按照 description 查找具体的 rule</span></span><br><span class="line">    <span class="keyword">assert</span> instruction.ruleDescription != <span class="keyword">null</span>;</span><br><span class="line">    instruction.rule =</span><br><span class="line">        getRuleByDescription(instruction.ruleDescription);</span><br><span class="line">    LOGGER.trace(<span class="string">"Looking up rule with description &#123;&#125;, found &#123;&#125;"</span>,</span><br><span class="line">        instruction.ruleDescription, instruction.rule);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: 执行相应的 rule</span></span><br><span class="line">  <span class="keyword">if</span> (instruction.rule != <span class="keyword">null</span>) &#123;</span><br><span class="line">    applyRules(</span><br><span class="line">        Collections.singleton(instruction.rule),</span><br><span class="line">        <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看 <code>applyRules()</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.hep.HepPlanner</span></span><br><span class="line"><span class="comment">//note: 执行 rule（forceConversions 默认 true）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyRules</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Collection&lt;RelOptRule&gt; rules,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> forceConversions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currentProgram.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span> currentProgram.group.collecting;</span><br><span class="line">    currentProgram.group.ruleSet.addAll(rules);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOGGER.trace(<span class="string">"Applying rule set &#123;&#125;"</span>, rules);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 当遍历规则是 ARBITRARY 或 DEPTH_FIRST 时，设置为 false，此时不会从 root 节点开始，否则每次 restart 都从 root 节点开始</span></span><br><span class="line">  <span class="keyword">boolean</span> fullRestartAfterTransformation =</span><br><span class="line">      currentProgram.matchOrder != HepMatchOrder.ARBITRARY</span><br><span class="line">      &amp;&amp; currentProgram.matchOrder != HepMatchOrder.DEPTH_FIRST;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nMatches = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> fixedPoint;</span><br><span class="line">  <span class="comment">//note: 两种情况会跳出循环，一种是达到 matchLimit 限制，一种是遍历一遍不会再有新的 transform 产生</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//note: 按照遍历规则获取迭代器</span></span><br><span class="line">    Iterator&lt;HepRelVertex&gt; iter = getGraphIterator(root);</span><br><span class="line">    fixedPoint = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">      HepRelVertex vertex = iter.next();<span class="comment">//note: 遍历每个 HepRelVertex</span></span><br><span class="line">      <span class="keyword">for</span> (RelOptRule rule : rules) &#123;<span class="comment">//note: 遍历每个 rules</span></span><br><span class="line">        <span class="comment">//note: 进行规制匹配，也是真正进行相关操作的地方</span></span><br><span class="line">        HepRelVertex newVertex =</span><br><span class="line">            applyRule(rule, vertex, forceConversions);</span><br><span class="line">        <span class="keyword">if</span> (newVertex == <span class="keyword">null</span> || newVertex == vertex) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++nMatches;</span><br><span class="line">        <span class="comment">//note: 超过 MatchLimit 的限制</span></span><br><span class="line">        <span class="keyword">if</span> (nMatches &gt;= currentProgram.matchLimit) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fullRestartAfterTransformation) &#123;</span><br><span class="line">          <span class="comment">//note: 发生 transformation 后，从 root 节点再次开始</span></span><br><span class="line">          iter = getGraphIterator(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// To the extent possible, pick up where we left</span></span><br><span class="line">          <span class="comment">// off; have to create a new iterator because old</span></span><br><span class="line">          <span class="comment">// one was invalidated by transformation.</span></span><br><span class="line">          <span class="comment">//note: 尽可能从上次进行后的节点开始</span></span><br><span class="line">          iter = getGraphIterator(newVertex);</span><br><span class="line">          <span class="keyword">if</span> (currentProgram.matchOrder == HepMatchOrder.DEPTH_FIRST) &#123;</span><br><span class="line">            <span class="comment">//note: 这样做的原因就是为了防止有些 HepRelVertex 遗漏了 rule 的匹配（每次从 root 开始是最简单的算法），因为可能出现下推</span></span><br><span class="line">            nMatches =</span><br><span class="line">                depthFirstApply(iter, rules, forceConversions, nMatches);</span><br><span class="line">            <span class="keyword">if</span> (nMatches &gt;= currentProgram.matchLimit) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Remember to go around again since we're</span></span><br><span class="line">          <span class="comment">// skipping some stuff.</span></span><br><span class="line">          <span class="comment">//note: 再来一遍，因为前面有跳过一些节点</span></span><br><span class="line">          fixedPoint = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!fixedPoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里会调用 <code>getGraphIterator()</code> 方法获取 HepRelVertex 的迭代器，迭代的策略（遍历的策略）跟前面说的顺序有关，默认使用的是【深度优先】，这段代码比较简单，就是遍历规则+遍历节点进行匹配转换，直到满足条件再退出，从这里也能看到 HepPlanner 的实现效率不是很高，它也无法保证能找出最优的结果。</p>
<p>总结一下，HepPlanner 在优化过程中，是先遍历规则，然后再对每个节点进行匹配转换，直到满足条件（超过限制次数或者规则遍历完一遍不会再有新的变化），其方法调用流程如下：</p>
<p><img src="/images/calcite/11-hep.png" alt="HepPlanner 处理流程"> </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="1-为什么要把-RelNode-转换-HepRelVertex-进行优化？带来的收益在哪里？"><a href="#1-为什么要把-RelNode-转换-HepRelVertex-进行优化？带来的收益在哪里？" class="headerlink" title="1. 为什么要把 RelNode 转换 HepRelVertex 进行优化？带来的收益在哪里？"></a>1. 为什么要把 RelNode 转换 HepRelVertex 进行优化？带来的收益在哪里？</h4><p>关于这个，能想到的就是：RelNode 是底层提供的抽象、偏底层一些，在优化器这一层，需要记录更多的信息，所以又做了一层封装。</p>
<h2 id="VolcanoPlanner"><a href="#VolcanoPlanner" class="headerlink" title="VolcanoPlanner"></a>VolcanoPlanner</h2><p>介绍完 HepPlanner 之后，接下来再来看下基于成本优化（CBO）模型在 Calcite 中是如何实现、如何落地的，关于 Volcano 理论内容建议先看下相关理论知识，否则直接看实现的话可能会有一些头大。从 Volcano 模型的理论落地到实践是有很大区别的，这里先看一张 VolcanoPlanner 整体实现图，如下所示（图片来自 <a href="https://www.slideshare.net/julianhyde/costbased-query-optimization-in-apache-phoenix-using-apache-calcite?qid=b7a1ca0f-e7bf-49ad-bc51-0615ec8a4971&amp;v=&amp;b=&amp;from_search=4" target="_blank" rel="external">Cost-based Query Optimization in Apache Phoenix using Apache Calcite</a>）：</p>
<p><img src="/images/calcite/12-VolcanoPlanner.png" alt="Calcite VolcanoPlanner Process"></p>
<p>上面基本展现了 VolcanoPlanner 内部实现的流程，也简单介绍了 VolcanoPlanner 在实现中的一些关键点（有些概念暂时不了解也不要紧，后面会介绍）：</p>
<ol>
<li>Add Rule matches to Queue：向 Rule Match Queue 中添加相应的 Rule Match；</li>
<li>Apply Rule match transformations to plan gragh：应用 Rule Match 对 plan graph 做 transformation 优化（Rule specifies an Operator sub-graph to match and logic to generate equivalent better sub-graph）；</li>
<li>Iterate for fixed iterations or until cost doesn’t change：进行相应的迭代，直到 cost 不再变化或者 Rule Match Queue 中 rule match 已经全部应用完成；</li>
<li>Match importance based on cost of RelNode and height：Rule Match 的 importance 依赖于 RelNode 的 cost 和深度。</li>
</ol>
<p>使用 VolcanoPlanner 实现的完整代码见 <a href="https://github.com/wangzzu/program-example/blob/master/calcite-example/src/main/java/com/matt/test/calcite/sql/SqlVolcanoTest.java" target="_blank" rel="external">SqlVolcanoTest</a>。</p>
<p>下面来看下 VolcanoPlanner 实现具体的细节。</p>
<h3 id="VolcanoPlanner-中的基本概念"><a href="#VolcanoPlanner-中的基本概念" class="headerlink" title="VolcanoPlanner 中的基本概念"></a>VolcanoPlanner 中的基本概念</h3><p>VolcanoPlanner 在实现中引入了一些基本概念，先明白这些概念对于理解 VolcanoPlanner 的实现非常有帮助。</p>
<h4 id="RelSet"><a href="#RelSet" class="headerlink" title="RelSet"></a>RelSet</h4><p>关于 RelSet，源码中介绍如下：</p>
<blockquote>
<p>RelSet is an equivalence-set of expressions that is, a set of expressions which have <strong>identical semantics</strong>.<br>We are generally interested in using the expression which has <strong>the lowest cost</strong>.<br>All of the expressions in an RelSet have the <strong>same calling convention</strong>.</p>
</blockquote>
<p>它有以下特点：</p>
<ol>
<li>描述一组等价 Relation Expression，所有的 RelNode 会记录在 <code>rels</code> 中；</li>
<li>have the same calling convention；</li>
<li>具有相同物理属性的 Relational Expression 会记录在其成员变量 <code>List&lt;RelSubset&gt; subsets</code> 中.</li>
</ol>
<p>RelSet 中比较重要成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelSet</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录属于这个 RelSet 的所有 RelNode</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;RelNode&gt; rels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Relational expressions that have a subset in this set as a child. This</span></span><br><span class="line"><span class="comment">   * is a multi-set. If multiple relational expressions in this set have the</span></span><br><span class="line"><span class="comment">   * same parent, there will be multiple entries.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;RelNode&gt; parents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">//note: 具体相同物理属性的子集合（本质上 RelSubset 并不记录 RelNode，也是通过 RelSet 按物理属性过滤得到其 RelNode 子集合，见下面的 RelSubset 部分）</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;RelSubset&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * List of &#123;<span class="doctag">@link</span> AbstractConverter&#125; objects which have not yet been</span></span><br><span class="line"><span class="comment">   * satisfied.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;AbstractConverter&gt; abstractConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set to the superseding set when this is found to be equivalent to another</span></span><br><span class="line"><span class="comment">   * set.</span></span><br><span class="line"><span class="comment">   * note：当发现与另一个 RelSet 有相同的语义时，设置为替代集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RelSet equivalentSet;</span><br><span class="line">  RelNode rel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Variables that are set by relational expressions in this set and available for use by parent and child expressions.</span></span><br><span class="line"><span class="comment">   * note：在这个集合中 relational expression 设置的变量，父类和子类 expression 可用的变量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> Set&lt;CorrelationId&gt; variablesPropagated;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Variables that are used by relational expressions in this set.</span></span><br><span class="line"><span class="comment">   * note：在这个集合中被 relational expression 使用的变量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> Set&lt;CorrelationId&gt; variablesUsed;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reentrancy flag.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">boolean</span> inMetadataQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RelSubset"><a href="#RelSubset" class="headerlink" title="RelSubset"></a>RelSubset</h4><p>关于 RelSubset，源码中介绍如下：</p>
<blockquote>
<p>Subset of an equivalence class where all relational expressions have the same physical properties.</p>
</blockquote>
<p>它的特点如下：</p>
<ol>
<li>描述一组物理属性相同的等价 Relation Expression，即它们具有相同的 Physical Properties；</li>
<li>每个 RelSubset 都会记录其所属的 RelSet；</li>
<li>RelSubset 继承自 AbstractRelNode，它也是一种 RelNode，物理属性记录在其成员变量 traitSet 中。</li>
</ol>
<p>RelSubset 一些比较重要的成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RelSubset</span> <span class="keyword">extends</span> <span class="title">AbstractRelNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * cost of best known plan (it may have improved since)</span></span><br><span class="line"><span class="comment">   * note: 已知最佳 plan 的 cost</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RelOptCost bestCost;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The set this subset belongs to.</span></span><br><span class="line"><span class="comment">   * RelSubset 所属的 RelSet，在 RelSubset 中并不记录具体的 RelNode，直接记录在 RelSet 的 rels 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> RelSet set;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * best known plan</span></span><br><span class="line"><span class="comment">   * note: 已知的最佳 plan</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RelNode best;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Flag indicating whether this RelSubset's importance was artificially</span></span><br><span class="line"><span class="comment">   * boosted.</span></span><br><span class="line"><span class="comment">   * note: 标志这个 RelSubset 的 importance 是否是人为地提高了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">boolean</span> boosted;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//~ Constructors -----------------------------------------------------------</span></span><br><span class="line">  RelSubset(</span><br><span class="line">      RelOptCluster cluster,</span><br><span class="line">      RelSet set,</span><br><span class="line">      RelTraitSet traits) &#123;</span><br><span class="line">    <span class="keyword">super</span>(cluster, traits); <span class="comment">// 继承自 AbstractRelNode，会记录其相应的 traits 信息</span></span><br><span class="line">    <span class="keyword">this</span>.set = set;</span><br><span class="line">    <span class="keyword">this</span>.boosted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">assert</span> traits.allSimple();</span><br><span class="line">    computeBestCost(cluster.getPlanner()); <span class="comment">//note: 计算 best</span></span><br><span class="line">    recomputeDigest(); <span class="comment">//note: 计算 digest</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 RelSubset 都将会记录其最佳 plan（<code>best</code>）和最佳 plan 的 cost（<code>bestCost</code>）信息。</p>
<h4 id="RuleMatch"><a href="#RuleMatch" class="headerlink" title="RuleMatch"></a>RuleMatch</h4><p>RuleMatch 是这里对 Rule 和 RelSubset 关系的一个抽象，它会记录这两者的信息。</p>
<blockquote>
<p>A match of a rule to a particular set of target relational expressions, frozen in time.</p>
</blockquote>
<h4 id="importance"><a href="#importance" class="headerlink" title="importance"></a>importance</h4><p>importance 决定了在进行 Rule 优化时 Rule 应用的顺序，它是一个相对概念，在 VolcanoPlanner 中有两个 importance，分别是 RelSubset 和 RuleMatch 的 importance，这里先提前介绍一下。</p>
<h5 id="RelSubset-的-importance"><a href="#RelSubset-的-importance" class="headerlink" title="RelSubset 的 importance"></a>RelSubset 的 importance</h5><p>RelSubset importance 计算方法见其 api 定义（<strong>图中的 sum 改成 Math.max{}</strong>这个地方有误）：</p>
<p><img src="/images/calcite/13-compute.png" alt="computeImportance"> </p>
<p>举个例子：假设一个 RelSubset（记为 $s_0$） 的 cost 是3，对应的 importance 是0.5，这个 RelNode 有两个输入（inputs），对应的 RelSubset 记为 $s_1$、$s_2$（假设 $s_1$、$s_2$ 不再有输入 RelNode），其 cost 分别为 2和5，那么 $s_1$ 的 importance 为</p>
<p>Importance of $s_1$ = $\frac{2}{3+2+5}$ $\cdot$ 0.5 = 0.1</p>
<p>Importance of $s_2$ = $\frac{5}{3+2+5}$ $\cdot$ 0.5 = 0.25</p>
<p>其中，2代表的是 $s_1$ 的 cost，$3+2+5$ 代表的是 $s_0$ 的 cost（本节点的 cost 加上其所有 input 的 cost）。下面看下其具体的代码实现（调用 RuleQueue 中的 <code>recompute()</code> 计算其 importance）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.RuleQueue</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recomputes the importance of the given RelSubset.</span></span><br><span class="line"><span class="comment"> * note：重新计算指定的 RelSubset 的 importance</span></span><br><span class="line"><span class="comment"> * note：如果为 true，即使 subset 没有注册，也会强制 importance 更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subset RelSubset whose importance is to be recomputed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> force  if true, forces an importance update even if the subset has</span></span><br><span class="line"><span class="comment"> *               not been registered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recompute</span><span class="params">(RelSubset subset, <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  Double previousImportance = subsetImportances.get(subset);</span><br><span class="line">  <span class="keyword">if</span> (previousImportance == <span class="keyword">null</span>) &#123; <span class="comment">//note: subset 还没有注册的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (!force) &#123; <span class="comment">//note: 如果不是强制，可以直接先返回</span></span><br><span class="line">      <span class="comment">// Subset has not been registered yet. Don't worry about it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    previousImportance = Double.NEGATIVE_INFINITY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 计算器 importance 值</span></span><br><span class="line">  <span class="keyword">double</span> importance = computeImportance(subset);</span><br><span class="line">  <span class="keyword">if</span> (previousImportance == importance) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 缓存中更新其 importance</span></span><br><span class="line">  updateImportance(subset, importance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算一个节点的 importance</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">computeImportance</span><span class="params">(RelSubset subset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> importance;</span><br><span class="line">  <span class="keyword">if</span> (subset == planner.root) &#123;</span><br><span class="line">    <span class="comment">// The root always has importance = 1</span></span><br><span class="line">    <span class="comment">//note: root RelSubset 的 importance 为1</span></span><br><span class="line">    importance = <span class="number">1.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> RelMetadataQuery mq = subset.getCluster().getMetadataQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The importance of a subset is the max of its importance to its</span></span><br><span class="line">    <span class="comment">// parents</span></span><br><span class="line">    <span class="comment">//note: 计算其相对于 parent 的最大 importance，多个 parent 的情况下，选择一个最大值</span></span><br><span class="line">    importance = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RelSubset parent : subset.getParentSubsets(planner)) &#123;</span><br><span class="line">      <span class="comment">//note: 计算这个 RelSubset 相对于 parent 的 importance</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">double</span> childImportance =</span><br><span class="line">          computeImportanceOfChild(mq, subset, parent);</span><br><span class="line">      <span class="comment">//note: 选择最大的 importance</span></span><br><span class="line">      importance = Math.max(importance, childImportance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LOGGER.trace(<span class="string">"Importance of [&#123;&#125;] is &#123;&#125;"</span>, subset, importance);</span><br><span class="line">  <span class="keyword">return</span> importance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//note：根据 cost 计算 child 相对于 parent 的 importance（这是个相对值）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">computeImportanceOfChild</span><span class="params">(RelMetadataQuery mq, RelSubset child,</span></span></span><br><span class="line"><span class="function"><span class="params">    RelSubset parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//note: 获取 parent 的 importance</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span> parentImportance = getImportance(parent);</span><br><span class="line">  <span class="comment">//note: 获取对应的 cost 信息</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span> childCost = toDouble(planner.getCost(child, mq));</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span> parentCost = toDouble(planner.getCost(parent, mq));</span><br><span class="line">  <span class="keyword">double</span> alpha = childCost / parentCost;</span><br><span class="line">  <span class="keyword">if</span> (alpha &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// child is always less important than parent</span></span><br><span class="line">    alpha = <span class="number">0.99</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: 根据 cost 比列计算其 importance</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span> importance = parentImportance * alpha;</span><br><span class="line">  LOGGER.trace(<span class="string">"Importance of [&#123;&#125;] to its parent [&#123;&#125;] is &#123;&#125; (parent importance=&#123;&#125;, child cost=&#123;&#125;,"</span></span><br><span class="line">      + <span class="string">" parent cost=&#123;&#125;)"</span>, child, parent, importance, parentImportance, childCost, parentCost);</span><br><span class="line">  <span class="keyword">return</span> importance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>computeImportanceOfChild()</code> 中计算 RelSubset 相对于 parent RelSubset 的 importance 时，一个比较重要的地方就是如何计算 cost，关于 cost 的计算见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">//note: Computes the cost of a RelNode.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RelOptCost <span class="title">getCost</span><span class="params">(RelNode rel, RelMetadataQuery mq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> rel != <span class="keyword">null</span> : <span class="string">"pre-condition: rel != null"</span>;</span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123; <span class="comment">//note: 如果是 RelSubset，证明是已经计算 cost 的 subset</span></span><br><span class="line">    <span class="keyword">return</span> ((RelSubset) rel).bestCost;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rel.getTraitSet().getTrait(ConventionTraitDef.INSTANCE)</span><br><span class="line">      == Convention.NONE) &#123;</span><br><span class="line">    <span class="keyword">return</span> costFactory.makeInfiniteCost(); <span class="comment">//note: 这种情况下也会返回 infinite Cost</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: 计算其 cost</span></span><br><span class="line">  RelOptCost cost = mq.getNonCumulativeCost(rel);</span><br><span class="line">  <span class="keyword">if</span> (!zeroCost.isLt(cost)) &#123; <span class="comment">//note: cost 比0还小的情况</span></span><br><span class="line">    <span class="comment">// cost must be positive, so nudge it</span></span><br><span class="line">    cost = costFactory.makeTinyCost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: RelNode 的 cost 会把其 input 全部加上</span></span><br><span class="line">  <span class="keyword">for</span> (RelNode input : rel.getInputs()) &#123;</span><br><span class="line">    cost = cost.plus(getCost(input, mq));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是 RelSubset importance 计算的代码实现，从实现中可以发现这个特点：</p>
<ol>
<li>越靠近 root 的 RelSubset，其 importance 越大，这个带来的好处就是在优化时，会尽量先优化靠近 root 的 RelNode，这样带来的收益也会最大。</li>
</ol>
<h5 id="RuleMatch-的-importance"><a href="#RuleMatch-的-importance" class="headerlink" title="RuleMatch 的 importance"></a>RuleMatch 的 importance</h5><p>RuleMatch 的 importance 定义为以下两个中比较大的一个（如果对应的 RelSubset 有 importance 的情况下）：</p>
<ol>
<li>这个 RuleMatch 对应 RelSubset（这个 rule match 的 RelSubset）的 importance；</li>
<li>输出的 RelSubset（taget RelSubset）的 importance（如果这个 RelSubset 在 VolcanoPlanner 的缓存中存在的话）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoRuleMatch</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes the importance of this rule match.</span></span><br><span class="line"><span class="comment"> * note：计算 rule match 的 importance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> importance of this rule match</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">computeImportance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> rels[<span class="number">0</span>] != <span class="keyword">null</span>; <span class="comment">//note: rels[0] 这个 Rule Match 对应的 RelSubset</span></span><br><span class="line">  RelSubset subset = volcanoPlanner.getSubset(rels[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">double</span> importance = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (subset != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//note: 获取 RelSubset 的 importance</span></span><br><span class="line">    importance = volcanoPlanner.ruleQueue.getImportance(subset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: Returns a guess as to which subset the result of this rule will belong to.</span></span><br><span class="line">  <span class="keyword">final</span> RelSubset targetSubset = guessSubset();</span><br><span class="line">  <span class="keyword">if</span> ((targetSubset != <span class="keyword">null</span>) &amp;&amp; (targetSubset != subset)) &#123;</span><br><span class="line">    <span class="comment">// If this rule will generate a member of an equivalence class</span></span><br><span class="line">    <span class="comment">// which is more important, use that importance.</span></span><br><span class="line">    <span class="comment">//note: 获取 targetSubset 的 importance</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> targetImportance =</span><br><span class="line">        volcanoPlanner.ruleQueue.getImportance(targetSubset);</span><br><span class="line">    <span class="keyword">if</span> (targetImportance &gt; importance) &#123;</span><br><span class="line">      importance = targetImportance;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the equivalence class is cheaper than the target, bump up</span></span><br><span class="line">      <span class="comment">// the importance of the rule. A converter is an easy way to</span></span><br><span class="line">      <span class="comment">// make the plan cheaper, so we'd hate to miss this opportunity.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// REVIEW: jhyde, 2007/12/21: This rule seems to make sense, but</span></span><br><span class="line">      <span class="comment">// is disabled until it has been proven.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// CHECKSTYLE: IGNORE 3</span></span><br><span class="line">      <span class="keyword">if</span> ((subset != <span class="keyword">null</span>)</span><br><span class="line">          &amp;&amp; subset.bestCost.isLt(targetSubset.bestCost)</span><br><span class="line">          &amp;&amp; <span class="keyword">false</span>) &#123; <span class="comment">//note: 肯定不会进入</span></span><br><span class="line">        importance *=</span><br><span class="line">            targetSubset.bestCost.divideBy(subset.bestCost);</span><br><span class="line">        importance = Math.min(importance, <span class="number">0.99</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> importance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RuleMatch 的 importance 主要是决定了在选择 RuleMatch 时，应该先处理哪一个？它本质上还是直接用的 RelSubset 的 importance。</p>
<h3 id="VolcanoPlanner-处理流程"><a href="#VolcanoPlanner-处理流程" class="headerlink" title="VolcanoPlanner 处理流程"></a>VolcanoPlanner 处理流程</h3><p>还是以前面的示例，只不过这里把优化器换成 VolcanoPlanner 来实现，通过这个示例来详细看下 VolcanoPlanner 内部的实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 初始化 VolcanoPlanner 对象，并添加相应的 Rule</span></span><br><span class="line">VolcanoPlanner planner = <span class="keyword">new</span> VolcanoPlanner();</span><br><span class="line">planner.addRelTraitDef(ConventionTraitDef.INSTANCE);</span><br><span class="line">planner.addRelTraitDef(RelDistributionTraitDef.INSTANCE);</span><br><span class="line"><span class="comment">// 添加相应的 rule</span></span><br><span class="line">planner.addRule(FilterJoinRule.FilterIntoJoinRule.FILTER_ON_JOIN);</span><br><span class="line">planner.addRule(ReduceExpressionsRule.PROJECT_INSTANCE);</span><br><span class="line">planner.addRule(PruneEmptyRules.PROJECT_INSTANCE);</span><br><span class="line"><span class="comment">// 添加相应的 ConverterRule</span></span><br><span class="line">planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);</span><br><span class="line">planner.addRule(EnumerableRules.ENUMERABLE_SORT_RULE);</span><br><span class="line">planner.addRule(EnumerableRules.ENUMERABLE_VALUES_RULE);</span><br><span class="line">planner.addRule(EnumerableRules.ENUMERABLE_PROJECT_RULE);</span><br><span class="line">planner.addRule(EnumerableRules.ENUMERABLE_FILTER_RULE);</span><br><span class="line"><span class="comment">//2. Changes a relational expression to an equivalent one with a different set of traits.</span></span><br><span class="line">RelTraitSet desiredTraits =</span><br><span class="line">    relNode.getCluster().traitSet().replace(EnumerableConvention.INSTANCE);</span><br><span class="line">relNode = planner.changeTraits(relNode, desiredTraits);</span><br><span class="line"><span class="comment">//3. 通过 VolcanoPlanner 的 setRoot 方法注册相应的 RelNode，并进行相应的初始化操作</span></span><br><span class="line">planner.setRoot(relNode);</span><br><span class="line"><span class="comment">//4. 通过动态规划算法找到 cost 最小的 plan</span></span><br><span class="line">relNode = planner.findBestExp();</span><br></pre></td></tr></table></figure>
<p>优化后的结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EnumerableSort(sort0=[<span class="variable">$0</span>], dir0=[ASC])</span><br><span class="line">  EnumerableProject(USER_ID=[<span class="variable">$0</span>], USER_NAME=[<span class="variable">$1</span>], USER_COMPANY=[<span class="variable">$5</span>], USER_AGE=[<span class="variable">$2</span>])</span><br><span class="line">    EnumerableMergeJoin(condition=[=(<span class="variable">$0</span>, <span class="variable">$3</span>)], joinType=[inner])</span><br><span class="line">      EnumerableFilter(condition=[&gt;(<span class="variable">$2</span>, 30)])</span><br><span class="line">        EnumerableTableScan(table=[[USERS]])</span><br><span class="line">      EnumerableFilter(condition=[&gt;(<span class="variable">$0</span>, 10)])</span><br><span class="line">        EnumerableTableScan(table=[[JOBS]])</span><br></pre></td></tr></table></figure>
<p>在应用 VolcanoPlanner 时，整体分为以下四步：</p>
<ol>
<li>初始化 VolcanoPlanner，并添加相应的 Rule（包括 ConverterRule）；</li>
<li>对 RelNode 做等价转换，这里只是改变其物理属性（<code>Convention</code>）；</li>
<li>通过 VolcanoPlanner 的 <code>setRoot()</code> 方法注册相应的 RelNode，并进行相应的初始化操作；</li>
<li>通过动态规划算法找到 cost 最小的 plan；</li>
</ol>
<p>下面来分享一下上面的详细流程。</p>
<h4 id="1-VolcanoPlanner-初始化"><a href="#1-VolcanoPlanner-初始化" class="headerlink" title="1. VolcanoPlanner 初始化"></a>1. VolcanoPlanner 初始化</h4><p>在这里总共有三步，分别是 VolcanoPlanner 初始化，<code>addRelTraitDef()</code> 添加 RelTraitDef，<code>addRule()</code> 添加 rule，先看下 VolcanoPlanner 的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a uninitialized &lt;code&gt;VolcanoPlanner&lt;/code&gt;. To fully initialize it, the caller must register the desired set of relations, rules, and calling conventions.</span></span><br><span class="line"><span class="comment"> * note: 创建一个没有初始化的 VolcanoPlanner，如果要进行初始化，调用者必须注册 set of relations、rules、calling conventions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolcanoPlanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> VolcanoPlanner&#125; with a given cost factory.</span></span><br><span class="line"><span class="comment"> * note: 创建 VolcanoPlanner 实例，并制定 costFactory（默认为 VolcanoCost.FACTORY）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolcanoPlanner</span><span class="params">(RelOptCostFactory costFactory, //</span></span></span><br><span class="line"><span class="function"><span class="params">    Context externalContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(costFactory == <span class="keyword">null</span> ? VolcanoCost.FACTORY : costFactory, <span class="comment">//</span></span><br><span class="line">      externalContext);</span><br><span class="line">  <span class="keyword">this</span>.zeroCost = <span class="keyword">this</span>.costFactory.makeZeroCost();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实并没有做什么，只是做了一些简单的初始化，如果要想设置相应 RelTraitDef 的话，需要调用 <code>addRelTraitDef()</code> 进行添加，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">//note: 添加 RelTraitDef</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addRelTraitDef</span><span class="params">(RelTraitDef relTraitDef)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !traitDefs.contains(relTraitDef) &amp;&amp; traitDefs.add(relTraitDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要给 VolcanoPlanner 添加 Rule 的话，需要调用 <code>addRule()</code> 进行添加，<strong>在这个方法里重点做的一步是将具体的 RelNode 与 RelOptRuleOperand 之间的关系记录下来，记录到 <code>classOperands</code> 中</strong>，相当于在优化时，哪个 RelNode 可以应用哪些 Rule 都是记录在这个缓存里的。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">//note: 添加 rule</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addRule</span><span class="params">(RelOptRule rule)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ruleSet.contains(rule)) &#123;</span><br><span class="line">    <span class="comment">// Rule already exists.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> added = ruleSet.add(rule);</span><br><span class="line">  <span class="keyword">assert</span> added;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String ruleName = rule.toString();</span><br><span class="line">  <span class="comment">//note: 这里的 ruleNames 允许重复的 key 值，但是这里还是要求 rule description 保持唯一的，与 rule 一一对应</span></span><br><span class="line">  <span class="keyword">if</span> (ruleNames.put(ruleName, rule.getClass())) &#123;</span><br><span class="line">    Set&lt;Class&gt; x = ruleNames.get(ruleName);</span><br><span class="line">    <span class="keyword">if</span> (x.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Rule description '"</span> + ruleName</span><br><span class="line">          + <span class="string">"' is not unique; classes: "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 注册一个 rule 的 description（保存在 mapDescToRule 中）</span></span><br><span class="line">  mapRuleDescription(rule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Each of this rule's operands is an 'entry point' for a rule call. Register each operand against all concrete sub-classes that could match it.</span></span><br><span class="line">  <span class="comment">//note: 记录每个 sub-classes 与 operand 的关系（如果能 match 的话，就记录一次）。一个 RelOptRuleOperand 只会有一个 class 与之对应，这里找的是 subclass</span></span><br><span class="line">  <span class="keyword">for</span> (RelOptRuleOperand operand : rule.getOperands()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends RelNode&gt; subClass</span><br><span class="line">        : subClasses(operand.getMatchedClass())) &#123;</span><br><span class="line">      classOperands.put(subClass, operand);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a converter rule, check that it operates on one of the</span></span><br><span class="line">  <span class="comment">// kinds of trait we are interested in, and if so, register the rule</span></span><br><span class="line">  <span class="comment">// with the trait.</span></span><br><span class="line">  <span class="comment">//note: 对于 ConverterRule 的操作，如果其 ruleTraitDef 类型包含在我们初始化的 traitDefs 中，</span></span><br><span class="line">  <span class="comment">//note: 就注册这个 converterRule 到 ruleTraitDef 中</span></span><br><span class="line">  <span class="comment">//note: 如果不包含 ruleTraitDef，这个 ConverterRule 在本次优化的过程中是用不到的</span></span><br><span class="line">  <span class="keyword">if</span> (rule <span class="keyword">instanceof</span> ConverterRule) &#123;</span><br><span class="line">    ConverterRule converterRule = (ConverterRule) rule;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RelTrait ruleTrait = converterRule.getInTrait();</span><br><span class="line">    <span class="keyword">final</span> RelTraitDef ruleTraitDef = ruleTrait.getTraitDef();</span><br><span class="line">    <span class="keyword">if</span> (traitDefs.contains(ruleTraitDef)) &#123; <span class="comment">//note: 这里注册好像也没有用到</span></span><br><span class="line">      ruleTraitDef.registerConverterRule(<span class="keyword">this</span>, converterRule);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-RelNode-changeTraits"><a href="#2-RelNode-changeTraits" class="headerlink" title="2. RelNode changeTraits"></a>2. RelNode changeTraits</h4><p>这里分为两步：</p>
<ol>
<li>通过 RelTraitSet 的 <code>replace()</code> 方法，将 RelTraitSet 中对应的 RelTraitDef 做对应的更新，其他的 RelTrait 不变；</li>
<li>这一步简单来说就是：Changes a relational expression to an equivalent one with a different set of traits，对相应的 RelNode 做 converter 操作，这里实际上也会做很多的内容，这部分会放在第三步讲解，主要是 <code>registerImpl()</code> 方法的实现。</li>
</ol>
<h4 id="3-VolcanoPlanner-setRoot"><a href="#3-VolcanoPlanner-setRoot" class="headerlink" title="3. VolcanoPlanner setRoot"></a>3. VolcanoPlanner setRoot</h4><p>VolcanoPlanner 会调用 <code>setRoot()</code> 方法注册相应的 Root RelNode，并进行一系列 Volcano 必须的初始化操作，很多的操作都是在这里实现的，这里来详细看下其实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(RelNode rel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We're registered all the rules, and therefore RelNode classes,</span></span><br><span class="line">  <span class="comment">// we're interested in, and have not yet started calling metadata providers.</span></span><br><span class="line">  <span class="comment">// So now is a good time to tell the metadata layer what to expect.</span></span><br><span class="line">  registerMetadataRels();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 注册相应的 RelNode，会做一系列的初始化操作, RelNode 会有对应的 RelSubset</span></span><br><span class="line">  <span class="keyword">this</span>.root = registerImpl(rel, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.originalRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.originalRoot = rel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Making a node the root changes its importance.</span></span><br><span class="line">  <span class="comment">//note: 重新计算 root subset 的 importance</span></span><br><span class="line">  <span class="keyword">this</span>.ruleQueue.recompute(<span class="keyword">this</span>.root);</span><br><span class="line">  <span class="comment">//Ensures that the subset that is the root relational expression contains converters to all other subsets in its equivalence set.</span></span><br><span class="line">  ensureRootConverters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>setRoot()</code> 方法来说，核心的处理流程是在 <code>registerImpl()</code> 方法中，在这个方法会进行相应的初始化操作（包括 RelNode 到 RelSubset 的转换、计算 RelSubset 的 importance 等），其他的方法在上面有相应的备注，这里我们看下 <code>registerImpl()</code> 具体做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers a new expression &lt;code&gt;exp&lt;/code&gt; and queues up rule matches.</span></span><br><span class="line"><span class="comment"> * If &lt;code&gt;set&lt;/code&gt; is not null, makes the expression part of that</span></span><br><span class="line"><span class="comment"> * equivalence set. If an identical expression is already registered, we</span></span><br><span class="line"><span class="comment"> * don't need to register this one and nor should we queue up rule matches.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：注册一个新的 expression；对 rule match 进行排队；</span></span><br><span class="line"><span class="comment"> * note：如果 set 不为 null，那么就使 expression 成为等价集合（RelSet）的一部分</span></span><br><span class="line"><span class="comment"> * note：rel：必须是 RelSubset 或者未注册的 RelNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rel relational expression to register. Must be either a</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> RelSubset&#125;, or an unregistered &#123;<span class="doctag">@link</span> RelNode&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> set set that rel belongs to, or &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the equivalence-set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RelSubset <span class="title">registerImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RelNode rel,</span></span></span><br><span class="line"><span class="function"><span class="params">    RelSet set)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> RelSubset) &#123; <span class="comment">//note: 如果是 RelSubset 类型，已经注册过了</span></span><br><span class="line">    <span class="keyword">return</span> registerSubset(set, (RelSubset) rel); <span class="comment">//note: 做相应的 merge</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span> !isRegistered(rel) : <span class="string">"already been registered: "</span> + rel;</span><br><span class="line">  <span class="keyword">if</span> (rel.getCluster().getPlanner() != <span class="keyword">this</span>) &#123; <span class="comment">//note: cluster 中 planner 与这里不同</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Relational expression "</span> + rel</span><br><span class="line">        + <span class="string">" belongs to a different planner than is currently being used."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now is a good time to ensure that the relational expression</span></span><br><span class="line">  <span class="comment">// implements the interface required by its calling convention.</span></span><br><span class="line">  <span class="comment">//note: 确保 relational expression 可以实施其 calling convention 所需的接口</span></span><br><span class="line">  <span class="comment">//note: 获取 RelNode 的 RelTraitSet</span></span><br><span class="line">  <span class="keyword">final</span> RelTraitSet traits = rel.getTraitSet();</span><br><span class="line">  <span class="comment">//note: 获取其 ConventionTraitDef</span></span><br><span class="line">  <span class="keyword">final</span> Convention convention = traits.getTrait(ConventionTraitDef.INSTANCE);</span><br><span class="line">  <span class="keyword">assert</span> convention != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!convention.getInterface().isInstance(rel)</span><br><span class="line">      &amp;&amp; !(rel <span class="keyword">instanceof</span> Converter)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Relational expression "</span> + rel</span><br><span class="line">        + <span class="string">" has calling-convention "</span> + convention</span><br><span class="line">        + <span class="string">" but does not implement the required interface '"</span></span><br><span class="line">        + convention.getInterface() + <span class="string">"' of that convention"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (traits.size() != traitDefs.size()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Relational expression "</span> + rel</span><br><span class="line">        + <span class="string">" does not have the correct number of traits: "</span> + traits.size()</span><br><span class="line">        + <span class="string">" != "</span> + traitDefs.size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that its sub-expressions are registered.</span></span><br><span class="line">  <span class="comment">//note: 其实现在 AbstractRelNode 对应的方法中，实际上调用的还是 ensureRegistered 方法进行注册</span></span><br><span class="line">  <span class="comment">//note: 将 RelNode 的所有 inputs 注册到 planner 中</span></span><br><span class="line">  <span class="comment">//note: 这里会递归调用 registerImpl 注册 relNode 与 RelSet，直到其 inputs 全部注册</span></span><br><span class="line">  <span class="comment">//note: 返回的是一个 RelSubset 类型</span></span><br><span class="line">  rel = rel.onRegister(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record its provenance. (Rule call may be null.)</span></span><br><span class="line">  <span class="comment">//note: 记录 RelNode 的来源</span></span><br><span class="line">  <span class="keyword">if</span> (ruleCallStack.isEmpty()) &#123; <span class="comment">//note: 不知道来源时</span></span><br><span class="line">    provenanceMap.put(rel, Provenance.EMPTY);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//note: 来自 rule 触发的情况</span></span><br><span class="line">    <span class="keyword">final</span> VolcanoRuleCall ruleCall = ruleCallStack.peek();</span><br><span class="line">    provenanceMap.put(</span><br><span class="line">        rel,</span><br><span class="line">        <span class="keyword">new</span> RuleProvenance(</span><br><span class="line">            ruleCall.rule,</span><br><span class="line">            ImmutableList.copyOf(ruleCall.rels),</span><br><span class="line">            ruleCall.id));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it is equivalent to an existing expression, return the set that</span></span><br><span class="line">  <span class="comment">// the equivalent expression belongs to.</span></span><br><span class="line">  <span class="comment">//note: 根据 RelNode 的 digest（摘要，全局唯一）判断其是否已经有对应的 RelSubset，有的话直接放回</span></span><br><span class="line">  String key = rel.getDigest();</span><br><span class="line">  RelNode equivExp = mapDigestToRel.get(key);</span><br><span class="line">  <span class="keyword">if</span> (equivExp == <span class="keyword">null</span>) &#123; <span class="comment">//note: 还没注册的情况</span></span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (equivExp == rel) &#123;<span class="comment">//note: 已经有其缓存信息</span></span><br><span class="line">    <span class="keyword">return</span> getSubset(rel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> RelOptUtil.equal(</span><br><span class="line">        <span class="string">"left"</span>, equivExp.getRowType(),</span><br><span class="line">        <span class="string">"right"</span>, rel.getRowType(),</span><br><span class="line">        Litmus.THROW);</span><br><span class="line">    RelSet equivSet = getSet(equivExp); <span class="comment">//note: 有 RelSubset 但对应的 RelNode 不同时，这里对其 RelSet 做下 merge</span></span><br><span class="line">    <span class="keyword">if</span> (equivSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">      LOGGER.trace(</span><br><span class="line">          <span class="string">"Register: rel#&#123;&#125; is equivalent to &#123;&#125;"</span>, rel.getId(), equivExp.getDescription());</span><br><span class="line">      <span class="keyword">return</span> registerSubset(set, getSubset(equivExp));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note： Converters are in the same set as their children.</span></span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">    <span class="keyword">final</span> RelNode input = ((Converter) rel).getInput();</span><br><span class="line">    <span class="keyword">final</span> RelSet childSet = getSet(input);</span><br><span class="line">    <span class="keyword">if</span> ((set != <span class="keyword">null</span>)</span><br><span class="line">        &amp;&amp; (set != childSet)</span><br><span class="line">        &amp;&amp; (set.equivalentSet == <span class="keyword">null</span>)) &#123;</span><br><span class="line">      LOGGER.trace(</span><br><span class="line">          <span class="string">"Register #&#123;&#125; &#123;&#125; (and merge sets, because it is a conversion)"</span>,</span><br><span class="line">          rel.getId(), rel.getDigest());</span><br><span class="line">      merge(set, childSet);</span><br><span class="line">      registerCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// During the mergers, the child set may have changed, and since</span></span><br><span class="line">      <span class="comment">// we're not registered yet, we won't have been informed. So</span></span><br><span class="line">      <span class="comment">// check whether we are now equivalent to an existing</span></span><br><span class="line">      <span class="comment">// expression.</span></span><br><span class="line">      <span class="keyword">if</span> (fixUpInputs(rel)) &#123;</span><br><span class="line">        rel.recomputeDigest();</span><br><span class="line">        key = rel.getDigest();</span><br><span class="line">        RelNode equivRel = mapDigestToRel.get(key);</span><br><span class="line">        <span class="keyword">if</span> ((equivRel != rel) &amp;&amp; (equivRel != <span class="keyword">null</span>)) &#123;</span><br><span class="line">          <span class="keyword">assert</span> RelOptUtil.equal(</span><br><span class="line">              <span class="string">"rel rowtype"</span>,</span><br><span class="line">              rel.getRowType(),</span><br><span class="line">              <span class="string">"equivRel rowtype"</span>,</span><br><span class="line">              equivRel.getRowType(),</span><br><span class="line">              Litmus.THROW);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// make sure this bad rel didn't get into the</span></span><br><span class="line">          <span class="comment">// set in any way (fixupInputs will do this but it</span></span><br><span class="line">          <span class="comment">// doesn't know if it should so it does it anyway)</span></span><br><span class="line">          set.obliterateRelNode(rel);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// There is already an equivalent expression. Use that</span></span><br><span class="line">          <span class="comment">// one, and forget about this one.</span></span><br><span class="line">          <span class="keyword">return</span> getSubset(equivRel);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      set = childSet;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Place the expression in the appropriate equivalence set.</span></span><br><span class="line">  <span class="comment">//note: 把 expression 放到合适的 等价集 中</span></span><br><span class="line">  <span class="comment">//note: 如果 RelSet 不存在，这里会初始化一个 RelSet</span></span><br><span class="line">  <span class="keyword">if</span> (set == <span class="keyword">null</span>) &#123;</span><br><span class="line">    set = <span class="keyword">new</span> RelSet(</span><br><span class="line">        nextSetId++,</span><br><span class="line">        Util.minus(</span><br><span class="line">            RelOptUtil.getVariablesSet(rel),</span><br><span class="line">            rel.getVariablesSet()),</span><br><span class="line">        RelOptUtil.getVariablesUsed(rel));</span><br><span class="line">    <span class="keyword">this</span>.allSets.add(set);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chain to find 'live' equivalent set, just in case several sets are</span></span><br><span class="line">  <span class="comment">// merging at the same time.</span></span><br><span class="line">  <span class="comment">//note: 递归查询，一直找到最开始的 语义相等的集合，防止不同集合同时被 merge</span></span><br><span class="line">  <span class="keyword">while</span> (set.equivalentSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    set = set.equivalentSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow each rel to register its own rules.</span></span><br><span class="line">  registerClass(rel);</span><br><span class="line"></span><br><span class="line">  registerCount++;</span><br><span class="line">  <span class="comment">//note: 初始时是 0</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> subsetBeforeCount = set.subsets.size();</span><br><span class="line">  <span class="comment">//note: 向等价集中添加相应的 RelNode，并更新其 best 信息</span></span><br><span class="line">  RelSubset subset = addRelToSet(rel, set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 缓存相关信息，返回的 key 之前对应的 value</span></span><br><span class="line">  <span class="keyword">final</span> RelNode xx = mapDigestToRel.put(key, rel);</span><br><span class="line">  <span class="keyword">assert</span> xx == <span class="keyword">null</span> || xx == rel : rel.getDigest();</span><br><span class="line"></span><br><span class="line">  LOGGER.trace(<span class="string">"Register &#123;&#125; in &#123;&#125;"</span>, rel.getDescription(), subset.getDescription());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This relational expression may have been registered while we</span></span><br><span class="line">  <span class="comment">// recursively registered its children. If this is the case, we're done.</span></span><br><span class="line">  <span class="keyword">if</span> (xx != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> subset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create back-links from its children, which makes children more</span></span><br><span class="line">  <span class="comment">// important.</span></span><br><span class="line">  <span class="comment">//note: 如果是 root，初始化其 importance 为 1.0</span></span><br><span class="line">  <span class="keyword">if</span> (rel == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">    ruleQueue.subsetImportances.put(</span><br><span class="line">        subset,</span><br><span class="line">        <span class="number">1.0</span>); <span class="comment">// todo: remove</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: 将 Rel 的 input 对应的 RelSubset 的 parents 设置为当前的 Rel</span></span><br><span class="line">  <span class="comment">//note: 也就是说，一个 RelNode 的 input 为其对应 RelSubset 的 children 节点</span></span><br><span class="line">  <span class="keyword">for</span> (RelNode input : rel.getInputs()) &#123;</span><br><span class="line">    RelSubset childSubset = (RelSubset) input;</span><br><span class="line">    childSubset.set.parents.add(rel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child subset is more important now a new parent uses it.</span></span><br><span class="line">    <span class="comment">//note: 重新计算 RelSubset 的 importance</span></span><br><span class="line">    ruleQueue.recompute(childSubset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rel == <span class="keyword">this</span>.root) &#123;<span class="comment">// <span class="doctag">TODO:</span> 2019-03-11 这里为什么要删除呢？</span></span><br><span class="line">    ruleQueue.subsetImportances.remove(subset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember abstract converters until they're satisfied</span></span><br><span class="line">  <span class="comment">//note: 如果是 AbstractConverter 示例，添加到 abstractConverters 集合中</span></span><br><span class="line">  <span class="keyword">if</span> (rel <span class="keyword">instanceof</span> AbstractConverter) &#123;</span><br><span class="line">    set.abstractConverters.add((AbstractConverter) rel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this set has any unsatisfied converters, try to satisfy them.</span></span><br><span class="line">  <span class="comment">//note: check set.abstractConverters</span></span><br><span class="line">  checkForSatisfiedConverters(set, rel);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure this rel's subset importance is updated</span></span><br><span class="line">  <span class="comment">//note: 强制更新（重新计算） subset 的 importance</span></span><br><span class="line">  ruleQueue.recompute(subset, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 触发所有匹配的 rule，这里是添加到对应的 RuleQueue 中</span></span><br><span class="line">  <span class="comment">// Queue up all rules triggered by this relexp's creation.</span></span><br><span class="line">  fireRules(rel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It's a new subset.</span></span><br><span class="line">  <span class="comment">//note: 如果是一个 new subset，再做一次触发</span></span><br><span class="line">  <span class="keyword">if</span> (set.subsets.size() &gt; subsetBeforeCount) &#123;</span><br><span class="line">    fireRules(subset, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>registerImpl()</code> 处理流程比较复杂，其方法实现，可以简单总结为以下几步：</p>
<ol>
<li>在经过最上面的一些验证之后，会通过 <code>rel.onRegister(this)</code> 这步操作，递归地调用 VolcanoPlanner 的 <code>ensureRegistered()</code> 方法对其 <code>inputs</code> RelNode 进行注册，最后还是调用 <code>registerImpl()</code> 方法先注册叶子节点，然后再父节点，最后到根节点；</li>
<li>根据 RelNode 的 digest 信息（一般这个对于 RelNode 来说是全局唯一的），判断其是否已经存在 <code>mapDigestToRel</code> 缓存中，如果存在的话，那么判断会 RelNode 是否相同，如果相同的话，证明之前已经注册过，直接通过 <code>getSubset()</code> 返回其对应的 RelSubset 信息，否则就对其 RelSubset 做下 merge；</li>
<li>如果 RelNode 对应的 RelSet 为 null，这里会新建一个 RelSet，并通过 <code>addRelToSet()</code> 将 RelNode 添加到 RelSet 中，并且更新 VolcanoPlanner 的 <code>mapRel2Subset</code> 缓存记录（RelNode 与 RelSubset 的对应关系），在 <code>addRelToSet()</code> 的最后还会更新 RelSubset 的 best plan 和 best cost（每当往一个 RelSubset 添加相应的 RelNode 时，都会判断这个 RelNode 是否代表了 best plan，如果是的话，就更新）；</li>
<li>将这个 RelNode 的 inputs 设置为其对应 RelSubset 的 children 节点（实际的操作时，是在 RelSet 的 <code>parents</code> 中记录其父节点）；</li>
<li>强制重新计算当前 RelNode 对应 RelSubset 的 importance；</li>
<li>如果这个 RelSubset 是新建的，会再触发一次 <code>fireRules()</code> 方法（会先对 RelNode 触发一次），遍历找到所有可以 match 的 Rule，对每个 Rule 都会创建一个 VolcanoRuleMatch 对象（会记录 RelNode、RelOptRuleOperand 等信息，RelOptRuleOperand 中又会记录 Rule 的信息），并将这个 VolcanoRuleMatch 添加到对应的 RuleQueue 中（就是前面图中的那个 RuleQueue）。</li>
</ol>
<p>这里，来看下 <code>fireRules()</code> 方法的实现，它的目的是把配置的 RuleMatch 添加到 RuleQueue 中，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fires all rules matched by a relational expression.</span></span><br><span class="line"><span class="comment"> * note： 触发满足这个 relational expression 的所有 rules</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rel      Relational expression which has just been created (or maybe</span></span><br><span class="line"><span class="comment"> *                 from the queue)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deferred If true, each time a rule matches, just add an entry to</span></span><br><span class="line"><span class="comment"> *                 the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireRules</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RelNode rel,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> deferred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RelOptRuleOperand operand : classOperands.get(rel.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (operand.matches(rel)) &#123; <span class="comment">//note: rule 匹配的情况</span></span><br><span class="line">      <span class="keyword">final</span> VolcanoRuleCall ruleCall;</span><br><span class="line">      <span class="keyword">if</span> (deferred) &#123; <span class="comment">//note: 这里默认都是 true，会把 RuleMatch 添加到 queue 中</span></span><br><span class="line">        ruleCall = <span class="keyword">new</span> DeferringRuleCall(<span class="keyword">this</span>, operand);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ruleCall = <span class="keyword">new</span> VolcanoRuleCall(<span class="keyword">this</span>, operand);</span><br><span class="line">      &#125;</span><br><span class="line">      ruleCall.match(rel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A rule call which defers its actions. Whereas &#123;<span class="doctag">@link</span> RelOptRuleCall&#125;</span></span><br><span class="line"><span class="comment"> * invokes the rule when it finds a match, a &lt;code&gt;DeferringRuleCall&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * creates a &#123;<span class="doctag">@link</span> VolcanoRuleMatch&#125; which can be invoked later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferringRuleCall</span> <span class="keyword">extends</span> <span class="title">VolcanoRuleCall</span> </span>&#123;</span><br><span class="line">  DeferringRuleCall(</span><br><span class="line">      VolcanoPlanner planner,</span><br><span class="line">      RelOptRuleOperand operand) &#123;</span><br><span class="line">    <span class="keyword">super</span>(planner, operand);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Rather than invoking the rule (as the base method does), creates a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> VolcanoRuleMatch&#125; which can be invoked later.</span></span><br><span class="line"><span class="comment">   * note：不是直接触发 rule，而是创建一个后续可以被触发的 VolcanoRuleMatch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VolcanoRuleMatch match =</span><br><span class="line">        <span class="keyword">new</span> VolcanoRuleMatch(</span><br><span class="line">            volcanoPlanner,</span><br><span class="line">            getOperand0(), <span class="comment">//note: 其实就是 operand</span></span><br><span class="line">            rels,</span><br><span class="line">            nodeInputs);</span><br><span class="line">    volcanoPlanner.ruleQueue.addMatch(match);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中，对于匹配的 Rule，将会创建一个 VolcanoRuleMatch 对象，之后再把这个 VolcanoRuleMatch 对象添加到对应的 RuleQueue 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.RuleQueue</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a rule match. The rule-matches are automatically added to all</span></span><br><span class="line"><span class="comment"> * existing &#123;<span class="doctag">@link</span> PhaseMatchList per-phase rule-match lists&#125; which allow</span></span><br><span class="line"><span class="comment"> * the rule referenced by the match.</span></span><br><span class="line"><span class="comment"> * note：添加一个 rule match（添加到所有现存的 match phase 中）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addMatch</span><span class="params">(VolcanoRuleMatch match)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String matchName = match.toString();</span><br><span class="line">  <span class="keyword">for</span> (PhaseMatchList matchList : matchListMap.values()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matchList.names.add(matchName)) &#123;</span><br><span class="line">      <span class="comment">// Identical match has already been added.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String ruleClassName = match.getRule().getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; phaseRuleSet = phaseRuleMapping.get(matchList.phase);</span><br><span class="line">    <span class="comment">//note: 如果 phaseRuleSet 不为 ALL_RULES，并且 phaseRuleSet 不包含这个 ruleClassName 时，就跳过(其他三个阶段都属于这个情况)</span></span><br><span class="line">    <span class="comment">//note: 在添加 rule match 时，phaseRuleSet 可以控制哪些 match 可以添加、哪些不能添加</span></span><br><span class="line">    <span class="comment">//note: 这里的话，默认只有处在 OPTIMIZE 阶段的 PhaseMatchList 可以添加相应的 rule match</span></span><br><span class="line">    <span class="keyword">if</span> (phaseRuleSet != ALL_RULES) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!phaseRuleSet.contains(ruleClassName)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.trace(<span class="string">"&#123;&#125; Rule-match queued: &#123;&#125;"</span>, matchList.phase.toString(), matchName);</span><br><span class="line"></span><br><span class="line">    matchList.list.add(match);</span><br><span class="line"></span><br><span class="line">    matchList.matchMap.put(</span><br><span class="line">        planner.getSubset(match.rels[<span class="number">0</span>]), match);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里 VolcanoPlanner 需要初始化的内容都初始化完成了，下面就到了具体的优化部分。</p>
<h4 id="4-VolcanoPlanner-findBestExp"><a href="#4-VolcanoPlanner-findBestExp" class="headerlink" title="4. VolcanoPlanner findBestExp"></a>4. VolcanoPlanner findBestExp</h4><p>VolcanoPlanner 的 <code>findBestExp()</code> 是具体进行优化的地方，先介绍一下这里的优化策略（每进行一次迭代，<code>cumulativeTicks</code> 加1，它记录了总的迭代次数）：</p>
<ol>
<li>第一次找到可执行计划的迭代次数记为 <code>firstFiniteTick</code>，其对应的 Cost 暂时记为 BestCost；</li>
<li>制定下一次优化要达到的目标为 <code>BestCost*0.9</code>，再根据 <code>firstFiniteTick</code> 及当前的迭代次数计算 <code>giveUpTick</code>，这个值代表的意思是：如果迭代次数超过这个值还没有达到优化目标，那么将会放弃迭代，认为当前的 plan 就是 best plan；</li>
<li>如果 RuleQueue 中 RuleMatch 为空，那么也会退出迭代，认为当前的 plan 就是 best plan；</li>
<li>在每次迭代时都会从 RuleQueue 中选择一个 RuleMatch，策略是选择一个最高 importance 的 RuleMatch，可以保证在每次规则优化时都是选择当前优化效果最好的 Rule 去优化；</li>
<li>最后根据 best plan，构建其对应的 RelNode。</li>
</ol>
<p>上面就是 <code>findBestExp()</code> 主要设计理念，这里来看其具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.VolcanoPlanner</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the most efficient expression to implement the query given via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.calcite.plan.RelOptPlanner#setRoot(org.apache.calcite.rel.RelNode)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：找到最有效率的 relational expression，这个算法包含一系列阶段，每个阶段被触发的 rules 可能不同</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The algorithm executes repeatedly in a series of phases. In each phase</span></span><br><span class="line"><span class="comment"> * the exact rules that may be fired varies. The mapping of phases to rule</span></span><br><span class="line"><span class="comment"> * sets is maintained in the &#123;<span class="doctag">@link</span> #ruleQueue&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：在每个阶段，planner 都会初始化这个 RelSubset 的 importance，planner 会遍历 rule queue 中 rules 直到：</span></span><br><span class="line"><span class="comment"> * note：1. rule queue 变为空；</span></span><br><span class="line"><span class="comment"> * note：2. 对于 ambitious planner，最近 cost 不再提高时（具体来说，第一次找到一个可执行计划时，需要达到需要迭代总数的10%或更大）；</span></span><br><span class="line"><span class="comment"> * note：3. 对于 non-ambitious planner，当找到一个可执行的计划就行；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In each phase, the planner sets the initial importance of the existing</span></span><br><span class="line"><span class="comment"> * RelSubSets (&#123;<span class="doctag">@link</span> #setInitialImportance()&#125;). The planner then iterates</span></span><br><span class="line"><span class="comment"> * over the rule matches presented by the rule queue until:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The rule queue becomes empty.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For ambitious planners: No improvements to the plan have been made</span></span><br><span class="line"><span class="comment"> * recently (specifically within a number of iterations that is 10% of the</span></span><br><span class="line"><span class="comment"> * number of iterations necessary to first reach an implementable plan or 25</span></span><br><span class="line"><span class="comment"> * iterations whichever is larger).&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For non-ambitious planners: When an implementable plan is found.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：此外，如果每10次迭代之后，没有一个可实现的计划，包含 logical RelNode 的 RelSubSets 将会通过 injectImportanceBoost 给一个 importance；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Furthermore, after every 10 iterations without an implementable plan,</span></span><br><span class="line"><span class="comment"> * RelSubSets that contain only logical RelNodes are given an importance</span></span><br><span class="line"><span class="comment"> * boost via &#123;<span class="doctag">@link</span> #injectImportanceBoost()&#125;. Once an implementable plan is</span></span><br><span class="line"><span class="comment"> * found, the artificially raised importance values are cleared (see</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #clearImportanceBoost()&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the most efficient RelNode tree found for implementing the given</span></span><br><span class="line"><span class="comment"> * query</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RelNode <span class="title">findBestExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//note: 确保 root relational expression 的 subset（RelSubset）在它的等价集（RelSet）中包含所有 RelSubset 的 converter</span></span><br><span class="line">  <span class="comment">//note: 来保证 planner 从其他的 subsets 找到的实现方案可以转换为 root，否则可能因为 convention 不同，无法实施</span></span><br><span class="line">  ensureRootConverters();</span><br><span class="line">  <span class="comment">//note: materialized views 相关，这里可以先忽略~</span></span><br><span class="line">  registerMaterializations();</span><br><span class="line">  <span class="keyword">int</span> cumulativeTicks = <span class="number">0</span>; <span class="comment">//note: 四个阶段通用的变量</span></span><br><span class="line">  <span class="comment">//note: 不同的阶段，总共四个阶段，实际上只有 OPTIMIZE 这个阶段有效，因为其他阶段不会有 RuleMatch</span></span><br><span class="line">  <span class="keyword">for</span> (VolcanoPlannerPhase phase : VolcanoPlannerPhase.values()) &#123;</span><br><span class="line">    <span class="comment">//note: 在不同的阶段，初始化 RelSubSets 相应的 importance</span></span><br><span class="line">    <span class="comment">//note: root 节点往下子节点的 importance 都会被初始化</span></span><br><span class="line">    setInitialImportance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//note: 默认是 VolcanoCost</span></span><br><span class="line">    RelOptCost targetCost = costFactory.makeHugeCost();</span><br><span class="line">    <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> firstFiniteTick = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> splitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> giveUpTick = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ++tick;</span><br><span class="line">      ++cumulativeTicks;</span><br><span class="line">      <span class="comment">//note: 第一次运行是 false，两个不是一个对象，一个是 costFactory.makeHugeCost， 一个是 costFactory.makeInfiniteCost</span></span><br><span class="line">      <span class="comment">//note: 如果低于目标 cost，这里再重新设置一个新目标、新的 giveUpTick</span></span><br><span class="line">      <span class="keyword">if</span> (root.bestCost.isLe(targetCost)) &#123;</span><br><span class="line">        <span class="comment">//note: 本阶段第一次运行，目的是为了调用 clearImportanceBoost 方法，清除相应的 importance 信息</span></span><br><span class="line">        <span class="keyword">if</span> (firstFiniteTick &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          firstFiniteTick = cumulativeTicks;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//note: 对于那些手动提高 importance 的 RelSubset 进行重新计算</span></span><br><span class="line">          clearImportanceBoost();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ambitious) &#123;</span><br><span class="line">          <span class="comment">// Choose a slightly more ambitious target cost, and</span></span><br><span class="line">          <span class="comment">// try again. If it took us 1000 iterations to find our</span></span><br><span class="line">          <span class="comment">// first finite plan, give ourselves another 100</span></span><br><span class="line">          <span class="comment">// iterations to reduce the cost by 10%.</span></span><br><span class="line">          <span class="comment">//note: 设置 target 为当前 best cost 的 0.9，调整相应的目标，再进行优化</span></span><br><span class="line">          targetCost = root.bestCost.multiplyBy(<span class="number">0.9</span>);</span><br><span class="line">          ++splitCount;</span><br><span class="line">          <span class="keyword">if</span> (impatient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstFiniteTick &lt; <span class="number">10</span>) &#123;</span><br><span class="line">              <span class="comment">// It's possible pre-processing can create</span></span><br><span class="line">              <span class="comment">// an implementable plan -- give us some time</span></span><br><span class="line">              <span class="comment">// to actually optimize it.</span></span><br><span class="line">              <span class="comment">//note: 有可能在 pre-processing 阶段就实现一个 implementable plan，所以先设置一个值，后面再去优化</span></span><br><span class="line">              giveUpTick = cumulativeTicks + <span class="number">25</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              giveUpTick =</span><br><span class="line">                  cumulativeTicks</span><br><span class="line">                      + Math.max(firstFiniteTick / <span class="number">10</span>, <span class="number">25</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//note: 最近没有任何进步（超过 giveUpTick 限制，还没达到目标值），直接采用当前的 best plan</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cumulativeTicks &gt; giveUpTick) &#123;</span><br><span class="line">        <span class="comment">// We haven't made progress recently. Take the current best.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.bestCost.isInfinite() &amp;&amp; ((tick % <span class="number">10</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        injectImportanceBoost();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOGGER.debug(<span class="string">"PLANNER = &#123;&#125;; TICK = &#123;&#125;/&#123;&#125;; PHASE = &#123;&#125;; COST = &#123;&#125;"</span>,</span><br><span class="line">          <span class="keyword">this</span>, cumulativeTicks, tick, phase.toString(), root.bestCost);</span><br><span class="line"></span><br><span class="line">      VolcanoRuleMatch match = ruleQueue.popMatch(phase);</span><br><span class="line">      <span class="comment">//note: 如果没有规则，会直接退出当前的阶段</span></span><br><span class="line">      <span class="keyword">if</span> (match == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span> match.getRule().matches(match);</span><br><span class="line">      <span class="comment">//note: 做相应的规则匹配</span></span><br><span class="line">      match.onMatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The root may have been merged with another</span></span><br><span class="line">      <span class="comment">// subset. Find the new root subset.</span></span><br><span class="line">      root = canonize(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//note: 当期阶段完成，移除 ruleQueue 中记录的 rule-match list</span></span><br><span class="line">    ruleQueue.phaseCompleted(phase);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (LOGGER.isTraceEnabled()) &#123;</span><br><span class="line">    StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    <span class="keyword">final</span> PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw);</span><br><span class="line">    dump(pw);</span><br><span class="line">    pw.flush();</span><br><span class="line">    LOGGER.trace(sw.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//note: 根据 plan 构建其 RelNode 树</span></span><br><span class="line">  RelNode cheapest = root.buildCheapestPlan(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">    LOGGER.debug(</span><br><span class="line">        <span class="string">"Cheapest plan:\n&#123;&#125;"</span>, RelOptUtil.toString(cheapest, SqlExplainLevel.ALL_ATTRIBUTES));</span><br><span class="line"></span><br><span class="line">    LOGGER.debug(<span class="string">"Provenance:\n&#123;&#125;"</span>, provenance(cheapest));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cheapest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体的流程正如前面所述，这里来看下 RuleQueue 中 <code>popMatch()</code> 方法的实现，它的目的是选择 the highest importance 的 RuleMatch，这个方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.calcite.plan.volcano.RuleQueue</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the rule match with the highest importance, and returns it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * note：返回最高 importance 的 rule，并从 Rule Match 中移除（处理过后的就移除）</span></span><br><span class="line"><span class="comment"> * note：如果集合为空，就返回 null</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Returns &#123;<span class="doctag">@code</span> null&#125; if there are no more matches.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the VolcanoPlanner may still decide to reject rule matches</span></span><br><span class="line"><span class="comment"> * which have become invalid, say if one of their operands belongs to an</span></span><br><span class="line"><span class="comment"> * obsolete set or has importance=0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.lang.AssertionError if this method is called with a phase</span></span><br><span class="line"><span class="comment"> *                              previously marked as completed via</span></span><br><span class="line"><span class="comment"> *                              &#123;<span class="doctag">@link</span> #phaseCompleted(VolcanoPlannerPhase)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VolcanoRuleMatch <span class="title">popMatch</span><span class="params">(VolcanoPlannerPhase phase)</span> </span>&#123;</span><br><span class="line">  dump();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 选择当前阶段对应的 PhaseMatchList</span></span><br><span class="line">  PhaseMatchList phaseMatchList = matchListMap.get(phase);</span><br><span class="line">  <span class="keyword">if</span> (phaseMatchList == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Used match list for phase "</span> + phase</span><br><span class="line">        + <span class="string">" after phase complete"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;VolcanoRuleMatch&gt; matchList = phaseMatchList.list;</span><br><span class="line">  VolcanoRuleMatch match;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//note: 按照前面的逻辑只有在 OPTIMIZE 阶段，PhaseMatchList 才不为空，其他阶段都是空</span></span><br><span class="line">    <span class="comment">// 参考 addMatch 方法</span></span><br><span class="line">    <span class="keyword">if</span> (matchList.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LOGGER.isTraceEnabled()) &#123;</span><br><span class="line">      matchList.sort(MATCH_COMPARATOR);</span><br><span class="line">      match = matchList.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      b.append(<span class="string">"Sorted rule queue:"</span>);</span><br><span class="line">      <span class="keyword">for</span> (VolcanoRuleMatch match2 : matchList) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> importance = match2.computeImportance();</span><br><span class="line">        b.append(<span class="string">"\n"</span>);</span><br><span class="line">        b.append(match2);</span><br><span class="line">        b.append(<span class="string">" importance "</span>);</span><br><span class="line">        b.append(importance);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOGGER.trace(b.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//note: 直接遍历找到 importance 最大的 match（上面先做排序，是为了输出日志）</span></span><br><span class="line">      <span class="comment">// If we're not tracing, it's not worth the effort of sorting the</span></span><br><span class="line">      <span class="comment">// list to find the minimum.</span></span><br><span class="line">      match = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> bestPos = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (VolcanoRuleMatch match2 : matchList) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span> (match == <span class="keyword">null</span></span><br><span class="line">            || MATCH_COMPARATOR.compare(match2, match) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          bestPos = i;</span><br><span class="line">          match = match2;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      match = matchList.remove(bestPos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skipMatch(match)) &#123;</span><br><span class="line">      LOGGER.debug(<span class="string">"Skip match: &#123;&#125;"</span>, match);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A rule match's digest is composed of the operand RelNodes' digests,</span></span><br><span class="line">  <span class="comment">// which may have changed if sets have merged since the rule match was</span></span><br><span class="line">  <span class="comment">// enqueued.</span></span><br><span class="line">  <span class="comment">//note: 重新计算一下这个 RuleMatch 的 digest</span></span><br><span class="line">  match.recomputeDigest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//note: 从 phaseMatchList 移除这个 RuleMatch</span></span><br><span class="line">  phaseMatchList.matchMap.remove(</span><br><span class="line">      planner.getSubset(match.rels[<span class="number">0</span>]), match);</span><br><span class="line"></span><br><span class="line">  LOGGER.debug(<span class="string">"Pop match: &#123;&#125;"</span>, match);</span><br><span class="line">  <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们就把 VolcanoPlanner 的优化讲述完了，当然并没有面面俱到所有的细节，VolcanoPlanner 的整体处理图如下：</p>
<p><img src="/images/calcite/14-volcano.png" alt="VolcanoPlanner 整体处理流程"> </p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><h4 id="1-初始化-RuleQueue-时，添加的-one-useless-rule-name-有什么用？"><a href="#1-初始化-RuleQueue-时，添加的-one-useless-rule-name-有什么用？" class="headerlink" title="1. 初始化 RuleQueue 时，添加的 one useless rule name 有什么用？"></a>1. 初始化 RuleQueue 时，添加的 one useless rule name 有什么用？</h4><p>在初始化 RuleQueue 时，会给 VolcanoPlanner 的四个阶段 <code>PRE_PROCESS_MDR, PRE_PROCESS, OPTIMIZE, CLEANUP</code> 都初始化一个 PhaseMatchList 对象（记录这个阶段对应的 RuleMatch），这时候会给其中的三个阶段添加一个 useless rule，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> VolcanoPlannerPhaseRuleMappingInitializer</span><br><span class="line">    getPhaseRuleMappingInitializer() &#123;</span><br><span class="line">  <span class="keyword">return</span> phaseRuleMap -&gt; &#123;</span><br><span class="line">    <span class="comment">// Disable all phases except OPTIMIZE by adding one useless rule name.</span></span><br><span class="line">    <span class="comment">//note: 通过添加一个无用的 rule name 来 disable 优化器的其他三个阶段</span></span><br><span class="line">    phaseRuleMap.get(VolcanoPlannerPhase.PRE_PROCESS_MDR).add(<span class="string">"xxx"</span>);</span><br><span class="line">    phaseRuleMap.get(VolcanoPlannerPhase.PRE_PROCESS).add(<span class="string">"xxx"</span>);</span><br><span class="line">    phaseRuleMap.get(VolcanoPlannerPhase.CLEANUP).add(<span class="string">"xxx"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始时还困惑这个什么用？后来看到下面的代码基本就明白了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (VolcanoPlannerPhase phase : VolcanoPlannerPhase.values()) &#123;</span><br><span class="line">  <span class="comment">// empty phases get converted to "all rules"</span></span><br><span class="line">  <span class="comment">//note: 如果阶段对应的 rule set 为空，那么就给这个阶段对应的 rule set 添加一个 【ALL_RULES】</span></span><br><span class="line">  <span class="comment">//也就是只有 OPTIMIZE 这个阶段对应的会添加 ALL_RULES</span></span><br><span class="line">  <span class="keyword">if</span> (phaseRuleMapping.get(phase).isEmpty()) &#123;</span><br><span class="line">    phaseRuleMapping.put(phase, ALL_RULES);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面在调用 RuleQueue 的 <code>addMatch()</code> 方法会做相应的判断，如果 phaseRuleSet 不为 ALL_RULES，并且 phaseRuleSet 不包含这个 ruleClassName 时，那么就跳过这个 RuleMatch，也就是说实际上只有 <strong>OPTIMIZE</strong> 这个阶段是发挥作用的，其他阶段没有添加任何 RuleMatch。</p>
<h4 id="2-四个-phase-实际上只用了-1个阶段，为什么要设置4个阶段？"><a href="#2-四个-phase-实际上只用了-1个阶段，为什么要设置4个阶段？" class="headerlink" title="2. 四个 phase 实际上只用了 1个阶段，为什么要设置4个阶段？"></a>2. 四个 phase 实际上只用了 1个阶段，为什么要设置4个阶段？</h4><p>VolcanoPlanner 的四个阶段 <code>PRE_PROCESS_MDR, PRE_PROCESS, OPTIMIZE, CLEANUP</code>，实际只有 <code>OPTIMIZE</code> 进行真正的优化操作，其他阶段并没有，这里自己是有一些困惑的：</p>
<ol>
<li>为什么要分为4个阶段，在添加 RuleMatch 时，是向四个阶段同时添加，这个设计有什么好处？为什么要优化四次？</li>
<li>设计了4个阶段，为什么默认只用了1个？</li>
</ol>
<p>这两个问题，暂时也没有头绪，有想法的，欢迎交流。</p>
<p>这部分的内容比较多，到这里 Calcite 主要处理流程的文章也终于梳理完了，因为是初次接触，文章理解有误的地方，欢迎各位指教~</p>
<p>附上上一篇文章：<a href="http://matt33.com/2019/03/07/apache-calcite-process-flow/">Apache Calcite 处理流程详解（一）</a>。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/wangxingxing2006/article/details/78907278" target="_blank" rel="external">HepPlanner源码分析——Calcite</a>；</li>
<li><a href="https://zhuanlan.zhihu.com/p/48735419" target="_blank" rel="external">SQL 查询优化原理与 Volcano Optimizer 介绍</a>；</li>
<li><a href="https://blog.csdn.net/u013007900/article/details/78993101" target="_blank" rel="external">高级数据库十六：查询优化器（二）</a>；</li>
<li><a href="http://rann.cc/2018/08/23/sql-optimized-principles.html" target="_blank" rel="external">【SQL】SQL优化器原理——查询优化器综述</a>；</li>
<li><a href="http://hbasefly.com/2017/03/01/sparksql-catalyst/" target="_blank" rel="external">SparkSQL – 从0到1认识Catalyst</a>；</li>
<li><a href="http://hbasefly.com/2017/05/04/bigdata%EF%BC%8Dcbo/" target="_blank" rel="external">BigData－‘基于代价优化’究竟是怎么一回事？</a>；</li>
<li><a href="https://www.slideshare.net/julianhyde/costbased-query-optimization-in-apache-phoenix-using-apache-calcite?qid=b7a1ca0f-e7bf-49ad-bc51-0615ec8a4971&amp;v=&amp;b=&amp;from_search=4" target="_blank" rel="external">Cost-based Query Optimization in Apache Phoenix using Apache Calcite</a>；</li>
<li><a href="https://cs.uwaterloo.ca/~david/cs848/volcano.pdf" target="_blank" rel="external">The Volcano Optimizer Generator: Extensibility and Efficient Search</a>：Volcano 模型的经典论文；</li>
<li><a href="https://pdfs.semanticscholar.org/c1a3/9da04a072f695e9a7f36bf397fba5c19b93c.pdf?_ga=2.162106044.1003201390.1552806109-329306565.1552806109" target="_blank" rel="external">The Cascades Framework for Query Optimization</a>：Cascades 模型的经典论文。</li>
</ol>
</div><div class="copyright"><h2 id="版权说明"><a href="#版权说明" title="版权说明" class="headerlink">版权说明</a></h2><p><strong><big><a href="http://matt33.com/copyright/">博客版权说明</a></big></strong></p><p>所有文章以 <strong><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external">知识共享署名 4.0 国际许可协议 </a></strong>进行授权，转载时请注明原文链接</p></div><div class="weixin"><h2 id="公众号"><a href="#公众号" title="公众号" class="headerlink">公众号</a></h2><p>个人公众号（柳年思水）已经上线，最新文章会同步在公众号发布，欢迎大家关注~</p><p></p><p><img src="/images/wangm92-3.png" style="text-align:center" width="600"></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2019/03/17/apache-calcite-planner/" data-id="ck99be5d000bsi3fyethk8alc" class="article-share-link">分享到</a><div class="tags"><a href="/tags/calcite/">calcite</a></div><div class="post-nav"><a href="/2019/10/19/paper-ray1/" class="pre">Paper 阅读: Real-Time Machine Learning: The Missing Pieces</a><a href="/2019/03/07/apache-calcite-process-flow/" class="next">Apache Calcite 处理流程详解（一）</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2019/03/17/apache-calcite-planner/';
var disqus_title = 'Apache Calcite 优化器详解（二）';
var disqus_url = 'http://matt33.com/2019/03/17/apache-calcite-planner/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/cpu-branch-predictor/">浅谈 CPU 分支预测技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/flink-task-mailbox/">Flink 基于 MailBox 实现的 StreamTask 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/flink-taskmanager-7/">Flink TaskManager 详解（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/flink-jobmanager-6/">Flink JobManager 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/flink-master-5/">Flink Master 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/20/flink-execution-graph-4/">Flink 如何生成 ExecutionGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/flink-job-graph-3/">Flink Streaming 作业如何转化为 JobGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/08/flink-stream-graph-2/">Flink DataStream API 概述及作业如何转换为 StreamGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/flink-learn-start-1/">Apache Flink 初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/paper-chandy-lamport/">Paper 阅读: Distributed Snapshots: Determining Global States of Distributed Systems</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>