<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2016年终总结]]></title>
      <url>http://wangzzu.github.io/2016/12/31/2016-summary/</url>
      <content type="html"><![CDATA[<p>今天凌晨2点吃完饭回来之后，真是辗转反侧，不知为何，一直难以入眠，或许因为过了睡点，又或许因为昨晚的年会玩得太嗨，也可能是感觉对过去的一年有些许遗憾……</p>
<p>昨晚参加了最后一次实验室的年会，前两年中的都是三等奖（100块钱），没想到昨晚运气大爆发了，中了特等奖（Kindle Voyage），也算是2016年一个比较好的收官。然而，晚上睡觉时内心却是如何也无法平静下来，脑海中一直不断闪烁着过去一年、甚至过去两三年发生的一些事，不管怎样，时间就是这样，过去的就是过去了，并不以我们的意志为转移。</p>
<p>孟子说“吾日三省吾身”，这句话我们上小学时都学过，可是大多数人并没有去认真践行过，可能是现在这个社会给人压力大得已经很少有时间去思考、去反思。但是很多人却都有年终总结的习惯，总结一下过去一年做了什么事，是否完成了去年年终总结定的计划，再做一下未来一年的计划。有计划的人生总是会好一点，至少会给未来一年指引方向，甚至可以通过一些量化的指标来屏蔽一些重要的问题：我要想什么样的人生，我想要什么样的生活。这两个问题真的很难去回答，其实我们每个人也只是在不断地去摸索，因为我们原本就没有一个很清晰的目标。即使有了清晰的目标也很难在未来一年的时间里去完成，而我们又都是如此地急功近利，如果一件事情要花费自己三五年的时间、甚至十年时间的话，很多人可能都会选择放弃，去选择一些易于在短期内实现的目标。如果一个人没有一个清晰的长远目标，或者没有这个概念的话，那么年度目标其实也就是督促自己做点事而已。对于我们这种即将毕业或者刚步入职场的人来说，虽然并不一定有一个非常清晰的长远目标，但是至少是要有一个这样的概念。选取一个或者多个对你非常重要、或者能给你带来很大的提高、而短期无法实现的长远目标，把这个分割到每一年里慢慢去实现，但有一点要明确的是长远目标的制定依然是为了那两个问题而设置的，那两个人肯定会在未来十年甚至二十年的时间不断地困扰我们，我们能做的，也只是不断地尝试，不断地去追寻内心（以上只是个人感慨，下面开始流水账）。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>从今年开始也算是正式迈入了职场，毕竟也在公司实习了半年多了，今年最重要的事情就是找工作这件事了，人生的第一份工作，好在最后去的部门、做的事情是自己想要的（找工作的感想可以参考<a href="http://wangzzu.github.io/2016/11/15/job-summary/">校招找工作小记</a>）。</p>
<p>除了正式工作，另一件非常重要的事就是毕业这件事了。记得去年下半年一直在绞尽脑汁，憋了好久才写了一篇小论文的大概，没写出多少，今年年初来了之后就边找实习边写小论文，最后也很幸运地成功水了一个会议。小论文之后又是大论文，纸老虎打了一个总是还会再出现一个，在实习前火急火燎地完成了初稿，后来又花了半个多月改了一下，到目前为止还没出现什么问题，祈祷盲审不中，明年顺利毕业。</p>
<p>关于明年，希望自己在工作上能有所建树，自己在公司未来的方向就是 Kafka 平台的开发和运维，希望自己能实现以下几个小目标：</p>
<ol>
<li>经过这半年对 Kafka 源码的学习和理解，希望明年把源码方面的东西都总结一下，对源码的核心设计了然于胸，多向社区提交一些 pr，成为 Kafka 领域较有权威的 contributor；</li>
<li>同事在公司经常会说<code>三分技术，七分做事</code>，虽然并不完全认同，但至少也得四分或五分做事，明年好好制定和完成自己的 KPI，认认真真做事，答应的事情要能按时按质搞定，做一个技术上靠谱的人，养成这样的习惯；</li>
<li>希望明年下半年晋升到P2.1，对小组、部门和公司业务有更深入的了解；</li>
<li>多与同事、业界交流技术经验，希望自己明年的 Github Contribute 更饱满；</li>
<li>好好运营自己的博客网站，每个月保持两篇技术文章输出（一篇 Kafka 相关）；</li>
<li>明年也应该补充一下自己的计算机基础知识，希望能够把《算法 第4版》、《深入理解计算机系统》和《计算机程序语言的构造与解释》这三本好好深入学习一下，前两本看了两年了才各自看了一半，真是惭愧，希望明年执行力强一些，把这三本坚持吭下去，并做一些相关的笔记；</li>
<li>对于其他的技术，要达到会用的效果，能够实现自己想要的功能，利用幂次法则用20%的时间达到80%的效果，选择三个方面：前端（Django、Boostrap使用）、spark（使用以及内部框架有较深入的了解）、机器学习（把周志华《机器学习》学习一下，找几个小项目做一下，参加一次天池大赛）；</li>
<li>每个月看一篇大数据方向的领域的相关论文，今年计划看12篇；</li>
<li>还有一个明年要做的也是很重要的是英语，先从听力开始，通过老友记去学习，要听到听懂每个句子未知，然后可以借鉴《技巧》里的不断加强难度练习的方式进行练习，一定要坚持下去，英语对于未来的发展还是至关重要的。</li>
</ol>
<p>上面的小目标也都不是很难，希望自己能够完成。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年貌似生活很平平淡淡，没有太大变化，只有几个微小的变化：</p>
<ul>
<li>之前和女朋友说了几年的云南自由行终于实现了，云南也确如网上所言，风景很好，我们整个旅途总体玩得也很开心，唯一不好的地方就是在香格里拉遇到了那些借着宗教、善意骗人的当地藏民，影响自己的心情，对那些地区多了一些偏见；</li>
<li>今年总共回家了三次，过春节一次，年中表弟结婚一次，十一回去一次，8月的时候老妈跟老弟来北京，带着他们在北京玩了三四天，老爸老妈随着年龄的增大，皱纹白发已经开始增多，自己纵有太多心酸也无可奈，只希望自己能早些立住脚，让父母过得舒适一些，年初春节的时候跟老爸老妈商量为了老弟的学习，就在学校附近租了房子专门让老妈去做饭，可是投入这么多，却没有任何收获，老弟反而更加肆无忌惮、更加贪玩，成绩也成了倒数，唉，少年不知愁滋味，只希望老弟早些长大；</li>
<li>今年自己开始买了一些装备玩户外，不过都是一些很成熟的入门级路线，不过开始总是好的，发现自己还是挺喜欢这些运动的；</li>
<li>年中的时候买了单反，开始玩起了摄影，不过目前技术依然很渣，虽然把 Lightroom 学得差不多了，但是却发现自己的硬伤是审美，并不很清楚什么样的照片才是美的照片，也并不知道在拍照时如何告诉拍照人摆 pose 以拍出最好的效果；</li>
<li>一个月前买了一个 Kindle，今年抽空确实看了不少书（<a href="https://github.com/wangzzu/awesome/blob/master/book-list.md" target="_blank" rel="external">2016个人书单</a>），大概有11本左右，因为之前看的书少，所以看的都是一些评分较高的书，其中也发现了几本好书，有两本准备寒假回去再看一遍，写几篇读书笔记，在以后的工作生活中按照书中介绍一些方法论去实验一下；</li>
<li>今年也算是坚持锻炼了身体，估计跑步跑了三百公里左右，上半年也经常去游泳，到公司实习后，回学校游泳不太方便，就经常去参加一些羽毛球活动，虽然没有把腹肌撕裂者坚持下去练出几块肌肉，但总体体重跟去年一样，并没有走样；</li>
<li>其他的都是一些琐碎之事，见了一些老朋友，很多都是几年未见的，在中学的时候感觉这些好哥们应该会一直在一起玩耍，现在却发现一年见上一面都很难，也由于各自在不同的环境下、不同的行业里大家慢慢渐行渐远，总之，感慨良多，要好好珍惜身边的好哥们，真如大土豆所言，能一直深交的好哥们人生有二三可能就已足矣。</li>
</ul>
<p>人生的时间，可能除了工作，其他基本上就属于生活了吧。中国讲<code>日子要越过越红火</code>，生活也是应该计划计划，未来一年希望能把下面的几件事搞定：</p>
<ul>
<li>走了近六年的爱情长跑，也总该有个结果了，希望明年能搞一个难忘的求婚仪式，结婚是明年还是后年可以再定，准备明年领证；</li>
<li>谈到了求婚，就不得不说到买房，希望明年户口迁杭州顺利，并把房子搞定，这个是明年重中之重，明年估计有一个月的工资就要交给铁总了；</li>
<li>希望老弟明年能进步，要不然在河南这样的高考大省，可能连上高中的机会都没有了，跟爸妈春节好好交交心，让他们少干点活，有些事情能不做的就不做了，到了这个年龄，健健康康才是最重要的；</li>
<li>坚持锻炼身体，在公司健身房多跑步（明年保持300km 以上），学习一下标准的羽毛球动作，提高球技（希望能在公司的高手场过上几招），冬天的时候跟公司的俱乐部学习一下滑雪，特别是单板（学会单板的滑行、刹车拐弯，冲一次高级场），也准备参加一些户外活动（爬山、穿越明年还是不能少），希望明年能体验一下蹦极，明年年初的毕业旅行计划去东南亚玩一趟，明年年终的时候，希望有时间和机会跟女友去日本或台湾一趟；</li>
<li>多读些书，非技术类的书籍明年计划读20本，好的书要做一下读书笔记；</li>
<li>明年就要出去租房子住了，希望合租的人能够好相处一些，明年打算练一下自己的厨艺，自己做饭还是要比外面干净很多，外面的东西越来越不放心了。</li>
<li>还有就是单反，学习审美，多拍多练习。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>人是越长大越孤单，小的时候每当我们做错事、有什么需要改正的缺点，父母都会去提醒我们，而长大之后，如果影响不到别人，别人可能根本不会搭理你，这也有可能是因为长大之后，大家性格思维都在固化，很难去纠正，别人也就懒得去管了。而对于我们个人的发展来说，这是非常不利的，找不到或发现不了自己的缺点，那提升自己就变得很难。所以，作为一个人，还是要有自知之明，正视自己的缺点，有的时候可能是从别人身上看到我们自己的影子（通过看别人来反思自己），有的时候可能朋友会对我们一些善意的提醒，对于这样的朋友，我们应该去珍惜。记得今年去华为面试的时候在公交上遇到了一个基督徒，人挺不错，他帮助我准备面试，并帮我指出一些问题，他指出的一个问题是我说话时语速太快，之前关于这个问题我真是一点都没有意识到，后来我刻意听了一下给别人发的微信语音，确实有这个问题，如果是平时聊天还好，而如果是做一些技术交流的话，就会出问题，对于一个问题因为自己比较熟悉、快速说出来并没有问题，而别人对这个问题如果不熟悉，自己的语句就应该放慢一些给别人足够的思考时间，这才是一种有效的交流方式，希望明年在这方面能有所改进。还有一个问题，发现身边有些同学，平时交流、出去玩都还可以，但是为人却很不大气，可能会需要一些成本才能感受出来，不过这个成本也值得，能够让自己对别人了解更深入些，以后交往有所顾忌，从这件事情上，其实也能够看出自己的一些影子，对于自己来说，需要做的是，与比较豪爽的人交往自己也应该豪爽，而与一些不大气或者小气的人交往时，就应该有所注意，当然也不能让被人的缺点阻挡自己的眼睛，还是要多发现别人的优点，毕竟人无完人。也希望自己明年能对一些事情看开一下，努力学习苏公<code>一蓑烟雨任平生</code>的人生态度。</p>
<p>总之，希望明年事事顺心，家人身体健康。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 的 Checked 和 Unchecked Exception【译】]]></title>
      <url>http://wangzzu.github.io/2016/12/13/java-exception/</url>
      <content type="html"><![CDATA[<p>如果在 Java 应用中对 Exception 能够正确处理，那么将会使你的程序更具有健壮性。但是很多人对 Exception 中的 <strong>Checked Exception</strong> 和 <strong>Unchecked Exception</strong> 并不理解，并且 Exception 又常常被被分为 JVM Exception 和程序 Exception，这就让一些开发者显得更加困惑了，本文就这几个概念详细讲述一下。（本文翻译自<a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="external">Checked and Unchecked Exceptions in Java</a>）</p>
<h1 id="Checked-Exception"><a href="#Checked-Exception" class="headerlink" title="Checked Exception"></a>Checked Exception</h1><p>Checked Exception 是必须在代码中进行恰当处理的 Exception，而且编译器会强制开发者对其进行处理，否则编译会不通过。你可以使用 <code>catch</code> 语句捕获这些 Exception 或者在方法声明处使用 <code>throws</code> 语句抛出该异常。</p>
<p>一般来说，Checked Exception 的发生主要是由于一些特殊情况没有考虑到，比如如果网络连接失败会抛出 IOException，但是我们的程序应该能够提前预料到这些可能发生的异常，并对其进行处理，这样程序在运行过程中才不会崩掉，这也是编译器强制开发者对 Checked Exception 进行处理的原因。假设在文件传输的过程中网络出现中断，这时候程序应该能够捕获到这种异常并进行处理（重新尝试传输文件）。</p>
<h1 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h1><p>Unchecked Exception 的发生有一些是由于开发者代码逻辑错误造成的，比如：NullPointerException 这种异常可以通过检查一个引用是否为 null 来进行避免。</p>
<p>但是也有一些 Unchecked Exception 出现并不是因为开发者程序的问题，这些 Exception 是 <code>java.lang.Error</code> 的子类。就像 OutOfMemoryError 可能发生在任意一个示例对象创建时，但我们不可能在每个对象实例创建时都使用 <code>catch</code> 块去捕获异常。因此，我们也就不可能预料这些异常的发生，编译器在编译时也无法检测到这些异常。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面这个例子，由于没有对 Checked Exception 进行处理而导致编译失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使上面的代码可以正确编译，我们可以在 <code>try/catch</code> 块中捕获相应的异常或者是使用 <code>throws</code> 在 main 方法声明处抛出异常。</p>
<p>但是如果在 main 方法<strong>内部</strong>抛出一个 Unchecked Exception，依然可以正常编译，下面的例子就可以正确编译。正如前面所述，Unchecked Exception 在编译期间是无法提前检测，因此，不对其进行处理也不会影响到正常编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnhandledException</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Exception-类层次结构"><a href="#Exception-类层次结构" class="headerlink" title="Exception 类层次结构"></a>Exception 类层次结构</h1><p><code>java.lang.Throwable</code> 类是一个 Checked Exception，Java 的 API 定义了 Throwable 的两个子类——<code>java.lang.Exception</code> 和 <code>java.lang.Error</code>， Error 类是 Unchecked Exception 类，而 Exception 则是 Checked Exception类。</p>
<p>Exception 类有一个 Unchecked Exception 子类——<code>java.lang.RuntimeException</code>，NullPointerException 和 ClassCastException 都是 RuntimeException 的子类。RuntimeException 和 Error 的所有子类都是 Unchecked Exception，其他的  Exception 则都是 Checked Exception，如下图所示。</p>
<p><img src="/images/java/Checked-and-Unchecked-Exceptions-in-Java.png" alt="Exception Hierarchy"></p>
<p>如果创建一个自定义的异常类，它是 Checked Exception 还是 Unchecked Exception 则依赖其父类的类型。如果它继承于一个 Unchecked Exception 类，那么它就是一个 Unchecked Exception，反之依然。</p>
<p>在对 Checked Exception 进行 <code>catch</code> 操作时，也需要遵循一定的规则：在 catch 块中捕获的异常，必须在 try 块中有出现这种异常的可能性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.out.println(<span class="string">"..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(java.io.IOException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子就不能成功编译，因为在 try 块中永远都不会抛出 IOException，所以你也不能去捕获这种异常。但是如果你捕获的是一个 Unchecked Exception，那么就不会有这种问题。</p>
<p>Exception 和 Throwable 这两个类有些特殊，虽然它们都是 Checked Exception 类，但你依然可以捕获它们即使在 try 块中没有抛出该异常的可能性，因此，下面的代码的就可以正确编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.out.println(<span class="string">"..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面所说的规则对于 Exception 和 Throwable 这两个类并不是完全适用，这是因为对 Exception 和 Throwable 这两个类都有 Unchecked Exception 类型的子类，所以编译器允许你捕获它们（编译器认为你是在捕获一个 Unchecked Exception）。要清楚一点，<strong>编译器并不会检查 Unchecked Exception</strong>，RuntimeException 是 Exception 的子类，Error 是 Throwable的子类, 而 RuntimeException 和 Error 都是 Unchecked Exception 类。因此，上面的代码是可以正确编译的，编译允许这样做的原因就是因为这种方式是可以捕获到 Unchecked Exception 的。</p>
<h1 id="JVM-和程序异常"><a href="#JVM-和程序异常" class="headerlink" title="JVM 和程序异常"></a>JVM 和程序异常</h1><p>JVM Exception 是由 JVM 自己抛出的异常，比如：如果调用的方法使用一个 null 引用，然后 JVM 就会抛出 NullPointerException，或者如果在程序中出现10除以0的情况，JVM 会抛出一个 ArithmeticException。这些异常都是自动地由 JVM 抛出。</p>
<p>除了 JVM Exception 外，其他所有的异常都是由程序引起的异常。程序中，我们可以显式地使用 <code>throw</code> 语句抛出异常，这里以 NumberFormatException 为例。NumberFormatException 可能被方法 <code>Integer.parseInt</code> 或 <code>Float.parseFloat</code> 抛出，都是程序中可能出现的异常。在 <code>Integer</code> 类方法 <code>parseInt</code> 的实现中，可以找到如下的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 JVM 不会抛出这种类型的异常，这些异常是使用 <code>throw</code> 语句显式地程序中抛出。当然也可以如下所示在程序中抛出 JVM Exception。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"I told you s shouldn't be null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是一般情况下，JVM Exception 是不会被开发者抛出的（JVM 自己抛出的），所有的 JVM Exception 都是 unchecked，而程序中的异常则可能是 checked 的或者 unchecked 的。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/specs/#44121" target="_blank" rel="external">Chapter11 Exception</a></li>
<li><a href="http://www.hacktrix.com/checked-and-unchecked-exceptions-in-java" target="_blank" rel="external">Checked and Unchecked Exceptions in Java</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim 快捷键总结]]></title>
      <url>http://wangzzu.github.io/2016/12/06/vim-basic/</url>
      <content type="html"><![CDATA[<p>Vim 到目前位置也用了将近两年，但是很多的快捷键每次要用到的时候还是会 Google 一下，只能记住很少的命令，查的过程其实还是会浪费很多时间，这里总结一下一些常用的 Vim 命令，以便以后查看。</p>
<h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>h,j,k,l</td>
<td>h表示往左，j表示往下，k表示往上，l表示往右</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>上一页</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>下一页</td>
</tr>
<tr>
<td>w, e, W, E</td>
<td>跳到单词的后面，小写包括标点</td>
</tr>
<tr>
<td>b, B</td>
<td>以单词为单位往前跳动光标，小写包含标点</td>
</tr>
<tr>
<td>0</td>
<td>跳到本行的头部</td>
</tr>
<tr>
<td>O</td>
<td>开启新的一行</td>
</tr>
<tr>
<td>^</td>
<td>一行的开始</td>
</tr>
<tr>
<td>$</td>
<td>一行的结尾</td>
</tr>
<tr>
<td>gg</td>
<td>文档的第一行</td>
</tr>
<tr>
<td>[N]G</td>
<td>文档的第N行（G 是最后一行），如：27+shift+g</td>
</tr>
</tbody>
</table>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>插入到光标前面</td>
</tr>
<tr>
<td>I</td>
<td>插入到行的开始位置</td>
</tr>
<tr>
<td>a</td>
<td>插入到光标的后面</td>
</tr>
<tr>
<td>A</td>
<td>插入到行的最后位置</td>
</tr>
<tr>
<td>o</td>
<td>在当前光标的下方插入新一行</td>
</tr>
<tr>
<td>O(Shift+o)</td>
<td>在当前光标的上方插入新一行</td>
</tr>
<tr>
<td>Esc</td>
<td>关闭插入模式</td>
</tr>
</tbody>
</table>
<h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>在插入模式替换光标所在的一个字符</td>
</tr>
<tr>
<td>J</td>
<td>合并下一行到上一行</td>
</tr>
<tr>
<td>s</td>
<td>删除光标所在的一个字符, 光标还在当行</td>
</tr>
<tr>
<td>S</td>
<td>删除光标所在的一行，光标还在当行，不同于dd</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步操作</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>恢复上一步操作</td>
</tr>
<tr>
<td>.</td>
<td>重复最后一个命令</td>
</tr>
<tr>
<td>~</td>
<td>变换为大写</td>
</tr>
<tr>
<td>[N]&gt;&gt;</td>
<td>一行或N行往右移动一个tab</td>
</tr>
<tr>
<td>[N]&lt;&lt;</td>
<td>一行或N行往左移动一个tab</td>
</tr>
</tbody>
</table>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:wq,:x</td>
<td>保存并关闭</td>
</tr>
<tr>
<td>:q</td>
<td>关闭（已保存）</td>
</tr>
<tr>
<td>:q!</td>
<td>强制关，不保存</td>
</tr>
</tbody>
</table>
<h1 id="查找和搜索"><a href="#查找和搜索" class="headerlink" title="查找和搜索"></a>查找和搜索</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>/pattern</td>
<td>搜索（非插入模式) ，支持正则</td>
</tr>
<tr>
<td>?pattern</td>
<td>往后搜索</td>
</tr>
<tr>
<td>n</td>
<td>光标到达搜索结果的前一个目标</td>
</tr>
<tr>
<td>N</td>
<td>光标到达搜索结果的后一个目标</td>
</tr>
<tr>
<td>r+p</td>
<td>将光标之后的字符替换为字母p</td>
</tr>
<tr>
<td>:s/word/replace</td>
<td>光标所在行的第一个 word 替换为replace。</td>
</tr>
<tr>
<td>:%s/word/replace/</td>
<td>全文查找 word 并替换为 replace</td>
</tr>
<tr>
<td>:1,50s/word/replace/</td>
<td>在第1行和第50行之间（含）进行搜索和替换</td>
</tr>
<tr>
<td>:45s/word/replace/</td>
<td>表示仅仅在第45行进行搜索和替换。而 1,$ 行号范围和 % 是等价的</td>
</tr>
</tbody>
</table>
<h1 id="剪切、复制与粘贴"><a href="#剪切、复制与粘贴" class="headerlink" title="剪切、复制与粘贴"></a>剪切、复制与粘贴</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>dd</td>
<td>删除一行，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>de</td>
<td>删除光标后的单词内容，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>dw</td>
<td>删除光标后的单词内容以及之后的空格，同时被删除内容存于剪贴板上</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词</td>
</tr>
<tr>
<td>[N]dd</td>
<td>删除以当前行开始的n行</td>
</tr>
<tr>
<td>x</td>
<td>删除后一个字符</td>
</tr>
<tr>
<td>X</td>
<td>删除前一个字符</td>
</tr>
<tr>
<td>D</td>
<td>删除一行最后一个字符</td>
</tr>
<tr>
<td>[N]yy</td>
<td>复制一行或者N行</td>
</tr>
<tr>
<td>yw</td>
<td>复制一个单词</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
</tbody>
</table>
<h1 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用（解释）</th>
</tr>
</thead>
<tbody>
<tr>
<td>:split</td>
<td>水平方向分割出一个窗口</td>
</tr>
<tr>
<td>:vsplit</td>
<td>垂直方向分割出一个窗口</td>
</tr>
<tr>
<td>:close</td>
<td>关闭窗口</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口</td>
</tr>
</tbody>
</table>
<h1 id="文字版"><a href="#文字版" class="headerlink" title="文字版"></a>文字版</h1><p>这里有一个别人总结的文字版<a href="http://tnerual.eriogerg.free.fr/vimqrc.pdf" target="_blank" rel="external">图片链接</a>。</p>
<p><img src="/images/linux/vim-text.png" alt="vim-text"></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html" target="_blank" rel="external">Vim 使用笔记</a></li>
<li><a href="http://cenalulu.github.io/linux/all-vim-cheatsheat/" target="_blank" rel="external">史上最全Vim快捷键键位图 – 入门到进阶</a></li>
<li><a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="external">简明 Vim 练级攻略</a></li>
<li><a href="http://www.jianshu.com/p/c23136f68d2f" target="_blank" rel="external">Vim快捷键整理</a></li>
<li><a href="http://lxs647.iteye.com/blog/1245948" target="_blank" rel="external">vi/vim 删除以及其它命令</a></li>
<li><a href="http://pizn.github.io/2012/03/03/vim-commonly-used-command.html" target="_blank" rel="external">Vim 命令总结</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[技巧，其实并没有什么技巧，只不过多了些毅力罢了]]></title>
      <url>http://wangzzu.github.io/2016/11/29/book/</url>
      <content type="html"><![CDATA[<p>本文是关于<a href="https://book.douban.com/subject/26874593/" target="_blank" rel="external">技巧</a>这本书的读书笔记。这本书是作者根据自己的生活学习经历悟出的一些方法论，满满的正能力，但有不同于一般的鸡汤文，书中提到的那些<strong>技巧</strong>，其实每个人都可以做到，但实际上却很少有人做到，正如作者所说<code>因为别人都睡着，你醒着那么你就是杰出的</code>。方法其实还是那种最简单的方法，简要来说就是<strong>行动+坚持</strong>，这也是最难的方法，因为坚持是最难的。用这种方法达到自己想要效果的人就认为这种方法非常有用，就如作者学习英语一样，而对于大多数那些坚持不下去的人来说，他们感觉这就是在扯犊子，正所谓方法因人而异。如果一味地去追求 XX 天精通 XX，其实最后的结果只会是<strong>从入门到放弃</strong>。</p>
<p>写着写着突然想讨论一下关于<strong>读书</strong>这个问题，在自己的印象中，自己第一次真正意义上、主动去读书应该是在中考结束的那个暑假，我现在已经忘了当时是什么原因让自己在那个暑假里读了好几本书，记得当时读了《三国演义》，在读完《三国演义》时觉得这本书应该是四大名著里写得最好的了，搞不懂为啥是《红楼梦》。而《红楼梦》这本书当时是强迫自己看下去的，这点还是有印象的，但当看到三十回之后，就被深深吸引住了，一发不可收拾，当时基本上晚上睡觉前都在读。当然，现在对于其中很多的细节都已经想不起来了，书中很多的故事也忘得差不多了，当年背了很久的《葬花词》也记不起几句了。我现在唯一有印象的，可能就是当时那段时光每天都在看书的场景（虽然是小说 :joy:），回忆起来还是很怀念的。再后来，上了高中之后，基本上就没有自己自主支配的时间，也就再也没有怎么看过书（非学科类的书）了。这就是在大学之前我与书的故事，很简单，但事实上，对于那个时候的我，并不知道怎么去读书，也不知道读这些书对自己有什么用，只是被书中的故事吸引而已，当然也就没有像红学研究者那样去思考这本书后面的故事。</p>
<p>到了大学之后，自己看的书也不是很多，其实是很少，这是我关于大学的遗憾之一，并没有在看书上花太多时间，大学四年自己看的书应该不会超过二十本。忘了是大二还是大三的时候，当时室友买了一本<a href="https://book.douban.com/subject/1013208/" target="_blank" rel="external">《如何阅读一本书》</a>，当时我在看到这本书的名字，对他不屑一顾地嘲笑了一番，当时感觉看书还需要学习、还需要让一本书来教你？看书不是每个人都会的吗？当时还没有开始接触豆瓣，并不知道在豆瓣上评分8.5的书意味着什么。</p>
<p>再后来，到研究生之后，记得在研一的时候，因为看了陈志武的《金融的逻辑》，对书中提出的观点感觉感觉很新颖，就把陈老师其他的几本书都看了一下，之后又看了一些小说以及吴军老师的书。前段时间在微博上看到有两本书突然很火，一本就是本文所说的《技巧》，另一本是《精进》。自己也就买了这两本书开始看，刚开始看的是《精进》，但是由于精进太偏方法论，理论更多些，感觉是需要在很安静的环境下看才比较好，所以到现在也就只看了一半，而《技巧》这本书都是以小故事的形式呈现，在宿舍或者公司读起来都很适合，所以虽然先看的《精进》，结果还是先把《技巧》看完了。《技巧》的作者 Tinyfool 是一个看过很多书的人，在书中也讲了很多看书的方法，而恰巧《精进》这本书的作者也讲了很多关于读书这一块的内容，告诉我们应该如何去读书、如何读懂一本书，在这一块，这两本书是解决了我的一些困惑。之前，我曾经想过，每看一本书，就做一个思维导图，到最后发现我做的思维导图压根没有别人做得那么好看，自己反而花了太多时间在思维导图的表达和形式上，开始觉得这并不是看书的一个好方式。</p>
<p>现在慢慢觉得关于读书这件事，第一步应该是选书，并不是评分高的书我们就应该去读，选书应该因人而异，读一本书我们是需要知道这本书解决我们哪方面的困惑，带着问题去读书，比如一些哲学类的东西在现实中可能无法找到解决方法，我们只有去借鉴前人的经验，但是也要明白一点：任何一个作者也是有其时代和历史局限性的，书中的答案并不定是正确的答案、并不一定可以解决自己的困惑。在选书上要选对自己有帮助的书，读书肯定是为了让自己收获一些东西，有些书可以解答自己的心理困惑，有些书可以讲述一些技术，也有一些书可以教给我们一些方法。但最关键的是自己要去思考和应用，对于提供书经验方法的书，我们可以学以致用；对于能解决一些困惑的书，我们要去思考这本书如何解决这个问题、从哪个角度出发以及中间论证的逻辑性等，这样才是真正的读书。现在回想起来，大学那时候的想法其实是很幼稚的，其实现在也不敢说自己就已经明白了读书的真谛，很多东西还是需要慢慢体会、慢慢积累、不断完善。</p>
<p>下面是《精进》作者采铜发的一段微博。</p>
<blockquote>
<p>很多人读完一本书的时候，喜欢画一个思维导图还原书中的主要观点。还有人会写一个书评，去分析和评价作者的观点对还是错。可是，作者的体系是他的体系，你无法直接受用；而观点的对错，对，是他对了，错，也是他错了，跟你什么关系呢？为什么一定要评个所以然出来呢？读书时，你更应着眼的是，这本书对你自己的意义。具体来讲，就是从“我”的需要出发，像一个探险家／考古学家／盗墓者／松鼠一样从各种书里探测、挖掘三种东西：原则、方法、素材。原则：书里有什么做事的原则是我可以借鉴的。方法：书里提供了什么做某事的方法。素材：书里提供了什么故事案例可以用来填充我的框架。这三样东西有些是在字面上，作者写明的，更多的，是深埋在文本之下，需要由你用你的洞察力去找出来。你读到的书是一整体，而你需要把它打散，找出你所需要的碎片，或原则，或方法，或素材，然后在你脑中拼接成型。——采铜微博。</p>
</blockquote>
<hr>
<p>下面的内容是自己在看书时，做的一些笔记，主要摘抄的书作者的观点以及个人的一些读后感。</p>
<h1 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h1><p>让人恐惧的不是死亡，而是希望。</p>
<ul>
<li>前妻的故事<ol>
<li>虽然学历低、家庭背景差，但是却有着一颗改变命令的心（这点很多人都有）；</li>
<li>她之所以从一个理发学徒变成一个年薪40w 的程序员（这个工资目前在程序员中并不算很高），但却很努力，而且不怕嘲笑，不懂的东西会虚心请教，最重要的是她能一直坚持下去了；</li>
<li>改变命运的心大部分人都有，但是一直把努力和不懂就问的品行坚持下去的人却很少。</li>
</ol>
</li>
<li>Sycx 的故事<br>-在互联网大潮之下潜行的成功创业者<ol>
<li>有一些互联网企业并不直接服务于用户，而是服务于产业，让互联网与一些具体的实体产业结合，这种商业模式可能不太好理解，但确实是互联网创业比较容易成功的地方。</li>
</ol>
</li>
<li>冯大辉的故事<ol>
<li>我不想做一辈子咸鱼，我构建我的个人品牌是希望积蓄力量，帮助我未来做事情；</li>
<li>无论加入的平台多么牛逼，只有自己踏踏实实做事情才能获得真正的成长。</li>
</ol>
</li>
<li>机会总是留给哪些不精明的人<ol>
<li>作者用一个身边人的例子（一位腾讯的早期员工）告诉读者一个道理：有时候人太过于精明，反而会忽略一些其他东西，从长远来看并不见得对自己有益（当然这个人的经历有很大运气的成分，但有一点可以确定的是，这个人并不甘于平庸，而且可以为了自己喜欢的东西放弃稳定的工作）。</li>
<li>作为一名普普通通的人，应该少一些浮想和幻想，多关注关注自己真正关注的东西，改变自己的心态。</li>
</ol>
</li>
<li>每个人都不完美<ol>
<li>对他人要宽容：要用发展的眼光看他人，人无完人；</li>
<li>对自己宽容：不要急躁，先承认现状，然后慢慢改进，才能平静地追求持续稳定的改进。</li>
</ol>
</li>
<li>我们能给世界留下什么<ol>
<li>作者简述乔布斯的故事，根据自己的经历做了一些思考，每个人在人生中都会经历各种起落，任何人都有烦恼，关键在于自己有没有 faith，有没有 calling，遇到困难时，有没有选择 fight。</li>
</ol>
</li>
<li>年轻是什么<ol>
<li>年轻是永远的积极向上、挑战自己、对世界继续充满好奇，希望每一天都过得有意义、充实，同时充满新鲜感，而老则相反，我们自己永远有选择的权利；</li>
<li>学习任何一个东西哪怕需要3-5年，但因为我们至少有几十年的时间可以去学习，所以去学习任何一个我们有兴趣的点都是完全可以的。</li>
</ol>
</li>
<li>身上的赘肉和自己的困境一样<ol>
<li>困境同样也不是一天之内降临的，也是慢慢积累的，找到解决办法，沿着一个既定的方向，慢慢来；</li>
<li>对于每个人来说，也许你们不胖，但是人生本是逆水行舟，当你停止前进的时候，你就老了，你就死了。</li>
</ol>
</li>
<li>疼痛有时候也是一种成长<ol>
<li>《异类》中谈论的一万个小时理论，并不是普普通通的一万个小时，而是不断冲破舒适区的一万个小时；</li>
<li>成长是由疼痛感的，就像爬楼梯，如果你可以轻轻松松爬5层，那么爬6层楼也许你会开始喘粗气，7层楼也许就会累了。那么5层就是你的舒适区，你每天都爬5层楼的话，就是坚持，而每天都试图<strong>多爬一层，这就是成长</strong>；</li>
<li>爱上成长，就是爱上那种疼痛的感觉，爱上那种感觉，就觉得自己一往无前、不可阻挡…..</li>
</ol>
</li>
<li>坚持本心，但不要拒绝任何改变<ol>
<li>我们在成长的过程中，都是一边追寻着改变而一边又畏惧着改变的；</li>
<li>这个时代变化太快，我觉得更幸福的模式不是找到一个好工作安稳一生，而是学会不停地改善自己，挑战自己的方法，然后用前进迎接这个世界一切的改变，永远站在风口浪尖上，直面前行。</li>
</ol>
</li>
<li>劫后<ol>
<li>有些东西无法预料，重要的是活好每一天。</li>
</ol>
</li>
<li>尽可能活成你想要的样子<ol>
<li>如果你发现自己不会背单词、不会游泳，那就是自己得到的欲望不够强烈；</li>
<li>The world is a playground. You know that when you are a kid but somewhere along the way, everyone forget it.</li>
</ol>
</li>
</ul>
<ol>
<li>这个世界对每个人都一样，但有些人活得很快乐，而有些人却很疼苦。</li>
</ol>
<h1 id="我们的伟业，是次序不断地改变自己"><a href="#我们的伟业，是次序不断地改变自己" class="headerlink" title="我们的伟业，是次序不断地改变自己"></a>我们的伟业，是次序不断地改变自己</h1><ul>
<li>作者学习英语的历程，很有借鉴意义<ol>
<li>作者并不是一个语言天赋很好的人，英文底子也不是很好，但最后却可以在两年内达到听说读写与外国人交流都没问题，这是很值得我们学习的，作者的技巧也就两点：循环渐进+坚持（过程很痛苦，但是回忆起来却很快乐），中间最喜欢作者说的一句话：<strong>当你感觉痛苦时，这时候就是成长</strong>；</li>
<li>虽然作者使用的是<strong>硬学</strong>，但要注意循环渐进，要由浅入深，而且不要急躁，作者看美剧突破无字幕用了半年，听 Postcast 突破也用了一个月；</li>
<li>在学习的时候，要给自己定下目标，然后去努力达到这个目标，这样才有方向性；</li>
<li>一切痛苦都不是痛苦，一切辛苦也都是快乐。</li>
</ol>
</li>
<li>掌握”学习曲线”，终身学习<ol>
<li>在任何环境中，我们都可以观察到，即使是一个不断变化的环境中，终身学习者也只占很少一部分，如果你是终身学习者，你可以秒杀一个领域里的你的同侪，终身学习是没有极限的；</li>
<li>学习曲线，当开始比较平，但是当你对一个东西了解以后，后面就是一个加速度过程，在开始的学习中，要设定合适的基准，不要控制太狠。</li>
</ol>
</li>
<li>锻炼你的大脑<ol>
<li>人有两个大脑，一个深思熟虑、功能非常强大；另一个比较像远古的动物，不太懂事，但它非常快，有点像反射，我们应该远离远古的大脑；</li>
<li>当你觉得难受时，你的大脑就在进化，无论在任何时候你觉得轻松，你都在使用你的习惯；</li>
</ol>
</li>
<li>二手知识的问题<ol>
<li>对于二手的知识的建议：一定要自己去看书，去看一手的东西，因为信息在传播的过程中会出现失真；</li>
<li>书读多了，读傻了，这是因为根本没有读懂书；</li>
<li>读一本书是要了解它的精髓，明白作者的心思，明白为什么这么写，学会一些思维方式、方法论或者一种思想感情，而不是会背几个段落。在读书的时候，如果你加入了自己的一些思考，用思维或者实践践行了书里面的理念，那么这本书，你就真的读懂了。</li>
</ol>
</li>
<li>学思关系<ol>
<li>学习的过程中，最重要的是要进行<strong>思考</strong>，比如，在看经济学的书的时候，学着利用学到的理论去分析现实生活中遇到的问题，去旅行去见世面，去了解不同的风土人情，跟书上的描写做对照，这也是思考；</li>
<li>看一本书，去吸收消化它，将它变成自己的理论，去验证它。</li>
</ol>
</li>
<li>阅读中的模型和数据<ol>
<li>一般来说，读书会给我们两种情形的收获：一是改造我们的思维方式，给我们展现一个新的思维模型，另一个是在现有的思维模型下，给我们数据，让我们对现有模型更精通、更确信。</li>
</ol>
</li>
<li>理性地设定目标<ol>
<li>再设定目标时，要设定一个长期目标，这个目标要有一定难度，让它指引着自己前进，当达到之后，再设定一个更大的目标；但近期目标一定要是可以达到的，每次完成一件事，成功了然后就会获得成就感，这会激励我们努力去做下一件事，这样才会进入一个<strong>正向循环</strong>之中；</li>
<li>人的学习曲线是一个二次函数，刚开始设置的短期目标比较低，然后慢慢提高，慢慢提高，追求在整个提升过程中，始终保持每一个短期目标都可达成，从而进入长效的正向循环之中，追求”乐学”和先慢后快的加速度运动过程之中。</li>
</ol>
</li>
<li>追求积累的力量<ol>
<li>我一直思考为什么需要终身学习、自主学习，以及我们应该怎么终身学习和自主学习。但是，扔需要强调的是，这里不会有任何捷径，我不知道任何捷径，我也不相信任何捷径；</li>
<li>年轻的时候，我以为成功是一个结果，是一个我们可以用毕生追求的目标。然而，这几年，我才慢慢明白，成功只是完善自己道路上的一个过程，没有尽头，爬上了一座高山，还有另外一座高山在等你。每一次你获得成功之前，都无不重要，获得之后，无非就是一个廉价的会议而已，你要追求的是自己的不断完善，这才是无尽的旅程。</li>
</ol>
</li>
<li>读书的时候我们在读什么<ol>
<li>人和动物的一个最大区别就是，人会思考，会将知识进行传承；</li>
<li>应试教育只是学习一种方式而已，并不是学校教育学习的东西就够我们使用了，毕业了之后就不需要学习了，实际上，在学校教育结束，我们还应该更加努力地去学习和看书，因为，在这个时代，大学毕业，竞争才刚刚开始；</li>
<li>对于任何一本好书，它的价值都远远大于它账面上的价格，在这样的情况下，迅速获取一本好书，获取其中的知识，从而提升自己的价值，这才是更合理的决策；</li>
<li>在书读太少的前提下谈优劣是一个笑话，在读得太少的前提下谈选择又是另外一个笑话，我们需要在阅读中不断的认识自己。</li>
</ol>
</li>
<li>时间和节奏的力量<ol>
<li>每个人的时间都很紧张，但是核心的问题不是时间本身，而是你能不能把握到节约时间的工作方法，简单来说，就是做事有规律有计划；</li>
<li>你可以试一下，学会每天都花固定的时间做一点点改进自己的事情，一年时间，你的改进就非常惊人，而你同时也会明白这样的人生才不会荒废。</li>
</ol>
</li>
<li>不要被你受的教育束缚<ol>
<li>不要相信某某东西很难，只有研究生博士才能学会这样的鬼话。实践才是学习的最好方法，我们要摆脱应试教育对自己的影响，从自身出发，从终身学习出发，仔细思考，自己的人该怎么渡过。</li>
</ol>
</li>
</ul>
<h1 id="前行的力量"><a href="#前行的力量" class="headerlink" title="前行的力量"></a>前行的力量</h1><p>我可以接收我自己沉沦一天、两天、三天，我决不能接收自己一直沉沦，我还没有死，所以，我不会停止前进，你们呢？</p>
<ul>
<li>比你聪明的人大多数也比你勤奋，你看不到的东西不代表没有发生过<ol>
<li>个人发展上，虽然个人的出身、家世背景对个人有一定影响，但是如果你足够努力，不断地去提高自己，在这个社会上，你完全可以过得很好。</li>
</ol>
</li>
<li>工作如何和个人成长相协调，写到刚毕业的大学生和毕业不足五年的朋友们<ol>
<li>工作无聊，不是个人无聊的原因，有些人是可以把无聊的工作，做的有声有色，甚至脱颖而出的；</li>
<li>对于校招的学生，当你在找到一个满意的工作之后，你必须要明白，你学历的价值在慢慢消退，慢慢地大家就会用一个对社会人的要求来要求你。</li>
</ol>
</li>
<li>工作方法篇：任务分解<ol>
<li>任务分解，尤其对于复杂问题，非常重要；</li>
<li>任务分解的过程，其实也就是对这个复杂问题思考的过程，只要经过深入的思考，你才能对这个任务进行分解。</li>
</ol>
</li>
<li>为什么有些人用一年时间获得了你十年的工作经验？<ol>
<li>优秀的人不但有极强的学习能力，而且他们的学习方法和对待事情的认真态度是不可阻挡的；</li>
<li>你是有十年工作经验？还是把一年工作经验用了十年？《异类》的理论是只有当你刻意去学习，不停地从自己舒适区跳出来，忍受一种痛苦和煎熬，改变自己之后，这样你付出的时间才算数；</li>
<li>如果当你在工作处理工作时，感觉很轻松，其实这时更应该有种危机感，因为这个时候其实你并没有在成长，只是在利用自己过去的经验而已。这个时候有两个办法可以去提高自己：一是找一份更有挑战性的工作，二是做一个副项目提高自己。</li>
</ol>
</li>
<li>改进自己从学会如何正确认识自己开始<ol>
<li>总之一句话，吾日三省吾身；</li>
<li>并不是所有人都可以做到，也并不是每个人都可以一直坚持下去，更应该通过外力的辅助让自己坚持一下。</li>
</ol>
</li>
<li>这是一个协作的世界<ol>
<li>在协作的世界里，很多你想做的事情更容易完成。</li>
</ol>
</li>
<li>字是一个一个写出的，路是一步一步走的<ol>
<li>走到天竺，分三步。第一步，开始走；第二步，走；第三步，到了；</li>
<li>实现自己计划的路上有多少辛苦。有多少磨难，你如果不上路，恐怕永远无法知道。</li>
</ol>
</li>
<li>急与快的区别<ol>
<li>欲速则不达，最好的方法，就不疾不徐，认真回到内心去思考，自己想要什么，自己可以做什么，什么是自己可以一步一个脚印解决问题的方法。</li>
</ol>
</li>
<li>什么是沟通？沟通的目的是什么？<ol>
<li>沟通是因为我们不同的人有不同的价值观，对事物有不同的看法，有不同的利益、不同的想法，但是我们要生活在一起，要在一起做事情，所以我们要相互交换意见；</li>
<li>沟通的目的并不是要战胜别人、说服别人，而是要说出自己的想法、自己的观点，就事论事，大家再一起寻找其中的平衡点。</li>
</ol>
</li>
<li>接触微博你节约了时间，然而并没有什么卵用<ol>
<li>耽误不耽误时间关键个人的计划，一定要保证事情优先，娱乐在后的原则，在保证自己计划、事情完成的情况，娱乐并不是坏的影响。</li>
</ol>
</li>
<li>理清头绪，找到节奏<ol>
<li>很多时候，当我们面对很多问题，很多压力，有时候甚至解决一个问题，又接着出现更多的问题，陷入一个恶性循环。当出现这种情况的时候，我们是需要思考、反思的，因为我们可能一直都没有直面真正的问题，做事情没有头绪，没有节奏，没有方法，当我们认为自己在辛苦工作，但却有从不思考为什么会一直做不好？</li>
<li>我们不应该在泥潭里坚持，而应该去积累，积累改进，积累思考跳出泥潭，去掌控自己的工作和生活。</li>
</ol>
</li>
<li>哪里真有什么信息过剩，你过省吸收的是垃圾，你需要的信息你根本没有获取够<ol>
<li>明白一点，信息从来没有过剩，我们只是沉迷在噪声里；</li>
<li>在合适的时间掌握稀缺的信息，是非常重要的，比如，当微信的小程序刚刚出来，在第一时间去学习、去应用，顺便写一些文章、做一些实用的东西；</li>
<li>深度挖掘信息的价值，如比看一本书，应该从中学会新的思维方法，将书中的方法论应用到自己的学习生活中，这样才是读懂了这本书；</li>
<li>什么信息才是自己需要的信息，要根据自己的需求出发，从自己<strong>成长的角度</strong>去考虑。</li>
</ol>
</li>
</ul>
<h1 id="我们都生活在生活之中"><a href="#我们都生活在生活之中" class="headerlink" title="我们都生活在生活之中"></a>我们都生活在生活之中</h1><ul>
<li>这世界上有无数的路，你走你的好了，别人怎么走跟你无关<ol>
<li>看完这篇文章，想起了一句话，在人生的过程中，每个人只能陪你走过一段距离。确实是这样，初中、高中时要好的朋友，等到工作了还有多少依然保持不错的联系？每个人的选择都不一样，最后的结果也只能是大家会渐行渐远；</li>
<li>这个世界上有无数条路，有很多路可以通向成功、幸福和快乐，关键是要找到自己的路，别人走什么路，其实跟我们关系并不大。</li>
</ol>
</li>
<li>自信心要如何培养？<ol>
<li>第一，要相信一点，其实大家都一样，我并不比大多数人聪明，同时也不比大多数人傻；第二，一次次的正反馈会增大我们的自信心；</li>
<li>要平时所有优秀的人，不要认为他们有什么天赋，学习优秀的人的做事方法，让自己也变得优秀，这才是进步。</li>
</ol>
</li>
<li>所有人都伤害不了你，伤害你的总是你自己<ol>
<li>这个世界有各种各样的人，有各种各样的评价标准，不管你多厉害，你也不可能取悦所有的人。关键在于找到自己真正在乎的人，找到自己真正在乎的标准。</li>
</ol>
</li>
<li>这世间并没有一种东西叫做拖延症<ol>
<li>拖延症这个概念确实是有害的，我们每个人的拖延都有无数的原因，如果我们不去分析拖延的具体原因，只是以拖延症来自我安慰，那么拖延症永远都无法得到解决。</li>
<li>拖延症，有一些情况是因为心理原因，有一些情况是因为自己把计划定得太死太严，不太合理。</li>
</ol>
</li>
<li>笨鸟先飞，但聪明的鸟飞得更快怎么办？<ol>
<li>笨鸟先飞，只是为了比自己昨天早到，要注意这里比较的对象是昨天的自己，而不是别人，如果选错了比较对象，只是自寻烦恼而已；</li>
<li>人活着，只是为了吃饱穿暖吗？如果只是这样，会不会太容易了？其实动物园里的猴子也可以吃饱穿暖，但是，这有什么意思？人活着总要有点念想，有点目标，要不人生岂不太无聊。</li>
</ol>
</li>
<li>梦想总是那么美好的，奈何你总是死在路口<ol>
<li>不去出发、不去努力，你怎么知道梦想不会实现。</li>
</ol>
</li>
<li>到底有没有寒门上升的阶梯？我们有没有希望？<ol>
<li>社会发展到现在，阶级在一定程度上确实在固化，但是这并不能否定个人努力的重要性，我们需要做的，其实就是一步一步地提升自己。</li>
</ol>
</li>
<li>成功并非只有一个标准<ol>
<li>对于人生来说，对于个人的成功来说，作者认为持续成长和内心平静。持续成长就是不断地去提升自己、越过一个又一个的高峰。内心平静就是 follow your heart，寻找内心的快乐。</li>
</ol>
</li>
<li>环境和你个人的关系，君子反求诸己<ol>
<li>环境对人的影响，其实也是非常重要的，这一点是毋庸置疑的，但是从另一角度想，如果一个和马云有同样生活经历的人，是不是也能有马云一样的成就呢？恐怕正常人都会觉得不太可能，同样也可以看出在人生中个人的影响力。对于我们大多数人来说，自己的之前的生活环境已经是无法改变了，现在能改变的只是自己了。如果只与自己做比较，影响自己发展的，只有自己个人；</li>
<li>对于我们很多人来说，由于我们的起点都不是很高，我们稍微努力一些成果就会很惊人，就跟在学校里提高学习成绩一样，差生稍微努力一下，效果会非常惊人的；</li>
<li>在现在这个社会里，能真正沉下心去做事的人并不多，只要稍微努力努力，我们就可以脱颖而出。换句话说，大多数在睡觉，你醒着你就是杰出的。</li>
</ol>
</li>
<li>《细节决定成败》的贡献和流毒<ol>
<li>与其一味地追求细节，更重要的是应该分清主次。</li>
</ol>
</li>
<li>改变不会在一夜降临，有耐心的人才能看到花开<ol>
<li>这世界上所有的变化和成长都是非常缓慢的，也只有这些缓慢的变化和成长才能慢慢积累，慢慢积累成翻天覆地的变化。</li>
</ol>
</li>
<li>外部条件解决后，你会发现最大的阻碍永远是你的内心<ol>
<li>如果外部条件解决之后，其实到最后你发现你没成功的原因并不是外部的条件，而是自己的内心。举个例子，在以前，如果你考不上耶鲁那你就上不了耶鲁的课，但是后来 MOOC 出现之后，你可以免费地去学很多名校的课，但是你最后发现你并没有坚持下去，这是因为你并没有那么想去上。记得在大二的时候，我第一次听说公开课这个概念，第一个看的是那个哲学课《死亡》，很明显我并没有坚持下去，直到现在，已经到研三了，也没有一门公开课坚持看完过。But now，我发现再不能这样下去了，那些对自己很有帮助的课，需要给自己定了一个计划，督促自己坚持下去。</li>
</ol>
</li>
<li>寻找和突破心障<ol>
<li>当你想做一件事，当时并没有去做，而且阻挡你的并不是金钱这些外部条件，那这是什么？可以称之为心障；</li>
<li>很多东西都可以算作是一种心障，比如学习成本的问题、不追求美好的生活。关于学习成本的问题，假如说学习一门语言或技术需要花费2年，但是我们可以用五年，甚至十年，那这合算吗？聪明人都知道，这怎么算都是合算的，更何况如果一门外语，尤其是英语，是可以用一辈子的，那这就更划算了，或者更详细算一下，英语熟练之后给你带来的好处，这就可以成为你学习的动力。</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观念在变化、在成长]]></title>
      <url>http://wangzzu.github.io/2016/11/25/book/</url>
      <content type="html"><![CDATA[<p>之前公司推送了一位大神的推荐书单，当中推荐了这本<a href="https://book.douban.com/subject/20463108/" target="_blank" rel="external">《观念的水位》</a>，那是第一次看到这本书，记得当时看到这本书的名字，瞬间就吸引了我的兴趣，然后就在豆瓣上搜索了一下，看到评价还不错，就加到了自己的书单里。再后来，回到学校就在网上找到这本书的电子版，下载到手机里就开始看了起来，中间大概花了半个月的时间把这本书看完，那段时间基本上每天在公司上下班的班车和地铁上都在看这本书。在看的过程中，根据每篇文章看后的感想，做了一部分的笔记，在文章的后面会列出来。</p>
<p>在刚开始读的时候，就感觉这本书写得很深刻，披露得也很现实，甚至有点怀疑这本书是不是在大陆出版的。从书的整体上来看，感觉这本书，可以分为三大部分，第一部分是作者根据身边的实事写的一些思考和感悟，主要是以作者在英国的生活经历为主；第二部分，确切的是说应该是作者对于一些名著（或小说）的读后感；第三部分，是作者对电影的一些感悟。因为作者主要是研究历史、政治经济学（确切应该是政治学）这一块，当然其中也有关于人性和心理学的内容，作者根据身边的实事、电影以及小说，对宪政、人性进入了很多深入的分析，其中很多的地方都是我从来没想过的点（书读得少，没办法）。最令自己的敬佩的是，作者每读一本书，都会写一篇文章，看一些好电影也是这样，作者都会去深入地思考，这些都是自己应该去学习的地方。</p>
<p>当然，这本书在豆瓣能达到8分以上，证明书的内容也不会差到哪去。在读这本书的过程中，有种当时读《野火集》的感觉，感觉我们国家相比于欧美发达国家而言，政治文明、法制文明、宪政制度真的相差很远，而且我们国家在发展的过程中，还出现了各种各样的问题，这些问题都影响着我们每一个人。我们都知道法制的重要性，可是一个没有独立司法环境的社会，如何保障法制社会的建立、如何保障公民权利，一个人既当球员又当裁判，该如何保障另一球队的公平性？</p>
<p>但是，这本书给我带来的希望的地方是，随着我们国家经济的发展，当人们吃饱肚子、衣食住行得到保证之后，人们就会有一些其他更高的追求（精神上），随着这部分人的人数在增加，也推动了全民观念的水位在上升。当然由于最近一年房价的疯涨，一线城市及强二线城市基本上都已经翻倍了，这种情况的发生，突然将中国中产阶级迅速打压下去，也导致了中国中产阶级都成了名副其实的负翁。</p>
<p>就在写的时候，突然想到一点，想到了宋朝，记得历史课上学过，在宋朝，由于经济非常发达（宋朝是一个并不是由于农民起义而灭掉的王朝），在当时诞生了资产阶级的萌芽，假设，如果历史可以假设，那么如果当时蒙古没有崛起，宋朝的经济肯定还会接着发展，宋朝当时的科技好像也在世界处于领先地位，如果能这样一直发展下去，中国会不会诞生现代文明？现在我们已经无法推断，我们知道的结果是，由于蒙古的崛起，宋朝灭亡了，中国资本主义的萌芽被消灭掉了，蒙古打到地中海，其实也是间接地促使欧洲的文艺复兴（这一点暂不讨论）。中国最初的资本主义萌芽被消灭掉之后，后来再也没有恢复起来，之后明朝也没有达到宋朝当时的经济水平，中国也就慢慢沦落为二流国家。在现代，西方人经常说一句话，一个国家的中产阶级是这个国家最宝贵的财富。反看我们国家，在房价暴涨之前，随着经济的发展，中国的中产阶级人数是在慢慢扩大的，但是后来由于房价暴涨，带动了生活成本的迅速上升，我们国家的中产阶级被房价压得喘不过气，不知道是不是与一千年前的宋朝有些相似之处。本来看到的希望，突然又被现实击破。</p>
<p>当然，在历史的发展过程中，即使对于那些老牌发达国家来说，他们也是慢慢地一步一步走到现在的，而且也不能说他们现在的制度就是最好制度。尤其是近段欧洲的难民问题、美国当选的新总统特朗普感觉像是由于美国民粹主义被煽动而当选的。世界变化实在是太快，我们也不知道未来会怎样发展，我们国家是不是能走出中等收入国家陷进，尤其在出现：由于房价上涨导致制造业成本上涨，很多制造业开始外流，向东南亚发展这情况下，我们知道，制造业和服务业目前是最能解决就业的，我们国家如果在服务业还没有发展到一定程度时制造业就开始下滑，那么结果可想而知，有多少人会失业？这些问题应该怎么去解决，我现在其实是有一些悲观的，我并不知道出路在哪，感觉祖国任重道远。</p>
<hr>
<p>对书中一些小节的读后感</p>
<blockquote>
<p>认定自由、民主“只适合西方”的看法是一种变相的种族主义，而种族主义是一种过于懒惰的世界观。——自序：春天里</p>
</blockquote>
<p>近百年来，中华民族都在为了自由、民主而努力，虽然现在我们国家的经济、政治、法制相比与以前已经进步很多了，可依然跟马克思描述的社会主义有很大距离，甚至有些地方离西方发达国家也有很多的差距，而我们却总是各种借口去推卸责任。</p>
<blockquote>
<p>追求快乐的本性使每个人都成为潜在的革命者，而一个远离快乐的制度也许可以依靠信息控制维持很久，但在信息控制越来越不可能的世界，一条缝会渐渐变成一扇门。</p>
</blockquote>
<p>人性到底是善还是恶，不同的人、不同的宗教会有不同的理解，但是人追求幸福、快乐的本性是一样的，由此可见，有些人去追求财富、一些人选择移民，这都是在追求自己认为的那种快乐生活，有些人会感觉金钱会让自己有安全感、可以为自己的快乐提供基础，有些人认为移民到发达国家，享受更好的医疗制度、教育制度，会让自己更快乐。</p>
<blockquote>
<p>经济基础、社会结构和国际环境的变化已经为新的制度变迁创造基础，这种看法用学术语言来说叫“结构主义”</p>
</blockquote>
<p>说到经济，不得不让人想到邓小平，这里其他的不谈，小平提出的发展才是硬道理，对大陆确实带来了很大的贡献。经济的发展，首先会让人民生活条件提高，当大部分的人经济水平上去之后，人们才会有时间、有精力去思考、追逐自己的内心所求。一旦当有一些东西阻挡了大部分追求自己想要东西的时候，这些人都会成为一个潜在的革命者。</p>
<blockquote>
<p>我当然不相信制度的改革可以一夜之间改变文化，但是制度的变革至少可以打开一个公共生活的空间，而公民素养的培养首先需要一个公共空间，就象学会跑步需要首先解开脚镣。——素什么质</p>
</blockquote>
<p>罗马不是一天建成的，同样，欧美现在的政治、法制、精神等文明也不是突然就冒出来的，美国也曾经有过一段非常腐败的时期，美国也是这样一步步过来的。同样，中国要想崛起也需要时间，但中国崛起的前提是制度不能成为发展的绊脚石，改革需要深入、需要彻底、需要适应我们国家的发展。</p>
<blockquote>
<p>鉴定民意的真伪，标准不在于民众选择的那一刻是不是真诚，而在于他们在形成意见时讨论是否自由、观念可否多元、信息是否充分。——民意与伪民意</p>
</blockquote>
<p>如果人民一直被洗脑，没有独立思考精神，民主很多时候会成为被民粹主义利用的工具，这也是为什么一直说中产阶级是一个国家宝贵的财富的原因，当然这里中产阶级指的是有独立思考意识的中产阶级。</p>
<blockquote>
<p>制度也许可以一夜之间改写，但是企业家精神、商业头脑、市场意识，只有通过漫长的学习才能形成。——给理想一点时间</p>
</blockquote>
<p>再次证明了时间、过程的重要性，对于个人也是如此，没有人可以在一夜之间学会这学会那，只有持续不断的学习、不断地去积累才会达到自己想要的效果。</p>
<blockquote>
<p>一个人“看到”一个事物并不等于他能“看见”它，人们往往需要穿过重重意识形态才能看见自己所看到的东西。——不知道与宁可不知道</p>
</blockquote>
<p>看到不等于看见，对于大多数人，都会不自觉地选择性地过滤掉一些信息，因为不知道这些信息反而让他感觉到一切都很美好，而知道这些信息，会让他看到自己的无知。</p>
<blockquote>
<p>斯坦福大学心理学家津巴多曾经做过一个著名的“斯坦福监狱实验”。24名学生随机抽签，一半当“狱卒”，一半当“犯人”。结果在一周的角色扮演过程中，演狱卒的学生越来越残暴，演犯人的则越来越卑怯。短短一星期，哪怕是一个实验的环境，角色感就可以改造人性，这事想想真叫人不寒而栗：现实中，有多少人经年累月地藏身于各种制度化的角色中，而其人性又在角色不断内化的过程中被劫持到了哪一个星球？——恶之平庸</p>
</blockquote>
<p>环境对人的影响非常大，这个让我深有感触，就像这次香格里拉之行，以导游为例，他是一个藏族人，同时也是藏传佛教的信徒，按理说，应该是很虔诚的，待人应该以善为本，可是他入了导游这一行，这个行业有太多的潜规则，强制游客购物，甚至不惜用道德绑架、人身威胁来强迫购物，很明显这些东西他都会拿提成的，难道他不知道这是不对的吗？但是在那些藏民眼中，他却是带动当地经济发展的好人，这个导游还资助当地藏区的贫困学生，难道他是坏人吗？明显也不是，他甚至在家人、藏民眼中还是善良的佛教徒。那这是什么原因？我现在能想到的只能是环境因素，或许他会用这个行业就是这样、大家都这样来安慰自己，来减少或消除内心的不安。</p>
<blockquote>
<p>愤怒之所以令人上瘾，大约是因为愤怒是通向正义感的捷径。——迷人的愤怒</p>
</blockquote>
<p>愤怒并没有错，但是要理性愤怒，要独立思考，不能人云亦云。</p>
<blockquote>
<p>中国近当代知识分子里我最爱的还是胡适和顾准，因为在一个几千年陶醉于“意境美”的文化里，他俩一个讲实证精神，一个讲经验主义。——告别印象主义</p>
</blockquote>
<p>实证精神确实是中国人欠缺的一种精神，实事求是的口号我们也喊了几十年了，但是依然没有成为我们的民族精神，反而假大空依然横行，就比如学术这一领域，无论是教授还是学生都以这个东西能不能写成论文发表为目的，而不是这个东西能不能用或者能不能改进现有的一些技术环境。</p>
<blockquote>
<p>试图绕过程序正义，依靠“宣传”“维稳”来寻求民众合作，在一个民众理性能力和权利意识逐渐强大的时代，只会越来越捉襟见肘，甚至会陷入政府“怎么做都是错”的可悲境地。——怎样推销糖果</p>
</blockquote>
<p>依靠强权让别人去接受一些想法或事实的做法已经满足不了现在的实际情况，应该邀请对方一起商讨、共同做一个决定，包括对孩子的教育也是这样。</p>
<blockquote>
<p>在非黑即白之外还有很多思想的灰色地带，而这个地带往往最考验思想的精细，通过将他人的观点极端 化取消其意义，恰恰是公共讨论中的避重就轻。——标签战</p>
</blockquote>
<p>在与人争论中，应该用事实和逻辑分析说话，而不是简单的片面的理解，就给人贴一个标签。很多东西并不能简单地说对与错。</p>
<blockquote>
<p>除非你意识到中国不仅仅存在于都市的“五环”。在海水的深处，阳光未曾照耀之处，还有韩颖雷金模们，并且每一个已知的韩颖雷金模们，很可能还对应无数我们尚未知晓也无从知晓的韩颖雷金模们。在苍苍莽莽的雪地里，要保持对那个被遮蔽世界的知觉，你得不断提醒自己不要睡着不要睡着不要睡着。——没来的请举手</p>
</blockquote>
<p>作为国人，对这个问题比较痛心，这个社会中有太多无助的人，他们是为了大多数人利益而牺牲的少数人。尤其是近几年，房价的暴涨，导致大陆的贫富差距迅速扩大，贫富差距之大，令人咋舌，这实际上是对中下层人民财富的一次间接剥削，是一次很不公平的财富转移。</p>
<blockquote>
<p>社会跟政府讲道理，政府就跟社会耍流氓；社会跟政府耍流氓，政府就跟社会讲道理。——法治何以可能</p>
</blockquote>
<p>民主对于法制的维护着实重要，民主实际上就是对权利者权利的制衡，它可以在普通公民利益与权利者利息之间达到一个平衡。</p>
<blockquote>
<p>当然博爱的起点是自爱。自爱加上同理心，才成为博爱。——他也可以是我</p>
</blockquote>
<p>权利的重要与权力的可怕，大家都深有体会，把权力关进笼子，赋予公民应有的权利，这样这个社会才能健康的发展，这也是近百年来，国人一直的追求，虽然我们离这个理想还有很远的距离，但不能阻挡我们追求的脚步。</p>
<blockquote>
<p>西谚云：不要让“最好”成为“更好”的敌人。意思是80分不完美，60分也不完美，但不要因为80分不是100分而否认从60分进步到80分的意义。不过中谚却说：五十步怎么可以笑百步?要我说，五十步怎么不可以笑百步，九十九步都可以笑百步。人类文明的进步靠的就是点点滴滴的努力，大的进步值得大的肯定，小进步值得小肯定。——合同异</p>
</blockquote>
<p>一味的合同异就否认了变量之间的差异，也就否认了这些点滴的进步，而不急会不无以至千里，人类的进步就是靠着这些点滴实现的。</p>
<blockquote>
<p>纯洁固然美好，但是它对世界丰富性和复杂性的敌视，它天然的非黑即白世界观，本身就为专制提供了最好的精神土壤。——权力的道德捆绑</p>
</blockquote>
<p>这就好比人不能说是绝对的好与坏，而中国从古至今都是依靠人治，法制观念淡薄，依靠人治的最明显的就是民间对包青天和海瑞的推崇，人治对于国家来说是危险的，法制才是把权力关进笼子，这样公民的权利才有保障。</p>
<blockquote>
<p>我心中理想的社会变革应是一个“水涨船高”的过程：政治制度的变革源于公众政治观念的变化，而政治观念的变化又植根于人们生活观念的变化。——观念的水位</p>
</blockquote>
<p>社会观念确实在变化，尤其是当越来越多的中产阶级走出国门，看到欧美国家人民的生活时，公民的权利意识在觉醒，但是有一点要注意的是中国中产阶级毕竟是少数，中国还有基数很大的农民阶级，他们的经济条件和公民意识还需要慢慢提高，所以感觉这也是中国深度改革还需要一点火候的原因。</p>
<blockquote>
<p>英国的报销门事件得以解决，政府信息公开是一个关键因素，但是信息公开本身，又依赖媒体自由、政党角逐、权力制衡等机制。仅仅依靠领导人的“决心”，信息公开很可能流于形式，甚至成为政治作秀。一般来说，谁也不会搬起石头砸自己的脚，要想根治浪费公款，只有把“搬起石头”的权力交给别人。——倒霉的英国议员</p>
</blockquote>
<p>一个人既当裁判又当球员显然是不合理，这样只会导致很多政策流于形式。</p>
<blockquote>
<p>其实诚恳地反思过去，核心意义并不是“秋后算账”，而恰恰是在直面历史的基础上实现真正的和解与稳定。——过去的怎样让它过去</p>
</blockquote>
<p>人需要反思，需要思考，国家同样也一样，如果不反思，悲剧只会不断重演。</p>
<blockquote>
<p>政府作为公共服务机构，其不作为和胡作非为一样可怕。——沉默罪</p>
</blockquote>
<p>政府作为唯一的合法暴力机构，如果默认他人胡作非为跟自己胡作非为没什么区别。</p>
<blockquote>
<p>对具体清晰的逃避也就是对批评的封闭。——大家一起来算账</p>
</blockquote>
<p>讲述问题或辩论时应该实事求是，而不是一味地扣高帽子，说一些比较虚的事情，更多地应该讲述具体的实事，做人做事都该如此。</p>
<blockquote>
<p>俾斯麦说“政治是一种可能性的艺术”，那么我们能敲开人性中哪种可能性，说到底还是取决于我们在缔造什么样的政治。——敲开最好的可能</p>
</blockquote>
<p>人性都是一样，如果哪个国家人民的素质有高低，那也只是后天环境影响的。一个好的政治制度应该激发公民心中的善、保护公民心中的善。</p>
<blockquote>
<p>政府本质上不过是个公共服务机构，而不是什么高高在上的官府。——让政治变得家常</p>
</blockquote>
<p>一个国家的政治制度和政府性质，对于一个民族的影响很大，好的制度会估计民族向善的方向发展，不好的反之。</p>
<blockquote>
<p>在一定意义上，与其说浩浩荡荡的游行队伍体现了人们对经济危机的一团怒火，不如说体现了欧美高度发达公民社 会的组织资源。——绞死银行家</p>
</blockquote>
<p>公民有言论自由、有充分表达自己意愿的渠道，这种制度才会让一个国家更稳定、人民生活更幸福。</p>
<blockquote>
<p>在言论自由和政治平等之间，如何实现平衡？——民主的裤衩</p>
</blockquote>
<p>自由与平等是人类一直在追逐的东西，但两者在某些情况下也会有冲突，如何进行平衡，这种事情一般由最高法院来裁决，美国的司法充分保证了司法的裁决不受政治的影响，</p>
<blockquote>
<p>多元的观点带来充分的政策辩论，而充分的辩论不但给民众一个从不同角度理解这个法案的机会，也督促辩论两党给其主张提供坚实的论据基础。——吵吵更健康</p>
</blockquote>
<p>美帝的很多政策就是多方互相妥协的结果，美帝充斥各种利益集团，国家要想稳定要想发展，必须平衡各方利益，谈判妥协几乎可以说是美帝的基因所在。相反，我们民族，从古至今都是忍受，再忍受，直至没有活路，然后革命，接着再进入循环。我们民族一直都在想突破这个兴亡迭代的循环，能不能突破还要看我们这几代人的努力。</p>
<blockquote>
<p>分析各国改革速度和改革成效关系的话，反而发现改得快的未必发展慢，改得慢的发展未必快。结论很可能是，相比改革公正性、法治化、政策合理性，变革速度可能本来就不是个核心问题。——苏东巨变：20年之后</p>
</blockquote>
<p>这种感觉可以归结于具体的国情，估计作者又该说了应该拿出具体事实，而不是简单的国情了事，什么是国情，国情这种东西很模糊，天天说国情的人都不一定能搞明白啥是国情。我个人的理解是：政治、法制的改革如果能走在经济发展的前面，那么就能快速促进经济的发展，一旦落后于经济，就会抑制经济的发展。</p>
<blockquote>
<p>人类花了28年等待有形柏林墙的倒塌，无形柏林墙的消除，也许要更漫长地等待。——俄罗斯的徘徊</p>
</blockquote>
<p>自由、民主是需要时间、需要代价的。</p>
<blockquote>
<p>民主制度并不是选民投下一张选票然后翘起二郎腿等待政治家给我们端茶倒水的“懒人”体制，而需要民众对政治经年累月地“巡逻”促成点滴改良及至水滴石穿。——当“革命”成为家常便饭</p>
</blockquote>
<p>罗马不是一日建成的，一个自由、民主的社会也是如此。并不是说有了选举制度，就可以实现民主，俄罗斯可是不单单有选举制度，还是多党制，但我们并不认为俄罗斯是民主国家。自由、民主需要时间、需要代价，观念的上升才能更好地促使社会的变更。</p>
<blockquote>
<p>制度大于出身，这才是民主的要义。——“亚洲特色”的民主</p>
</blockquote>
<p>记得大陆官方当时发表声明嘲笑日本是政治世袭，国内当时可真是一片骂声，原因很清晰，日本还是世袭？那中国、朝鲜是什么？简直呵呵了。看一个社会、一个国家、一个民族，不去学习别人好的部分，老是揪住人家一些小污点不放，感觉很没有大国的胸襟。</p>
<blockquote>
<p>我认为，在经济政策上要允许试错，但藐视程序正义则是破坏现代政治的根基。——当民主缺失中产阶级</p>
</blockquote>
<p>最典型的例子就是美帝当面禁酒令，虽然执行禁酒令的时间只有13年，但确使美国经济倒退了不止20年，但是，这也丝毫没有成为阻挡美国后来崛起的绊脚石。美国现在的文明就是这样一点一点试错中成长的，什么东西都不是一蹴而就的。</p>
<blockquote>
<p>百万人涌现街头，其实并不突然。追求更多自由、更真实民主的暗流一直在伊朗“螺旋型”前进。——历史螺旋式终结</p>
</blockquote>
<p>自由民主可以说是这个世界的普世价值，每个国家和民族都在不余遗力地追求，正如前面所言，这并不是一触而就的，每个国家在走向这的过程都是曲折的，就像我们中华民族，虽然已经努力了一百多年，但与我们的理想还相差甚远。</p>
<blockquote>
<p>能够有制度性制衡来推动不同机构和利益集团之间的协商互动。一个只注重垂直呼应民意而忽视水平制衡的政府，也许合法性很高，但是合理性很低。——选举式独裁</p>
</blockquote>
<p>从美国的经验来看，权力之间的制衡以及利益集团间的相互妥协（在美国，各个协会组织或公会组织都是代表其协会成员的利息的利息集团）才是西方民主的真谛</p>
<blockquote>
<p>面对全球化，值得思考的不是它是否带来挑战，而是挑战与机遇是否对称。——我们在输出什么</p>
</blockquote>
<p>经济全球化确实带了很多问题，但是肯定是机遇与挑战并存的，问题当然很复杂，也不能一概而论。</p>
<blockquote>
<p>虽然美国收入差距在拉大，但社会仍具有相当的流动性。——有多少资本主义可以重来</p>
</blockquote>
<p>这也是美国价值观风靡全球的原因之一，一个相信个人奋斗的国家，是更容易吸引全球的人才，尤其是那些出身并不是很优秀的家庭。</p>
<blockquote>
<p>根据奥尔森集体行动的逻辑，当一个政策的受益或者受损对象比较集中，他们组织起来行动的可能性也更大。——从更人道的到更霸道的</p>
</blockquote>
<p>他们之间有明确的公共利息，不但利息明确，而且很少有分歧。</p>
<blockquote>
<p>量入为出本是最朴素的道理，但是将福利视为集体权利而不是个体责任的文化已使很多人失去了这种朴实。对于这些人来说，胖子的问题不是暴饮暴食，而是医生的减肥食谱。</p>
</blockquote>
<p>高额的福利必须会有高额的税收，福利不是从天上掉下来的，可惜的是我们国家欧洲的税收非洲的福利。</p>
<blockquote>
<p>一想到在那样无望的时代，曾国藩还奋发图强，对他的钦佩不禁如滔滔江水。转而又想到，即使是以他的奋发图强，也只能哀叹“天命”之不可违，却从未抬头观望天窗外的璀璨星空，又觉得个人面对历史，还真是胳膊拧不过大腿。——成圣又如何</p>
</blockquote>
<p>方向是错的，再努力又有何用？可是应该如何分辨自己的方向是否正确呢？曾国藩当时是没有这个条件去感受西方政治制度，自然也无法看到天窗外的星空。西方政治制度最大的特点就是不相信人性，他们用制度、用规则去管理，而不是人治、德治。</p>
<blockquote>
<p>这也是戈尔巴乔夫始料不及之处。他以为他可以放开管制同时强化专政，但多元社会和权力垄断不相容。他必须做出选择，是继续支撑这个空心帝国，还是捅破那层纸。最后他说，如果不是我们，是谁？如果不在此刻，又待何时？——那个搬起石头砸自己脚的人</p>
</blockquote>
<p>戈尔巴乔夫在来临的这个时刻做出了他应该做的决定，他选择戳破这个纸老虎，选择放弃专制，但历史并没有按照他预期的想象发展，现在俄罗斯也并不是自由民主的代表，改革的道路一片艰辛。</p>
<blockquote>
<p>摘下有色眼镜观察他国并不容易，因为我们脑子里充满了各种“想当然”。也许问题的关键并不在于我们怎么看待他国，而是怎么看待自己。——超越那些“想当然”</p>
</blockquote>
<p>在改革时，当然不能完全照抄某种经济改革，但也不能因为某些经济政策导致了一些不好后果，就把把它全盘否定。突然感觉我对这本书的一些见解好像都是在某些课上学到了，看来有些课有些书至少理论上还是很不错的，只是执行的过程中出了一些偏差。</p>
<blockquote>
<p>正是这种矛盾使其从一开始就不可能是一个逻辑上自洽的帝国：你不可能一边宣扬天赋人权，一边心安理得地铐住黑人送到加勒比海的甘蔗地。——当自由遭遇一丝微风</p>
<p>获得民众的信任并非一劳永逸之事。如果最高法院在其判决中背叛了美国宪法的最基本价值观，没有对这些价值观进行与时俱进的适应性诠释，或者在宪法所追求的不同价值观之间没有实现微妙的平衡，民众的信任和服从很可能随风而去。这大约是美国法官们工作的艰难之处：他们永远在如履薄冰，永远在风口浪尖。——法治的“秘密”</p>
</blockquote>
<p>美国法院的主要是目的就是维护宪法赋予公民的个人权利神圣不可侵犯，在历次判决中，都是以这个作为原则，这也是高等法院受公民信任的原因。</p>
<blockquote>
<p>从这个意义上来说，王彩玲这个角色比Howard更有意义：如果对个体意志的赞叹并不依赖于它是否引向“成功”，那么兰德分配给Howard的最后成功命运就是个多余的情节。不但多余，甚至是误导性的，它给人造成“功夫不负有心人”的错觉：不，功夫常常是会负有心人的；功夫负不负有心人本该没有那么重要的；“有心”的价值是不能用“负与不负”来衡量的。——你比你想象得更自由</p>
</blockquote>
<p>如果坚持初心，坚持个人的信念，成不成功又有什么不同，都只是外界的看法而已。</p>
<blockquote>
<p>犹豫不是为了逃避选择，但是它令选择之后的制度设计更加审慎和包容。——诸善之间</p>
</blockquote>
<p>当面临选择时，每一种选择都有其合理性，其实都是一种对哲学的思考，人类更多的时候是在多种选择中达成一种妥协。</p>
<blockquote>
<p>今天，权力的巩固仍然借助于对历史的改写与屏蔽。历史一层层被擦掉，或者被涂抹，失忆的人群也因此成为价值的木偶。——像一滴水一样</p>
</blockquote>
<p>正如驴得水中所说，过去的如果就让它过去，未来只会更糟。东亚民族自古以来都有改写历史的习惯，直到今天也是这样，花了那么多代价、交了那么多学费，就这样为了“政治正确”而被改写，我们可能又不得不重新去探索，这只会让未来变得更糟糕。</p>
<blockquote>
<p>所以我现在读书并不指望醍醐灌顶，更不觉得书架上会有什么“神明”，仅仅希望每一本书能推进一小点知识或者带来一个小启发。正如政治上不存在什么“救世主”，智识上也不存在什么“救世主”。真正的好书，都向证伪敞开，而不是给你一个一劳永逸的启示录让你枕着它睡大觉。振聋发聩的东西，我一向觉得可疑。——从经典到经验</p>
</blockquote>
<p>读书并不一定要去读那些深奥的经典之作，更多的应该根据自己的问题，这本书能给自己一些启发、带来一些思考、解决一些困惑，更能体现这本书的价值。</p>
<blockquote>
<p>真的，他们是怎么说服自己的？这事首先令人困惑，其次才令人沮丧。他们怎么能够在窃听骚扰跟踪袭击迫害诚实正直的人之后，一转身，对自己的孩子说：孩子，你要做一个好人。——没有你们就没有他们</p>
</blockquote>
<p>这种事情就像我们对一个幼女强奸犯说，你怎么能这样对待这个小姑娘，这个小姑娘也是别人的女儿，如果别人这样对待你的女儿你会怎么样？有时候我也搞不懂他们是怎么说服自己的，这个可能需要对人性进行更深层次的深挖。</p>
<blockquote>
<p>一切专制者都试图控制人的思想，但警察无法进驻人的大脑，于是只能控制思想的表达。语言因此必须被消毒、被驯化。一些词被妖魔化，另一些词被扎上蝴蝶结，一些词被灌入硫酸，另一些词则被喷上了香水。多年的教育之后，一提起“农民起义”，我就想起了“可歌可泣”，一说到“国民党”，就想起“三座大山”……成年以后我知道历史并非如此非黑即白，但这些被“加工”过的词汇在意识深处留下的情绪反射却经久不去。以条件反射代替思考，使每一个词语在展开其内容之前散发出某种“气味”，正是此类教育的成功之处。——语言的贫困</p>
</blockquote>
<p>这是多么的真实啊，记得小时候不知从何时开始，脑海里一出现欧美资本主义国家，就会想到万恶的资本主义、剥削压迫无产阶级，可是长大之后，我慢慢知道这个世界实际上很复杂，好与坏都是相伴而生的，而我们因为意识形态的问题边只看到某些国家好的地方或者坏的地方，又因为媒体是被完全限制的，所以我们接受的只是他们想让我们接受的，不过互联网确实是在慢慢打破这种限制，让我知道了做一个人是应该独立思考的，而不是等着别人去喂食，这也是我现在对外面的世界充满很大的好奇心，也是现在努力的原因，因为我想要自己去探索一些东西，而不是被强行灌输。作者后面这十几篇文章都是通过电影慢慢感受的，而自己在看电影时只是简单地看一下剧情，并没有深入思考，这也是我应该向作者学习的地方之一。</p>
<blockquote>
<p>影片最后，中年迈克问老年汉娜是否会想起那些犹太人，汉娜冷冷地答：“我怎么想无关紧要，反正死的人都死了。”“我以为你学到了更多的东西。”“我学到了，我学会了阅读。”汉娜学会了阅读，也仅仅是阅读而已。——爱是</p>
</blockquote>
<p>感觉已经超出了我理解范围，我也很难明白为什么人会这么复杂，有那么多面，即使这很多面实际上是有矛盾的。</p>
<blockquote>
<p>说到底，谁都终将被扔回时间的海底，在那里与其它鱼虾贝壳一同聆听无边寂静，而在这之前，我们能指望的，大约只是心灵成长，祈祷生的优雅可以抚慰它的渺小。——记得当年草上飞</p>
</blockquote>
<p>成长的道路各有不同，个人的环境、遭遇各有不同，最后每个人的最后每个人的结果当然也并不会按照自己所想的那样发展。但在命运的手上也有漏网之鱼，虽然并不多，但还是有的，这也是这个世界的美妙之处。</p>
<blockquote>
<p>抑与解放，但是刘天昭不。她写一个小女孩擦玻璃的神情，写帆布椅子上坐着的一个无所事事的老太太，写窗外三三两两的人群，写前任房客掉到床底下的储蓄本，写一只灰喜鹊在天空中划过的轨迹，写夜半大街的光线……总之她写一切貌似轻微、无关和混沌的时刻和人物。她简直是故意通过描写这些“无关紧要”的事物来暗暗颠覆这个世界的权力结构和等级秩序。谁说政治局委员的命运就比远亲里某个“破鞋”的命运更惊心动魄？又或者，凭什么一个“破鞋”的命运一定比窗前一只乌鸦起落的声音更值得书写？在被时间击败、被时间席卷、被时间吞噬方面，万物皆平等，因而都值得在颤抖中被文字拥抱。——诗的世界在每一个角落等待</p>
</blockquote>
<p>她那本书的厉害在于与别人切入点的不同吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从《驴得水》到《我不是潘金莲》的一些思考]]></title>
      <url>http://wangzzu.github.io/2016/11/20/movie-think/</url>
      <content type="html"><![CDATA[<p>今年好久没去电影院看过电影了，今天趁着周末去看场电影，选了最近比较火的<a href="https://movie.douban.com/subject/26630781/?from=showing" target="_blank" rel="external">《我不是潘金莲》</a>，据说这部电影跟《驴得水》有些相似之处，比较贴近现实，并那么做作。看完之后确实感慨很多，相比于以前的那些烂电影真的要好很多。</p>
<p>今年上映的国产电影，不得不说有几部确实还是挺不错的，虽然还是烂片居多。关于电影，其实我一直都是有个疑问，之前看过很多的韩国电影，看完真心感觉很多韩国电影拍得很不错，尤其是近几年，韩国的犯罪系列电影拍得很精彩，韩国也拍了很多反应社会现实的电影，如《熔炉》、《金福南杀人事件》，这些电影其实都可以归结于人性系列。那么问题来了，为什么韩国的电影近几年能够异军突起，甚至有成为亚洲电影骄傲的趋势，而我们大陆拍得电影，几乎每年都被在吐槽烂、简直扶不上墙，更别提走出国门了，一年上映几百部的电影，而豆瓣评分过7分也只有个位数，原因何在？是我们的导演不如韩国？编剧不如韩国？或者说文化氛围不如韩国？貌似这些理由都没有说服力，毕竟我们曾经拍出《让子弹飞》、《霸王别姬》、《大话西游》等这些优秀的电影，而且我们国家也出了诺贝尔文学奖获得者莫言，那么原因在哪里？很多人说是广电总局的问题，说我们国家的电影审核太严，我同样也认为这是其重要的原因之一，电影的剧本要符合主流价值观，这也使得很多好的题材并不能过审。而近段上映的两部电影——《驴得水》和《我不是潘金莲》，多多少少让我们感觉到影中的情景就是赤赤裸裸的现实，让我们明显感觉到中国电影的环境在慢慢变得健康，而不像以前那样的畸形，这两部电影的大热也不是没有原因的。</p>
<p>电影是艺术的一种，关于这一点，是我们不可否认的，一部好的艺术作品，是能够启发每个人的思考，而不仅仅是嘻嘻哈哈就过去了，对于电影作品也是如此。</p>
<p>在《驴得水》中，首先是基层人员为了能够获得更多的利益，谎报在编正式人员数，甚至不惜伪造；其次，中层领队对上级拨下来的教育扶贫资金克扣，影中克扣了70%，剩下的30%在基层人员手里大家再分一点，最后真正落到实处的都不足两成、甚至不足一成；最后，为了应付上级领导的检查，中层领导和基层人员为了各自的利益一起糊弄上级领导。这种现象在现实中大家都应该深有体会，尤其对那些三四五线的小城市，恐怕更为严重，这也是年轻人毕业 之后纷纷选择竞争更为公平的一线强二线的城市去打拼的原因（当然并不是说一线强二线就是绝对公平的，相比于三四五线还是要好很多的）。记得当时看过驴得水之后，为影中的剧情拍手叫好，当时看完电影甚至感觉有些诧异，这种电影竟然过审了？</p>
<p>今天看了《我不是潘金莲》，女主李雪莲因为一件离婚案去县里、市里告，在去市里喊冤的时候，为了不影响市里的精神文明检查她还在省委领导视察期间被关进派出所，最后幸运的是她去北京告状的时候遇到了中央的首长，更幸运的是遇到了一个比较好的中央首长，当然故事还在继续，就是因为她这一告从法院院长、县长、市长都一并被处置了，但唯独没有处置她的前夫秦玉河，这里先不讨论李雪莲是否有理（其实这个并不重要，李雪莲确实是个法盲，这部电影给人的思考更应该关注这些人民公仆的表现），在这个过程中我们看到了从下到上、从县到省是如何对待普通公民李雪莲的。首先判官李公道对这个案子判决根据我们已有的法律知识是没有问题的，但是后面的各个官员对于普通公民的态度呢？影片中也出现了法院院长喝酒应酬的情景，李雪莲前去告状，他们连深入了解这个案件的耐心都没有，甚至还生怕李雪莲在前任院长面前说了什么不该说的话，他们直接告诉李雪莲你要是对法院判决不服那就去市里告、检举法院厅长的话去检察院，这跟我们没关系，然后李雪莲就问：你们难道就不管了吗？那人说：我们什么时候说不管了，关键是我们管不了。</p>
<p>这些说的这听起来确实也没有错，当李雪莲在法院院长应酬的饭店外面蹲点，去拦截法院院长的车告状，这里看一下当时影中的情景是怎样的？</p>
<ul>
<li>李雪莲前去告状，法院中另一人直接抱住李雪莲，不让李雪莲在前任院长面前说话，生怕李雪莲说了什么队他们的不利的东西，当时前任院长有心想问一下，这时候他老婆说了一句：你已经退休了，这些事情你管不了了。这个场景我想我们大家都有深有体会的，因为很真实、很现实；</li>
<li>那些法院公职人员对待公民的态度问题，其中那个抱住李雪莲的人还一把把李雪莲推倒在地上，反而自己还大吼道：你想干嘛，真是巨大的讽刺。</li>
<li>影中还出现了两次（记得是两次）打扮颇为靓丽的年轻女子，一次在与两人法院院长吃饭的饭局上，另一次在市长与县长谈话的那个小桥边，同样也有讽刺意味十足。</li>
</ul>
<p>影片也丝毫没有遮掩下级干部是如何欺瞒、甚至糊弄上级，影中连省长向中央首长汇报都是这样，省长都向人代表明确暗示在首长面前不要多说话、讨论仅限昨天会议问题、绝对不能扯远，由此可见，别说民意上达中央了，估计省里都懒得去管。个人认为《我不是潘金莲》这部影片最牛逼的地方在于它直接就映照现实，这些东西以前可都是忌口，就连《驴得水》还用了民国做背景，而它倒好，故事背景直接就发生在近二十年，故事的最后也提高了计划生育政策，普通公民为了多生一个孩子甚至不惜以离婚作掩护，而现在的现实是很多夫妻为了多买套房、享受优惠不惜假离婚，当然也出现了一些假的变成了真的场景，在新闻上是屡见不鲜，可见一切都在改变，而似乎有些东西又丝毫没变，不知道那些这样做的人，过了二十年之后再回忆会是什么感想。</p>
<p>从《驴得水》到《我不是潘金莲》这两部电影，其实我感慨最多还是中国的电影环境在变化，大家都知道2015年和2016年这两年其中一个处在风口的行业是什么？是内容，广大普通民众对于那些套用各大明星的烂电影简直是深恶痛绝，也对那些省级卫视里那些无聊的电视剧和娱乐节目感到厌烦。记得前段时间看新闻，还说今年的票房相比去年下降了很多，我想这更多就是民众再对烂电影的一次共同抗议吧。但这也成了很多用心做内容公司一次机遇，就以电影行业为例，心迷宫、夏洛特烦恼、大圣回来等小投资的电影大热，口碑和票房双丰收，可见市场这只无形的手确实在发挥它应用的作用。</p>
<p>内容行业的人估计也在意识到现在的一些年轻人喜好正在发生改变，假大空、没有任何深入的电影，真的让人无法接受，浪费钱就不说了，更重要的是浪费了我们宝贵的时间。这种结果也是互联网对这个行业冲击的影响，首先，互联网对电影口碑的传播几乎起着决定性的作用，之前是豆瓣评分，现在朋友圈好友推荐，口碑传播的方式在慢慢变化，一部作品的口碑对其最后的成功与否也起着越来越大的作用；再者，互联网的发展，让普通民众接收到了不同信息，民众也不再像以前那样，给什么信息我们就只能接收什么信息，信息的接收渠道十分有限，但是现在我们可以接收到更多的信息，这也在潜移默化影响我们的生活，其实，我就是想说一句话，随着经济的发展，公民观念的水位在慢慢上升。举一个例子，之前那段时间我们一直都在看美国的总统大选，看得好不热闹，然后这两天也刚我们国家的人大代表换届选举，搞笑的场景就出现了，新闻上有一个地方川普的得票率达到了10%，而这个地方总投票率却不到半数，最后选举只好重新举行。对于在大城市生活的人来说，我们还是能明确感受普通公民权利意识的觉醒，这也是我们国家正在进步的表现。</p>
<p>最后，一部好的电影作品是应该引人思考、深入人性的，希望我们国家拍得电影越来越好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[校招找工作小记]]></title>
      <url>http://wangzzu.github.io/2016/11/15/job-summary/</url>
      <content type="html"><![CDATA[<p>2016年，是一个很重要的年份，不但是自己的本命年，还是自己要踏出校园、走向工作的一年。从今年过完年回到学校，记得大概是2月底，这期间经历刷题、找实习、校招，直到前两天把三方交上，今天公司盖完章拿到回执信，工作也算终于确定了下来。在这过程中，经历过失落、兴奋、伤心等等，中间的喜悲，也只有自己最清楚了，趁着这几天晚上有点时间，回想一下过去几个月的心理路程写一篇校招的小记，也算是对这几个月的酸甜苦辣做一下总结。</p>
<blockquote>
<p>莎士比亚：不要因为一次失败，就放弃你原来决心想达到的目标。</p>
</blockquote>
<h1 id="慌慌张张找实习"><a href="#慌慌张张找实习" class="headerlink" title="慌慌张张找实习"></a>慌慌张张找实习</h1><p>记得当时二月底回到实验室，刚来没几天，网易的实习招聘就开始了，当时还没到三月，丫的网易直接把实习的战线拉到了二月底。当时感觉真是日了狗了，啥都没准备，所以也就没有内推网易。然后就开始慌慌张张地准备找实习了（<strong>提醒：找实习就是找工作，一定要认真对待</strong>），先是写简历，把自己在实验室做的那些项目总结一下，重点是把项目给整理一下，根据面试的经验，对于简历中的项目一般会问以下这几个问题（这几个问题有的难度大有的小，看个人人品了，不过最后都准备一下）：</p>
<ol>
<li>项目的目的是什么？要解决什么问题？</li>
<li>为了解决这个问题或完成这个项目，设计方案是什么？以及为什么要使用这个设计方案？</li>
<li>项目中遇到了哪些难点，如何解决？</li>
<li>你再回头看这个设计方案，有什么哪些地方可以再优化？</li>
<li>如果现在让你重新设计方案来解决这个问题，你会怎么设计？（这种问题一般是之前的设计方案有漏洞或者有可以改进的地方时，面试官才会问到）。</li>
</ol>
<p>整理完自己的项目之后，就开始看一些计算机的基础知识，因为自己是做大数据方向，所以当时也就选定了 Java 开发工程师或者是大数据开发工程师的职位，其他的职位就不再考虑了。在准备 Java 基础的时候，主要就是看一下一些常见的 Java 面试题，这个网上有很多，个人的经验，觉得面的最多的就是：容器（hash 很重要）、多线程、并发等了，这个还是比较容易准备的，但当时由于自己准备的太晚，而且很多大公司的实习生开始得也比较早，所以当时就感觉时间很紧张。</p>
<p>如果想投开发岗的话，算法是必须要准备的，《<strong>剑指 Offer</strong>》这本书是肯定要刷一遍的，记得当时自己花了四五天时间急急忙忙把这本书看完，但只是看了算法过程，并没有手写代码，后来在面试中也就吃了亏，手写算法还是要好好准备的，准备一些常见的算法即可。对于 Java 开发，除了算法，JVM 的一些内容也要重点掌握，这个就是看《<strong>深入理解 Java 虚拟机</strong>》这本书了。反正对于我，记得当时刚开始面试时，遇到这种问题基本上都是一脸懵逼，不过面的多了，就知道往哪方面准备了。记得当时先投了阿里云那边，是室友的一个同学内推的，室友的这个同学先对我进行了预面试，问得也是 Java 和大数据方面的基础知识，面试完就感觉自己前几天准备的东西白准备了，都没怎么记住，当时瞬间感觉自己要完了、感觉要完全找不到实习了。</p>
<p>即使当时预面试的结果不是很理想，但是也得投简历，要不然连面试的机会都没了，所以就先投了阿里云。然后紧接着第二天中午就收到了面试电话，聊的内容当时感觉还是很深的，但从现在的角度看，其实也就那样（校招的时候很多公司问得会更深）。这是人生中第一次正式工作面试，中间聊得还挺不错的，面试官对我还比较满意，还让我推荐实验室的同学。我当时也是很幸喜，谁知道好景不长，第二天傍晚就收到了阿里的二面电话，先问了一个问题：介绍一下 Hadoop 生态圈的技术，当时就开始从 MapReudce、hdfs、HBase 开始讲起了，讲了有足足五分钟，电话那边连个音都没有（当时都怀疑那边是不是还有人在听），当时面的时候还是很紧张的，在介绍 hdfs 的时候，面试官突然问到：secondNameNode 的作用是什么？然后就回答错了，之后面试官又开始问了 spark、linux、flink 等相关的问题，自己全程是不会来结束讨论的，然后就没有然后了，这个面试只持续了15分钟就结束了，到了第二天，官网上状态就显示自己的面试结果是已回绝。第一次应聘就这样结束了，当时分析失败的原因认为主要是个人基础准备不足，还有一个是缺乏面试经验，一方面是自己准备的确实不好，另一方面是面试的时候没有把面试官领到自己熟悉的领域上来，而且前面在讨论 hadoop 的时候，并没有与面试官进行一些互动，总之，面的第一家公司就这样挂了。</p>
<p>自己当初找工作时候的目标，其实很明确，就是想去阿里的中间件做 Java 开发工程师。可惜天公不作美，阿里是我面试的第一家公司，也是第一个拒掉我的公司。经历这次面试之后，自己又把相关的基础准备了一下，接着又面了XX街、XX之家，这两家都属于比较小的公司，当时想的是积累一下面试经验，XX之家实在是太耿直了，面了一面就给了 offer，面试官人还挺好，说实话自己到现在还挺愧疚的，去那边面试了，人家给了 offer，结果自己又没去，感觉这样确实不太好。</p>
<p>其实当时自己想的也很清楚，也就准备重点投一下这6家公司：BAT、某滴、某米、某团，其他的投的话只是积累一下面试经验。当然，虽然想得很好，但现实却很骨感，T 家从头到尾都没给面试机会，感觉老是投不对岗，实习的时候投的后台，发现大都是招 C++，听人说大数据应该投基础研究，然后校招投的基础研究，笔试的时候发现题目全特么都是机器学习相关的，当时心中真是一万只草泥马奔腾而过啊，注定无缘。对于 B 家，实习的时候师兄帮忙内推的，面的是一个比较对口的部门，不过因为准备的不充分、基础也回答得不好，虽然一面面了一个半小时，结果还是挂了，不过面试官真的很 nice，面完的时候还对我的面试情况做了一下总结，说我哪地方不好，哪地方还可以，唉，最终还是挂了，校招内推的时候也没敢投，因为这次面我的这个面试官是百度负责 Kafka 技术的小组 leader，当时感觉如果校招再投简历的话简历还是会到他那里，所以就没敢再投。虽然后面百度正式校招的时候也参加了笔试，自我感觉做得还可以，不过最后还是没有面试的机会，也是无缘了。关于 A 家，因为之前实习的时候没过，后来校招的时候也找了内推，但是今年 A 家基本上没怎么校招，今年的校招基本上都是实习生转正，还有一些是内推。因为自己一直想去 A 家的中间件团队，校招的时候就找到了<a href="http://weibo.com/u/2176287895?topnav=1&amp;wvr=6&amp;topsug=1" target="_blank" rel="external">黑桃夹克</a>师兄帮忙内推，师兄很热心，但是今年 A 家的 hc 实在太少，记得当时简历投了一个月都没人理，最后直接变成了校招，让参加笔试，真心感觉 A 家今年没怎么招人，当然这跟具体部门、职位有关。</p>
<p>慢慢的就过了五一，当时实验室好多人的实习基本上已经确定了，大家基本上都拿到了一个比较好的 offer，那段时间自己心里还是能明显感觉到找实习的压力，记得那期间还失眠了一段时间。既然没找到心仪的实习 offer，只能对面试经验再做总结，自己不会的再好好准备。随后，某米和美团的实习也开始了，然后就让师兄师姐帮忙内推，关于某米的面试经历印象还是很深刻的，去面某米之前，其实还是挺想去某米的，自己对某米的商业模式是一直比较看好，但是面试结果真的是大跌眼镜了。当时的一面面试官感觉是一个刚毕业一两年的工程师，随便问了一些大数据和 java 相关的基础知识，然后就开始写算法了，写了一道算法和一个 mr，然后就进入到二面，二面面试官让我设计一个系统，用一个朋友圈来举例，全程聊了将近一个半小时，感觉最后的结果是面试官不理解我说的，而我也没完全理解面试官说的问题，总之，中间聊的时候我都想直接甩袖子走人。面完某米，记得当时我都开始怀疑自己是不是理解能力有问题，不过也深刻地明白了一个道理：<strong>一定要跟面试官确定好问题</strong>，如果你默认是这样，很有可能就中了面试官的套。</p>
<p>面完某米之后，没过几天就收到了美团的面试通知，然后就去美团面试，面美团之前想的是面面再说，反正最后也不一定去，当时约的是两点，我去的比较早，一点半就到了，然后到了一个会议室开始面试，记得当时跟一面面试官聊了一个半小时，关于 Kafka 相关的聊了近 40 min，聊的还比较深，然后又聊了很多基础知识，还写了两道算法。当时面完一面之后，当时感觉自己拿这个 offer 应该还是很稳的，因为自己在实验室做的跟这边做的完全对口。过了一会就开始了二面，刚好跟二面面试官是老乡，二面面试官是做实时的，聊了很多 storm 相关的，因为美团要求前二面必须手写算法，所以又做了一道算法，基本上就结束了，大概也聊了六七十分钟。最后又跟三面面试官聊了半个小时，三面聊了一点点技术，其他的基本上就是聊聊兴趣、聊聊人生什么的。当时从下午两点开始面，面完基本上快六点了，当时面完的感觉是美团这边招人还是挺严格的，纯技术面一口气面了三面。不过美团真的很给力，面完的第二天就给了 offer，因为我当时7月份才能实习，面试官也愿意等我到七月份入职，当时考虑一周之后，就把 offer 签了，决定去美团这边实习，当然最主要的原因是跟我的之前做的很对口，还有就是感觉那边面试还是挺严格的，所以觉得技术应该也不会差到哪去。</p>
<h1 id="实习篇"><a href="#实习篇" class="headerlink" title="实习篇"></a>实习篇</h1><p>到了七月之后，准时到公司报到，去的时候第一周就领到了全新的 Mac pro，之前没用过 mac，各种不顺手，不过用了一周之后，就觉得 Mac 用着真特么爽。去了之后，才知道，当时我的一面面试官，就是之后带我的 Mentor，他已经工作五年了，之前在阿里工作过4年，技术还是很不错的，当时觉得自己还是很幸运的，能有这位师兄带我，之前二面面试官是我们小组的 leader，三面面试官是我们大部门的 leader，被称为百度的 Metrcis 之父，还真没想到这边居然还卧虎藏龙。所以，在刚开始那段时间对自己的工作特别满意，自己在这边确实也能学到东西，被 Mator 逼着看 Kafka 的源码（感谢）。</p>
<p>这里，顺便说一下关于大公司与小公司的选择问题吧。下面纯属个人想法，关于这个选择，如果由能力能去清华的计算机，那不用考虑去就行了，毕竟那里牛人更多、氛围也更好，但是如果去不了清华的计算机，而只能去清华的XX（就是就业很不好的那种小众专业），那完全可以选择去北航的计算机或北邮的计算机。也就是说，如果有能力拿到 BAT 的核心部门的 offer，那就去；但如果只能拿到边缘部门的 offer，那完全可以选择其他公司（某滴、某米、某团）的核心部门。毕竟选择一家公司，不能只看公司的名气、薪酬，还要看当你哪天离开这家公司的时候，你自己成长了多少，个人感觉，这个才是最重要的，在大公司当螺丝钉，也只有在大公司这个环境下你才有价值，一旦离开这个大环境，你能选择的就很少了，所以，应该把个人能力的提升放在一个比较重要的位置。这里，对于应届生，我是比较推荐这六家公司（国外的公司暂不讨论），一些较小或者偏初期的创业公司，对于应届生来说，还是要谨慎一些好。还有就是哪些处在风口的企业，也要慎重，哪些公司估值泡沫很大，而且明显让人感觉的是：哇塞，今年这家公司开的好高，但是明年开高公司又变成了另外一家，所以还是要慎重，在找工作的时候，一定要有一个清晰的目标。</p>
<h1 id="急急忙忙校招"><a href="#急急忙忙校招" class="headerlink" title="急急忙忙校招"></a>急急忙忙校招</h1><p>在美团实习了两个月之后，这时候就已经到了九月份，帝都的互联网校招基本上也开始了，记得当时在论坛随便找了一个师兄内推了 X 狐，然后就通知周末去面试，去之前心里是一点都没普，毕竟算法好久没看了，很多东西长时间不看是会忘的，算法就是这样，当时就随便准备了一下就去面试了，结果很出乎意料，在面试之前，看了一些关于 Java 并发、多线程的内容，当时还做了一下总结，写了一篇博客——<a href="http://wangzzu.github.io/2016/08/21/java-concurrency/">Java 并发学习(一)</a>，没想到的是面试官问了很多这方面的内容，虽然二面的时候有一些关于 OOM 调试的问题答的不怎么好，但没过几天 X 狐还是给发了 offer，当时可以说我拿到第一个校招，虽然最后没怎么去，还是很感觉 X 狐能给我这次机会的。</p>
<p>面完 X 狐之后又陆陆续续投一批简历，参加了一批笔试，前面已经说了 BAT 的经历，除了 BAT 之外，其他能投的公司并没有多少，之后参加了某滴的内推笔试，笔试挂，某滴今年招了很多的社招的人，B 家听说有很多人跳到了某滴，阿里正明也去滴滴了，某滴今年真是大热，不过由于发展过快，外面也爆出了很多关于某滴内部管理混乱的问题，最近 zf 又出了一系列政策，导致某滴的日子其实也不好过，今年也能明确感受到某滴校招力度较小，总之，没拿到某滴的面试机会。接着又投了某米，参加了某米的笔试，感觉笔试题做的还是不错的，后来通知去面试，面了某米的互娱事业部，一面聊的还挺好，二面问了一些很基础、平且一般接触不到的问题，比如：Java 泛型的设计有什么不好的地方？问的问题有种说不出来的感觉，当时感觉某米应该是可以过的，结果很尴尬，没有收到 offer。之后由于实习拿过XX街的 offer，所以直接参加了XX街的终面，大神华黎亲自面的（不知道华黎是谁，可以看看这本书<a href="http://item.jd.com/11449803.html" target="_blank" rel="external">《大型网站系统与Java中间件实践》</a>，华黎可是当年阿里中间件核心人物之一），后来顺利拿到了 offer，不过因为其他的一些个人原因，没有选择去，很是抱歉。十月底又顺便水了一把华为的面试，也算是见到了华为的壮观面试场景，三点半的面试，等到了6点才面，一面20min 就结束了，而且面试官跟我做的完全不对口，甚至连 CentOS 都没听说过，接着又等到了七点半开始二面，二面还是一对二同时面（一个面试官同时面两个人），面试问的问题基本上就是 hr 问得那些，后来虽然也收到 offer，但总感觉心里没谱，所以就没去，毕竟华为的声名在外啊，对华为的感觉就是，重点看学校、看学习成绩，按学校级别给工资，基本上一看是好学校差不多的话都会要，进去之后估计是再统一培训，有些人比较喜欢这种，我是不太喜欢这种文化，这也是没选择华为的原因之一。</p>
<p>接着说一下，对今年校招的感觉吧，今年的校招的工资整体要比全年高一个档次，但就业其实并没有去年好，只不过是前面那批人把校招工资拉开了一个档次，当然主要的原因还是今年互联网被华为搅得天翻地覆，谁让华为有钱，而且一招招几千甚至上万人。虽然去年也有一些公司工资开得很高，但招的人太少，影响不了互联网大局。华为就不一样了，招人多，还只招好学校的，还就完全不一样了。在之前，华为都是捡漏的，今年不但薪资高，而且校招还特别早，身边真的有很多人选择了华为放弃了 BAT。听说，当初有人拿到 BAT 其中某家的 offer，因为批发价太低，想谈一下工资，结果人家不给谈，他拿到华为 offer 之后直接就放弃了这家，再后来，这家公司开始给之前放弃 offer 的人打电话，表示工资可以谈，而且还开始补招，真是呵里个呵啊（前面的”他”实际上代表的是他们，泛指很多人）。从今年的情况来看华为的影响力还是相当大的，带动了整个互联网的薪酬水平。如果单纯讨论互联网公司，个人感觉今年首先 A 家招人很少，除了实习生转正和内推，基本上没有校招；B 家招人挺多，可能因为这家公司人员流动性比较大，每年招的人都挺多；T 家不太清楚，感觉跟那边不太对口；美团今年招人还是挺多的，比往年招的力度都要大，公司对于技术还是很重视的；某滴招人也不多，可能是社招人太多还有公司业务发展受限的原因；某米，感觉招人也不少吧，记得某米去年只招了100+人，今年发出的 offer 肯定是比这个高的。互联网公司整体校招力度跟去年比可能稍微差一些，不过由于华为今年突然发力，对于好的学校而言，整体的就业形式并不去年差。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里，推荐一篇文章，黑桃夹克师兄当时找工作的时候写的：<a href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/" target="_blank" rel="external">找工作小记——善待挫折</a>，在拿到美团 offer 之前，我也经历一段很不自信、很沮丧的时段，这篇文章在这段时间给我了很大的鼓励，很感谢师兄分享自己的经历。毕竟像师兄这种能到阿里中间件 offer 的牛人，在找工作的时候也并不是一帆风顺的。</p>
<p>最后，说一下个人的感想，我因为一开始就决定了选择走技术这条路，所以基本上也就没有考虑其他行业、其他职位，这个要看个人的选择和职业规划，技术这条路有它的好处，其坏处也很明显，很容易达到职业瓶颈，这个暂时不是我考虑的问题，实际上做技术的人大都在后来慢慢转到管理、产品、运营，甚至去创业去了，能一直在技术上坚持走下去的人并不多，这也说明了技术这条路充满着艰险，并不如想象中的那么好走，这个完全就看个人后期的职业发展了。</p>
<p>在前行的道路上，我们也应该时常停下来多思考思考，想一下自己想要的是什么、想要的生活是什么样的等，下面一句<a href="http://cnbible.com/hosea/4-6.htm" target="_blank" rel="external">圣经：何西阿书 4章6节</a>中一句话作为结束，也希望所有面临校招的童鞋们都拿到适合自己的 offer。</p>
<blockquote>
<p>我的民因无知识而灭亡。你弃掉知识，我也必弃掉你，使你不再给我作祭司。你既忘了你　神的律法，我也必忘记你的儿女。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[人类简史，一段不知走向何处的简史]]></title>
      <url>http://wangzzu.github.io/2016/10/23/brief-history-of-humankind/</url>
      <content type="html"><![CDATA[<p>陆陆续续从7月份开始读这本书，直到昨天（10月底）才把这本书，拖这么久之后，发现，书中讲的很多东西已忘记的差不多了，也没有刚开始看前几章时那种爱不释手的感觉。只能根据自己一些浅显的记忆以及当时在书中记录的一些笔记来述说一下自己的感悟。</p>
<p><img src="/images/book/brief-history.jpg" alt="人类简史"></p>
<p>当初想要看这本书，是因为这本书被很多大牛们推荐，而且豆瓣也给出了<a href="https://book.douban.com/subject/25985021/" target="_blank" rel="external">人类简史-豆瓣</a> 9.3分的高分，好评如潮，感觉不得不看看这部神作。关于读书这个问题，这段时间也在同时看<a href="https://book.douban.com/subject/26874593/" target="_blank" rel="external">《技巧》</a>和<a href="https://book.douban.com/subject/26761696/" target="_blank" rel="external">《精进》</a>这两本书，这两本书都提到了学习方法、读书的方法论，作者根据自己的实践经验进行的一些总结。我个人的大概的理解是：如果是读过某本书，并没有去仔细思考， 那就是读死书，效率很低，如果能能够尝试着去理解作者的思维逻辑，然后去思考自己有哪些东西可以学习、借鉴或者是可以丰富自己的知识体系，这才是读书的真谛，想着去学习作者的经验，而不是简简单单地把书读完，等把这两本书读完，到时候会详细记录一下自己的感悟。</p>
<p>关于《人类简史》这本书，在阅读时，作者有很多非常新奇的观点，这些观点至少我之前是没有遇到过的（可能书读的少的原因），下面举几个书中的例子</p>
<blockquote>
<p>然而历史的铁则告诉我们，每一种由想象建构出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。——第八章，历史从无正义</p>
<p>一次又一次，人类要让社会有秩序的方法，就是会将成员分成各种想象出来的阶级，像是上等人、平民和奴隶；白人和黑人；贵族和平民；婆罗门和首陀罗；又或是富人和穷人。所有这些阶级，就是要让某些人在法律上、政治上或社会上高人一等，从而规范了数百万人的关系。——第八章，历史从无正义</p>
</blockquote>
<p>历史上很多出现的东西都只是智人的想象而已，比如古代的皇帝、律法等，现代的金钱、经济制度等，只不过都是我们的想象，但是我们所有人都出在和生活在这个想象之中，要是有一个人否定了这个想象，立马就会人神共愤。而且人类总是不断地去完善这个所谓的自然、必然的结果，当资本主义出现问题的时候，智人开始考虑社会主义，它向智人描述了一种乌托邦的生活愿景，但是终究抵不过人性的恶，社会主义也并没有按照智人原来的意愿去发展，反而束缚了智人。</p>
<blockquote>
<p>人类历史在过去一直是由两大周期来主导：植物的生长周期，以及太阳能的变化周期（白天和黑夜，夏季和冬季）。 ——第十七章 工业的巨轮<br>在水煮沸的那一刻，水壶或锅的盖子会开始跳上跳下。这时热能转换为动能，但是我们过去都只觉得这样乱跳有点烦人，至于一时忘记而让水煮干就更麻烦了。没人注意到这件事的真正潜力。<br>蒸汽机种类繁多，但有一个共同的原则：燃烧某种燃料（例如煤），再用产生的热将水煮沸，产生蒸汽。<br>工业革命的核心，其实就是能源转换的革命。<br>学习如何有效驾驭和转换能量之后，也解决了另一个阻碍经济成长的问题：原料短缺。 ——第十七章 工业的巨轮</p>
</blockquote>
<p>对于作者的这种想法，我当时是感到很震惊的，感觉很能刷新我的认知，工业革命对人类可以是具有划时代的重要历史事件，在作者看来，其本质就是能量的转变，之前的能量变化过程是：植物吸收太阳能，将太阳能转换为食物的能量，人类或者牛拿到这部分能量之后，再来干别的事情（人类的活动、牛耕地等活动），进行能量转换。而工业革命之后的过程是：煤（动植物存储的能量）的能量转换动能（蒸汽机），动能再进行转换，这极大地提高了智人利用能源的方式，在这个基础上，智人开始利用蒸汽机技术进行航海、火车、工厂等活动。关于最后一句，可以这样理解，人类可以利用的能源暂时可以说无穷尽的，现在还有很多已知的能量我们还不能高效地利用，更别提还有很多未知的、潜在的能量了，在不同的阶段人类利用能量的方式也不一样。举个例子：人类现在每年消耗的能量总和，地球只需要短短90分钟就可以从太阳接收这么多能量，所以对于人类来说，能量是无穷尽的，只是我们暂时还不能高效地去获取或利用这些能量。</p>
<p>文章中有很多类似的观点，包括后来金钱的由来、宗教的发展等，作者站在一个更高的地方去看待整个历史进程，而不是单纯地从历史、文化等角度，向读者展示了一个不同的视角。下面引用一段豆瓣中的内容简介</p>
<blockquote>
<p>十万年前，地球上至少有六种不同的人<br>但今日，世界舞台为什么只剩下了我们自己？<br>从只能啃食虎狼吃剩的残骨的猿人，到跃居食物链顶端的智人，<br>从雪维洞穴壁上的原始人手印，到阿姆斯壮踩上月球的脚印，<br>从认知革命、农业革命，到科学革命、生物科技革命，<br>我们如何登上世界舞台成为万物之灵的？<br>从公元前1776年的《汉摩拉比法典》，到1776年的美国独立宣言，<br>从帝国主义、资本主义，到自由主义、消费主义，<br>从兽欲，到物欲，从兽性、人性，到神性，<br>我们了解自己吗？我们过得更快乐吗？<br>我们究竟希望自己得到什么、变成什么？</p>
</blockquote>
<p>可以说，《人类简史》这本书就是围绕着上述问题来讲述的，作者使用很多假设、推断去思考这些问题，虽然并不一定完全准确，但对很多的问题的分析表达的逻辑都很清晰，这是这本书的牛X 之处。</p>
<p>在人类历史之初，这个世界应该是有很多的人种，但到最后只剩下智人一种，其他的人类种族都已经从这个世界上消失，这是什么原因，如果说这是自然灾害或是其他的原因，肯定不能使人信服。而且这些种族的灭绝都是在智人到达他们的居住地之后发生的，这就不得不使人相信：因为食物的争夺，智人消灭了他们或者是同化了他们，在那个时代，争夺食物实际上就是让自己或自己族群活下去的唯一办法，也只有达尔文的进化论能够解释通这种现象——适者生存，但是这到底是正确的还是错误的？到现在我们依然没有答案，当然如果说这个理论是合理的或是合法的，智人现在就可以肆无忌惮杀害其他物种，甚至可以可以杀害不适的智人，所以，有一点是确定的，现代达尔文主义是错误的，甚至比纳粹还要可怕，这不是人类想要的结果。</p>
<p>智人从一开始消灭其他人种，爬上食物链顶端，可以说认知革命的结果，认知革命让智人开始拥有智慧，智人可以以族群进行生活，建立社群，为了生活大家一起合作。虽然智人人口的增加了，时间一长，又发生了农业革命，智人不再经常去迁徙，而是在一个地方固定居住下来，开始种植植物、训练动物，逐步出现了村落、城市、国家，而随着这些概念的出现，又开始出现了法律、制度以及非农业人员，到最后出现国王等，现在看起来很容易理解过程，但是智人走了近十万年。从十万年前智人开始出现，到5000年前世界上第一个国家开始出现，这中间足足有十万年。</p>
<p>再看一下制度的发展，从公元前1776年的《汉摩拉比法典》，到1776年的美国独立宣言，这中间又走了三千多年。这三千年，智人从最初的一个国家雏形到最后建立一个真正意义的现代国家。在最初的农业社会，智人都是以家庭或者社群为单位生活，甚至金融、养老、处罚等都是以家庭为单位进行，几千年来都是这样，甚至中国现在一些落后的农村仍然是这样（指的是金融和养老这部分，关于这方面，可以参考陈志武老师的书）。但后来自从国家、市场的概念出来以后，就不断冲击着传统的以家庭为社会单位的地位，当然这是工业革命为整个人类带来的巨大变化。工业革命的发展，更加强化了国家、市场这些概念，甚至也驱使了后来的大航海时代、一战、二战等。似乎这几千年来，智人取得了非常巨大的成就，甚至随着现代科技的发展，尤其是现代基因工程，智人开始干预造物主的工作。但是，从开始的社群主义、帝国主义、资本主义到自由主义和消费主义，以及智人从兽欲，到物欲，从兽性、人性，到神性，智人是否了解自己？智人过得到底快乐吗？</p>
<p>关于这点，我们先看一下佛教是如何解释的</p>
<blockquote>
<p>人想要离苦得乐，就必须了解自己所有的主观感受都只是一瞬间的波动，而且别再追求某种感受。如此一来，虽然感受疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明、自在。这样产生的心灵平静力量强大，那些穷极一生疯狂追求愉悦心情的人完全难以想象。</p>
</blockquote>
<p>佛教与现代生物学和新世纪运动的相同点，在于都认定快乐不在于外在条件。但佛教更重要也更深刻的见解在于，真正的快乐也不在于我们的主观感受。我们如果越强调主观感受，反而就越感到苦。佛教给我们的建议是，除了别再追求外在成就之外，同时也别再追求那些感觉良好的心里感受了。但现代的自由主义则劝我们去追求内心想要的东西，但我们内心到底想要什么？恐怕智人到现在也不清楚自己自己到底想要什么？</p>
<p>最后引用本书的后记作为结尾。</p>
<blockquote>
<p>变成神的这种动物</p>
<p>在7万年前，智人还不过是一种微不足道的动物，在非洲的角落自顾自地生活。但就在接下来的几千年间，智人就成了整个地球的主人、生态系统的梦魇。时至今日，智人似乎只要再跨一步就能进入神的境界，不仅有望获得永恒的青春，更拥有创造和毁灭一切的神力。</p>
<p>但遗憾的是，智人在地球上的所作所为，实在没有太多令人自豪。虽然我们主宰了环境、增加了粮食产量、盖起城市、建立帝国，还创造了无远弗届的贸易网络，但全球的痛苦减少了吗？一次又一次，虽然整体人类的能力大幅提升，但却不一定能改善个别人类的福祉，而且常常还让其他动物深受其害。</p>
<p>在过去的几十年间，至少就人类的生存条件而言有了确实的进步，饥荒、瘟疫和战争都已减少。然而，其他动物的生存条件却是以前所未有的速度急遽恶化，而且就算是人类相关的改进，也还需要再长时间观察才能判断是否利大于弊，是否能够延续。</p>
<p>此外，虽然现在人类已经拥有许多令人赞叹的能力，但我们仍然对目标感到茫然，而且似乎也仍然总是感到不满。我们的交通工具已经从独木舟变成帆船、变成汽船、变成飞机，再变成航天飞机，但我们还是不知道自己该前往的目的地。我们拥有的力量比以往任何时候都更强大，但几乎不知道该怎么使用这些力量。更糟糕的是，人类似乎也比以往任何时候更不负责。我们让自己变成了神，而唯一剩下的只有物理法则，我们也不用对任何人负责。正因如此，我们对周遭的动物和生态系统掀起一场灾难，只为了寻求自己的舒适和娱乐，但从来无法得到真正的满足。</p>
<p>拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫过于如此了。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[json 对象添加 double 型数值遇到的问题]]></title>
      <url>http://wangzzu.github.io/2016/10/15/json-kafka-bug/</url>
      <content type="html"><![CDATA[<p>这是一个关于修改 Kafka 源码时遇到的一个 bug，以及后续引起的一些思考。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我们的目标是将 Kafka 中的 <code>Producer</code> 和 <code>Consumer</code> 客户端提供的 metrics，写入到一个 Json 对象中，然后再将这个 Json 对象通过 Http 请求发送到一个 service 服务上。</p>
<p>Kafka 原生提供的 metrics 信息非常多，这些 metrics 信息的大概内容如下图所示。</p>
<p><img src="/images/kafka/kafka-metrics.png" alt="Client Metrics"></p>
<p>在使用下面代码将 metrics 写入到 json 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Map.Entry&lt;MetricName, ? extends Metric&gt; metricEntry : metrics.entrySet()) &#123;</div><div class="line">	jsonObject.put(metricEntry.getKey().toString(),metricEntry.getValue().value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这部分是直接添加到 <code>kafka-client</code> 中的，将 <code>kafka-client</code> 打包后，再依赖这个 jar 包，client 在启动时就报了错误，但是并没有退出。</p>
<h1 id="原因查找"><a href="#原因查找" class="headerlink" title="原因查找"></a>原因查找</h1><p>刚开始以为json 对象的大小超出了 Http 协议中的长度限制，因为重写了 <code>MetricName</code> 类的 <code>toString()</code> 方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toFlitString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"MetricName [name="</span> + name + <span class="string">", group="</span> + group + <span class="string">", tags="</span> + tags + <span class="string">"]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将长度过长而且用途不大的 <code>description</code> 字段去掉，但是结果依然，并没有解决问题。</p>
<p>接下来为了想知道是往 json 对象添加 metrics 这部分是否执行，因此在 <code>for</code> 循环内添加了一行输出，最后发现输出十行后程序就不再输出，这一行的内容如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Key: MetricName [name=request-latency-max, group=consumer-node-metrics, description=, tags=&#123;client-id=consumer-1, node-id=node-2&#125;]	Value: -Infinity</div></pre></td></tr></table></figure>
<p>这时候发现了 <code>-Infinity</code> 这个值，参考这篇文章 <a href="http://www.cnblogs.com/zhisuoyu/archive/2016/03/24/5314541.html" target="_blank" rel="external">java中的NAN和INFINITY</a>，才知道这是一个特殊的值，所以就怀疑是这个问题，因此，写了一个小测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.meituan.kafka.json;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.json.JSONObject;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by wangmeng on 15/10/2016.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</div><div class="line">        jsonObject.put(<span class="string">"name"</span>,<span class="string">"matt"</span>);</div><div class="line">        jsonObject.put(<span class="string">"age"</span>,<span class="number">24</span>);</div><div class="line">        jsonObject.put(<span class="string">"double"</span>,<span class="number">10</span>/<span class="number">0.0</span>);</div><div class="line">        System.out.println(jsonObject.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序结果真是报错，报错内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; org.json.JSONException: JSON does not allow non-finite numbers.</div><div class="line">	at org.json.JSONObject.testValidity(JSONObject.java:1578)</div><div class="line">	at org.json.JSONObject.put(JSONObject.java:1291)</div><div class="line">	at org.json.JSONObject.put(JSONObject.java:1220)</div><div class="line">	at com.meituan.kafka.json.JsonTest.main(JsonTest.java:13)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>
<p>因此，查看了一下 <code>org.json.JSONObject.testValidity</code> 源码，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Put a key/value pair in the JSONObject. If the value is null, then the</div><div class="line"> * key will be removed from the JSONObject if it is present.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key</div><div class="line"> *            A key string.</div><div class="line"> * <span class="doctag">@param</span> value</div><div class="line"> *            An object which is the value. It should be of one of these</div><div class="line"> *            types: Boolean, Double, Integer, JSONArray, JSONObject, Long,</div><div class="line"> *            String, or the JSONObject.NULL object.</div><div class="line"> * <span class="doctag">@return</span> this.</div><div class="line"> * <span class="doctag">@throws</span> JSONException</div><div class="line"> *             If the value is non-finite number or if the key is null.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">put</span><span class="params">(String key, Object value)</span> <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null key."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">        testValidity(value);</div><div class="line">        <span class="keyword">this</span>.map.put(key, value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.remove(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Throw an exception if the object is a NaN or infinite number.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> o</div><div class="line"> *            The object to test.</div><div class="line"> * <span class="doctag">@throws</span> JSONException</div><div class="line"> *             If o is a non-finite number.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testValidity</span><span class="params">(Object o)</span> <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double) &#123;</div><div class="line">            <span class="keyword">if</span> (((Double) o).isInfinite() || ((Double) o).isNaN()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(</div><div class="line">                        <span class="string">"JSON does not allow non-finite numbers."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Float) &#123;</div><div class="line">            <span class="keyword">if</span> (((Float) o).isInfinite() || ((Float) o).isNaN()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(</div><div class="line">                        <span class="string">"JSON does not allow non-finite numbers."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查到这里，找到了具体的原因，对 <code>Double</code> 类型的对象，其值不能为 <code>NAN</code> 和 <code>INFINITY</code>，下面再看一下这个两个值在 java 中是如何定义的，对于 double 型的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Double</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding the positive infinity of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equal to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff0000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding the negative infinity of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equal to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0xfff0000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY = -<span class="number">1.0</span> / <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A constant holding a Not-a-Number (NaN) value of type</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125;. It is equivalent to the value returned by</div><div class="line">     * &#123;<span class="doctag">@code</span> Double.longBitsToDouble(0x7ff8000000000000L)&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</div><div class="line">    .....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，对于这个问题，我们已经完整地解决了，并且也查找到了最终的原因。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>之前的文章，总是会写<code>写在前面</code>这一章，本文写了一章<code>写在最后</code>。</p>
<p>这本是一个 bug，实际上并没必要写成一篇文章进行分析，而我这样做的原因是：告诉自己，或者是提醒自己，遇到问题，不但要想着解决问题，还要深入理解这个问题产生的原因。</p>
<p>以前自己在开发中，遇到过很多的坑，很多坑，找到解决办法之后就过去了，后来好久之后再遇到这个问题时，结果还需要花一些时间去查找，一个是自己的记性确实不是太好，另一个当时并没有对遇到的问题深入剖析，把问题的内部原因详细记录下来，希望这篇文章是一个起点，以后博客中，不但要有总结性的文章、思考性的文章，还要有一些详细剖析 bug 的文章。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM 学习——垃圾收集器与内存分配策略]]></title>
      <url>http://wangzzu.github.io/2016/09/18/jvm-basic2/</url>
      <content type="html"><![CDATA[<p>本文主要是对《深入理解java虚拟机 第二版》第三章部分做的总结，文章中大部分内容都来自这章内容，也是博客 JVM 学习的第二部分。</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>说到垃圾收集（Garbage Collection，GC），很多人可能会认为这是 Java 自有的特性，曾经我也一度这样想，后来才知道 GC 的历史要远远长于 Java，它第一次真正使用是在 Lisp 中，现在，像 python、go 等都有自己的垃圾收集器。在 GC 最开始设计时，人们在思考 GC 时就需要完成三件事情：</p>
<ol>
<li>哪些内存需要进行回收？</li>
<li>什么时候对这些内存进行回收？</li>
<li>如何进行回收？</li>
</ol>
<p>经过将近半个多世纪的发展，内存的动态分配与垃圾回收技术现在已经非常成熟，看起来是进入半自动化时代，但是我们依然需要去学习 GC 和内存分配，因为，当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这一块进行必要的监控和调节。</p>
<p>回到 Java 语言，在前面介绍的 Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不絮地执行着出栈和入栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此，这几块区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分的内存和回收都是动态的，垃圾回收器主要关注的也是这部分的内存。</p>
<h1 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h1><p>Java 的堆里存放的几乎所有的对象实例，在进行垃圾回收前，第一件事情就是要确定哪些对象还”存活”着、哪些对象已经”死去”（即不可能再被任何途径使用的对象）。</p>
<h2 id="判断的方法"><a href="#判断的方法" class="headerlink" title="判断的方法"></a>判断的方法</h2><h3 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
  </p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>基本思想：通过一系列的称为 <strong>GC Roots</strong> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain)，当一个对象到GC Roots没有任何引用链时，则证明此对象是不可用的。</p>
<p>在 Java 中，可作为 GC Roots 的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
</ol>
<h3 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h3><table>
<thead>
<tr>
<th></th>
<th>引用计数法</th>
<th>可达性分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>实现简单，效率高（很少使用这种方法）</td>
<td>在主流的商业程序语言（Java、C#等）的主流实现中，都使用这种方法</td>
</tr>
<tr>
<td>缺点</td>
<td>无法解决对象之间相互循环引用问题（主流的 JVM 都没有使用这种方法）</td>
<td>实现稍微有些复杂</td>
</tr>
</tbody>
</table>
<h2 id="对象的四种引用"><a href="#对象的四种引用" class="headerlink" title="对象的四种引用"></a>对象的四种引用</h2><p>在 Java 中，如果仅仅把对象分为引用和没有被引用这两种状态，那么在一些场景下就无能为力了，比如：我们希望有这样一类对象，当内存空间充足时，则能保留在内存之中，而如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。因此，在 JDK1.2 之后，Java 就对引用的概念进行了扩充，将引用非为一下四种：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>定义</th>
<th>声明方式</th>
<th>回收条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用（ Strong Reference）</td>
<td>强引用就是指在程序代码之中普遍存在的</td>
<td>类似于<code>Object obj= new Object()</code> 这类的引用</td>
<td>只要强引用还在，永不会回收</td>
</tr>
<tr>
<td>软引用（ Soft Reference）</td>
<td>软引用是用来描述一些还有用但并非必需的对象</td>
<td>使用<code>SoftReference</code> 类来声明</td>
<td>系统将要发生内存溢出异常之前，将会把这些对象列入回收范围，进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</td>
</tr>
<tr>
<td>弱引用（ Weak Reference）</td>
<td>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些</td>
<td>使用 <code>WeakReference</code> 类实现弱引用</td>
<td>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</td>
</tr>
<tr>
<td>虚引用（WeakReference）</td>
<td>它是最弱的一种引用关系，一个引用是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</td>
<td>使用<code>PhantomReference</code> 类来实现虚引用</td>
<td>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</td>
</tr>
</tbody>
</table>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法；</li>
<li>当对象没有覆盖 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被虚拟机调用过，虚拟机将这两种情况都视为<strong>没有必要执行</strong>；</li>
<li>如果对象要在 <code>finalize()</code> 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。 任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次。</li>
</ol>
<p>这里有两点要注意：</p>
<ol>
<li>如果一个对象被判定有必要执行 <code>finalize()</code> 方法，那这个对象会先被放置在一个叫做 <code>F-Queue</code> 的队列中，并由虚拟机自动建立的、低优先级的 <code>Finalizer</code> 线程去执行它。这里的 “执行” 指的是虚拟机会触发这个方法，但不会承诺等待它运行结束，原因是：如果一个对象在执行 <code>finalize()</code> 时运行缓慢，或者发生死循环，将很有可能导致 <code>F-Queue</code> 队列中其他对象永久处于等待，甚至整个内存回收系统崩溃。</li>
<li>不鼓励大家使用这种方法来拯救对象。相反，建议大家尽量避免使用它，因为它不是 C/ C++ 中的析构函数，而是 Java 刚诞生时为了使 C/ C++ 程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 关闭外部资源，使用 <code>try- finally</code> 或者其他方式都可以做得更好、更及时，所以笔者大家完全可以忘掉 Java 语言中有这个方法的存在。</li>
</ol>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（或者 HotSpot 的永久代）是没有垃圾收集的，Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价” 一般比较低。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<p>判断一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻很多。类需要同时满足下面 3 个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收；</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收；</li>
<li>该类对应的 <code>java. lang. Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>是否对类进行回收， HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose: class</code> 以及 <code>-XX:+ TraceClassLoading</code>、<code>- XX:+ TraceClassUnLoading</code> 查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、 CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>本节主要是介绍一下垃圾收集算法的思想，并不涉及具体的实现。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法，有两个阶段</p>
<ol>
<li>首先标记所有需要回收的对象；</li>
<li>在标记完成后统一进行回收。</li>
</ol>
<p>执行过程如下图所示。</p>
<p><img src="/images/java/jvm/mark-sweep.png" alt="mark-sweep"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p>算法执行过程如下图所示</p>
<p><img src="/images/java/jvm/copy.png" alt="copy"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor[ 1]。 当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<p>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8: 1。 当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（ Handle Promotion）。 如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-整理算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>算法执行过程如下图所示</p>
<p><img src="/images/java/jvm/mark-compact.png" alt="mark-compact"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用分代收集（ Generational Collection） 算法。</p>
<p>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</li>
</ul>
<h2 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h2><table>
<thead>
<tr>
<th>算法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记-清除</td>
<td>最基础的算法，不是一般的简单</td>
<td>一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片</td>
</tr>
<tr>
<td>复制</td>
<td>实现简单，运行高效</td>
<td>减少了内存使用空间；而且在对象存活率较高时需要进行较多的复制操作（不适合老年代）</td>
</tr>
<tr>
<td>标记-整理</td>
<td>根据老年代的特点提出的一种算法，适合老年代</td>
<td>只适合于某些特定情况</td>
</tr>
<tr>
<td>分代收集</td>
<td>使用多种收集算法，根据各自的特点选用不同的收集算法</td>
<td>在具体的实现上比前面的更加复杂</td>
</tr>
</tbody>
</table>
<h1 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h1><p>上面介绍的基础的理论，这一节讲述一下 HotSpot 虚拟机如何实现这些算法的。</p>
<h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的的。</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>在 OopMap 的协助下， HotSpot 可以快速且准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得更高。</p>
<p>实际上，HotSpot 并没有为每条指令都生成 OopMap，而只是在 “特定的位置” 记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在达到安全点时才能暂停。</p>
<p>Safepoint 的选定既不能太少以至于让 GC 等待时间太长，也不能多余频繁以至于过分增大运行时的负载。所以，安全点的选定基本上是以 “是否具有让程序长时间执行的特征” 为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，”长时间执行” 的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。</p>
<p>对于 Safepoint， 另一个需要考虑的问题是如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都“跑”到最近的安全点上再停顿下来： 抢先式中断（ Preemptive Suspension） 和主动式中断（ Voluntary Suspension）</p>
<ol>
<li>抢占式中断：它不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它 “跑” 到安全点上。</li>
<li>主动式中断：当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ol>
<p>现在<strong>几乎没有虚拟机采用抢占式中断来暂停线程从而响应 GC 事件</strong>。</p>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>在使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题，但实际上情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但如果程序在 “不执行” 的时候呢？所谓程序不执行就是没有分配 CPU 时间，典型的例子就是处于 Sleep 状态或者 Blocked 状态，这时候线程无法响应 JVM 的中断请求，JVM 也显然不太可能等待线程重新分配 CPU 时间。对于这种情况，就需要<strong>安全区域（Safe Regin）</strong>来解决了。</p>
<p>在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾收集器是内存回收的具体实现，这里讨论的收集器是 JDK 1.7 Update 14 之后的 HotSpot 虚拟机（目前 G1 仍然处于实验状态），这个虚拟机包含的所有收集器如下图所示。</p>
<p><img src="/images/java/jvm/hotspot.png" alt="hotspot"></p>
<p>下面会介绍一下这几种收集器的特性、基本原理和使用场景，并重点分析 CMS 和 G1 这两个相对复杂的收集器，了解它们的部分运作细节。</p>
<blockquote>
<p>注：这里只是介绍这些收集器，进行一下比较，但并非是挑选一个最好的收集器，目前到现在为止还没有最好的收集器出现，更没有万能的收集器，我们只是选择对具体应用最合适的收集器。</p>
</blockquote>
<h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>它曾是最基本、发展历史最悠久的收集器，它是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会是使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。<strong>Stop The World</strong> 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图展示了 Serial/Serial old 收集器的运行过程。</p>
<p><img src="/images/java/jvm/serial.png" alt="serial"></p>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。ParNew/Serial old 收集器的运行过程如下图所示</p>
<p><img src="/images/java/jvm/parnew.png" alt="ParNew"></p>
<p>ParNew 收集器除了多线程收集之外，其他与 Serial 收集器相比并没有太多创新之处，但它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。（CMS收集器第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。）</p>
<p>CMS 作为老年代的收集器，却无法与 JDK 1. 4. 0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，只能选择ParNew或者Serial收集器中的一个。ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 选项后的默认新生代收集器，也可以使用 <code>-XX:+UseParNewGC</code> 选项来强制指定它。</p>
<p>由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。但是，当 CPU 的数量增加时，它对于 GC 时系统资源的有效利用还是很有好处的，它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（使用超线程时）的环境下，可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。</p>
<h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>它与其他收集器的不同之处在于：它的关注点与其他收集器不同。CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（ Throughput）。</p>
<blockquote>
<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
</blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量：</p>
<ol>
<li>控制最大垃圾收集停顿时间， <code>-XX:MaxGCPauseMillis</code>，设置时间小一点并不能使用系统的收集速度更快，因为 GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的；</li>
<li>直接设置吞吐量大小， <code>-XX:GCTimeRatio GC</code>，CTimeRatio是指垃圾收集时间占总时间的比率。</li>
</ol>
<p>Parallel Scavenge 收集器经常称为 “吞吐量优先” 收集器。Parallel Scavenge 收集器还提供一个参数 <code>-XX:+ UseAdaptiveSizePolicy</code>，当这个参数打开后，就不需要收工指定一些细节参数了（如：新生代的大小等），虚拟机会动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为<strong>GC 自适应的调解策略（GC Ergonomics）</strong>。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>
<h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 “标记-整理” 算法。</p>
<p>这个收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，那么它主要还有两大用途：</p>
<ol>
<li>在 JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用；</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ol>
<p>Serial Old 收集器的工作过程如下图所示</p>
<p><img src="/images/java/jvm/serial.png" alt="serial"></p>
<h2 id="Parallel-old-收集器"><a href="#Parallel-old-收集器" class="headerlink" title="Parallel old 收集器"></a>Parallel old 收集器</h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理” 算法。 这个收集器是在 JDK 1. 6 中才开始提供的。在此之前，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（ PS MarkSweep） 收集器外别无选择（还记得上面说过 Parallel Scavenge 收集器无法与 CMS 收集器配合工作吗？）。由于老年代 Serial Old 收集器在服务端应用性能上的拖累，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。</p>
<p>知道 Parallel old 收集器出现后，”吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel old 收集器，Parallel old 收集器的工作过程如下图所示</p>
<p><img src="/images/java/jvm/parallelold.png" alt="Parallel Old"></p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间为目标，多数应用于互联网站或者B/S系统的服务器端上。</p>
<p>CMS 是基于 “标记—清除” 算法实现的，整个过程分为4个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>有以下几个特点：</p>
<ul>
<li>其中，初试标记、重新标记这两个步骤仍然需要 “Stop The World”；</li>
<li>初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快；</li>
<li>并发标记阶段就是进行 GC Roots Tracing 的过程；</li>
<li>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初试标记阶段稍长一些，但远比并发标记的时间短。</li>
</ul>
<p>CMS 收集器的运作步骤如下图所示，在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="/images/java/jvm/cms.png" alt="cms"></p>
<ul>
<li>优点<ol>
<li>并发收集、低停顿， Sun 公司的一些官方文档中也称之为并发低停顿收集器（ Concurrent Low Pause Collector）。</li>
</ol>
</li>
<li>缺点<ol>
<li>CMS 收集器对 CPU 资源非常敏感。</li>
<li>CMS 收集器无法处理浮动垃圾（ Floating Garbage），可能出现 “Concurrnet Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 <code>-XX: CMSInitiatingOccupancyFraction</code> 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。要是 CMS 运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 <code>-XX: CM SInitiatingOccupancyFraction</code> 设置得太高很容易导致大量” Concurrent Mode Failure” 失败，性能反而降低。</li>
<li>收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次 Full GC。CMS 收集器提供了一个 <code>-XX:+UseCMSCompactAtFullCollection</code> 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
</ol>
</li>
</ul>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>  G1 是一款面向服务器应用垃圾收集器，与其他GC收集器想必，G1具备以下特点：</p>
<ol>
<li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短 Stop The World 停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1 收集器仍然可以通过并发的方式让Java程序继续执行；</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一半时间、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：与CMS的 “标记-清理” 算法不同，G1从整体上看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间)上来看是基于“复制”算法实现，无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。</li>
<li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，小号在垃圾收集上的时间不能超过N毫秒，这几乎已经是实时Java(RTSJ）的垃圾收集器的特征了。<br>  <br>下图展示 G1 收集器的运行步骤</li>
</ol>
<p><img src="/images/java/jvm/g1.png" alt="G1"></p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记（Initial Marking）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短；</li>
<li>并发标记（Concurrent Marking）：从 GC Roots 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行；</li>
<li>最终标记（Final Marking）：最终标记则是为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行；</li>
<li>筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划，根据 Sun 公司透露的信息来看，这个阶段是可以做到与用户程序并发执行。</li>
</ol>
<h2 id="垃圾收集器对比"><a href="#垃圾收集器对比" class="headerlink" title="垃圾收集器对比"></a>垃圾收集器对比</h2><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>特性</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial 收集器</td>
<td>复制算法；单线程；新生代；简单而高效；需要进行 stop the world。</td>
<td>它是虚拟机运行在 Client 模式下的默认新生代收集器</td>
</tr>
<tr>
<td>ParNew 收集器</td>
<td>复制算法；Serial 的多线程版本；新生代；默认的线程数与 CPU 数一致</td>
<td>它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。</td>
</tr>
<tr>
<td>Parallel Scavenge 收集器</td>
<td>复制算法；并行多线程；新生代；吞吐量优先原则；有自适应调节策略</td>
<td>适合后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Serial Old 收集器</td>
<td>标记-整理算法；老年代；单线程；</td>
<td>这个收集器的主要意义在于给 Client 模式下的虚拟机使用</td>
</tr>
<tr>
<td>Parallel Old 收集器</td>
<td>标记-整理；老年代；多线程；与 parallel scavenge 收集器结合实现吞吐量优先</td>
<td>与 Parallel Scavenge 结合使用，适用那些注重吞吐量以及对 CPU 资源敏感的场合</td>
</tr>
<tr>
<td>CMS 收集器</td>
<td>标记-清除；老年代；并发收集、低停顿；有三个缺点（参见上面）</td>
<td>非常适合那些重视响应速度，希望系统停顿时间最短的应用</td>
</tr>
<tr>
<td>G1 收集器</td>
<td>分代收集；空间整合；可预测的停顿</td>
<td>面向服务器应用垃圾收集器</td>
</tr>
</tbody>
</table>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseSerialGC</td>
<td>Jvm运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>打开此开关后，使用ParNew + Serial Old的收集器进行垃圾回收</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>使用ParNew + CMS + Serial Old的收集器组合进行内存回收，Serial Old作为CMS出现“Concurrent Mode Failure”失败后的后备收集器使用。</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>Jvm运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>使用Parallel Scavenge + Parallel Old的收集器组合进行回收</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Subrvivor = 8:1</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄，每次Minor GC之后，年龄就加1，当超过这个参数的值时进入老年代</td>
</tr>
<tr>
<td>-XX:UseAdaptiveSizePolicy</td>
<td>动态调整java堆中各个区域的大小以及进入老年代的年龄</td>
</tr>
<tr>
<td>-XX:+HandlePromotionFailure</td>
<td>是否允许新生代收集担保，进行一次minor gc后, 另一块Survivor空间不足时，将直接会在老年代中保留</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>设置并行GC进行内存回收的线程数</td>
</tr>
<tr>
<td>-XX:GCTimeRatio GC</td>
<td>时间占总时间的比列，默认值为99，即允许1%的GC时间，仅在使用Parallel Scavenge 收集器时有效</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间，在Parallel Scavenge 收集器下有效</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值为68%，仅在CMS收集器时有效，-XX:CMSInitiatingOccupancyFraction=70</td>
</tr>
<tr>
<td>-XX:+UseCMSCompactAtFullCollection</td>
<td>由于CMS收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在CMS收集器时有效</td>
</tr>
<tr>
<td>-XX:+CMSFullGCBeforeCompaction</td>
<td>设置CMS收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与UseCMSCompactAtFullCollection参数一起使用</td>
</tr>
<tr>
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型优化</td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>是否关闭手动System.gc</td>
</tr>
<tr>
<td>-XX:+CMSParallelRemarkEnabled</td>
<td>降低标记停顿</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小不可设置过大，会影响Perm的大小，-XX:LargePageSizeInBytes=128m</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>告诉虚拟机在发送垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配情况</td>
</tr>
</tbody>
</table>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>本节主要探讨给对象分配内存的部分，对象主要分配在新生代的 Eden 区上，少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，取决于使用的哪种垃圾收集器组合以及 jvm 的参数设置。下面会介绍几条最普遍的内存分配规则。</p>
<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。</p>
<ol>
<li>新生代 GC（ Minor GC）： 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>老年代 GC（ Major GC/ Full GC）： 指发生在老年代的 GC， 出现了 Major GC， 经常会伴随至少一次的 Minor GC（ 但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。 Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li>
</ol>
<p>堆空间分配例子：</p>
<p><code>-verbose: gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails -XX:SurvivorRatio=8</code></p>
<p>在运行时通过 <code>-Xms20M</code>、<code>-Xmx20M</code>、<code>-Xmn10M</code> 这 3 个参数限制了 Java 堆大小为 20MB， 不可扩展，其中 10MB 分配给新生代，剩下的 10MB 分配给老年代。<code>-XX:SurvivorRatio=8</code> 决定了新生代中 Eden 区与一个 Survivor 区的空间比例是 8: 1</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>大对象对虚拟机的内存分配来说是一个坏消息（）遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”它们。</p>
<p><code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配（避免了在 Eden 以及两个 Survivor 区之间发送大量的内存复制）。 <code>PretenureSizeThreshold</code> 参数只对 Serial 和 ParNew 两款收集器有效， Parallel Scavenge 收集器不认识这个参数。</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。 对象在 Survivor 区中每熬过一次 Minor GC， 年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX: MaxTenuringThreshold</code> 设置。</p>
<h2 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h2><p>为了适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 <code>MaxTenuringThreshold</code> 才能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。当大量对象在 Minor GC 后仍绕存活，就需要老年代进行空间分配担保，把 Survivor 无法容纳的对象直接进入老年代。如果老年代的判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次 Full GC。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1472975542&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">深入理解java虚拟机</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM学习——java 内存区域与内存溢出分析]]></title>
      <url>http://wangzzu.github.io/2016/09/07/jvm-basic1/</url>
      <content type="html"><![CDATA[<p>本文主要是对《深入理解java虚拟机 第二版》第二章部分做的总结，文章中大部分内容都来自这章内容，之所以记录到博客，是想通过这个过程加深自己的理解，并且方便以后遇到相关问题之后进行查阅。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>Java 虚拟机所管理的内存包括以下几个运行时数据区域，如下图所示。</p>
<p><img src="/images/java/jvm/jvm.png" alt="jvm"></p>
<ul>
<li>线程间共享区域：方法区和堆；</li>
<li>线程间私有区域：虚拟机栈、本地方法栈和程序计数器。</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>特点：</p>
<ol>
<li>它是一块较小的内存空间，可以看出当前线程所执行的字节码的行号指示器；</li>
<li>字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都要靠它完成；</li>
<li>每个线程都有一个自己的计数器，线程之间的计数器互不影响；</li>
<li>JVM多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的；</li>
<li>执行Native方法时，计数器不起作用，职位空缺（null）；</li>
<li>此区域是唯一没有规定OOM的区域。</li>
</ol>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frmae）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表存放了编译期可知的基本数据类型（boolean、byte、char、shot、int、float、long、double）、对象引用（reference 类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>其中，long、double因为长度为64bit，会占用两个Slot，其余的数据类型只占用一个。由此可知局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>虚拟机栈中可能会出现两种异常情况：</p>
<ol>
<li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度.</li>
<li><code>OutOfMemoryError</code>：虚拟机栈动态扩展内存时，无法申请到足够的内存.</li>
</ol>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈作用很相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java Heap 是 jvm 所管理的内存中最大的区域。Java Heap 是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例和数组都在这里分配内存。</p>
<p>Java Heap 是垃圾收集器管理的主要区域，也叫做 GC 堆。其可细分为新生代和老年代，而新生代又可分为Eden 空间、From Survivor 空间和 To Survivor 空间。</p>
<p>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code> 和<code>-Xms</code>控制）。但如果在堆中没有内存完成实例分配，并且也无法再扩展时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>其中，<code>-Xmn</code> 用来控制新生代内存的大小。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>特点</p>
<ol>
<li>线程间共享的内存区域；</li>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li>
<li>当方法区无法满足内存的分配需求时，将抛出 <code>OutOfMemoryError</code> 异常；</li>
</ol>
<h2 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池 Runtime Constant Pool"></a>运行时常量池 Runtime Constant Pool</h2><p>特点</p>
<ol>
<li>属于方法区的一部分，</li>
<li>保存Class文件中描述的符号引用和各种字面量.</li>
<li>因为是方法区的一部分，所以会受到方法区内存的限制，当常量池无法再申请到内存时，抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h2 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存 Direct Memory"></a>直接内存 Direct Memory</h2><ol>
<li>直接内存不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也可能会出现 <code>OutOfMemoryError</code> 异常；</li>
<li>在 JDK 1.4 中新加入了 NIO（<code>New Input/Output</code>），引入 <code>Channel</code> 和 <code>Buffer</code> 的 I/O 方式，它可以用 <code>native</code> 方法申请堆外内存，然后通过 JVM 堆中的 <code>DirectByteBuffer</code> 对象操作这块内存，在一些场景下可以显著提高性能（零拷贝）；</li>
<li>虽然本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。开发者在配置虚拟机参数时，会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使得各个区域总和大于物理内存限制，从而导致动态扩展时出现 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<h1 id="HotSpot虚拟机对象解密"><a href="#HotSpot虚拟机对象解密" class="headerlink" title="HotSpot虚拟机对象解密"></a>HotSpot虚拟机对象解密</h1><p>在了解了JVM 内存的概况之后，这里再介绍一下这些虚拟机内存中的数据的其它细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样设计细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。这里我们以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，深入学习 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java 是一门面向对象的编程语言，在 Java 中无时无刻都有对象被创建出来。在语言层次上，创建对象（例如克隆、反序列化）通常只是一个 <code>new</code> 关键字而已，本小节主要讨论一下对与一个普通的 Java 对象（不包括数组和 Class 对象等）创建的过程是怎样的？</p>
<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>当虚拟机遇到一条 <code>new</code> 指令时，虚拟机会进行以下步骤创建对象。</p>
<ol>
<li>将先去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行响应的类加载过程（这部分本文暂时不涉及）；</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来；</li>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（这步操作保证了对象的实例字段在 Java 代码中可以不赋初值就可以直接使用）；</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象的对象头（Object Header）之中。</li>
</ol>
<p>这些步骤结束之后，对于虚拟机来说，一个新的对象已经产生了，但是从 Java 角度来看，对象创建才刚刚开始，还没有对对象进行初始化操作。</p>
<h3 id="堆内存分配方法"><a href="#堆内存分配方法" class="headerlink" title="堆内存分配方法"></a>堆内存分配方法</h3><p>从上节的第二步中可以看到，虚拟机为新生对象分配内存，相当于把一块固定大小的内存从 Java 堆中划分出来。</p>
<ol>
<li>我们假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式叫做<strong>指针碰撞</strong>（Bump the Pointer）；</li>
<li>如果 Java 堆中的内存不是完整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>空闲列表</strong>（Free List）。</li>
</ol>
<p>选择哪种分配方式由 Java 堆是否完整决定，而 Java 堆是否完整又由所采用的垃圾收集器是否带有<strong>压缩整理</strong>功能决定。</p>
<ul>
<li>在使用 Serial、ParNew 等带有 Compact 过程的收集器时，系统采用的分配算法是指针碰撞；</li>
<li>而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用的是空闲列表。</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在JVM 中，对象创建是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现在给对象 A 分配内存时，指针还没来得及修改，对象 B 又同时使用原来的指针分配内存的情况。对于这个问题，有两种解决方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用 <strong>CAS</strong> 配上失败重试的方式更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 <code>-XX:+/-UseTLAB</code> 参数来设定。</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别是32bit 和64bit，官方称为”Mark Word”。</p>
<blockquote>
<p>注：对象需要存储的运行时数据很多，其实已经超出了32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，因此，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>
</blockquote>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。另外，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据才是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFilds 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充仅仅起着占位符的作用，由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java 堆会先划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="/images/java/jvm/getobject1.png" alt="getobject1"></p>
<p>通过句柄访问的最大好处 reference 中存储的是稳定的句柄地址，在对象被移动（gc 时移动对象非常普遍）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p>
<h3 id="直接地址访问"><a href="#直接地址访问" class="headerlink" title="直接地址访问"></a>直接地址访问</h3><p>使用直接地址访问时，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p>
<p><img src="/images/java/jvm/getobject2.png" alt="getobject2"></p>
<p>使用直接指针访问方式的最大好处就是速度更快，节省了一次指针定位的开销，HotSpot 也是这是使用这种方式实现的。</p>
<h1 id="OOM-调试"><a href="#OOM-调试" class="headerlink" title="OOM 调试"></a>OOM 调试</h1><p>根据前面的介绍，我们知道在 JVM 中，除了程序计数器之后，虚拟机内存的其他几个区域都有发生 OOM 异常的可能，本节会通过一些示例来验证异常发生的场景以及讲述一下如何进行调试。</p>
<h2 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h2><p>Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子中，我们限制 Java 堆的大小为5MB，不可扩展（将堆的最小值 <code>-Xms</code> 参数与最大值 <code>-Xmx</code> 参数设置为一样即可）。JVM 参数设置为 <code>-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError</code>，程序代码如下（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/heap/HeapOOMTest.java" target="_blank" rel="external">HeapOOMTest</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOMTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_NAME = <span class="string">"matt"</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_AGE = <span class="number">18</span>;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = DEFAULT_NAME;</div><div class="line">            <span class="keyword">this</span>.age = DEFAULT_AGE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            persons.add(<span class="keyword">new</span> Person());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: Java heap space</div><div class="line">Dumping heap to java_pid9479.hprof ...</div><div class="line">Heap dump file created [11824236 bytes <span class="keyword">in</span> 0.092 secs]</div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:2245)</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:2219)</div><div class="line">	at java.util.ArrayList.grow(ArrayList.java:242)</div><div class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216)</div><div class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208)</div><div class="line">	at java.util.ArrayList.add(ArrayList.java:440)</div><div class="line">	at heap.HeapOOMTest.main(HeapOOMTest.java:47)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>
<h3 id="示例异常分析"><a href="#示例异常分析" class="headerlink" title="示例异常分析"></a>示例异常分析</h3><p>Java 堆内存的 OOM 异常是实际应用中常见的内存异常情况。当出现 Java 堆内存溢出时，会报错误信息 <code>java.lang.OutOfMemoryError</code>，会跟着进一步提示 <code>Java heap space</code>。</p>
<p>出现这个异常之后，首先需要确定内存中的数据是否是必要，也就是要先分清楚是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<ol>
<li>如果是内存泄露，可进一步通过工具查看泄露对象到 GC Roots 的引用链。于是就能找到对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的，这样就就可以定位出泄露代码的位置；</li>
<li>如果不是内存泄露，需要检查一下虚拟机的参数（<code>-Xmx</code> 与 <code>-Xms</code>），与物理机内存对比看是否还可以调大，然后再检查一下代码，是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>由于在 HotSpot 虚拟机中并不区分虚拟机栈而本地方法栈。因此，对于 HotSpot 来说，虽然 <code>-Xoss</code> 参数（设置本地方法栈大小）存在，但实际上无效的，栈容量只由 <code>-Xss</code> 参数设定。对于虚拟机栈和本地方法栈，在 Java 虚拟机中描述了两种异常：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则将抛出 <code>OutOfMemoryError</code> 异常。</li>
</ol>
<blockquote>
<p>注：这里有一个问题，当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是针对同一件事情两种描述。</p>
</blockquote>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>对单线程的情况，尝试一下两种方法都是获得 <code>StackOverflowError</code> 异常（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/stack/StackTest1.java" target="_blank" rel="external">StackTest1</a>）</p>
<ul>
<li>使用<code>-Xss</code>参数减少栈内存容量。结果：抛出 <code>StackOverflowError</code> 异常，异常出现时输出的栈深度相应减少；</li>
<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出 <code>StackOverflowError</code> 异常时输出的堆栈深度相应减少。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss256k</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</div><div class="line">        stackLength++;</div><div class="line">        stackLeak();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        StackTest1 stackTest1=<span class="keyword">new</span> StackTest1();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            stackTest1.stackLeak();</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">            System.out.println(<span class="string">"stack length: "</span>+stackTest1.stackLength);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.StackOverflowError</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:9)</div><div class="line">stack length: 1868</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</div><div class="line">	at stack.StackTest1.stackLeak(StackTest1.java:10)</div><div class="line">	....</div></pre></td></tr></table></figure>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>根据上面的测试结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是  <code>StackOverflowError</code> 异常。</p>
<h2 id="方法区和运行时常量池异常"><a href="#方法区和运行时常量池异常" class="headerlink" title="方法区和运行时常量池异常"></a>方法区和运行时常量池异常</h2><p>运行时常量池是方法区的一部分。可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 来限制方法区的大小，从而间接限制其中常量池的容量。下面的例子主要讲述一下方法区异常的示例。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，我们的思路是运行时产生大量的类去填满方法区，知道溢出。在我们的示例中，我们借助 CGLib 直接操作字节码运行时生成了大量的动态类（<a href="https://github.com/wangzzu/java_learn/blob/master/jvm/src/main/java/methodarea/JavaMethodAreaOOM.java" target="_blank" rel="external">JavaMethodAreaOOM</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">            enhancer.setSuperclass(OOMObject.class);</div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            enhancer.create();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError: PermGen space</div><div class="line">    Dumping heap to java_pid10480.hprof ...</div><div class="line">    Heap dump file created [10685765 bytes <span class="keyword">in</span> 0.086 secs]</div><div class="line">    Exception <span class="keyword">in</span> thread <span class="string">"main"</span></div><div class="line">    Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler <span class="keyword">in</span> thread <span class="string">"main"</span></div></pre></td></tr></table></figure>
<p>方法区溢出</p>
<ul>
<li>方法区存储类信息，当类过多时，就会导致方法区溢出.</li>
<li>实际应用中，主流框架如Spring、Hibernate（CGLIB）、JSP、OSGi等会动态生成大量Class；而类被回收的判定条件是非常苛刻的.</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1472975542&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">深入理解java虚拟机</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-vm/" target="_blank" rel="external">深入理解java虚拟机 | 极客学院</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库事务性（MySQL 存储引擎及索引结构）]]></title>
      <url>http://wangzzu.github.io/2016/08/31/database-transaction/</url>
      <content type="html"><![CDATA[<h1 id="数据库事务性"><a href="#数据库事务性" class="headerlink" title="数据库事务性"></a>数据库事务性</h1><p>并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</li>
<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ol>
<h2 id="数据库的并发控制"><a href="#数据库的并发控制" class="headerlink" title="数据库的并发控制"></a>数据库的并发控制</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<h3 id="锁的分类-oracle"><a href="#锁的分类-oracle" class="headerlink" title="锁的分类(oracle)"></a>锁的分类(oracle)</h3><ol>
<li>按操作划分，可分为DML锁、DDL锁</li>
<li>按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql）</li>
<li>按锁级别划分，可分为共享锁、排他锁</li>
<li>按加锁方式划分，可分为自动锁、显示锁</li>
<li>按使用方式划分，可分为乐观锁、悲观锁</li>
</ol>
<ul>
<li>DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁));</li>
<li>DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义.</li>
<li>其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</li>
</ul>
<h1 id="数据隔离级别"><a href="#数据隔离级别" class="headerlink" title="数据隔离级别"></a>数据隔离级别</h1><p>如果不对数据库进行并发控制，可能会产生异常情况：</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li>当一个事务读取另一个事务尚未提交的修改时，产生脏读。</li>
<li>同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。</li>
</ul>
</li>
<li>非重复读(Nonrepeatable Read)：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</li>
<li>幻像读(Phantom Reads)：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。<ul>
<li>当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。</li>
</ul>
</li>
<li>丢失修改(Lost Update)<ul>
<li>第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。</li>
<li>第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。</li>
</ul>
</li>
</ol>
<p>为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）</p>
<ol>
<li>未提交读(Read Uncommitted)<ul>
<li>直译就是”读未提交”，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。</li>
<li>Read Uncommitted允许脏读。</li>
</ul>
</li>
<li>已提交读(Read Committed)<ul>
<li>直译就是”读提交”，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。</li>
<li>Read Commited 不允许脏读，但会出现非重复读。</li>
</ul>
</li>
<li>可重复读(Repeatable Read)<ul>
<li>直译就是”可以重复读”，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。</li>
<li>Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。</li>
</ul>
</li>
<li>串行读(Serializable)<ul>
<li>直译就是”序列化”，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
<li>Serializable 不允许不一致现象的出现。</li>
</ul>
</li>
</ol>
<h2 id="事务隔离的实现——锁"><a href="#事务隔离的实现——锁" class="headerlink" title="事务隔离的实现——锁"></a>事务隔离的实现——锁</h2><ol>
<li>共享锁(S锁)<ul>
<li>用于只读操作(<code>SELECT</code>)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。</li>
</ul>
</li>
<li>更新锁(U锁)<ul>
<li>用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。</li>
</ul>
</li>
<li>独占锁(X锁，也叫排他锁)<ul>
<li>一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。</li>
</ul>
</li>
</ol>
<p>隔离级别如何实现，这部分的详细内容可以参考<a href="http://www.hollischuang.com/archives/943" target="_blank" rel="external">深入分析事务的隔离级别</a>一文，下表是进行的总结。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>实现原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读(Read uncommitted)</td>
<td>事务在读数据的时候并未对数据加锁；事务在修改数据的时候只对数据增加行级共享锁。</td>
</tr>
<tr>
<td>提交读(Read committed)</td>
<td>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。</td>
</tr>
<tr>
<td>可重复读(Repeatable reads)</td>
<td>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</td>
</tr>
<tr>
<td>可序列化(Serializable)</td>
<td>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</td>
</tr>
</tbody>
</table>
<h1 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h1><p>关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异。</p>
<p>对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。本节将总结和分析各个引擎的特点，以及适用场合，这里先不会纠结于更深层次的东西，下面就对MySQL支持的存储引擎进行简单的介绍。（本节主要参考<a href="http://www.jellythink.com/archives/640" target="_blank" rel="external">MySQL存储引擎介绍</a>一文）</p>
<p>在mysql客户端中，使用以下命令可以查看MySQL支持的引擎。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</div></pre></td></tr></table></figure>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p><code>MyISAM</code> 表是独立于操作系统的，这说明可以轻松地将其从 Windows 服务器移植到 Linux 服务器；每当我们建立一个 <code>MyISAM</code> 引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个 <code>MyISAM</code> 引擎的 <code>tb_Demo</code> 表，那么就会生成以下三个文件：</p>
<ul>
<li><code>tb_demo.frm</code>：存储表定义；</li>
<li><code>tb_demo.MYD</code>：存储数据；</li>
<li><code>tb_demo.MYI</code>：存储索引。</li>
</ul>
<p>有以下特点：</p>
<ul>
<li>不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不能使用</li>
<li>表级锁定：其锁定机制是表级锁定，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能</li>
<li>读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读</li>
<li>只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据</li>
</ul>
<p><code>MyISAM</code> 表无法处理事务，这就意味着有事务处理需求的表，不能使用 <code>MyISAM</code> 存储引擎。<code>MyISAM</code> 存储引擎特别适合在以下几种情况下使用：</p>
<ul>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><code>InnoDB</code> 是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。<code>InnoDB</code> 是默认的存储引擎，<code>InnoDB</code> 还引入了行级锁定和外键约束。</p>
<p>有以下几点特点：</p>
<ol>
<li>具有较好的事务支持：支持4个事务隔离级别，支持多版本读</li>
<li>行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响</li>
<li>读写阻塞与事务隔离级别相关</li>
<li>具有非常高效的缓存特性：能缓存索引，也能缓存数据</li>
<li>整个表和主键以Cluster方式存储，组成一颗平衡树</li>
<li>所有Secondary Index都会保存主键信息</li>
</ol>
<p>在以下场合下，使用 <code>InnoDB</code> 是最理想的选择：</p>
<ol>
<li>更新密集的表。<code>InnoDB</code> 存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。<code>InnoDB</code> 存储引擎是支持事务的标准 MySQL 存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，<code>InnoDB</code> 表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有 <code>InnoDB</code>。</li>
<li>支持自动增加列<code>AUTO_INCREMENT</code>属性。</li>
</ol>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，<code>InnoDB</code> 是不错的选择。</p>
<h2 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h2><p>使用 MySQL <code>Memory</code> 存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统<strong>内存</strong>。虽然在内存中存储表数据确实会提供很高的性能，但当 mysqid 守护进程崩溃时，所有的 <code>Memory</code> 数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在 <code>Memory</code> 数据表里的数据使用的是长度不变的格式，这意味着不能使用 <code>BLOB</code> 和 <code>TEXT</code> 这样的长度可变的数据类型，<code>VARCHAR</code> 是一种长度可变的类型，但因为它在 MySQL 内部当做长度固定不变的 <code>CHAR</code> 类型，所以可以使用。</p>
<p>一般在以下几种情况下适用 <code>Memory</code> 存储引擎：</p>
<ol>
<li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数 <code>max_heap_table_size</code> 控制 <code>Memory</code> 表的大小，设置此参数，就可以限制 <code>Memory</code> 表的最大大小；</li>
<li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li>
<li>存储在 <code>Memory</code> 表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li>
</ol>
<p><code>Memory</code> 同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<code>&lt;</code>、<code>&gt;</code>和<code>&gt;=</code>等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在<code>=</code>和<code>&lt;&gt;</code>的操作符中，不适合在<code>&lt;</code>或<code>&gt;</code>操作符中，也同样不适合用在 <code>order by</code> 子句中。</p>
<p>可以在表创建时利用 <code>USING</code> 子句指定要使用的版本。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span></div><div class="line">(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</div><div class="line">    username <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    pwd <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">index</span> <span class="keyword">using</span> <span class="keyword">hash</span> (username),</div><div class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">memory</span>;</div></pre></td></tr></table></figure>
<p>上述代码创建了一个表，在 <code>username</code> 字段上使用了 <code>HASH</code> 散列索引。下面的代码就创建一个表，使用 <code>BTREE</code> 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span></div><div class="line">(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">smallint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</div><div class="line">    username <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    pwd <span class="built_in">varchar</span>(<span class="number">15</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">index</span> <span class="keyword">using</span> btree (username),</div><div class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</div><div class="line">)<span class="keyword">engine</span>=<span class="keyword">memory</span>;</div></pre></td></tr></table></figure>
<h2 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h2><p><code>MERGE</code> 存储引擎是一组 <code>MyISAM</code> 表的组合，这些 <code>MyISAM</code> 表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，<code>Merge</code> 表就是几个相同 <code>MyISAM</code> 表的聚合器；<code>Merge</code> 表中并没有数据，对 <code>Merge</code> 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 <code>MyISAM</code> 表进行操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th>适用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>MyISAM</td>
<td>独立于操作系统的；不支持事务；表级锁定；</td>
<td>不需要事务支持；并发相对较低；  数据修改相对较少，以读为主；数据一致性要求不是非常高</td>
</tr>
<tr>
<td>InnoDB</td>
<td>事务性；行级锁定；外键约束；</td>
<td>需要事务支持；数据更新较为频繁；   数据一致性要求较高；行级锁定对高并发有很好的适应能力</td>
</tr>
<tr>
<td>MEMORY</td>
<td>存储内存里，数据容易丢失；性能高；存储的数据表要求数据类型长度不可变</td>
<td>数据小，但是可能会被频繁访问；数据是临时，并且立即可用；  可靠性不高的数据</td>
</tr>
</tbody>
</table>
<h1 id="数据库的索引结构"><a href="#数据库的索引结构" class="headerlink" title="数据库的索引结构"></a>数据库的索引结构</h1><p>在 MySQL 官方定义中，索引（ Index ）是帮助 MySQL 高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>在 MySQL 中，主要有四种类型的索引，分别为： B-Tree 索引， Hash 索引， Fulltext （全文）索引和 R-Tree 索引。</p>
<p>具体可以参考<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理-张洋</a>一文，本文以后会把这部分给补充上。</p>
<p>关于数据库的索引结构还有一下几篇文章推荐：</p>
<ul>
<li><a href="http://database.51cto.com/art/201504/473322_all.htm" target="_blank" rel="external">为什么要用B+树结构——MySQL索引结构的实现</a></li>
<li><a href="http://ju.outofmemory.cn/entry/29124" target="_blank" rel="external">mysql索引原理之B+/-Tree</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7786014" target="_blank" rel="external">B-树和B+树的应用：数据搜索和数据库索引</a></li>
<li><a href="http://www.2cto.com/database/201404/295109.html" target="_blank" rel="external">2014阿里实习生面试题——mysql如何实现索引的</a></li>
</ul>
<hr>
<p>参考</p>
<ul>
<li><a href="http://2627lounuo.blog.51cto.com/10696599/1787812" target="_blank" rel="external">数据库之——索引、触发器、事务（存储引擎）</a></li>
<li><a href="http://www.jellythink.com/archives/640" target="_blank" rel="external">MySQL存储引擎介绍</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理-张洋</a></li>
<li><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="external">深入分析事务的隔离级别</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TCP/IP 协议]]></title>
      <url>http://wangzzu.github.io/2016/08/30/http-protocol/</url>
      <content type="html"><![CDATA[<p>TCP/IP 协议在计算机网络中是非常重要的部分，本文主要是简单介绍其中的 TCP 协议和 IP 协议，也会涉及一些在面试中经常遇到的问题。</p>
<h1 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h1><p>在最项目开发中，经常会遇到各种协议，互联网基础通信框架就是 TCP/IP。TCP/IP 是个协议族，可分为四个层次：网络接口层（连接层）、网络层、传输层和应用层。</p>
<p>可以这样理解它们的作用：</p>
<ol>
<li>连接层负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、Wi-Fi、MPLS 等；</li>
<li>网络层负责分配地址和传送二进制数据，主要协议是IP协议，也有 ICMP 协议、ARP 协议、RARP 协议和 BOOTP 协议；</li>
<li>传输层负责传送文本数据，主要协议是 TCP 协议与 UDP 协议；</li>
<li>应用层负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是 FTP、HTTP、TELNET、SMTP、DNS 等。</li>
</ol>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>TCP提供一种面向连接的、可靠的字节流服务</li>
<li>在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li>
<li>TCP使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP使用累积确认</li>
<li>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p>
<p>TCP 连接三次握手四次挥手（下小节介绍）如下图所示（图片来自<a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a>）</p>
<p><img src="/images/computebase/tcp.jpg" alt="tcp"></p>
<ol>
<li>第一次握手：建立连接<ul>
<li>客户端发送连接请求报文段，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为 <code>x</code>；</li>
<li>然后，客户端进入 <code>SYN_SEND</code>状态，等待服务器的确认；</li>
</ul>
</li>
<li>第二次握手：服务器收到 <code>SYN</code> 报文段<ul>
<li>服务器收到客户端的 <code>SYN</code> 报文段，需要对这个 <code>SYN</code> 报文段进行确认，设置 <code>Acknowledgment Number</code> 为 <code>x+1</code> (<code>Sequence Number+1</code>)；</li>
<li>同时，自己自己还要发送 <code>SYN</code> 请求信息，将 <code>SYN</code> 位置为1，<code>Sequence Number</code> 为<code>y</code>；服务器端将上述所有信息放到一个报文段（即 <code>SYN+ACK</code> 报文段）中，一并发送给客户端，此时服务器进入 <code>SYN_RECV</code> 状态；</li>
</ul>
</li>
<li>第三次握手：客户端收到服务器的 <code>SYN+ACK</code> 报文段<ul>
<li>将 <code>Acknowledgment Number</code> 设置为<code>y+1</code>，向服务器发送 <code>ACK</code> 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li>
</ul>
</li>
</ol>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>
<h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>
<blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<p>在书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>示意图如上图所示。</p>
<p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的，这时候 TCP 采用的是四次挥手。</p>
<ol>
<li>第一次挥手<ul>
<li>主机1（可以使客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code>，向主机2发送一个 <code>FIN</code> 报文段；</li>
<li>此时，主机1进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机2了；</li>
</ul>
</li>
<li>第二次挥手<ul>
<li>主机2收到了主机1发送的 <code>FIN</code> 报文段，向主机1回一个 <code>ACK</code> 报文段，<code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加1；</li>
<li>主机1进入 <code>FIN_WAIT_2</code> 状态；</li>
<li>主机2告诉主机1，我“同意”你的关闭请求；</li>
</ul>
</li>
<li>第三次挥手<ul>
<li>主机2向主机1发送 <code>FIN</code> 报文段，请求关闭连接;</li>
<li>同时主机2进入 <code>LAST_ACK</code> 状态；</li>
</ul>
</li>
<li>第四次挥手<ul>
<li>主机1收到主机2发送的 <code>FIN</code> 报文段，向主机2发送 <code>ACK</code> 报文段，然后主机1进入 <code>TIME_WAIT</code> 状态；</li>
<li>主机2收到主机1的 <code>ACK</code> 报文段以后，就关闭连接；</li>
<li>此时，主机1等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p>那四次分手又是为何呢？TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机1发出 <code>FIN</code> 报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 <code>ACK</code> 报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了 <code>FIN</code> 报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ol>
<li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实 <code>FIN_WAIT_1</code> 和 <code>FIN_WAIT_2</code> 状态的真正含义都是表示等待对方的 <code>FIN</code> 报文。而这两种状态的区别是：<code>FIN_WAIT_1</code> 状态实际上是当 SOCKET 在 <code>ESTABLISHED</code> 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 SOCKET 即进入到 <code>FIN_WAIT_1</code> 状态。而当对方回应 <code>ACK</code> 报文后，则进入到 <code>FIN_WAIT_2</code> 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 <code>ACK</code> 报文，所以 <code>FIN_WAIT_1</code> 状态一般是比较难见到的，而 <code>FIN_WAIT_2</code> 状态还有时常常可以用 <code>netstat</code>看到。（主动方）</li>
<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上 <code>FIN_WAIT_2</code> 状态下的 SOCKET，表示<strong>半连接</strong>，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你( <code>ACK</code> 信息)，稍后再关闭连接。（主动方）</li>
<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 <code>ACK</code> 报文给对方，此时则进入到 <code>CLOSE_WAIT</code> 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 <code>CLOSE_WAIT</code> 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>
<li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 <code>CLOSED</code> 可用状态了。（被动方）</li>
<li><code>TIME_WAIT</code>: 表示收到了对方的 <code>FIN</code> 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 <code>CLOSED</code> 可用状态了。如果 <code>FINWAIT1</code> 状态下，收到了对方同时带 <code>FIN</code> 标志和 ACK 标志的报文时，可以直接进入到 <code>TIME_WAIT</code> 状态，而无须经过 <code>FIN_WAIT_2</code> 状态。（主动方）</li>
<li><code>CLOSED</code>: 表示连接中断。</li>
</ol>
<h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>这部分可以参考<a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a>一文。</p>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="什么是-SYN-攻击（SYN-Flood）？"><a href="#什么是-SYN-攻击（SYN-Flood）？" class="headerlink" title="什么是 SYN 攻击（SYN Flood）？"></a>什么是 SYN 攻击（SYN Flood）？</h3><p>在三次握手过程中，服务器发送 <code>SYN-ACK</code> 之后，收到客户端的 <code>ACK</code> 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 <code>SYN_RCVD</code> 状态。当收到 ACK 后，服务器才能转入 <code>ESTABLISHED</code> 状态.</p>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送 <code>SYN</code> 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code>SYN</code> 包将长时间占用未连接队列，正常的 <code>SYN</code> 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<p><code>SYN</code> 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。</p>
<h3 id="如何检测-SYN-攻击？"><a href="#如何检测-SYN-攻击？" class="headerlink" title="如何检测 SYN 攻击？"></a>如何检测 SYN 攻击？</h3><p>检测 <code>SYN</code> 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次 <code>SYN</code> 攻击。在 Linux/Unix 上可以使用系统自带的 <code>netstats</code> 命令来检测 <code>SYN</code> 攻击。</p>
<h3 id="如何防御-SYN-攻击？"><a href="#如何防御-SYN-攻击？" class="headerlink" title="如何防御 SYN 攻击？"></a>如何防御 SYN 攻击？</h3><p><code>SYN</code> 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 <code>SYN</code> 攻击的危害，常见的防御 <code>SYN</code> 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="TCP-与-UDP-的区别？"><a href="#TCP-与-UDP-的区别？" class="headerlink" title="TCP 与 UDP 的区别？"></a>TCP 与 UDP 的区别？</h3><ol>
<li>TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。</li>
<li>TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。</li>
<li>TCP无界有拥塞控制，TCP有界无拥塞控制。</li>
</ol>
<p>补充：</p>
<ul>
<li>基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。</li>
<li>基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>特点</td>
<td>面向连接；可靠；开销大</td>
<td>无连接；不可靠；效率高；可靠性由应用层负责</td>
</tr>
</tbody>
</table>
<h3 id="三次握手过程及其原因"><a href="#三次握手过程及其原因" class="headerlink" title="三次握手过程及其原因"></a>三次握手过程及其原因</h3><p>如上面所述</p>
<h3 id="四次挥手及其原因"><a href="#四次挥手及其原因" class="headerlink" title="四次挥手及其原因"></a>四次挥手及其原因</h3><p>如上面所述</p>
<h1 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h1><p>这部分可以参考<a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a>一文。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html" target="_blank" rel="external">TCP/IP模型的一个简单解释</a></li>
<li><a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
<li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="external">TCP 协议</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></li>
<li><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发学习（一）]]></title>
      <url>http://wangzzu.github.io/2016/08/21/java-concurrency/</url>
      <content type="html"><![CDATA[<p>本文主要是根据华黎的《大型网站系统与Java中间件实践》和 <a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason</a> 的几篇博客，对 Java 并发方面的内容做的一些总结，会着重讲述并发方面一些常见的类、接口和方法。</p>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>对于多线程编程，线程安全是我们首先要考虑的问题，关于线程安全有三个核心概念：原子性、可见性和顺序性，这三个概念需要先理解清楚。</p>
<h2 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>与数据库中事务的原子性概念相似，即对于一个操作（有可能包含有多个子操作）要么全部执行，要么全部都不执行。</p>
<p>关于原子性，最经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作技术——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p>
<h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</p>
<p>以下面这段代码为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>; <span class="comment">// 语句1</span></div><div class="line"><span class="keyword">long</span> counter = <span class="number">0L</span>; <span class="comment">// 语句2</span></div><div class="line">counter = <span class="number">1</span>; <span class="comment">// 语句3</span></div><div class="line">started = <span class="keyword">true</span>; <span class="comment">// 语句4</span></div></pre></td></tr></table></figure>
<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p>
<h2 id="Java如何解决多线程并发问题"><a href="#Java如何解决多线程并发问题" class="headerlink" title="Java如何解决多线程并发问题"></a>Java如何解决多线程并发问题</h2><p>上面已经提出了这三个核心的概念，在 Java 多线程中，我们会经常遇到这三个概念引发的多线程并发问题，下面讲述一下 Java 如果解决这些问题。</p>
<h3 id="Java如何保证原子性"><a href="#Java如何保证原子性" class="headerlink" title="Java如何保证原子性"></a>Java如何保证原子性</h3><h4 id="锁和同步"><a href="#锁和同步" class="headerlink" title="锁和同步"></a>锁和同步</h4><p>常用的保证Java操作原子性的工具是<strong>锁</strong>和<strong>同步方法</strong>（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</div><div class="line">  lock.lock();</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span> j = i;</div><div class="line">    i = j + <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (anyObject)&#123;</div><div class="line">    <span class="keyword">int</span> j = i;</div><div class="line">    i = j + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。（这一部分会后面详细讲述）</p>
<h4 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h4><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。<code>AtomicInteger</code>使用方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; numThreads; b++) &#123;</div><div class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; iteration; a++) &#123;</div><div class="line">      atomicInteger.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">  &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Java如何保证可见性"><a href="#Java如何保证可见性" class="headerlink" title="Java如何保证可见性"></a>Java如何保证可见性</h3><p>Java提供了<code>volatile</code>关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<h3 id="Java如何保证顺序性"><a href="#Java如何保证顺序性" class="headerlink" title="Java如何保证顺序性"></a>Java如何保证顺序性</h3><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<p>Java中可通过<code>volatile</code>在一定程序上保证顺序性，另外还可以通过<code>synchronized</code>和锁来保证顺序性。</p>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为<strong>happens-before原则</strong>隐式的保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<h3 id="happens-before原则（先行发生原则）"><a href="#happens-before原则（先行发生原则）" class="headerlink" title="happens-before原则（先行发生原则）"></a>happens-before原则（先行发生原则）</h3><ul>
<li>传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性</li>
<li>锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li>
<li>volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作</li>
<li>程序次序规则：一个线程内，按照代码顺序执行</li>
<li>线程启动规则：Thread对象的start()方法先发生于此线程的其它动作</li>
<li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li>
<li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取</li>
<li>对象终结规则：一个对象构造先于它的finalize发生</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>多核时代，面向多核编程就非常重要了，基于 java 的并发和多线程开发非常重要。与其每次需要时都创建线程相比，线程池可以降低创建线程的开销，线程池在线程执行结束后进行的是回收操作，而不是真正的销毁线程。</p>
<p>线程池的好处：</p>
<ol>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行；</li>
<li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/8/8.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPoolTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(count));</div><div class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    list.add(random.nextInt());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        threadPoolExecutor.shutdown();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            threadPoolExecutor.awaitTermination(<span class="number">1</span>,TimeUnit.DAYS);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"ThreadPool demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</div><div class="line">        System.out.println(list.size());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadTest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    list.add(random.nextInt());</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                thread.join();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"Thread demo runs "</span>+count+ <span class="string">" times, the total time of spending is: "</span>+(System.currentTimeMillis()-startTime));</div><div class="line">        System.out.println(list.size());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count=<span class="number">10000</span>;</div><div class="line">        threadPoolTest(count);</div><div class="line">        threadTest(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadPool demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 66</div><div class="line">10000</div><div class="line">Thread demo runs 10000 <span class="built_in">times</span>, the total time of spending is: 1333</div><div class="line">10000</div></pre></td></tr></table></figure>
<p>从例子中，可以直接地看到，使用线程池能极大地提高程序的运行速度。</p>
<p>两种方式差别在于，使用线程池的方式是复用线程的，而不使用线程池的方式是每次都要创建线程的。不使用线程时消耗时间过多，主要是由于创建线程的开销占整个时间的比例比较大。还有另外两种线程池：</p>
<ul>
<li>newFixedThreadPool创建一个指定工作线程数量的线程池（固定数量的线程 ）。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</li>
<li>newCachedThreadPool创建一个可缓存的线程池（线程数量根据任务数量动态变化 ）。这种类型的线程池特点是：<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>该方法返回的线程池是没有线程上限的，因为没有办法去控制总体的线程数量，而每个线程都是消耗内存的，这可能会导致过多的内存被占用。</li>
</ul>
</li>
<li>newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</li>
<li>newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)</li>
</ul>
<p>关于线程池内部原理部门可以看一下这两篇文章，未来也会把主要内容总结到博客里面</p>
<ul>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19243889" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（1）</a></li>
<li><a href="http://blog.csdn.net/mazhimazh/article/details/19283171" target="_blank" rel="external">Java 7之多线程线程池 - 线程池原理（2）</a></li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>每个Java对象都可以用做一个实现同步的互斥锁，这些锁被称为内置锁。线程进入同步代码块或方法时自动获得内置锁，退出同步代码块或方法时自动释放该内置锁。进入同步代码块或者同步方法是获得内置锁的唯一途径。</p>
<h2 id="实例同步方法"><a href="#实例同步方法" class="headerlink" title="实例同步方法"></a>实例同步方法</h2><p>synchronized用于修饰实例方法（非静态方法）时，执行该方法需要获得的是该类实例对象的内置锁（同一个类的不同实例拥有不同的内置锁）。如果多个实例方法都被synchronized修饰，则当多个线程调用同一实例的不同同步方法（或者同一方法）时，需要竞争锁。但当调用的是不同实例的方法时，并不需要竞争锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>foo1()</code> 和 <code>foo2()</code>是 <code>SynchronizedDemo1</code> 的两个成员方法，在多线程编程中，调用同一个对象的 <code>foo1()</code> 或者 <code>foo2()</code>是互斥的，这是针对同一个对象的多线程方法调用互斥。</p>
<h2 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h2><p>synchronized用于修饰静态方法时，执行该方法需要获得的是该类的class对象的内置锁（一个类只有唯一一个class对象）。调用同一个类的不同静态同步方法时会产生锁竞争。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo3</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo4</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>foo3()</code> 和 <code>foo4()</code>是 <code>SynchronizedDemo2</code> 类的两个静态方法。在不同的线程中，这两个方法的调用是互斥的，不仅它们之间，任何两个不同线程之间的调用也是互斥的。</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>synchronized用于修饰代码块时，进入同步代码块需要获得synchronized关键字后面括号内的对象（可以是实例对象也可以是class对象）的内置锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo3</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo5</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo6</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">synchronized</span>(SynchronizedDemo3.class)&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>synchronized(this)</code>与<code>SynchronizedDemo3</code>中加<code>synchronized</code>的成员方法是互斥的，而<code>synchronized(SynchronizedDemo3.class)</code>与<code>SynchronizedDemo3</code>加<code>synchronized</code>的静态方法是互斥的。</p>
<p><code>synchronized</code>用于修饰代码块会更加灵活，因为其后的参数可以是任意对象。</p>
<h2 id="synchronized使用总结"><a href="#synchronized使用总结" class="headerlink" title="synchronized使用总结"></a>synchronized使用总结</h2><p>锁的使用是为了操作临界资源的正确性，而往往一个方法中并非所有的代码都操作临界资源。换句话说，方法中的代码往往并不都需要同步。此时建议不使用同步方法，而使用同步代码块，只对操作临界资源的代码，也即需要同步的代码加锁。这样做的好处是，当一个线程在执行同步代码块时，其它线程仍然可以执行该方法内同步代码块以外的部分，充分发挥多线程并发的优势，从而相较于同步整个方法而言提升性能。</p>
<p>释放Java内置锁的唯一方式是synchronized方法或者代码块执行结束。若某一线程在synchronized方法或代码块内发生死锁，则对应的内置锁无法释放，其它线程也无法获取该内置锁（即进入跟该内置锁相关的synchronized方法或者代码块）。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock是<code>java.util.concurrent.locks</code>中的一个类，是从 JDK5开始加入的，与 synchronized 用法类似，不过它需要显式地进行 unlock。Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。使用synchronized的地方一定可以用ReentrantLock代替。</p>
<p>重入锁需要显示请求获取锁，并显示释放锁。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，一般建议将释放锁操作放在finally块里，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  renentrantLock.lock();</div><div class="line">  <span class="comment">// 用户操作</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  renentrantLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）还提供了其它获取锁的方法以实现不同的效果。</p>
<ol>
<li><code>lockInterruptibly()</code>：该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。与lock方法不同的是，在阻塞期间，如果当前线程被打断（interrupt）则该方法抛出<code>InterruptedException</code>。该方法提供了一种解除死锁的途径。</li>
<li><code>tryLock()</code>：该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。</li>
<li><code>tryLock(long time, TimeUnit unit)</code>：该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：1）若该时间内锁可用，则获得锁，并返回true；2）若等待期间当前线程被打断，则抛出InterruptedException；3）若等待时间结束仍未获得锁，则返回false。</li>
</ol>
<p>重入锁可定义为公平锁或非公平锁，默认实现为非公平锁。</p>
<ol>
<li>公平锁是指多个线程获取锁被阻塞的情况下，锁变为可用时，最新申请锁的线程获得锁。可通过在重入锁（RenentrantLock）的构造方法中传入true构建公平锁，如<code>Lock lock = new RenentrantLock(true)</code>；</li>
<li>非公平锁是指多个线程等待锁的情况下，锁变为可用状态时，哪个线程获得锁是随机的。synchonized相当于非公平锁。可通过在重入锁的构造方法中传入false或者使用无参构造方法构建非公平锁。效率相对高一点。</li>
</ol>
<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><p>这个主要用于读多写少并且读不需要互斥的场景，这样场景使用读写锁会比使用全部互斥的锁性能高出很多，<code>ReentrantReadWriteLock</code>通过<code>readLock()</code>和<code>writeLock()</code>两个方法获取读锁和写锁。</p>
<p>实际上，<code>ReadWriteLock</code>接口并非继承自Lock接口，<code>ReentrantReadWriteLock</code>也只实现了<code>ReadWriteLock</code>接口而未实现Lock接口。<code>ReadLock()</code>和<code>WriteLock()</code>，是<code>ReentrantReadWriteLock</code>类的静态内部类，它们实现了Lock接口。</p>
<p>一个<code>ReentrantReadWriteLock</code>实例包含一个<code>ReentrantReadWriteLock.ReadLock</code>实例和一个<code>ReentrantReadWriteLock.WriteLock</code>实例。通过<code>readLock()</code>和<code>writeLock()</code>方法可分别获得读锁实例和写锁实例，并通过Lock接口提供的获取锁方法获得对应的锁。</p>
<p>读写锁的锁定规则如下：</p>
<ul>
<li>获得读锁后，其它线程可获得读锁而不能获取写锁</li>
<li>获得写锁后，其它线程既不能获得读锁也不能获得写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      readWriteLock.readLock().lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 started with read lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 1 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        readWriteLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      readWriteLock.readLock().lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 started with read lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 2 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        readWriteLock.readLock().unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">      Lock lock = readWriteLock.writeLock();</div><div class="line">      lock.lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 started with write lock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">          ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"\tThread 3 ended"</span>);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;).start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sat Jun 18 21:33:46 CST 2016  Thread 1 started with <span class="built_in">read</span> lock</div><div class="line">Sat Jun 18 21:33:46 CST 2016  Thread 2 started with <span class="built_in">read</span> lock</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 2 ended</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 1 ended</div><div class="line">Sat Jun 18 21:33:48 CST 2016  Thread 3 started with write lock</div><div class="line">Sat Jun 18 21:33:50 CST 2016  Thread 3 ended</div></pre></td></tr></table></figure>
<p>从上面的执行结果可见，thread 1和thread 2都只需获得读锁，因此它们可以并行执行。而thread 3因为需要获取写锁，必须等到thread 1和thread 2释放锁后才能获得锁。</p>
<h1 id="volatitle"><a href="#volatitle" class="headerlink" title="volatitle"></a>volatitle</h1><p><code>synchronized</code>保证了一个线程中变量的可见性，而<code>volatile</code>则是保证了所修饰变量的可见性（可见性可以参考前面所述）。<code>volatile</code>是轻量级的实现变量可见性的方法，其具体使用也很简单。</p>
<p>对于同一个变量线程间的可见性与多个线程中操作互斥是两件事情，操作互斥是提供了操作整体的原子性，下面通过一个例子来看。</p>
<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>对于读操作来说，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i3;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getI3</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> i3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>getI1()</code>：该方法调用获取的是当前线程中的副本，这个值不一定是最新的值；</li>
<li><code>getI2()</code>：因为 i2 是被<code>volatile</code>修饰，因此对于 JVM 来说，这个变量不会又线程的本地副本，只会放在主存中，所以得到的值一定是最新的；</li>
<li><code>getI3()</code>：因为有<code>synchronized</code>关键字修饰，保证了线程的本地副本与主存的同步，所以也会得到最新的值。</li>
</ol>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>再对比一下它们的写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i1 = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i2;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI2</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i2 = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i3;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setI3</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    i3 = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下这三种情况：</p>
<ol>
<li><code>setI1()</code>：当前线程调用之后会得到最新的 i1 值，而另外的线程获取不一定可以立刻看到最新而值；</li>
<li><code>setI2()</code>：可以立刻在其他线程看到新的值，因为<code>volatile</code>保证了只有一份主存中的数据；</li>
<li><code>setI3()</code>：调用后必须在<code>synchronized</code>修饰的方法或代码中读取 i3 的值才可以看到最新值，因为<code>synchronized</code>不仅会把当前线程修改的本地副本同步给主存，还会从主存读取数据更新本地副本。</li>
</ol>
<h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>因为<code>volatile</code>只是保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量。</p>
<p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">new</span> Thread( () -&gt; &#123;</div><div class="line">    <span class="keyword">while</span>(isRunning) &#123;</div><div class="line">      someOperation();</div><div class="line">    &#125;</div><div class="line">  &#125;).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> </span>&#123;</div><div class="line">  isRunning = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用<code>stop()</code>方法将<code>isRunning</code>设置为<code>false</code>，循环也不一定会立即结束。可以通过<code>volatile</code>关键字，保证<code>while</code>循环及时得到<code>isRunning</code>最新的状态从而及时停止循环，结束线程。</p>
<h1 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h1><p>在 JDK5 中增加了<code>java.util.concurrent.atomic</code>包，这个包是一些以<code>Atomic</code>开头的类，这些类主要提供一些相关的原子操作。</p>
<p>以<code>AtomicInteger</code>为例来看一个多线程计数器的场景，场景很简单，就是让多个线程都对计数器进行加1操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            counter = counter + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> counter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            counter = counter - <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> counter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在采用了<code>AtomicInteger</code>之后，代码就会变成下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter2</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> counter.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> counter.decrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用<code>AtomicInteger</code>之后代码变得简洁了，更重要的是性能得到了提升，而且还比较明显的提升，原因是<code>AtomicInteger</code>内部通过 JNI 的方式使用了硬件支持的 CAS 指令。</p>
<h1 id="wait、notify-和-notifyAll"><a href="#wait、notify-和-notifyAll" class="headerlink" title="wait、notify 和 notifyAll"></a>wait、notify 和 notifyAll</h1><p>wait、notify 和 notifyAll 是 java Object 对象上的三个方法，也就是所有的Java类都可以调用这三个方法。</p>
<p>在多线程情况下，可以把某个对象作为事件对象，通过这个对象的 wait、notify 和 notifyAll方法来完成线程间的状态通知，三个方法的作用如下：</p>
<ul>
<li>wait：是当前线程进行等待；</li>
<li>notify：是唤醒同一个对象 wait 方法的线程，但是只是唤醒一个等待线程；</li>
<li>notifyAll：是唤醒同一个对象 wait 方法的线程，唤醒所有的等待线程。</li>
</ul>
<p>注意：</p>
<p>wait方法需要释放锁，前提条件是它已经持有锁。所以wait和notify（或者<code>notifyAll</code>）方法都必须被包裹在<code>synchronized</code>语句块中，并且<code>synchronized</code>后锁的对象应该与调用<code>wait</code>方法的对象一样。否则抛出<code>IllegalMonitorStateException</code>.</p>
<p>wait 与 sleep 的区别</p>
<ul>
<li>wait：它是在当前线程持有 wait 对象锁的情况下，暂时放弃锁，并让出 CPU 资源，并积极等待其它线程调用同一对象的 notify 或者 notifyAll 方法。换言之，即使notify被调用，但只要锁没有被释放，原等待线程因为未获得锁仍然无法继续执行。</li>
<li>sleep：它告诉操作系统至少指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。</li>
</ul>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>是<code>java.util.concurrent</code>包中的一个类，<code>CountDownLatch</code>主要提供的机制是当多个线程达到了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己后续的工作。需要注意的是，等待线程可以是多个，即 CountDownLatch 是可以唤醒多个等待的线程的。达到自己预期状态的线程会调用<code>CountDownLatch</code>的<code>countDown</code>方法，而等待线程会调用<code>CountDownLatch</code>的<code>wait</code>方法。</p>
<p>如果<code>CountDownLatch</code>初始化的 count 值为1，那么这就变成了单一事件了，即由一个线程来通知其他线程，效果等同于对象的<code>wait</code>和<code>notifyAll</code>。count 值大于1是常用的方式，目的是让多个线程达到各自的预期状态，变为一个事件进行通知，线程则继续自己的行为。</p>
<h3 id="CountDownLatch适用场景"><a href="#CountDownLatch适用场景" class="headerlink" title="CountDownLatch适用场景"></a>CountDownLatch适用场景</h3><p>Java多线程编程中经常会碰到这样一种场景——某个线程需要等待一个或多个线程操作结束（或达到某种状态）才开始执行。比如开发一个并发测试工具时，主线程需要等到所有测试线程均执行完成再开始统计总共耗费的时间，此时可以通过<code>CountDownLatch</code>轻松实现。</p>
<h3 id="CountDownLatch实例"><a href="#CountDownLatch实例" class="headerlink" title="CountDownLatch实例"></a>CountDownLatch实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> countdownlatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">int</span> totalThread = <span class="number">3</span>;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(totalThread);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</div><div class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"started"</span>));</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            Thread.sleep(<span class="number">1000</span>);</div><div class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                            ex.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        countDown.countDown();</div><div class="line">                        System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</div><div class="line">                    &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">        countDown.await();</div><div class="line">        <span class="keyword">long</span> stop = System.currentTimeMillis();</div><div class="line">        System.out.println(String.format(<span class="string">"Total time : %sms"</span>, (stop - start)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 0 started</div><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 2 started</div><div class="line">Tue Aug 09 14:44:19 CST 2016	Thread 1 started</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 2 ended</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 1 ended</div><div class="line">Tue Aug 09 14:44:20 CST 2016	Thread 0 ended</div><div class="line">Total time : 1029ms</div></pre></td></tr></table></figure>
<p>可以看到，主线程等待所有3个线程都执行结束后才开始执行。</p>
<h3 id="CountDownLatch主要接口分析"><a href="#CountDownLatch主要接口分析" class="headerlink" title="CountDownLatch主要接口分析"></a>CountDownLatch主要接口分析</h3><p>CountDownLatch工作原理相对简单，可以简单看成一个倒计时器，在构造方法中指定初始值，每次调用countDown()方法时讲计数器减1，而await()会等待计数器变为0。CountDownLatch关键接口如下</p>
<ul>
<li>countDown() 如果当前计数器的值大于1，则将其减1；若当前值为1，则将其置为0并唤醒所有通过await等待的线程；若当前值为0，则什么也不做直接返回。</li>
<li>await() 等待计数器的值为0，若计数器的值为0则该方法返回；若等待期间该线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为0，若在指定时间内计数器的值变为0，则该方法返回true；若指定时间内计数器的值仍未变为0，则返回false；若指定时间内计数器的值变为0之前当前线程被中断，则抛出InterruptedException并清除该线程的中断状态。</li>
<li>getCount() 读取当前计数器的值，一般用于调试或者测试。</li>
</ul>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="CyclicBarrier适用场景"><a href="#CyclicBarrier适用场景" class="headerlink" title="CyclicBarrier适用场景"></a>CyclicBarrier适用场景</h3><p>CyclicBarrier，从字面理解是指循环屏障，CyclicBarrier可以在构造时指定需要在屏障前执行await的个数，所有对await的调用都会等待，只到调用await的次数达到预定指，所有等待都会立即被唤醒。</p>
<p>从使用场景上来说，CyclicBarrier是让多个线程互相等待某一事件的发生，然后同时被唤醒。而上文讲的CountDownLatch是让某一线程等待多个线程的状态，然后该线程被唤醒。</p>
<h3 id="CyclicBarrier实例"><a href="#CyclicBarrier实例" class="headerlink" title="CyclicBarrier实例"></a>CyclicBarrier实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cyclicbarrier;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> totalThread = <span class="number">5</span>;</div><div class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</div><div class="line">            <span class="keyword">final</span> String threadName = <span class="string">"Thread "</span> + i;</div><div class="line">            Thread thread=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">" is waiting"</span>));</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        barrier.await();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                        ex.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(String.format(<span class="string">"%s\t%s %s"</span>, <span class="keyword">new</span> Date(), threadName, <span class="string">"ended"</span>));</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1  is waiting</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 4 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 1 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 2 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 0 ended</div><div class="line">Tue Aug 09 18:54:39 CST 2016	Thread 3 ended</div></pre></td></tr></table></figure></p>
<p>从执行结果可以看到，每个线程都不会在其它所有线程执行<code>await()</code>方法前继续执行，而等所有线程都执行<code>await()</code>方法后所有线程的等待都被唤醒从而继续执行。</p>
<h3 id="CyclicBarrier主要接口分析"><a href="#CyclicBarrier主要接口分析" class="headerlink" title="CyclicBarrier主要接口分析"></a>CyclicBarrier主要接口分析</h3><p>CyclicBarrier提供的关键方法如下</p>
<ul>
<li>await()：等待其它参与方的到来（调用await()）。如果当前调用是最后一个调用，则唤醒所有其它的线程的等待并且如果在构造CyclicBarrier时指定了action，当前线程会去执行该action，然后该方法返回该线程调用await的次序（getParties()-1说明该线程是第一个调用await的，0说明该线程是最后一个执行await的），接着该线程继续执行await后的代码；如果该调用不是最后一个调用，则阻塞等待；如果等待过程中，当前线程被中断，则抛出InterruptedException；如果等待过程中，其它等待的线程被中断，或者其它线程等待超时，或者该barrier被reset，或者当前线程在执行barrier构造时注册的action时因为抛出异常而失败，则抛出BrokenBarrierException。</li>
<li>await(long timeout, TimeUnit unit)：与await()唯一的不同点在于设置了等待超时时间，等待超时时会抛出TimeoutException。</li>
<li>reset()：该方法会将该barrier重置为它的初始状态，并使得所有对该barrier的await调用抛出BrokenBarrierException。</li>
</ul>
<h3 id="CountDownLatch-与-CyclicBarrier"><a href="#CountDownLatch-与-CyclicBarrier" class="headerlink" title="CountDownLatch 与 CyclicBarrier"></a>CountDownLatch 与 CyclicBarrier</h3><p><code>CountDownLatch</code> 与 <code>CyclicBarrier</code> 都是用于多个线程间的协调，二者的一个差别是：</p>
<ol>
<li><code>CountDownLatch</code>：它是在多个线程都进行了<code>latch.countDown</code>后才会触发事件，唤醒<code>await</code>在 latch 上的线程，而执行<code>countDown</code>的线程，执行完<code>countDown</code>后继续进行自己的工作，也就是说，<code>countDown</code>的线程会继续执行，而唤醒的是<code>await</code>的线程；</li>
<li><code>CyclicBarrier</code>：它是一个栅栏，用于同步所有调用<code>await</code>方法的线程，并且等待所有线程都到了<code>await</code>方法时，这些线程才一起返回继续各自的工作，因为使用<code>CyclicBarrier</code>的线程都会阻塞在<code>await</code>方法上，所以在线程池中使用<code>CyclicBarrier</code>时要特别小心，如果线程池的线程数过少，那么很容易发生死锁。</li>
</ol>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="Phaser适用场景"><a href="#Phaser适用场景" class="headerlink" title="Phaser适用场景"></a>Phaser适用场景</h3><p><code>CountDownLatch</code>和<code>CyclicBarrier</code>都是JDK 1.5引入的，而<code>Phaser</code>是JDK 1.7引入的。<code>Phaser</code>的功能与<code>CountDownLatch</code>和<code>CyclicBarrier</code>有部分重叠，同时也提供了更丰富的语义和更灵活的用法。</p>
<p><code>Phaser</code>顾名思义，与<strong>阶段</strong>相关。<code>Phaser</code>比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个CyclicBarrier来实现，每个CyclicBarrier负责等待一个阶段的任务全部完成。但是使用CyclicBarrier的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而Phaser可同时解决这两个问题。</p>
<h3 id="Phaser实例"><a href="#Phaser实例" class="headerlink" title="Phaser实例"></a>Phaser实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> phaser;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">int</span> parties = <span class="number">3</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> phases = <span class="number">4</span>;</div><div class="line">        <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(parties) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"====== Phase : "</span> + phase + <span class="string">" ======"</span>);</div><div class="line">                <span class="keyword">return</span> registeredParties == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i;</div><div class="line">            <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;</div><div class="line">                        System.out.println(String.format(<span class="string">"Thread %s, phase %s"</span>, threadId, phase));</div><div class="line">                        phaser.arriveAndAwaitAdvance();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread 1, phase 0</div><div class="line">Thread 2, phase 0</div><div class="line">Thread 0, phase 0</div><div class="line">====== Phase : 0 ======</div><div class="line">Thread 0, phase 1</div><div class="line">Thread 2, phase 1</div><div class="line">Thread 1, phase 1</div><div class="line">====== Phase : 1 ======</div><div class="line">Thread 1, phase 2</div><div class="line">Thread 2, phase 2</div><div class="line">Thread 0, phase 2</div><div class="line">====== Phase : 2 ======</div><div class="line">Thread 1, phase 3</div><div class="line">Thread 2, phase 3</div><div class="line">Thread 0, phase 3</div><div class="line">====== Phase : 3 ======</div></pre></td></tr></table></figure>
<p>从上面的结果可以看到，多个线程必须等到其它线程的同一阶段的任务全部完成才能进行到下一个阶段，并且每当完成某一阶段任务时，Phaser都会执行其onAdvance方法。</p>
<h3 id="Phaser主要接口分析"><a href="#Phaser主要接口分析" class="headerlink" title="Phaser主要接口分析"></a>Phaser主要接口分析</h3><p>Phaser主要接口如下</p>
<ul>
<li>arriveAndAwaitAdvance()：当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从0开始），同时其它线程的该方法也返回下一个阶段的序号。</li>
<li>arriveAndDeregister()：该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser会在后文中讲到），并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。</li>
<li>arrive()：该方法不作任何等待，直接返回下一阶段的序号。</li>
<li>awaitAdvance(int phase)：该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。该阶段数一般由arrive()方法或者arriveAndDeregister()方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前Phaser已经被终止）。</li>
<li>awaitAdvanceInterruptibly(int phase)：效果与awaitAdvance(int phase)相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出InterruptedException。</li>
<li>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)：效果与awaitAdvanceInterruptibly(int phase)相当，区别在于如果超时则抛出TimeoutException。</li>
<li>bulkRegister(int parties)：注册多个party。如果当前phaser已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance方法正在执行，则该方法等待其执行完毕。如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该Phaser会被注册到其父Phaser中。</li>
<li>forceTermination()：强制让该Phaser进入终止状态。已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。</li>
</ul>
<h1 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h1><p>信号量维护一个许可集，构造时需要传入参数，总数就是控制并发的数量，在执行可通过<code>acquire()</code>获取许可（如果acquire 成功返回，Semaphore 可用的信号量就会减少一个，若无可用许可acquire 就会阻塞，等待有 release 释放信号后，acquire 才会得到信号并返回），通过<code>release()</code>释放许可，从而可能唤醒一个阻塞等待许可的线程。</p>
<p>与互斥锁类似，信号量限制了同一时间访问临界资源的线程的个数，并且信号量也分<strong>公平信号量</strong>与<strong>非公平信号量</strong>。而不同的是，互斥锁保证同一时间只会有一个线程访问临界资源，而信号量可以允许同一时间多个线程访问特定资源。所以信号量并不能保证原子性。</p>
<p>信号量的一个典型使用场景是限制系统访问量。每个请求进来后，处理之前都通过<code>acquire</code>获取许可，若获取许可成功则处理该请求，若获取失败则等待处理或者直接不处理该请求。</p>
<h2 id="信号量的使用方法"><a href="#信号量的使用方法" class="headerlink" title="信号量的使用方法"></a>信号量的使用方法</h2><ul>
<li>acquire(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前可用许可数少于permits指定的个数，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，则抛出InterruptedException；</li>
<li>acquire()：等价于acquire(1)；</li>
<li>acquireUninterruptibly(int permits)：申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前许可数少于permits，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，继续等待可用许可数大于等于permits，并且获取成功后设置线程中断状态；</li>
<li>acquireUninterruptibly()：等价于acquireUninterruptibly(1)；</li>
<li>drainPermits()：获取所有可用许可，并返回获取到的许可个数，该方法不阻塞；</li>
<li>tryAcquire(int permits)：尝试获取permits个可用许可，如果当前许可个数大于等于permits，则返回true并且可用许可数减permits；否则返回false并且可用许可数不变；</li>
<li>tryAcquire()：等价于tryAcquire(1)；</li>
<li>tryAcquire(int permits, long timeout, TimeUnit unit)：尝试获取permits（必须为非负数）个许可，若在指定时间内获取成功则返回true并且可用许可数减permits；若指定时间内当前线程被中断，则抛出InterruptedException；若指定时间内可用许可数均小于permits，则返回false；</li>
<li>tryAcquire(long timeout, TimeUnit unit)：等价于tryAcquire(1, long timeout, TimeUnit unit)；</li>
<li>release(int permits)：释放permits个许可，该方法不阻塞并且某线程调用release方法前并不需要先调用acquire方法；</li>
<li>release()：等价于release(1)。</li>
</ul>
<blockquote>
<p>注意：与<code>wait/notify</code>和<code>await/signal</code>不同，<code>acquire/release</code>完全与锁无关，因此<code>acquire</code>等待过程中，可用许可满足要求时<code>acquire</code>可立即返回，而不用像锁的<code>wait</code>和条件变量的<code>await</code>那样重新获取锁才能返回。或者可以理解成，只要可用许可满足需求，就已经获得了锁。</p>
</blockquote>
<p>如果<code>Semaphore</code>管理的信号量只有1个，那么就是互斥锁了；如果多于1个信号量，则主要用于控制并发数。</p>
<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p><code>Exchanger</code>从名字上来看，就是交换的意思，<code>Exchanger</code>用于在两个线程之间进行数据交换，线程会阻塞在Exchanger的<code>exchange</code>方法上，直到另外一个线程也到了同一个Exchanger的<code>exchange</code>方法时，二者进行交换，然后两个线程会继续执行自身相关的代码。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> exchanger;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</div><div class="line">                list.add(<span class="number">1</span>);</div><div class="line">                list.add(<span class="number">2</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    list = exchanger.exchange(list);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Thread1"</span> + list);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">2</span>);</div><div class="line">                list.add(<span class="number">4</span>);</div><div class="line">                list.add(<span class="number">5</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    list=exchanger.exchange(list);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Thread2"</span> + list);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread2[1, 2]</div><div class="line">Thread1[4, 5]</div></pre></td></tr></table></figure>
<h1 id="Future-和-Future-Task"><a href="#Future-和-Future-Task" class="headerlink" title="Future 和 Future Task"></a>Future 和 Future Task</h1><p><code>Future</code>是一个接口，<code>Future Task</code>是一个具体实现类。</p>
<p>在实际开发的环境中，我们经常会遇到这样一种场景中，在一个函数中我们调用了一个函数，正常情况下，程序会在理阻塞，知道调用函数返回结果，而很多情况下返回的结果我们并不会马上使用，这样的话就浪费很多时间。我们期待的情况是：调用函数后马上返回，然后继续向下执行，等需要用数据时再来用，或者说再来等待这个数据，具体的实现方式有两种方式，一个是用<code>Future</code>，一个是用回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Future&lt;HashMap&gt; future = getDataFromRemote2();</div><div class="line"><span class="comment">// do something</span></div><div class="line">HashMap data = (HashMap) future.get();</div></pre></td></tr></table></figure>
<p>可以看到，我们调用的方式返回的是一个 Future 对象，然后接着进行自己的处理，后面通过<code>future.get()</code>来获得真正的返回值。也就说，在调用了<code>getDataFromRemote2</code>后，就已经启动了对远程计算结果的获取，同时自己的线程还在继续处理，直到需要时再获取数据。我们先看一下<code>getDataFromRemote2</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Future&lt;HashMap&gt; <span class="title">getDataFromRemote2</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> threadPool.submit(<span class="keyword">new</span> Callback&lt;HashMap&gt;()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> HashMap <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">			returngetDataFromRemote();</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getDataFromRemote()</code>方法是从远程获取一些计算结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">HashMap <span class="title">getDataFromRemote</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p><code>getDataFromRemote2</code>中使用了<code>getDataFromRemote</code>来完成具体操作，并且使用到了线程池，把任务添加到线程池中，把 Future 对象返回出去。我们调用了<code>getDataFromRemote2</code>的线程，然后回来继续下面的执行，而背后是另外的线程在进行远程调用及等待的工作。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>参考<a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a>。调用回调函数的函数这里称作中间函数，而调用中间函数的函数我们成为起始函数。回调函数是作为函数的参数传入到中间函数中，中间函数在运行时，在需要调用这个函数的地方就调用回调函数，并将结果返回给中间函数，中间函数再把处理后的结果返回给起始函数。</p>
<p>回调实际上有两种：阻塞式回调和延迟式回调。</p>
<ul>
<li>阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；</li>
<li>延迟式回调里，回调函数的调用有可能是在起始函数返回之后。</li>
</ul>
<p>一般使用的回调函数都是阻塞式回调，而延迟式回调通常牵扯到多线程。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11449803.html" target="_blank" rel="external">大型网站系统与 Java 中间件实践</a></li>
<li><a href="http://www.jasongj.com/categories/java/" target="_blank" rel="external">Jason的博客：java 并发部分</a></li>
<li><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">回调函数（callback）是什么?</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka 0.10.0 SASL/PLAIN身份认证及权限实现]]></title>
      <url>http://wangzzu.github.io/2016/07/29/sasl-plain-kafka/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下使用官方发布的 Kafka 0.10.0 版如何实现 SASL/PLAIN 认证机制以及权限控制。</p>
<h1 id="Kafka-安全机制"><a href="#Kafka-安全机制" class="headerlink" title="Kafka 安全机制"></a>Kafka 安全机制</h1><p> Kafka 的安全机制主要分为两部分：</p>
<ul>
<li>身份认证（Authentication）：对client 与服务器的连接进行身份认证。</li>
<li>权限控制（Authorization）：实现对于消息级别的权限控制</li>
</ul>
<blockquote>
<p>In release 0.9.0.0, the Kafka community added a number of features that, used either separately or together, increases security in a Kafka cluster.<br>These features are considered to be of beta quality. The following security measures are currently supported:</p>
<ol>
<li>Authentication of connections to brokers from clients (producers and consumers), other brokers and tools, using either SSL or SASL (Kerberos). SASL/PLAIN can also be used from release 0.10.0.0 onwards.</li>
<li>Authentication of connections from brokers to ZooKeeper</li>
<li>Encryption of data transferred between brokers and clients, between brokers, or between brokers and tools using SSL (Note that there is a performance degradation when SSL is enabled, the magnitude of which depends on the CPU type and the JVM implementation.)</li>
<li>Authorization of read / write operations by clients</li>
<li>Authorization is pluggable and integration with external authorization services is supported</li>
</ol>
</blockquote>
<p>这段话的中文意思也就是说</p>
<ol>
<li>可以使用 SSL 或者 SASL 进行客户端（producer 和 consumer）、其他 brokers、tools与 brokers 之间连接的认证，SASL/PLAIN将在0.10.0中得到支持；</li>
<li>对brokers和zookeeper之间的连接进行Authentication；</li>
<li>数据传输用SSL加密，性能会下降；</li>
<li>对clients的读写操作进行Authorization；</li>
<li>Authorization 是pluggable，与外部的authorization services结合进行支持。</li>
</ol>
<h1 id="Kafka身份认证"><a href="#Kafka身份认证" class="headerlink" title="Kafka身份认证"></a>Kafka身份认证</h1><p>Kafka 目前支持SSL、SASL/Kerberos、SASL/PLAIN三种认证机制，关于这些认证机制的介绍可以参考一下三篇文章。</p>
<ul>
<li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="external">数字证书原理</a>;</li>
<li><a href="http://www.cnblogs.com/mailingfeng/archive/2012/07/18/2597392.html" target="_blank" rel="external">数字证书, 数字签名, SSL(TLS) , SASL</a>;</li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="external">SSL的延迟</a></li>
</ul>
<h2 id="SASL-PLAIN-认证"><a href="#SASL-PLAIN-认证" class="headerlink" title="SASL/PLAIN 认证"></a>SASL/PLAIN 认证</h2><p>可以参考<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a>，这个官方文档的中文版。</p>
<h3 id="Kafka-Server-端配置"><a href="#Kafka-Server-端配置" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h3><p>需要在 Kafka 安装目录下的config/server.properties文件中配置以下信息</p>
<h2 id="Kafka-Server-端配置-1"><a href="#Kafka-Server-端配置-1" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h2><p>在 kafka 安装目录下的<code>config/server.properties</code>配置一下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">listeners=SASL_PLAINTEXT://ip:pot</div><div class="line">security.inter.broker.protocol=SASL_PLAINTEXT</div><div class="line">sasl.mechanism.inter.broker.protocol=PLAIN</div><div class="line">sasl.enabled.mechanisms=PLAIN</div><div class="line">authorizer.class.name = kafka.security.auth.SimpleAclAuthorizer</div><div class="line">super.users=User:admin</div></pre></td></tr></table></figure>
<p>还需要配置一个名 <code>kafka_server_jaas.conf</code> 的配置文件，将配置文件放置在<code>conf</code>目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_admin=&quot;admin&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里，我们配置了两个用户：admin 和 alice，密码分别为 admin 和 alice。<br>最后需要为 Kafka 添加 <code>java.security.auth.login.config</code> 环境变量。在 <code>bin/kafka-run-class.sh</code> 中添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KAFKA_SASL_OPTS=<span class="string">'-Djava.security.auth.login.config=/opt/meituan/kafka_2.10-0.10.0.0/config/kafka_server_jaas.conf'</span></div><div class="line"><span class="comment"># Launch mode</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></div><div class="line">  nohup <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="built_in">exec</span> <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注：实际上，我们只是添加了第一行，并在第4和第6行中添加了 $KAFKA_SASL_OPTS 这个环境变量。</p>
</blockquote>
<h3 id="KafkaClient-配置"><a href="#KafkaClient-配置" class="headerlink" title="KafkaClient 配置"></a>KafkaClient 配置</h3><p>首先需要在客户端配置 <code>kafka_client_jaas.conf</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">KafkaClient &#123;</div><div class="line">  org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">  username=&quot;alice&quot;</div><div class="line">  password=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在（producer 和 consumer）程序中添加环境变量和配置，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"java.security.auth.login.config"</span>, <span class="string">".../kafka_client_jaas.conf"</span>); <span class="comment">// 环境变量添加，需要输入配置文件的路径</span></div><div class="line">props.put(<span class="string">"security.protocol"</span>, <span class="string">"SASL_PLAINTEXT"</span>);</div><div class="line">props.put(<span class="string">"sasl.mechanism"</span>, <span class="string">"PLAIN"</span>);</div></pre></td></tr></table></figure>
<p>配置完以上内容后，就可以正常运行 producer 和 consumer 程序，如果账户密码错误的话，程序就不能正常进行，但是不会有任何提示，这方面后面会进行一些改进。</p>
<h1 id="Kafka权限控制"><a href="#Kafka权限控制" class="headerlink" title="Kafka权限控制"></a>Kafka权限控制</h1><p>这个小节介绍一下 Kafka 的 ACL 。</p>
<h2 id="权限的内容"><a href="#权限的内容" class="headerlink" title="权限的内容"></a>权限的内容</h2><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ</td>
<td>读取topic</td>
</tr>
<tr>
<td>WRITE</td>
<td>写入topic</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除topic</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建topic</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改topic</td>
</tr>
<tr>
<td>DESCRIBE</td>
<td>获取topic的信息</td>
</tr>
<tr>
<td>ClusterAction</td>
<td></td>
</tr>
<tr>
<td>ALL</td>
<td>所有权限</td>
</tr>
</tbody>
</table>
<p>访问控制列表ACL存储在zk上，路径为<code>/kafka-acl</code>。</p>
<h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>Kafka 提供的命令如下表所示</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default</th>
<th>Option type</th>
</tr>
</thead>
<tbody>
<tr>
<td>–add</td>
<td>Indicates to the script that user is trying to add an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–remove</td>
<td>Indicates to the script that user is trying to remove an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–list</td>
<td>Indicates to the script that user is trying to list acts.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–authorizer</td>
<td>Fully qualified class name of the authorizer.</td>
<td>kafka.security.auth.SimpleAclAuthorizer</td>
<td>Configuration</td>
</tr>
<tr>
<td>–authorizer-properties</td>
<td>key=val pairs that will be passed to authorizer for initialization. For the default authorizer the example values are: zookeeper.connect=localhost:2181</td>
<td></td>
<td>Configuration</td>
</tr>
<tr>
<td>–cluster</td>
<td>Specifies cluster as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–topic [topic-name]</td>
<td>Specifies the topic as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–group [group-name]</td>
<td>Specifies the consumer-group as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–allow-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Allow</strong> permission. You can specify multiple –allow-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–deny-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Deny</strong> permission. You can specify multiple –deny-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–allow-host</td>
<td>IP address from which principals listed in –allow-principal will have access.</td>
<td>if –allow-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–deny-host</td>
<td>IP address from which principals listed in –deny-principal will be denied access.</td>
<td>if –deny-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–operation</td>
<td>Operation that will be allowed or denied. Valid values are : Read, Write, Create, Delete, Alter, Describe, ClusterAction, All</td>
<td>All</td>
<td>Operation</td>
</tr>
<tr>
<td>–producer</td>
<td>Convenience option to add/remove acls for producer role. This will generate acls that allows WRITE, DESCRIBE on topic and CREATE on cluster.</td>
<td></td>
<td>Convenience</td>
</tr>
<tr>
<td>–consumer</td>
<td>Convenience option to add/remove acls for consumer role. This will generate acls that allows READ, DESCRIBE on topic and READ on consumer-group.</td>
<td></td>
<td>Convenience</td>
</tr>
</tbody>
</table>
<h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>通过几个例子介绍一下如何进行权限设置。</p>
<h3 id="add-操作"><a href="#add-操作" class="headerlink" title="add 操作"></a>add 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为用户 alice 在 test（topic）上添加读写的权限</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --operation Read --operation Write --topic <span class="built_in">test</span></div><div class="line"><span class="comment"># 对于 topic 为 test 的消息队列，拒绝来自 ip 为198.51.100.3账户为 BadBob  进行 read 操作，其他用户都允许</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:* --allow-host * --deny-principal User:BadBob --deny-host 198.51.100.3 --operation Read --topic <span class="built_in">test</span></div><div class="line"><span class="comment"># 为bob 和 alice 添加all，以允许来自 ip 为198.51.100.0或者198.51.100.1的读写请求</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:bob --allow-principal User:alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h3 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出 topic 为 test 的所有权限账户</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --list --topic <span class="built_in">test</span></div></pre></td></tr></table></figure>
<p>输出信息为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Current ACLs <span class="keyword">for</span> resource `Topic:<span class="built_in">test</span>`:</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Describe from hosts: *</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Read from hosts: *</div><div class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Write from hosts: *</div></pre></td></tr></table></figure>
<h3 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove 操作"></a>remove 操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 移除 acl</div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --remove --allow-principal User:Bob --allow-principal User:Alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic test</div></pre></td></tr></table></figure>
<h3 id="producer-和-consumer-的操作"><a href="#producer-和-consumer-的操作" class="headerlink" title="producer 和 consumer 的操作"></a>producer 和 consumer 的操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># producer</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --producer --topic <span class="built_in">test</span></div><div class="line"></div><div class="line"><span class="comment">#consumer</span></div><div class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --add --allow-principal User:alice --consumer --topic <span class="built_in">test</span> —group <span class="built_in">test</span>-group</div></pre></td></tr></table></figure>
<h1 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h1><p>本小节记录了在使用 SASL/PLAIN 时遇到的一些坑。</p>
<h2 id="Controller连接broker失败"><a href="#Controller连接broker失败" class="headerlink" title="Controller连接broker失败"></a>Controller连接broker失败</h2><p>错误信息如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[2016-07-27 17:45:46,047] WARN [Controller-1-to-broker-1-send-thread], Controller 1<span class="string">'s connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</span></div><div class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:63)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll$1(NetworkClientBlockingOps.scala:112)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka$utils$NetworkClientBlockingOps$$pollUntil$extension(NetworkClientBlockingOps.scala:120)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady$extension(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</div><div class="line">    at kafka.controller.RequestSendThread.liftedTree1$1(ControllerChannelManager.scala:181)</div><div class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</div><div class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</div><div class="line">[2016-07-27 17:45:46,056] INFO [delete-topics-thread-1], Starting  (kafka.controller.TopicDeletionManager$DeleteTopicsThread)</div><div class="line">[2016-07-27 17:45:46,057] DEBUG [Topic Deletion Manager 1], Waiting for signal to start or continue topic deletion (kafka.controller.TopicDeletionManager)</div><div class="line">[2016-07-27 17:45:46,351] WARN [Controller-1-to-broker-1-send-thread], Controller 1's connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</div><div class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:63)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll<span class="variable">$1</span>(NetworkClientBlockingOps.scala:112)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka<span class="variable">$utils</span><span class="variable">$NetworkClientBlockingOps</span>$<span class="variable">$pollUntil</span><span class="variable">$extension</span>(NetworkClientBlockingOps.scala:120)</div><div class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady<span class="variable">$extension</span>(NetworkClientBlockingOps.scala:59)</div><div class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</div><div class="line">    at kafka.controller.RequestSendThread.liftedTree1<span class="variable">$1</span>(ControllerChannelManager.scala:181)</div><div class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</div><div class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</div></pre></td></tr></table></figure>
<p>查找原因查找了半天，之前以为是<code>kafka_server_jaas.conf</code>文件的格式有问题，改了之后发现 Kafka 有时启动正常，有时不能正常启动，修改之前 conf 文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_matt=“33&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后分析可能是因为没有在 user 中配置 admin 账户，因为 broker 之间也开启了身份认证，修改之后的配置文件如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KafkaServer &#123;</div><div class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</div><div class="line">    username=&quot;admin&quot;</div><div class="line">    password=&quot;admin&quot;</div><div class="line">    user_admin=&quot;admin&quot;</div><div class="line">    user_alice=&quot;alice&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>修改完之后，Kafka 就可以正常运行了。</p>
<hr>
<p>参考：</p>
<ul>
<li>confluent的官网博客：<a href="http://www.confluent.io/blog/apache-kafka-security-authorization-authentication-encryption" target="_blank" rel="external">Apache Kafka Security 101</a></li>
<li>Kafka 官网：<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">KIP-12 - Kafka Sasl/Kerberos and SSL implementation</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Security" target="_blank" rel="external">Kafka Security</a></li>
<li>Kafka 官网：<a href="http://kafka.apache.org/documentation.html#security" target="_blank" rel="external">Kafka security</a></li>
<li>Kafka 官网中文翻译<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Apache Kafka 0.10.0 new Consumer使用]]></title>
      <url>http://wangzzu.github.io/2016/07/22/kafak-new-consumer-use/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下Kafka new Consumer的使用，关于new Consumer的基本概念可以参考上一篇博文<a href="http://wangzzu.github.io/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍【译】</a>，这篇对于Kafka的new Consumer介绍得比较清楚。本文的一部分内容也来自上一篇文章。</p>
<h1 id="Consumer-Client"><a href="#Consumer-Client" class="headerlink" title="Consumer Client"></a>Consumer Client</h1><p>本节主要介绍Kafka从一些topic消费数据的示例。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="初始化与配置"><a href="#初始化与配置" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>Consumer的创建过程与之前旧的API创建方法一样，一个Consumer必备的最小配置项如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>); <span class="comment">// 通过其中的一台broker来找到group的coordinator，并不需要列出所有的broker</span></div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props); <span class="comment">// consumer实例</span></div></pre></td></tr></table></figure>
<p>Consumer的其他配置项可以参考<a href="http://kafka.apache.org/documentation.html#newconsumerconfigs" target="_blank" rel="external">New Consumer Configs</a>，除了上面的这几个配置之外，其他的几个比较常用的配置信息如下表所示</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>heartbeat.interval.ms</td>
<td>3000</td>
<td>当使用Kafka的group管理机制时，consumer向coordinator发送心跳的间隔，这个值要比session.timeout.ms小，最好不要超过session.timeout.ms的\frac{1}{3}</td>
</tr>
<tr>
<td>session.timeout.ms</td>
<td>30000</td>
<td>当使用Kafka的group管理机制时用于检测到consumer失败的时长，如果在这个时间内没有收到consumer的心跳信息，就认为Consumer失败了</td>
</tr>
<tr>
<td>auto.offset.reset</td>
<td>latest</td>
<td>group首次开始消费数据时的offset，有以下几个值可以选择：earliest、latest、none、anything else.</td>
</tr>
<tr>
<td>enable.auto.commit</td>
<td>true</td>
<td>设置为true时，Consumer的offset将会被周期性地自动commit</td>
</tr>
<tr>
<td>auto.commit.interval.ms</td>
<td>5000</td>
<td>Consumer的offset自动commit时的周期</td>
</tr>
</tbody>
</table>
<h2 id="Consumer-Auto-Offset-Commit"><a href="#Consumer-Auto-Offset-Commit" class="headerlink" title="Consumer Auto Offset Commit"></a>Consumer Auto Offset Commit</h2><p>本例使用Kafka的自动commit机制，每隔一段时间（可通过<code>auto.commit.interval.ms</code>来设置）就会自动进行commit offset。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>); <span class="comment">// 自动commit</span></div><div class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>); <span class="comment">// 自动commit的间隔</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>)); <span class="comment">// 可消费多个topic,组成一个list</span></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>在使用自动commit时，系统是保证at least once，因为offset是在这些messages被应用处理成功后才进行commit的；</li>
<li>subscribe方法需要传入所有topic的列表，一个group所消费的topic是不能动态增加的，但是可以在任何时间改变这个列表，它会把前面的设置覆盖掉；</li>
<li>poll中的参数就是设置一个时长，Consumer在进行拉取数据进行block的最大时间限制；</li>
</ol>
<h2 id="Consumer-Manual-Offset-Control"><a href="#Consumer-Manual-Offset-Control" class="headerlink" title="Consumer Manual Offset Control"></a>Consumer Manual Offset Control</h2><p>要进行手动commit，需要在配置文件中将enable.auto.commit设置为false，来禁止自动commit，本例以手动同步commit为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>));</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</div><div class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工同步commit offset</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在本例中，我们调用了commitSync方法，这是同步commit的方式，同时Kafka还提供了commitAsync方法，它们的区别是：使用同步提交时，consumer会进行block知道commit的结果返回，这样的话如果commit失败就可以今早地发现错误，而当使用异步commit时，commit的结果还未返回，Consumer就会开始拉取下一批的数据，但是使用异步commit可以系统的吞吐量，具体使用哪种方式需要开发者自己权衡；</li>
<li>本例中的实现依然是保证at least once，但是如果每次拉取到数据之后，就进行commit，最后再处理数据，就可以保证at last once。</li>
</ol>
<h2 id="Consumer-Manual-Partition-Assign"><a href="#Consumer-Manual-Partition-Assign" class="headerlink" title="Consumer Manual Partition Assign"></a>Consumer Manual Partition Assign</h2><p>Kafka在进行消费数据时，可以指定消费某个topic的某个partition，这种使用情况比较特殊，并不需要coordinator进行rebalance，也就意味着这种模式虽然需要设置group id，但是它跟前面的group的机制并不一样，它与旧的Consumer中的Simple Consumer相似，这是Kafka在新的Consumer API中对这种情况的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</div><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></div><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(props);</div><div class="line">TopicPartition partition0 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">0</span>);</div><div class="line">TopicPartition partition1 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">2</span>);</div><div class="line">consumer.assign(Arrays.asList(partition0, partition1));</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</div><div class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工sync offset</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>与前面的subscribe方法一样，在调用assign方法时，需要传入这个Consumer要消费的所有TopicPartition的列表；</li>
<li>不管对于simple consumer还是consumer group，所有offset的commit都必须经过group coordinator；</li>
<li>在进行commit时，必须设置一个合适的group.id，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个CommitFailedException异常，但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</li>
</ol>
<h1 id="KafkaStream使用"><a href="#KafkaStream使用" class="headerlink" title="KafkaStream使用"></a>KafkaStream使用</h1><p>KafkaStream是在Kafka 0.10.0版中新提出的内容，Kafka官方也说了设计这个feature的原因——为了简单，之前在流处理方面，一般情况下都会使用Kafka作为消息队列，然后再搭建一个流处理环境做流处理，而现在我们可以直接在Kafka中进行流处理，不需要再搭建另外一个环境（加了这个feature之后会使得Kafka变得更加复杂，不过官网说，在使用时我们只需要在工程中添加一个外部依赖包即可使用这个功能）。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>需要在pom文件中添加如下依赖，KafkaStream在实际运行时也是依赖这个外部的jar包运行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="初始化与配置-1"><a href="#初始化与配置-1" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>KafkaStream使用的一个基本初始化部分如下所示（代码来自<a href="http://kafka.apache.org/0100/javadoc/index.html?org/apache/kafka/streams/KafkaStreams.html" target="_blank" rel="external">Javadoc</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"my-stream-processing-application"</span>);</div><div class="line">props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(StreamsConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</div><div class="line">props.put(StreamsConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</div><div class="line">props.put(StreamsConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">props.put(StreamsConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</div><div class="line">StreamsConfig config = <span class="keyword">new</span> StreamsConfig(props);</div><div class="line"></div><div class="line">KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</div><div class="line">builder.from(<span class="string">"my-input-topic"</span>).mapValue(value -&gt; value.length().toString()).to(<span class="string">"my-output-topic"</span>);</div><div class="line"></div><div class="line">KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, config);</div><div class="line">streams.start();</div></pre></td></tr></table></figure>
<p>完整的配置选项如下表所示，也可以参考<a href="http://kafka.apache.org/documentation.html#streamsconfigs" target="_blank" rel="external">Streams Configs</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>application.id</td>
<td>流处理应用的标识，对同一个应用需要一致，因为它是作为消费的group_id的</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>bootstrap.servers</td>
<td>host1:port1,host2:port2 这样的列表，是用来发现所有Kafka节点的种子，因此不需要配上所有的Kafka节点</td>
<td>list</td>
<td></td>
</tr>
<tr>
<td>client.id</td>
<td>应用的一个客户端的逻辑名称，设定后可以区分是哪个客户端在请求</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>zookeeper</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>key.serde</td>
<td>键的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>partition.grouper</td>
<td>用于分区组织的类，需要实现PartitionGrouper接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.DefaultPartitionGrouper</td>
</tr>
<tr>
<td>replication.factor</td>
<td>流处理应用会创建change log topic和repartition topic用于管理内部状态，这个参数设定这些topic的副本数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>state.dir</td>
<td>状态仓库的存储路径</td>
<td>string</td>
<td>/tmp/kafka-streams</td>
</tr>
<tr>
<td>timestamp.extractor</td>
<td>时间戳抽取类，需要实现TimestampExtractor接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.ConsumerRecordTimestampExtractor</td>
</tr>
<tr>
<td>value.serde</td>
<td>值的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>buffered.records.per.partition</td>
<td>每个分区缓存的最大记录数</td>
<td>int</td>
<td>1000</td>
</tr>
<tr>
<td>commit.interval.ms</td>
<td>存储处理器当前位置的间隔毫秒数</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>metric.reporters</td>
<td>用于性能报告的类列表。需要实现MetricReporter接口。JmxReporter会永远开启不需要指定</td>
<td>list</td>
<td>[]</td>
</tr>
<tr>
<td>metric.num.samples</td>
<td>计算性能需要的采样数</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td>metric.sample.window.ms</td>
<td>性能采样的时间间隔</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>num.standby.replicas</td>
<td>每个任务的后备副本数</td>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>num.stream.threads</td>
<td>执行流处理的线程数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>poll.ms</td>
<td>等待输入的毫秒数</td>
<td>long</td>
<td>100</td>
</tr>
<tr>
<td>state.cleanup.delay.ms</td>
<td>一个分区迁移后，在删除状态前等待的毫秒数</td>
<td>long</td>
<td>60000</td>
</tr>
</tbody>
</table>
<h2 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h2><p>这是个将一个topic的事件进行过滤的示例，处理很简单，下面给出了这个例子的完整代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Serdes;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStream;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStreamBuilder;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.KafkaStreams;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.StreamsConfig;</div><div class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.Predicate;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 16/7/22.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFilter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"test-filter"</span>);</div><div class="line">        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"10.4.232.70:9091,10.4.232.77:2181"</span>);</div><div class="line">        props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line">        props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line"></div><div class="line">        <span class="comment">// setting offset reset to earliest so that we can re-run the demo code with the same pre-loaded data</span></div><div class="line">        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</div><div class="line"></div><div class="line">        KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</div><div class="line"></div><div class="line">        KStream&lt;String, String&gt; source = builder.stream(<span class="string">"test"</span>);</div><div class="line"></div><div class="line">        source.filter(<span class="keyword">new</span> Predicate&lt;String, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String key, String value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> (value.split(<span class="string">","</span>)[<span class="number">3</span>]).equals(<span class="string">"food"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).to(<span class="string">"food"</span>);</div><div class="line"></div><div class="line">        KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, props);</div><div class="line">        streams.start();</div><div class="line"></div><div class="line">        <span class="comment">// usually the stream application would be running forever,</span></div><div class="line">        <span class="comment">// in this example we just let it run for some time and stop since the input data is finite.</span></div><div class="line">        Thread.sleep(<span class="number">5000L</span>);</div><div class="line"></div><div class="line">        streams.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本文只是介绍这两个重要feature的使用方法，而KafkaStream并没有深入去讨论，后面会对本文再进行更新，并且还会增加Producer和Consumer使用安全机制的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Apache Kafka 0.9 Consumer Client 介绍【译】]]></title>
      <url>http://wangzzu.github.io/2016/07/21/kafka-new-consumer/</url>
      <content type="html"><![CDATA[<p>近段时间在公司实习，有一项任务就是负责对Kafka新版本的一些feature做一下调研，主要是调研的内容是Kafka在0.9.0版本中提供的两个新特性：New Consumer API和安全认证机制，本文是在研究Kafka的新consumer API时看过的一篇文章，对于理解新API的设计理念以及应用，有很多的帮助，因此就打算翻译一下，帮助自己更好理解的同时也为开源做一些贡献。本文译自<a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a>一文，是Confluent官方出的一篇关于Kafka新Consumer客户端介绍的文章。</p>
<blockquote>
<p>注：个人的英文及写作水平有限，虽然有些地方能够理解作者的意思，但是可能自己会表达不准确，读者遇到难以理解的地方，可以对照英文原文进行阅读。另外，有些在Kafka中经常出现专有英文名词，本文会尽量还用英文表示，本来直接看这些英文名词就非常简洁，翻译成中文反而难以理解。</p>
</blockquote>
<p>Kafka最初被设计时，它原生地提供了一个Scala版本的producer和Consumer客户端。但是随着Kafka的应用更加广泛，我们意识到这些API有很多的缺陷。比如，Kafka提供了一个<strong>high-level</strong>的Consumer API，它可以实现consumer group和自动容错，但是不能支持一些更复杂的使用场景，同时我们也提供了一套<strong>simple</strong>的Consumer API以提供更全面、更细粒度的控制，但是这种Consumer需要开发者自己设计容错机制。因此，我们重新设计和开发了客户端，以适应哪些旧的客户端很难或者无法适用的应用场景，并且建立了一套可以支持长久发展的API。</p>
<p>开始的第一阶段，在0.8.1的版本中，我们重写设计了Producer的API。最近的0.9.0版本完成了第二阶段，引入了新的Consumer API。在Kafka本身提供的一套新的<strong>group coordination protocol</strong>的基础上，新的Consumer有以下这些优势：</p>
<ul>
<li>Clean Consolidated API：新的Consumer结合了旧的”simple”和”high-level”Consumer客户端，同时提供了group协调机制和更细粒度的消费机制；</li>
<li>Reduced Dependencies：新的Consumer完全是用Java编写的，它在运行过程中没有依赖Scala或者Zookeeper，这使得我们的工程的依赖包更加轻量化；</li>
<li>Better Security：Kafka 0.9.0提供的<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">security extensions</a>只被新的Consumer所支持；</li>
<li>新的Consumer同样也增加一系列用于管理消费过程中group容错的协议。之前这部分的设计是使用Java客户端实现的，它需要频繁地与Zookeeper进行交互，这个实现逻辑上的复杂性使得这些它很难推广到其他语言的客户端上。而随着新协议的提出，实现变得更加简单，实际上<a href="https://github.com/edenhill/librdkafka" target="_blank" rel="external">C Client</a>已经开始应用这个协议了。</li>
</ul>
<p>尽管新的Consumer使用了重新设计的API和一个新的coordination protocol，但是Kafka的那些基础的概念并没有任何变化。因此，对旧的Consumer非常熟悉的开发者在理解新Consumer客户端的设计时并不会遇到太大困难。然而，却有一些不易察觉细节需要额外的关注，特别是在理解<strong>group management</strong>和<strong>thread model</strong>上时。本文的目的就是讲述一下新Consumer的使用以及解释一下这些细节问题。</p>
<blockquote>
<p>有一点需要注意：在本文还在写的时候，新的Consumer在稳定性方面仍然被认为是”beta”。</p>
</blockquote>
<p>我们已经解决了几个在0.9.0版中遇到的重要bug，如果你在使用0.9.0版时遇到任何问题，我们建议你先对这个分支进行一下测试。如果依然遇到问题，可以通过<a href="https://kafka.apache.org/contact.html" target="_blank" rel="external">mail lists</a>或者<a href="https://issues.apache.org/jira/secure/Dashboard.jspa" target="_blank" rel="external">JIRA</a>提出。</p>
<h1 id="Getting-Started：开始"><a href="#Getting-Started：开始" class="headerlink" title="Getting Started：开始"></a>Getting Started：开始</h1><p>开始讲述代码之前，我们先回顾一下Kafka的基本概念。在Kafka中，每一个topic都被分为一系列消息的集合，这些集合被称为partition，Producer会在这些消息集合的尾部追加数据，Consumer从给定的位置读取数据。Kafka通过consumer group实现规模化地消费topic数据，group是一系列Consumers共享一个共同的标识符。下图展示了一个有3个partition的topic被一个有2个成员的group消费的情况，topic的每个partition被安排到group中的一个cosumer上。</p>
<p><img src="/images/kafka/consumer-figure1.png" alt="consumer group"></p>
<p>旧的Consumer依赖ZK进行group管理，而新的Consumer则使用了一个Kafka自身提供的group coordination protocol实现。对于每一个group，都会从所有的broker中选取一个作为<strong>group coordinator</strong>，这个coordinator是负责维护和管理这个group的状态，它的主要工作是当一个consumer加入、一个consumer离开（挂掉或者手动停止等）或者topic的partition改变时重新进行partition分配，这个过程就是group的<strong>rebalance</strong>。</p>
<blockquote>
<p>这里有一个问题需要思考，每个topic的元数据信息（具体的指的是，这个topic有多少个partition，每个partition的leader在哪台broker上）是不是也有coordinator保存的？还是这些元数据信息直接保存在broker上？</p>
</blockquote>
<p>当一个group刚开始被初始化时，group中consumer可以选择从每个partition的最小或者最大的offset开始消费数据，然后每个partition中的message会按顺序依次进行消费。随着Consumer的处理，它会对已经成功处理的msg进行commit（提交的是msg的offset）。例如，如下图所示，Consumer当前消费的msg的offset（<code>Current Position</code>）是6，上一次已经提交的msg的offset（<code>Last Committed Offset</code>）是1.</p>
<p><img src="/images/kafka/consumer-figure2.png" alt="consumer offset"></p>
<p>当一个partition被分配到group中的另外一个consumer时，初始化的位置是<code>Last Committed Offset</code>。如果本例中的consumer突然挂掉，这个group中的consumer将不得不从1（<code>Last Committed Offset</code>）开始消费数据，在这种情况下，offset为1~6的message将被重新处理。</p>
<p>图中也展示了在log中其他两个比较重要的位置信息，<code>Log End Offset</code>是写入log中的最新一条message的offset，而<code>High Watermark</code>是log中已经成功备份到其他replicas中的最新一条message的offset，也就是说<code>Log End Offset</code>与<code>High Watermark</code>之间的数据已经写入到log中，但是还未成功备份到其他的replicas中。从consuemr端来看，<code>High Watermark</code>是consumer可以消费的最后一条message的offset，这种机制会阻止Consumer读取那些未备份的message，因为这些message在后面可能会丢失。</p>
<h1 id="Configuration-and-Initialization：配置与初始化"><a href="#Configuration-and-Initialization：配置与初始化" class="headerlink" title="Configuration and Initialization：配置与初始化"></a>Configuration and Initialization：配置与初始化</h1><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0-cp1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>与其他的Kafka客户端一样，新版的Consumer也需要使用一个<code>Properties</code>文件来创建。下面例子中的配置，是对于一个Consumer group来说的几个必备的配置项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div></pre></td></tr></table></figure>
<p>与旧的Consumer和Producer一样， 我们需要先配置一个brokers的初始列表，以便Consumer能够找到集群中其他的节点，这并不需要列出集群中的所有节点，客户端从列表中的broker中来找到全部的alive brokers，本例我们假设这台broker是运行在本地上的。Consumer也需要设置key和value反序列化的方式。最后，为了加入一个Consumer Group，也需要设置group id，它是group的一个标识符。在本文的下面，我们会介绍更多的配置选项。</p>
<blockquote>
<p>这里也有一个问题需要思考，Kafka是如何通过初始的broker列表来找到Kafka集群所有的节点信息？</p>
</blockquote>
<h1 id="Topic-Subscription：订阅Topic"><a href="#Topic-Subscription：订阅Topic" class="headerlink" title="Topic Subscription：订阅Topic"></a>Topic Subscription：订阅Topic</h1><p>开始消费前，必须首先配置出应用需要订阅的topic信息，下面的例子中，我们订阅了来自Topic为”foo”和”bar”的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</div></pre></td></tr></table></figure>
<p>开始订阅之后，Consumer可以与group的其他Consumer进行协调，来得到自己的partition分配，这个过程是在Consumer开始消费数据时自动进行的。下面，我们会展示如何使用<strong>assign</strong> API来手动进行partition分配，但是需要注意的是，Consumer中同时使用自动管理和手动管理是没有必要的。</p>
<p><code>subscribe</code>方法是不能增加的：程序中必须包含想要消费的所有topic列表，你可以在任何时间改变你订阅的topic的集合，但是之前订阅的这些topic会被你使用<code>subscribe</code>方法调用的新的列表所取代。</p>
<h1 id="Basic-Poll-Loop：基本的poll循环模型"><a href="#Basic-Poll-Loop：基本的poll循环模型" class="headerlink" title="Basic Poll Loop：基本的poll循环模型"></a>Basic Poll Loop：基本的poll循环模型</h1><p>Consumer需要支持并行地拉取数据，常见的情况就是从分布在不同broker上的多个topic的多个partition上拉取数据。为了实现这种情况，Kafka使用了一套类似于Unix中的<code>poll</code>或者<code>select</code>调用的API风格：一旦topic进行注册，未来所有的coordination、rebalance和数据拉取都是在一个event loop中通过一个单一的poll调用来触发的。这种实现方式是简单有效的，它可以处理来自单线程的所有IO。</p>
<blockquote>
<p>思考：Consumer在调用<code>poll</code>方法时处理逻辑是怎么样？</p>
</blockquote>
<p>在订阅了一个topic之后，你需要启动一个<code>event loop</code>来获得partition分配并开始开始拉取数据，这听起来很复杂，但是你需要做的就是在一个循环中调用<code>poll</code>方法，然后Consumer会自动处理其他的所有的事情。每一次对于<code>poll</code>方法的调用都会返回一个从其所分配的partition上拉取的message集合（集合可能会空）。下面的例子展示了在一个基本的poll循环模型中打印Consumer拉取的mmessage的offset和value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>poll</code>API返回了根据<code>Current Position</code>拉取到的record。当group第一次创建时，这个位置是根据配置来进行设置的，可以被设置每个partition的最早或者最新的offset。但是一旦这个Consumer开始commit offset，之后的每次rebalance都会把position重置到<code>Last Committed Offset</code>位置。<code>poll</code>的这个参数是用来控制当Consumer在<code>Current Position</code>等待数据时block的最大时间，只要有任何record是可用的，Consumer就会立马返回，但是如果没有任何record是可用，Consumer将会等待一定的时长（被设置的时间）。</p>
<blockquote>
<p>思考：新API中的record与旧API中的message有什么区别与联系？</p>
</blockquote>
<p>Consumer最初被设计时就是运行在它自己的线程上，在多线程情况下使用时如果没有额外的同步机制它并不是线程安全的，而且也不推荐去尝试。在这个例子中，我们使用了一个flag（<code>runnning</code>），当应用关掉时它用于从poll循环中中断。当这个flag被其他线程（例如：关闭进程的线程）设置为false时，当poll返回时循环就会结束，而且无论是否返回record应用都会结束进程。</p>
<p>当Consumer进程结束时，你应该显式地关闭Consumer进程，这样不仅可以清除使用的socket，而且可以确保Consumer会向Coordinator发送它离开group的信息。</p>
<p>在上面的例子中，我们使用了较小的定时来确保在关闭Consumer时没有太多的延迟，或者，你也可以设置一个较长的定时，通过使用<code>weakup</code>API来从循环中中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + “: ” + record.value());</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">  <span class="comment">// ignore for shutdown</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们将时长设置为了<code>Long.MAX_VALUE</code>，它意味着Consumer将会一直bolck直到下一批records返回。相比于前面例子中使用的flag，本例中线程通过调用<code>consumer.wakeup()</code>来中断poll循环，同时进程抛出一个<code>WakeupException</code>异常。这个API被其他线程调用是安全的，但值得注意的是：如果进程当前没有调用poll，这个异常会在下次调用时被抛出。在这个例子中，我们可以捕捉这个异常来阻止它继续传播。</p>
<blockquote>
<p>思考：1.只要有数据，poll就立马返回吗？还是poll会等待一段时间或者一定消息量后返回？2.poll中设置的time参数在什么情况下起作用？如果拉取的消息为空，而时间又超出的话会出现什么情况？</p>
</blockquote>
<h1 id="Putting-in-all-Together：一个完整的例子"><a href="#Putting-in-all-Together：一个完整的例子" class="headerlink" title="Putting in all Together：一个完整的例子"></a>Putting in all Together：一个完整的例子</h1><p>在下面的例子中，我们创建一个简单的<code>Runnable</code>任务，它初始化这个Consumer、订阅一个topic的列表，并且一直执行poll循环除非遇到外部触发结束进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; topics;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumerLoop</span><span class="params">(<span class="keyword">int</span> id,</span></span></div><div class="line">                      String groupId,</div><div class="line">                      List&lt;String&gt; topics) &#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.topics = topics;</div><div class="line">    Properties props = <span class="keyword">new</span> Properties();</div><div class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</div><div class="line">    props.put(“group.id”, groupId);</div><div class="line">    props.put(“key.deserializer”, StringDeserializer.class.getName());</div><div class="line">    props.put(“value.deserializer”, StringDeserializer.class.getName());</div><div class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      consumer.subscribe(topics);</div><div class="line"></div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">          Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">          data.put(<span class="string">"partition"</span>, record.partition());</div><div class="line">          data.put(<span class="string">"offset"</span>, record.offset());</div><div class="line">          data.put(<span class="string">"value"</span>, record.value());</div><div class="line">          System.out.println(<span class="keyword">this</span>.id + <span class="string">": "</span> + data);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">      <span class="comment">// ignore for shutdown</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      consumer.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    consumer.wakeup();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了测试这个示例，需要有一个运行0.9.0版Kafka的broker，并且需要一个有一些待消费数据的topic，向一个topic写入数据的最简单的办法是使用<code>kafka-verifiable-producer.sh</code>脚本。为了确保实验更有趣，我们将topic设置为多个partition，这样的话就不用使一个parition去做所有的工作了。在本例中，Kafka的broker和Zookeeper都运行在本地，你可以在一个Kafka根目录下键入以下命令进行设置topic和partiion。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bin/kafka-topics.sh --create --topic consumer-tutorial --replication-factor 1 --partitions 3 --zookeeper localhost:2181</span></div><div class="line"></div><div class="line"><span class="comment"># bin/kafka-verifiable-producer.sh --topic consumer-tutorial --max-messages 200000 --broker-list localhost:9092</span></div></pre></td></tr></table></figure>
<p>然后我们创建了一个有三个成员的consumer group，这个group来订阅我们刚才创建的那个topic</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> numConsumers = <span class="number">3</span>;</div><div class="line">  String groupId = <span class="string">"consumer-tutorial-group"</span></div><div class="line">  List&lt;String&gt; topics = Arrays.asList(<span class="string">"consumer-tutorial"</span>);</div><div class="line">  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);</div><div class="line"></div><div class="line">  <span class="keyword">final</span> List&lt;ConsumerLoop&gt; consumers = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numConsumers; i++) &#123;</div><div class="line">    ConsumerLoop consumer = <span class="keyword">new</span> ConsumerLoop(i, groupId, topics);</div><div class="line">    consumers.add(consumer);</div><div class="line">    executor.submit(consumer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">for</span> (ConsumerLoop consumer : consumers) &#123;</div><div class="line">        consumer.shutdown();</div><div class="line">      &#125;</div><div class="line">      executor.shutdown();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        executor.awaitTermination(<span class="number">5000</span>, TimeUnit.MILLISECONDS);</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子向一个executor提交三个consumer，每一个线程都分配了一个唯一的id，便于我们清楚是哪个线程在接收数据。当进程停止时，shutdown的Hook将被触发，它将使用<code>weakup</code>中断这三个线程，并且等待它们关闭。如果你运行这个程序，你将会看到所有这些线程接收到数据，下面是运行之后的输出例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2: &#123;partition=0, offset=928, value=2786&#125;</div><div class="line">2: &#123;partition=0, offset=929, value=2789&#125;</div><div class="line">1: &#123;partition=2, offset=297, value=891&#125;</div><div class="line">2: &#123;partition=0, offset=930, value=2792&#125;</div><div class="line">1: &#123;partition=2, offset=298, value=894&#125;</div><div class="line">2: &#123;partition=0, offset=931, value=2795&#125;</div><div class="line">0: &#123;partition=1, offset=278, value=835&#125;</div><div class="line">2: &#123;partition=0, offset=932, value=2798&#125;</div><div class="line">0: &#123;partition=1, offset=279, value=838&#125;</div><div class="line">1: &#123;partition=2, offset=299, value=897&#125;</div><div class="line">1: &#123;partition=2, offset=300, value=900&#125;</div><div class="line">1: &#123;partition=2, offset=301, value=903&#125;</div><div class="line">1: &#123;partition=2, offset=302, value=906&#125;</div><div class="line">1: &#123;partition=2, offset=303, value=909&#125;</div><div class="line">1: &#123;partition=2, offset=304, value=912&#125;</div><div class="line">0: &#123;partition=1, offset=280, value=841&#125;</div><div class="line">2: &#123;partition=0, offset=933, value=2801&#125;</div></pre></td></tr></table></figure>
<p>这个输出展示三个partition的消费情况，每一个partition都被安排到其中的一个线程上。在每个partition中，你都会看到offset如期望中的一样在不断增加，你可以使用命令行或者IDE中的<code>Ctrl+C</code>关闭这个进程。</p>
<h1 id="Consumer-Liveness：Consumer存活"><a href="#Consumer-Liveness：Consumer存活" class="headerlink" title="Consumer Liveness：Consumer存活"></a>Consumer Liveness：Consumer存活</h1><p>Group中每一个Consumer都被安排它订阅topic的partitions的一个子集，group会使用一个group锁在这些partition上。只要这些锁还被持有，其他的Consumer成员就不能从这些partition上读取数据。如果这些Consumer运行正常，这种情况就是我们想要的结果，这也是避免重复读消费数据的唯一办法。但是如果由于节点或者程序故障造成Consumer异常退出时，你需要能够释放这些锁，以便这些partition可以被安排到其他健康的Consumer上。</p>
<p>Kafka的group coordination protocol通过心跳机制来解决这个问题（Consumer通过心跳机制来实现持有锁和释放锁），在每一次rebalance之后，当前group中的所有Consumer都会定期向group的coordinator发送心跳信息，如果可以收到这个Consumer的心跳信息，就证明这个Consumer是正常的。一旦收到心跳信息，这个coordinator会重新开始计时。如果定时到了而还没有收到心跳信息，coordinator将会把这个consumer标记为dead，并且会向group的其他成员发送信号，这样就会进行rebalance操作，从而重新对这些partition进行分配。定时的时长就是session 时长，它可以通过客户端的<code>session.timeout.ms</code>这个参数来设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"60000"</span>);</div></pre></td></tr></table></figure>
<p>session时长机制可以确保如果遇到节点或者应用崩亏、或者网络把consumer从group中隔离的情况，锁会被释放。但是，通常应用失败的情况处理起来有点麻烦，因为即使Consumer仍然向coordinator发送心跳信息也不能证明应用是正常运行的。</p>
<p>Consumer的poll循环是被设置为解决这个问题，当你调用<code>poll</code>方法或者其他的阻塞的API时所有的网络IO就已经完成。而且Consumer并不会在后台调用任何其他线程，这就意味着心跳信息只是在调用<code>poll</code>方法时发送给coordinator的。如果因为处理代码的逻辑部分抛出异常或者下游系统崩溃而造成应用停止<code>poll</code>方法调用，那么也会造成没有任何心跳被发送，然后session定时就会超时，这个group就会进行rebalance操作。</p>
<p>如果一个consumer在给定的时间内没有发送心跳信息，这种机制就会被触发一个虚假的rebalance操作。当然可以通过将定时设置足够大来避免这种情况的发生，它默认的时长是30s，但是它没有必要的将时长设置高达几分钟。设置为更长时长的一个问题就是它需要花费更多的时间来发现失败的Consumer。</p>
<h1 id="Delivery-Semantics：可靠的消息传递"><a href="#Delivery-Semantics：可靠的消息传递" class="headerlink" title="Delivery Semantics：可靠的消息传递"></a>Delivery Semantics：可靠的消息传递</h1><p>当一个consumer group刚开始被创建的时候，最初的offset是通过<code>auto.offset.reset</code>配置项来进行设置的。一旦Consumer开始处理数据，它根据应用的需要来定期地对offset进行commit。在每一次的rebalance之后，group会将这个offset将被设置为<code>Last Committed Offset</code>。但如果consumer在对已经处理过的message进行commit之前挂掉了，另外一个Consumer最终会重复处理这些已经处理但未commit的数据。应用中对offset进行commit越频繁，在一次崩溃后你重复消费的数据就会越少。</p>
<p>在前面的例子中，我们都已经设置了自动提交机制，当把<code>enable.auto.commit</code>设置为<code>true</code>（default）时，Consumer会周期性地自动触发的offset commit机制，这个时长可以通过<code>auto.commit.interval.ms</code>来进行配置。通过减少这个间隔，我们可以限制当崩溃发生时Consumer重新处理的数据量。</p>
<p>如果要使用consumer的commit API，首先需要在配置文件中将<code>enable.auto.commit</code>设置为false，来禁止自动commit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>);</div></pre></td></tr></table></figure>
<p>这个commit API使用起来非常简单，难点在于如何与poll循环配合使用。下面的例子，主体中包含了commit细节实现的完整的poll循环。调用同步commit的API是处理手动提交的最简单的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用无参的<code>commitSync</code>API进行commit的offset是在调用<code>poll</code>后返回的，因为是同步commit，所以这个调用将会被一直block直到commit成功或者因为不可恢复的错误而失败。处理过程中，需要特别注意的是message处理的时间大于session时长的这种情况，如果这种情况发生，coordinator就会把这个consumer踢出这个group，它会导致抛出<code>CommitFailedException</code>异常。应用程序应该能够处理这种错误，并对由于消费自从上一次成功提交后的message造成的变化进行回滚操作。</p>
<p>一般情况下，你应该确保message被成功处理后，这个offset被commit了。但是如果在commit被发送之前consumer挂掉了，然后这些messages就会被重复处理。如果这个commit机制保证<code>Last Committed Offset</code>不会超过<code>Current Position</code>（如图2所示，上图，非下图），然后系统就会保证<strong>at least once</strong>消息传递机制。</p>
<p><img src="/images/kafka/consumer-figure3.png" alt="consumer commit offset"></p>
<p>通过改变commit机制来保证<code>Current Position</code>不会超过<code>Last Committed Offset</code>，如上图所示，你将会得到<strong>at most once</strong>消息传递保证。如果在<code>Current Position</code>赶上<code>Last Committed Offset</code>之前consumer挂掉了，这段时间内的所有messages都会丢失，但是可以确定是没有消息会处理超过一次。为了实现这个机制，我们只需要改变commit和消息处理的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    consumer.commitSync();</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要注意的是，如果使用<strong>默认的自动commit机制，系统是保证<code>at least once</code>消息处理</strong>，因为offset是在这些messages被应用处理后才进行commit的。在最糟糕的情况下，系统不得不重新处理的消息数量是由自动commit的间隔决定的（可以通过<code>auto.commit.interval.ms</code>设置）。</p>
<blockquote>
<p>思考：为什么kafka不能保证exactly once？</p>
</blockquote>
<p>通过应用commit API，你可以对重复处理的消息量进行更细的控制，在更极端的情况下，你甚至可以在每一条消息被处理后都进行commit，如下面的例子所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line">        consumer.commitSync(Collections.singletonMap(record.partition(), <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>)));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">      <span class="comment">// application specific failure handling</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们调用<code>commitSync</code>方法通过对明确的offset进行commit，要注意的是，要进行commit的offset应该是应用将要读取的下一条消息的offset。当<code>commitSync</code>方法被无参调用时，这个consumer对应用返回的<code>Last Offset（+1）</code>进行commit，但是在这里并不能使用，因为我们不允许<code>The Committed Position</code>超过我们实际的处理位置（<code>Current Position</code>）。</p>
<p>由于处理线程在每次进行commit请求并等待服务器返回这个过程中需要进行加锁，很明显对于大多数的应用场景，这种设计并不适用，这种设计会严重影响到consumer的吞吐量。更合理的设计是每接收N条消息后再进行commit，为了更高的吞吐量N的值可以进行调整。</p>
<p>本例中<code>commitSync</code>方法的参数是一个map的数据结构，key为topic partition，value为<code>OffsetAndMetadata</code>的实例。Commit API允许在每次commit时包含一些额外的元数据信息，这些数据信息可以是record进行commit的时间、要发送的host、或者应用程序中需要的任何其他信息，在本例中，我们并没有添加这个额外信息。</p>
<p>相比于对每接收一条message就进行commit，一个更加合理的机制是当你处理完每个partition的数据后进行commit offset。<code>ConsumerRecords</code>集合类提供了获取它内部每个partition集合以及每个partition内数据的方法。下面的例子详细描述这种机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</div><div class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</div><div class="line">      List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</div><div class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords)</div><div class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">      <span class="keyword">long</span> lastoffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</div><div class="line">      consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastoffset + <span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>截止到目前为止，我们主要研究的是同步commit的API，但是consumer也提供了异步提交的API——<code>commitAsync</code>。使用异步commit一般情况下会提高系统的吞吐量，因为应用可以在commit结果还未返回时就能开始处理下一批的message。但是你可能在之后才会发现commit失败了，这是需要开发者进行权衡。下面的例子是异步commit的基本用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">while</span> (running) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</div><div class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</div><div class="line"></div><div class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="comment">// application specific failure handling</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在本例中，在<code>commitAsync</code>中我们提供了回调方法，这个方法只会在commit完成后（不管成功还是失败）才会被consumer触发。如果你不需要这个设置，你也可以使用无参的<code>commitAsync</code>API。</p>
<blockquote>
<p>思考：在进行commit时，如果commit失败，consumer会怎么处理，同步与异步的处理过程是一样的吗？</p>
</blockquote>
<h1 id="Consumer-Group-Inspection：consumer-group查看"><a href="#Consumer-Group-Inspection：consumer-group查看" class="headerlink" title="Consumer Group Inspection：consumer group查看"></a>Consumer Group Inspection：consumer group查看</h1><p>当一个consuemr group是active，你可以通过在命令行运行<code>consumer-groups.sh</code>脚本来查看partition assignment和group消费情况，这个脚本存放在Kafka的<code>bin</code>目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bin/kafka-consumer-groups.sh --new-consumer --describe --group consumer-tutorial-group --bootstrap-server localhost:9092</span></div></pre></td></tr></table></figure>
<p>输出的结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GROUP, TOPIC, PARTITION, CURRENT OFFSET, LOG END OFFSET, LAG, OWNER</div><div class="line">consumer-tutorial-group, consumer-tutorial, 0, 6667, 6667, 0, consumer-1_/127.0.0.1</div><div class="line">consumer-tutorial-group, consumer-tutorial, 1, 6667, 6667, 0, consumer-2_/127.0.0.1</div><div class="line">consumer-tutorial-group, consumer-tutorial, 2, 6666, 6666, 0, consumer-3_/127.0.0.1</div></pre></td></tr></table></figure>
<p>上面的结果展示了这个consumer group的partition分配以及哪个consumer实例消费这个partition，还有<code>Last Committed Offset</code>（这里也可以认为是<code>Current Offset</code>）。每个partition的lag就是这个partition的最后offset与<code>Last Committed Offset</code>的差值。Administrators会一直进行监控以确保consuemr group能跟得上producers。</p>
<h1 id="Using-Manual-Assignment：使用手动的assign"><a href="#Using-Manual-Assignment：使用手动的assign" class="headerlink" title="Using Manual Assignment：使用手动的assign"></a>Using Manual Assignment：使用手动的assign</h1><p>正如本文开始所述的一样，新的Consumer实现了对那些不需要group的场景进行更细粒度的控制，对这种场景的支持是建议使用新Consumer API的重要原因之一。旧的<code>simple consumer</code>虽然也提供这样的设计，但是却需要你自己做很多的容错处理。而新的Consumer API，你只需要提供了你需要读取的topic的partition，然后就可以开始读取数据，其他的东西Consumer会帮你处理。</p>
<p>下面的例子展示了如何使用<code>partitionsFor</code> API来分配安排一个topic的所有partition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (PartitionInfo partition : consumer.partitionsFor(topic))</div><div class="line">  partitions.add(<span class="keyword">new</span> TopicPartition(topic, partition.partition()));</div><div class="line">consumer.assign(partitions);</div></pre></td></tr></table></figure>
<p>和<code>subscribe</code>方法相似，调用<code>assign</code>方法时必须传入consuemr要读取的所有parition的集合，一旦partition被分配了，poll循环部分就与前面的过程基本一样。</p>
<p>有一点需要的注意的是，不管是一个simple consumer还是一个consumer group，所有offset的commit都必须经过<strong>group coordinator</strong>。因此，如果你需要进行commit，你必须设置一个合适的<code>group.id</code>，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个<code>CommitFailedException</code>异常。但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</p>
<h1 id="Conclusion：结论"><a href="#Conclusion：结论" class="headerlink" title="Conclusion：结论"></a>Conclusion：结论</h1><p>新的Consumer给Kafka社区带了很多的好处，比如，简洁的API、更好的安全性和对ZK更少的依赖。本文介绍了new consumer的基本用法，并注重于poll循环模型以及使用commit API来控制传递机制。虽然还有很多需要讨论的地方，但是本文对于基本的使用是足够了。尽管新的comsumer还在开发中，但是我们仍然鼓励你去尝试使用。使用中如果遇到什么问题，欢迎通过邮件告诉我们.</p>
<hr>
<p>参考</p>
<ul>
<li><a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac常用软件及环境配置]]></title>
      <url>http://wangzzu.github.io/2016/07/09/mac-software/</url>
      <content type="html"><![CDATA[<p>近段时间因为在公司实习，公司提供的电脑都是Mac，还给发了一台全新的Mac pro，刚开始用的时候有很多不习惯的地方，但是用了几天之后就感觉Mac真的爽到爆啊，本篇文章就记录一下自己感觉在Mac上用到的一些不错的软件，以及Mac下一些常用编程工具的配置安装方法，这样也方便自己以后查看，本篇文章会一直保持更新。</p>
<h1 id="Mac基本配置"><a href="#Mac基本配置" class="headerlink" title="Mac基本配置"></a>Mac基本配置</h1><p>推荐一些Mac下常用的软件</p>
<ul>
<li>笔记：<a href="https://www.yinxiang.com/download/?offer=www_menu" target="_blank" rel="external">Evernote</a>，<a href="http://www.jianshu.com/p/a26fffc3c746" target="_blank" rel="external">Evernote（印象笔记）用户如何使用Markdown</a>；</li>
<li>MarkDown：<a href="http://zh.mweb.im/" target="_blank" rel="external">MWeb</a>、<a href="http://25.io/mou/" target="_blank" rel="external">Mou</a>、Ulysses、<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">MacDown</a>；</li>
<li>编辑器：<a href="https://atom.io/" target="_blank" rel="external">Atom</a>；</li>
<li>思维导图：<a href="http://www.xmindchina.net/" target="_blank" rel="external">XMid</a>、SimpleMind；</li>
<li>NTFS挂载：<a href="http://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="external">Tuxera NTFS</a>（<a href="http://www.orsoon.com/Mac/129966.html" target="_blank" rel="external">序列号</a>，建议买正版）；</li>
<li>播放器：MPV（mpv安装及快捷键操作参考<a href="https://intxt.net/meet-mpv/" target="_blank" rel="external">mpv安装</a>一文，<a href="https://mpv.io/installation/" target="_blank" rel="external">mpv安装地址</a>）；</li>
<li>浏览器：chrome，必须是chrome；</li>
<li>上网：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/" target="_blank" rel="external">shadowsocks</a>；</li>
<li>英文写作检查的软件：1Checker;</li>
<li><a href="http://www.jianshu.com/p/c98c73704ff6" target="_blank" rel="external">Mac vim高亮设置</a>;</li>
</ul>
<p>博文推荐</p>
<ul>
<li><a href="http://www.jianshu.com/p/19e8ffd91576" target="_blank" rel="external">Mac下开发常用的必备软件</a>，这里有office、ps等工具的安装；</li>
<li><a href="http://www.iphoneba.net/231.html" target="_blank" rel="external">Adobe After Effects CC 2015 Mac</a>，推荐使用正版；</li>
<li><a href="http://www.waitsun.com/lightroom-cc-6-0.html" target="_blank" rel="external">Adobe Photoshop Lightroom CC for Mac 6.0 优秀的图像后期处理软件</a>，推荐使用正版；</li>
</ul>
<h2 id="mpv-的一些常用快捷键"><a href="#mpv-的一些常用快捷键" class="headerlink" title="mpv 的一些常用快捷键"></a>mpv 的一些常用快捷键</h2><p>mpv 是 mac 下使用非常舒服的一款视频播放器，下面是一些常用的快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SPACE</td>
<td>暂停/播放切换</td>
</tr>
<tr>
<td>UP</td>
<td>快进 60 秒</td>
</tr>
<tr>
<td>DOWN</td>
<td>回退 60 秒</td>
</tr>
<tr>
<td>LEFT</td>
<td>回退 5 秒</td>
</tr>
<tr>
<td>RIGHT</td>
<td>快进 5 秒</td>
</tr>
<tr>
<td><code>]</code></td>
<td>加速播放</td>
</tr>
<tr>
<td><code>[</code></td>
<td>减速播放</td>
</tr>
<tr>
<td>j</td>
<td>循环选择字幕</td>
</tr>
<tr>
<td>J</td>
<td>反向循环选择字幕</td>
</tr>
<tr>
<td>#</td>
<td>循环切换音轨</td>
</tr>
<tr>
<td>f</td>
<td>切换全屏状态</td>
</tr>
<tr>
<td>T</td>
<td>切换视频窗口是否总在最前</td>
</tr>
<tr>
<td>s</td>
<td>视频截图，包含字幕</td>
</tr>
<tr>
<td>S</td>
<td>视频截图，不带字幕</td>
</tr>
<tr>
<td>Alt+s</td>
<td>自动逐帧视频截图，再按一次停止截图</td>
</tr>
</tbody>
</table>
<h2 id="chrome常用配置"><a href="#chrome常用配置" class="headerlink" title="chrome常用配置"></a>chrome常用配置</h2><p>chrome既方便又强大，于是乎，不得不单独弄出一小章来介绍。</p>
<h3 id="常用小插件"><a href="#常用小插件" class="headerlink" title="常用小插件"></a>常用小插件</h3><p>对工程师来说，可以参考这篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402064553&amp;idx=1&amp;sn=4bc95ed03916f87cc8dfd17baed54f24" target="_blank" rel="external">吐血推荐珍藏的Chrome插件</a>。</p>
<ul>
<li>代理：<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">switchyomega</a>；</li>
<li>流程图：<a href="https://chrome.google.com/webstore/detail/gliffy-diagrams/bhmicilclplefnflapjmnngmkkkkpfad" target="_blank" rel="external">gliffy</a>;</li>
<li>MarkDown：<a href="chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html" target="_blank" rel="external">MarkDown Here</a>;</li>
<li>词典：<a href="https://chrome.google.com/webstore/detail/%E7%BF%B0%E6%9E%97%E8%8B%B1%E6%B1%89%E5%8F%8C%E8%A7%A3%E8%AF%8D%E5%85%B8/fidicgekecdkdmkjghdgadgdmcfodfid" target="_blank" rel="external">翰林英汉双解词典</a>;</li>
<li>Momentum：使用这个插件每次打开一个 Tab 时，不再是一个空白页面，而是一副精美的图片；</li>
<li>Alexa Traffic Rank：Alexa排名是指网站的世界排名，非常有权威。直接主流网站或博客绝对是有Alexa排名的，我们在浏览博客或者网站的时候就可以通过Alexa排名知晓该网站的流行程度，适用于经常看博客的人，装了这个插件一键查看网站排名；</li>
<li>Isometric Contributions：一个小玩意，可以让在 GitHub 上的 commit 像盖楼一样的展示，很有趣；</li>
<li>Avatars for Github：顾名思义，默认我们在 GitHub 主页动态只能看到 id 的，而安装了这个插件就可以看到 GitHub 头像了，让你一眼就能知道是谁；</li>
</ul>
<h1 id="Mac下常用快捷键"><a href="#Mac下常用快捷键" class="headerlink" title="Mac下常用快捷键"></a>Mac下常用快捷键</h1><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页刷新</td>
<td>command+r</td>
</tr>
<tr>
<td>自定义截图</td>
<td>command+shfit+4</td>
</tr>
<tr>
<td>显示器</td>
<td>control+shift+电源键</td>
</tr>
<tr>
<td>将文本编辑器由带格式变为存文本</td>
<td>command+shfit+t</td>
</tr>
<tr>
<td>EverNote无格式粘贴</td>
<td>command+shift+option+v</td>
</tr>
<tr>
<td>文件/文件夹重命名</td>
<td>选中该文件/文件夹，点击回车键</td>
</tr>
</tbody>
</table>
<p>快捷键可以参考<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">Mac键盘快捷键</a>一文.</p>
<p>这里有一篇Bash下的快捷键的wiki，<a href="https://github.com/hokein/Wiki/wiki/Bash-Shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" target="_blank" rel="external">Bash Shell常用快捷键</a>，可以方便查找bash下的常用快捷键。</p>
<p>其他博文推荐：</p>
<ol>
<li><a href="http://wuchong.me/blog/2014/06/29/the-first-experience-of-mac/" target="_blank" rel="external">Mac上手体验</a></li>
<li><a href="http://www.macx.cn/thread-2133104-1-1.html" target="_blank" rel="external">Mac快速锁屏</a></li>
<li><a href="https://support.apple.com/kb/PH18669?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="external">Mac锁屏后设置需要输密码</a></li>
<li><a href="http://www.hangge.com/blog/cache/detail_540.html" target="_blank" rel="external">Mac下文本编辑器</a></li>
<li><a href="http://popozhu.github.io/2013/09/24/mac%E5%85%89%E6%A0%87%E9%80%9F%E5%BA%A6%E8%B0%83%E6%95%B4/" target="_blank" rel="external">Mac光标速度调整</a></li>
</ol>
<h1 id="Mac终端iTerm2配置"><a href="#Mac终端iTerm2配置" class="headerlink" title="Mac终端iTerm2配置"></a>Mac终端iTerm2配置</h1><p>Mac下的iTerm2用着真的超爽</p>
<h2 id="iTerm2下载安装"><a href="#iTerm2下载安装" class="headerlink" title="iTerm2下载安装"></a>iTerm2下载安装</h2><p><a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2下载</a></p>
<p>下载完直接安装即可。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</div></pre></td></tr></table></figure>
<p>安装成功后的效果如下图所示</p>
<p><img src="/images/mac/iterm-1.png" alt="zsh"></p>
<h2 id="安装powerline"><a href="#安装powerline" class="headerlink" title="安装powerline"></a>安装powerline</h2><p>关于powerline的介绍可以参考<a href="http://cenalulu.github.io/linux/mac-powerline/" target="_blank" rel="external">为Bash和VIM配置一个美观奢华的状态提示栏</a>这篇文章，powerline就是一个全局的状态提示栏，安装方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先安装pip指令</span></div><div class="line">sudo easy_install pip</div><div class="line"><span class="comment"># 安装管道</span></div><div class="line">pip install powerline-status</div></pre></td></tr></table></figure>
<p>在第二步安装时，出现了这个错误，<code>error: [Errno 1] Operation not permitted: u&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/powerline&#39;</code>，如下图所示</p>
<p><img src="/images/mac/iterm-2.png" alt="error"></p>
<p>这个问题出现的原因，因为没有安装python，解决办法如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.安装Homebrew</span></div><div class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div><div class="line"><span class="comment"># 2.配置python</span></div><div class="line">brew install python</div><div class="line"><span class="comment"># 3.安装管道</span></div><div class="line">pip install --user powerline-status</div></pre></td></tr></table></figure>
<p>powerline的安装可以参考：</p>
<ol>
<li>brew安装参考<a href="http://brew.sh/" target="_blank" rel="external">官网</a></li>
<li>PowerLine安装参考<a href="http://powerline.readthedocs.io/en/latest/installation/osx.html" target="_blank" rel="external">官网</a></li>
</ol>
<h2 id="安装字体库"><a href="#安装字体库" class="headerlink" title="安装字体库"></a>安装字体库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载字体库</span></div><div class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git</div><div class="line"><span class="comment"># 安装所有字体</span></div><div class="line"><span class="built_in">cd</span> fonts</div><div class="line">./install.sh</div></pre></td></tr></table></figure>
<p>安装成功后，如下图所示</p>
<p><img src="/images/mac/iterm-3.png" alt="font"></p>
<p>安装完成后会提示所有的字体均已下载到<code>/Users/superdanny/Library/Fonts</code>路径。</p>
<h2 id="字体设置、配色方案设置及主题设置"><a href="#字体设置、配色方案设置及主题设置" class="headerlink" title="字体设置、配色方案设置及主题设置"></a>字体设置、配色方案设置及主题设置</h2><h3 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h3><p>安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的<code>Regular Font</code>和<code>Non-ASCII Font</code>的字体都设置成powerline的字体，我这里设置的字体是<code>14pt Meslo LG S DZ Regular for Powerline</code>.</p>
<p><img src="/images/mac/iterm-4.png" alt="font-setting"></p>
<h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><h4 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h4><p>需要先在github下下载solarized工程，<a href="https://github.com/altercation/solarized" target="_blank" rel="external">solarized github地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/altercation/solarized</div></pre></td></tr></table></figure>
<p>然后进入刚刚下载的工程的<code>solarized/iterm2-colors-solarized</code> 下双击 <code>Solarized Dark.itermcolors</code> 和 <code>Solarized Light.itermcolors</code> 两个文件就可以把配置文件导入到 iTerm2 里.</p>
<h4 id="配置配色方案"><a href="#配置配色方案" class="headerlink" title="配置配色方案"></a>配置配色方案</h4><p>通过load presets选择刚刚安装的配色主题即可</p>
<p><img src="/images/mac/iterm-5.png" alt="color"></p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>这里使用的是agnoster主题，<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="external">oh-my-zsh-agnoster-fcamblor Github地址</a></p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.下载主题</span></div><div class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor</div><div class="line"><span class="comment"># 2.安装主题</span></div><div class="line"><span class="built_in">cd</span> oh-my-zsh-agnoster-fcamblor</div><div class="line">./install</div></pre></td></tr></table></figure>
<h4 id="设置该主题"><a href="#设置该主题" class="headerlink" title="设置该主题"></a>设置该主题</h4><p>编辑<code>~/.zshrc</code>文件，然后将<code>ZSH_THEME</code>后面的字段改为<code>agnoster</code>。<code>ZSH_THEME=&quot;agnoster&quot;</code>（agnoster即为要设置的主题）.</p>
<h4 id="增加指令高亮效果"><a href="#增加指令高亮效果" class="headerlink" title="增加指令高亮效果"></a>增加指令高亮效果</h4><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮，这里需要先下载<code>zsh-syntax-highlighting</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.下载工程项目</span></div><div class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-syntax-highlighting.git</div><div class="line"><span class="comment"># 2.打开.zshrc文件，在最后添加下面内容</span></div><div class="line"><span class="built_in">source</span> /Users/matt/git//zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</div><div class="line"><span class="comment"># 3.打开.zshrc文件，在最后面添加下面内容</span></div><div class="line">plugins=(zsh-syntax-highlighting)</div></pre></td></tr></table></figure>
<p>配置完之后效果如下图所示</p>
<p><img src="/images/mac/iterm-6.png" alt="end"></p>
<h2 id="iTerm2快捷键"><a href="#iTerm2快捷键" class="headerlink" title="iTerm2快捷键"></a>iTerm2快捷键</h2><p>iTerm2快捷键的使用可以参考<a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a>这篇文章，这里给出一些常用的命令</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建标签</td>
<td>command + t</td>
</tr>
<tr>
<td>关闭标签</td>
<td>command + w</td>
</tr>
<tr>
<td>切换标签</td>
<td>command + 数字 command + 左右方向键</td>
</tr>
<tr>
<td>切换全屏</td>
<td>command + enter</td>
</tr>
<tr>
<td>查找</td>
<td>command +f</td>
</tr>
<tr>
<td>垂直分屏</td>
<td>command + d</td>
</tr>
<tr>
<td>水平分屏</td>
<td>command + shift + d</td>
</tr>
<tr>
<td>切换屏幕</td>
<td>command + option + 方向键 command + [ 或 command + ]</td>
</tr>
<tr>
<td>查看历史命令</td>
<td>command + ;</td>
</tr>
<tr>
<td>查看剪贴板历史</td>
<td>command + shift + h</td>
</tr>
<tr>
<td>清除当前行</td>
<td>ctrl + u</td>
</tr>
<tr>
<td>到行首</td>
<td>ctrl + a</td>
</tr>
<tr>
<td>到行尾</td>
<td>ctrl + e</td>
</tr>
<tr>
<td>前进后退</td>
<td>ctrl + f/b (相当于左右方向键)</td>
</tr>
<tr>
<td>上一条命令</td>
<td>ctrl + p</td>
</tr>
<tr>
<td>搜索命令历史</td>
<td>ctrl + r</td>
</tr>
<tr>
<td>删除当前光标的字符</td>
<td>ctrl + d</td>
</tr>
<tr>
<td>删除光标之前的字符</td>
<td>ctrl + h</td>
</tr>
<tr>
<td>删除光标之前的单词</td>
<td>ctrl + w</td>
</tr>
<tr>
<td>删除到文本末尾</td>
<td>ctrl + k</td>
</tr>
<tr>
<td>交换光标处文本</td>
<td>ctrl + t</td>
</tr>
<tr>
<td>清屏1</td>
<td>command + r</td>
</tr>
<tr>
<td>清屏2</td>
<td>ctrl + l</td>
</tr>
</tbody>
</table>
<h1 id="编程环境配置"><a href="#编程环境配置" class="headerlink" title="编程环境配置"></a>编程环境配置</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一般情况下，可能需要安装多个版本的JDK，具体各个版本的下载，JDK7和JDK8可以在官网上直接下载，而JDK6的下载资源就比较难找了，可以参考<a href="http://www.codecate.com/code/archives/16" target="_blank" rel="external">Mac安装jdk1.6 1.7 1.8</a>这篇文章</p>
<p>下载安装完这三个版本的JDK之后，需要进行以下配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bash下是~/.bashrc文件</span></div><div class="line"><span class="built_in">export</span> JAVA_6_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/</div><div class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_7_HOME</span></div><div class="line"><span class="built_in">alias</span> jdk8=<span class="string">'export JAVA_HOME=$JAVA_8_HOME'</span></div><div class="line"><span class="built_in">alias</span> jdk7=<span class="string">'export JAVA_HOME=$JAVA_7_HOME'</span></div><div class="line"><span class="built_in">alias</span> jdk6=<span class="string">'export JAVA_HOME=$JAVA_6_HOME'</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</div></pre></td></tr></table></figure>
<h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><h3 id="idea安装"><a href="#idea安装" class="headerlink" title="idea安装"></a>idea安装</h3><p><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">idea下载地址</a></p>
<p>如果下载的版本是2016.1版，这里有一个<a href="http://aiyougege.com/articles/022711.html" target="_blank" rel="external">激活码</a>，不过推荐购买正版，免费版推荐社区版，一般的开发也就够用了。</p>
<h3 id="Google-Java编程规范配置"><a href="#Google-Java编程规范配置" class="headerlink" title="Google Java编程规范配置"></a>Google Java编程规范配置</h3><p>参考<a href="http://zacard.net/2016/04/11/idea-google-code-style/" target="_blank" rel="external">Idea直接导入xml文件</a>一文。</p>
<p>idea可以支持自定义的code style，并且google code style也提供了对idea的xml配置，直接导入就可以在idea中使用google提倡的code style了。</p>
<p>使用方法：</p>
<ol>
<li>从github上clone <a href="https://github.com/google/styleguide" target="_blank" rel="external">Google Style GitHub</a>；</li>
<li>复制对应的xml配置（如intellij-java-google-style.xml）到“~/Library/Preferences/IDEA/codestyles/”下</li>
<li>重启idea在Prefrence-&gt;Editor—&gt;Code Stytle-&gt;Java,选择GoogleStyle即可</li>
</ol>
<p>mac下格式化代码的快捷键： <code>command+alt+L</code></p>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>需要配置的内容主要有以下几项：</p>
<ol>
<li>自动行号显示</li>
<li>字体</li>
<li>SDK设置（就是jdk，scala等设置）</li>
<li>maven设置</li>
<li>快捷键</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>常用的快捷键如下表所示</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看所选代码的源码</td>
<td>cmd + ↓</td>
</tr>
<tr>
<td>查看maven依赖</td>
<td>opt+shift+cmd+U</td>
</tr>
<tr>
<td>智能补齐代码</td>
<td>opt + enter</td>
</tr>
<tr>
<td>生成一些常用方法，如：toString、get 等</td>
<td>control + enter</td>
</tr>
</tbody>
</table>
<p>关于快捷键可以参考<a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html" target="_blank" rel="external">Mac下idea快捷键</a>一文。</p>
<ul>
<li><a href="http://baowp.iteye.com/blog/1989575" target="_blank" rel="external">Mac下Idea打开Maven的jar包依赖图</a></li>
</ul>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="external">PyCharm下载地址</a></p>
<p>2016版的可以使用<a href="http://blog.csdn.net/jiang314/article/details/51680072" target="_blank" rel="external">注册码</a>进行破解，不过推荐购买正版。</p>
<h1 id="其他常用命令安装"><a href="#其他常用命令安装" class="headerlink" title="其他常用命令安装"></a>其他常用命令安装</h1><h2 id="tree命令安装"><a href="#tree命令安装" class="headerlink" title="tree命令安装"></a>tree命令安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 需要先安装HomeBrew</span></div><div class="line">brew install tree</div></pre></td></tr></table></figure>
<h1 id="Mac下遇到的其他问题"><a href="#Mac下遇到的其他问题" class="headerlink" title="Mac下遇到的其他问题"></a>Mac下遇到的其他问题</h1><h2 id="bashrc每次打开iterm都要重新加载"><a href="#bashrc每次打开iterm都要重新加载" class="headerlink" title="~/.bashrc每次打开iterm都要重新加载"></a>~/.bashrc每次打开iterm都要重新加载</h2><p>参考<a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">文章</a></p>
<p>原因：使用的zsh，而不是bash，所以zsh没有义务去加载<code>~/.bashrc</code>文件，zsh下别名一般放置到<code>~/.zshrc</code>文件中。</p>
<p>解决办法：在<code>~/.zshrc</code>文件的最后添加<code>source ~/.bashrc</code>.</p>
<h2 id="修改电脑名的方法"><a href="#修改电脑名的方法" class="headerlink" title="修改电脑名的方法"></a>修改电脑名的方法</h2><p>有人可能感觉跟我一样有强迫症，看到电脑名太长影响终端的显示，就想着怎么修改一下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行下面命令“mac”是你想要改的电脑名称</span></div><div class="line">sudo scutil --set HostName mac</div></pre></td></tr></table></figure>
<blockquote>
<p>注：关闭终端之后，重新打开终端就会生效。</p>
</blockquote>
<h2 id="修改电脑名导致的错误"><a href="#修改电脑名导致的错误" class="headerlink" title="修改电脑名导致的错误"></a>修改电脑名导致的错误</h2><p>使用上面的方法修改电脑名，可能会导致一个这样的错误.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 其中 mac 为自己设置的电脑名，不同的电脑名显示不一样</span></div><div class="line">java.net.UnknownHostException: mac: mac: nodename nor servname provided, or not known</div></pre></td></tr></table></figure>
<p>这个问题和路由映射有关系，处理方法就是对 mac 做个DNS解析指向127.0.0.1.</p>
<p>修改文件 <code>/etc/hosts</code>，在里面增加对 127.0.0.1 的解析.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1    mac    localhost</div></pre></td></tr></table></figure>
<p>保存生效后，就没有问题了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="external">iTerm 2 &amp;&amp; Oh My Zsh</a></li>
<li><a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a></li>
<li><a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">为什么我的Mac不加载/etc/bashrc文件呢？</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis简单介绍]]></title>
      <url>http://wangzzu.github.io/2016/06/06/redis-introduce/</url>
      <content type="html"><![CDATA[<p>本文是根据我在<a href="https://www.shiyanlou.com/courses/106" target="_blank" rel="external">实验楼-Redis基础教程</a>中学习的总结，简单讲述了一下Redis的安装和使用。</p>
<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括 <code>lists</code>, <code>sets</code>, <code>ordered sets</code> 以及 <code>hashes</code> ，当然还有和<code>Memcached</code>一样的 strings结构。Redis当然还包括了对这些数据结构的丰富操作。</p>
<p>Redis常被称作是一款数据结构服务器（<code>data structure server</code>）。Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（<code>append</code>）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p>
<h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><ul>
<li>性能极高：Redis能支持超过 100K+ 每秒的读写频率。</li>
<li>丰富的数据类型：Redis支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li>
<li>原子：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性：Redis还支持 <code>publish/subscribe</code>, 通知, key 过期等等特性。</li>
</ul>
<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>在<a href="http://redis.io/" target="_blank" rel="external">Redis官网</a>中下载最新的稳定版，这里我选用的是<code>3.2.0</code>稳定版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 解压按照包</div><div class="line">$ tar xvfz redis-3.2.0.tar.gz</div><div class="line"></div><div class="line"># 编译</div><div class="line">$ cd redis-3.2.0</div><div class="line">$ sudo make</div><div class="line">$ sudo make install</div><div class="line"></div><div class="line"># 测试</div><div class="line">$ make test</div></pre></td></tr></table></figure>
<p>测试成功的结果如下图所示：</p>
<p><img src="/images/redis/test.png" alt="test"></p>
<h1 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h1><h2 id="启动与配置"><a href="#启动与配置" class="headerlink" title="启动与配置"></a>启动与配置</h2><p>在 Redis 安装完成后，注意一些重要的文件，可用 ls 命令查看。</p>
<ul>
<li>服务端的启动脚本：<code>src/redis-server</code>；</li>
<li>客户端的启动脚本：<code>src/redis-cls</code>；</li>
<li>默认配置文件：<code>redis.conf</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动redis服务器</span></div><div class="line">$ ./src/redis-server</div></pre></td></tr></table></figure>
<p>启动成功结果如下图：</p>
<p><img src="/images/redis/start.png" alt="start"></p>
<blockquote>
<p>说明： 从上图中，可以发现启动的端口为缺省的<strong>6379</strong>. 用户可以在启动的时候，指定具体的配置文件，并在其中指定启动的端口。</p>
</blockquote>
<h2 id="配置-PATH"><a href="#配置-PATH" class="headerlink" title="配置$PATH"></a>配置$PATH</h2><p>然后将可执行文件放置在$PATH环境目录下，便于以后使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo　cp src/redis-server /usr/<span class="built_in">local</span>/bin/</div><div class="line">$　sudo cp src/redis-cli /usr/<span class="built_in">local</span>/bin/</div></pre></td></tr></table></figure>
<h2 id="查看Redis"><a href="#查看Redis" class="headerlink" title="查看Redis"></a>查看Redis</h2><p>再启动玩Redis服务器之后，可以通过以下命令来查看Redis运行情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep redis</div><div class="line"><span class="comment"># 通过启动命令检查Redis服务器状态</span></div><div class="line">$ netstat -nlt|grep 6379</div></pre></td></tr></table></figure>
<p><img src="/images/redis/state.png" alt="state"></p>
<h2 id="启动Redis-client"><a href="#启动Redis-client" class="headerlink" title="启动Redis-client"></a>启动Redis-client</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的<code>key-value</code> 存储器，正如本文开头所述Redis同时也是一种<code>data structures server</code>。传统的<code>key-value</code>是指支持使用一个<code>key</code>字符串来索引<code>value</code>字符串的存储，而Redis中，<code>value</code>不仅仅支持字符串，还支持更多的复杂结构，包括列表，集合，哈希表等。</p>
<p>在本小节中，我们一一讲解：Redis keys是采用<strong>二进制安全</strong>（这里的二进制安全可以理解为：只关心二进制化的字符串，不关心具体格式，只会严格的按照二进制的数据存取，并不会按照某种具体格式去解析，杜绝了出乱码的问题），这就意味着你可以使用任何二进制序列作为重点，从像”foo”可以联系一个 JPEG 文件。空字符串也是一个有效的密钥。</p>
<h2 id="Redis-strings"><a href="#Redis-strings" class="headerlink" title="Redis strings"></a>Redis strings</h2><p>字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。</p>
<p>这里启动<code>redis-cli</code>来看看Redis strings数据类型。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动服务器与客户端</span></div><div class="line">$ sudo service redis-server start</div><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># redis客户端下</span></div><div class="line">&gt; <span class="built_in">set</span> mykey somevalue</div><div class="line">&gt; get mykey</div></pre></td></tr></table></figure>
<p>如上例所示，可以<code>SET</code>和<code>GET</code>命令来创建和检索strings。注意,<code>set</code>命令将取代现有的任何已经存在的key。</p>
<p><code>SET</code>命令还有一个提供附加参数的选项,我们能够让<code>SET</code>命令只有在没有相同key的情况下成功，反之亦然，可以让<code>SET</code>命令在有相同key值得情况下成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey newval nx</div><div class="line">&gt; <span class="built_in">set</span> mykey newval xx</div></pre></td></tr></table></figure>
<p>即使string是Redis的基本类型，也可以对其进行一些有趣的操作，例如加法器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> counter 100</div><div class="line">&gt; incr counter</div><div class="line">&gt; incr counter</div><div class="line">&gt; incrby counter 50</div></pre></td></tr></table></figure>
<p><code>INCR</code>命令让the value 成为一个整数，运行一次<code>INCR</code>便+1。<code>INCRBY</code>命令便是一个加法运算。类似的命令如减法运算为： <code>DECR and DECRBY</code>。</p>
<p>Redis可以运用<code>MSET and MGET</code> 命令完成一次性的完成多个key-value的对应关系，使用<code>MGET</code>命令，Redis返回一个value数组。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mset a 10 b 20 c 30</div><div class="line">&gt; mget a b c</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/strings.png" alt="string"></p>
<h2 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p>
<ul>
<li><code>LPUSH</code> 命令插入一个新的元素导头部；</li>
<li><code>RPUSH</code>插入一个新元素导尾部.</li>
</ul>
<p>当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间中删除。</p>
<p><code>PUSH</code>一类的命令的返回值为list的长度。一些类表操作和结果的例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; rpush mylist A</div><div class="line">&gt; rpush mylist B</div><div class="line">&gt; lpush mylist first</div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>LRANGE</code> 利用了两个检索值，0表示list的开头第一个，-1表示list的倒数第一个，即最后一个。-2则便是list的倒数第二个，以此类推。</p>
</blockquote>
<p>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入list。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; rpush mylist 1 2 3 4 5 <span class="string">"foo bar"</span></div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<p>在Redis的命令操作中，还有一类重要的操作：<code>POP</code>，取出list元素。和<code>PUSH</code>操作类似，<code>POP</code>命令可以选择不同的方向取出元素.<code>POP</code>命令返回值为取出的元素。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; del mylist</div><div class="line">&gt; rpush mylist a b c</div><div class="line">&gt; rpop mylist</div><div class="line">&gt; lrange mylist 0 -1</div><div class="line">&gt; lpop mylist</div><div class="line">&gt; lrange mylist 0 -1</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/list.png" alt="list"></p>
<h2 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h2><p>Redis Hashes是字符串字段和字符串值之间的映射，因此他们是展现对象的完美数据类型。 (例如:一个有名，姓，年龄等等属性的用户)：一个带有一些字段的<code>hash</code>仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的Redis实例中。 哈希主要用来表现对象，他们有能力存储很多对象，因此你可以将哈希用于许多其他的任务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; hmset user:1000 username antirez birthyear 1977 verified 1</div><div class="line">&gt; hget user:1000 username</div><div class="line">&gt; hget user:1000 birthyear</div><div class="line">&gt; hgetall user:1000</div></pre></td></tr></table></figure>
<ul>
<li><code>HMSET</code>命令设置一个多域的hash表；</li>
<li><code>HGET</code>命令获取指定的单域；</li>
<li><code>HGETALL</code>命令获取指定key的所有信息；</li>
<li><code>HMGET</code>类似于<code>HGET</code>，只是返回一个value数组。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; hmget user:1000 username birthyear no-such-field</div></pre></td></tr></table></figure>
<p>同样可以根据需要对hash表的表项进行单独的操作，例如 <code>HINCRBY</code>， （原本birthyear 为1977，见上一图）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; hincrby user:1000 birthyear 10</div><div class="line">&gt; hincrby user:1000 birthyear 10</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/hash.png" alt="hash"></p>
<h2 id="Redis-无序集合"><a href="#Redis-无序集合" class="headerlink" title="Redis 无序集合"></a>Redis 无序集合</h2><p>Redis 集合（Set）是一个<strong>无序的字符串集合</strong>. 你可以以$O(1)$的时间复杂度 (无论集合中有多少元素时间复杂度都是常量）完成添加、删除，以及测试元素是否存在。 Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（<code>unions</code>）, 求交集（<code>intersections</code>），找出不同的元素（<code>differences of sets</code>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sadd myset 1 2 3</div><div class="line">&gt; smembers myset</div></pre></td></tr></table></figure>
<ul>
<li><code>SADD</code>命令产生一个无序集合，并返回集合的元素个数；</li>
<li><code>SMEMBER</code>用于查看集合；</li>
<li><code>SISMEMBER</code>用于查看集合是否存在，匹配项包括集合名和元素个数，匹配成功返回1，匹配失败返回0。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sismember myset 3</div><div class="line">&gt; sismember myset 30</div><div class="line">&gt; sismember mys 3</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set1.png" alt="set1"></p>
<h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>Redis有序集合与普通集合非常相似，是一个<strong>没有重复元素的字符串集合</strong>。不同之处是有序集合的没有成员都关联了一个<strong>评分</strong>，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。 使用有序集合你可以以非常快的速度（$O\log{N}$）添加，删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（<code>score</code>）或者次序（<code>position</code>）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。</p>
<p><code>ZADD</code>与<code>SADD</code>类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; zadd hackers 1940 <span class="string">"Alan Kay"</span></div><div class="line">&gt; zadd hackers 1957 <span class="string">"Sophie Wilson"</span></div><div class="line">&gt; zadd hackers 1953 <span class="string">"Richard Stallman"</span></div><div class="line">&gt; zadd hackers 1949 <span class="string">"Anita Borg"</span></div><div class="line">&gt; zadd hackers 1965 <span class="string">"Yukihiro Matsumoto"</span></div><div class="line">&gt; zadd hackers 1914 <span class="string">"Hedy Lamarr"</span></div><div class="line">&gt; zadd hackers 1916 <span class="string">"Claude Shannon"</span></div><div class="line">&gt; zadd hackers 1969 <span class="string">"Linus Torvalds"</span></div><div class="line">&gt; zadd hackers 1912 <span class="string">"Alan Turing"</span></div></pre></td></tr></table></figure>
<ul>
<li><code>ZRANGE</code>是查看正序的集合;</li>
<li><code>ZREVRANGE</code>是查看反序的集合。0表示集合第一个元素，-1表示集合的倒数第一个元素。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; zrange hackers 0 -1</div><div class="line">&gt; zrevrange hackers 0 -1</div></pre></td></tr></table></figure>
<p>使用<code>WITHSCORES</code> 参数返回记录值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; zrange hackers 0 -1 withscores</div></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set2.png" alt="set2"></p>
<h1 id="Redis系统管理"><a href="#Redis系统管理" class="headerlink" title="Redis系统管理"></a>Redis系统管理</h1><p>在Redis中，命令大小写不敏感。</p>
<h2 id="适合全体类型的常用命令"><a href="#适合全体类型的常用命令" class="headerlink" title="适合全体类型的常用命令"></a>适合全体类型的常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动服务器与客户端</span></div><div class="line">$ redis-server</div><div class="line">$ redis-cli</div></pre></td></tr></table></figure>
<h3 id="EXISTS-and-DEL"><a href="#EXISTS-and-DEL" class="headerlink" title="EXISTS and DEL"></a>EXISTS and DEL</h3><ul>
<li><code>EXISTS key</code> 判断一个key是否存在，存在返回 1;否则返回0;</li>
<li><code>DEL key</code> 删除某个key，或是一系列key，<code>DEL key1 key2 key3 key4</code>。成功返回1，失败返回0（key值不存在）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey hello</div><div class="line">&gt; exists mykey</div><div class="line"></div><div class="line">&gt; del mykey</div><div class="line">&gt; exists mykey</div></pre></td></tr></table></figure>
<p><img src="/images/redis/exist.png" alt="exist"></p>
<h3 id="TYPE-and-KEYS"><a href="#TYPE-and-KEYS" class="headerlink" title="TYPE and KEYS"></a>TYPE and KEYS</h3><ul>
<li><code>TYPE key</code>：返回某个key元素的数据类型 ( none:不存在,string:字符,list,set,zset,hash)，key不存在返回空。</li>
<li><code>KEYS key—pattern</code> ：返回匹配的key列表 (<code>KEYS foo*</code>:查找foo开头的keys)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> mykey x</div><div class="line">&gt; <span class="built_in">type</span> mykey</div><div class="line">&gt; keys my*</div><div class="line">&gt; del mykey</div><div class="line">&gt; keys my*</div><div class="line">&gt; <span class="built_in">type</span> mykey</div></pre></td></tr></table></figure>
<p><img src="/images/redis/type.png" alt="type"></p>
<h3 id="RANDOMKEY-and-CLEAR"><a href="#RANDOMKEY-and-CLEAR" class="headerlink" title="RANDOMKEY and CLEAR"></a>RANDOMKEY and CLEAR</h3><ul>
<li><code>RANDOMKEY</code> ： 随机获得一个已经存在的key，如果当前数据库为空，则返回空字符串</li>
<li><code>CLEAR</code> ：清除界面。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; randomkey</div><div class="line">&gt; clear</div></pre></td></tr></table></figure>
<h3 id="RENAME-and-RENAMENX"><a href="#RENAME-and-RENAMENX" class="headerlink" title="RENAME and RENAMENX"></a>RENAME and RENAMENX</h3><ul>
<li><code>RENAME oldname newname</code>：改key的名字，新键如果存在将被覆盖;</li>
<li><code>RENAMENX oldname newname</code>：更改key的名字，如果名字存在则更改失败.</li>
</ul>
<p>笔者randomkey结果为mylist，将此key值更名为newlist。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; randomkey</div><div class="line">&gt; rename mylist newlist</div><div class="line">&gt; exists mylist</div><div class="line">&gt; exists newlist</div></pre></td></tr></table></figure>
<p><img src="/images/redis/rename.png" alt="rename"></p>
<h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><p><code>DBSIZE</code> ：返回当前数据库的key的总数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dbsize</div></pre></td></tr></table></figure>
<h2 id="Redis-时间相关命令"><a href="#Redis-时间相关命令" class="headerlink" title="Redis 时间相关命令"></a>Redis 时间相关命令</h2><h3 id="限定key生存时间"><a href="#限定key生存时间" class="headerlink" title="限定key生存时间"></a>限定key生存时间</h3><p>这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的DEL操作。</p>
<ul>
<li><code>EXPIRE</code>：设置某个key的过期时间（秒）,(<code>EXPIRE bruce 1000</code>：设置<code>bruce</code>这个key1000秒后系统自动删除)</li>
</ul>
<blockquote>
<p>注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> key some-value</div><div class="line">&gt; expire key 10</div><div class="line"><span class="comment"># 马上执行此命令</span></div><div class="line">&gt; get key</div><div class="line"><span class="comment"># 10s后执行此命令</span></div><div class="line">&gt; get key</div></pre></td></tr></table></figure>
<p>结果显示，执行EXPIRE命令后，马上GET，显示key存在。10秒后再GET时，key 已经被自动删除。</p>
<p><img src="/images/redis/ttl.png" alt="ttl"></p>
<h3 id="查询key剩余生存时间"><a href="#查询key剩余生存时间" class="headerlink" title="查询key剩余生存时间"></a>查询key剩余生存时间</h3><p>限时操作可以再<code>SET</code>命令中实现，并且可用<code>TTL</code>命令查询key剩余生存时间。</p>
<p><code>TTL</code>：查找某个key还有多长时间过期,返回时间秒</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">set</span> key 100 ex 30</div><div class="line">&gt; ttl key</div><div class="line">&gt; ttl key</div></pre></td></tr></table></figure>
<h3 id="清除key"><a href="#清除key" class="headerlink" title="清除key"></a>清除key</h3><ul>
<li><code>FLUSHDB</code>：清空当前数据库中的所有键;</li>
<li><code>FLUSHALL</code>：清空所有数据库中的所有键.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; flushdb</div><div class="line">&gt; flushall</div></pre></td></tr></table></figure>
<h2 id="Redis设置相关命令"><a href="#Redis设置相关命令" class="headerlink" title="Redis设置相关命令"></a>Redis设置相关命令</h2><p>Redis有其配置文件，可以通过client-command窗口查看或者更改相关配置。相关命令介绍如下：</p>
<h3 id="CONFIG-GET-and-CONFIG-SET"><a href="#CONFIG-GET-and-CONFIG-SET" class="headerlink" title="CONFIG GET and CONFIG SET"></a>CONFIG GET and CONFIG SET</h3><ul>
<li><code>CONFIG GET</code>：用来读取运行Redis服务器的配置参数。</li>
<li><code>CONFIG SET</code>：用于更改运行Redis服务器的配置参数。</li>
<li><code>AUTH</code> : 认证密码，下面针对Redis密码的示例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; config get requirepass （查看密码）</div><div class="line">&gt; config <span class="built_in">set</span> requirepass <span class="built_in">test</span>123 （设置密码为<span class="built_in">test</span>123 ）</div><div class="line">&gt; config get requirepass  （报错，没有认证）</div><div class="line">&gt; auth <span class="built_in">test</span>123</div><div class="line">&gt; config get requirepass</div></pre></td></tr></table></figure>
<p>由结果可知，刚开始时Reids并未设置密码，密码查询结果为空。然后设置密码为test123，再次查询报错。经过auth命令认证后，可正常查询。</p>
<p>可以经过修改Redis的配置文件redis.conf修改密码。</p>
<p><code>CONFIG GET</code>命令是以list的key-value对显示的，如查询数据类型的最大条目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; config get *max-*-entries*</div></pre></td></tr></table></figure>
<p><img src="/images/redis/pass.png" alt="pass"></p>
<h3 id="重置报告"><a href="#重置报告" class="headerlink" title="重置报告"></a>重置报告</h3><p><code>CONFIG RESETSTAT</code>：重置数据统计报告，通常返回值为’OK”。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; CONFIG RESETSTAT</div></pre></td></tr></table></figure>
<h2 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h2><p><code>INFO [section]</code> ：查询Redis相关信息。 INFO命令可以查询Redis几乎所有的信息，其命令选项有如下：</p>
<ul>
<li><code>server</code> : Redis server的常规信息</li>
<li><code>clients</code> : Client的连接选项</li>
<li><code>memory</code> : 存储占用相关信息</li>
<li><code>persistence</code> : RDB and AOF 相关信息</li>
<li><code>stats</code> : 常规统计</li>
<li><code>replication</code> : Master/slave请求信息</li>
<li><code>cpu</code> : CPU 占用信息统计</li>
<li><code>cluster</code> : Redis 集群信息</li>
<li><code>keyspace</code> : 数据库信息统计</li>
<li><code>all</code> : 返回所有信息</li>
<li><code>default</code> : 返回常规设置信息</li>
</ul>
<p>若命令参数为空，info命令返回所有信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; info keyspace</div><div class="line">&gt; info server</div></pre></td></tr></table></figure>
<h1 id="Redis的高级应用"><a href="#Redis的高级应用" class="headerlink" title="Redis的高级应用"></a>Redis的高级应用</h1><p>本节来讲述Redis的高级应用，包括：安全性设置，主从复制，事务处理， 持久化机制， 虚拟内存的使用。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>设置在客户端连接是需要指定的密码（由于redis速度相当的快，一秒钟可以150K次的密码尝试，所以需要设置一个密码强度很大的密码）。</p>
<p>设置密码的方式有两种：</p>
<ol>
<li>使用<code>config set</code> 命令的<code>requirepass</code> 参数，具体格式为<code>config set requirepass “password”</code>;</li>
<li>配置<code>redis.conf</code> 中设置<code>requirepass</code>属性，后面为密码。</li>
</ol>
<p>输入认证的方式也有两种：</p>
<ol>
<li>登录时可以 <code>redis-cli -a password</code>;</li>
<li>登录后使用 <code>auth password</code>.</li>
</ol>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>第一种密码设置方式在上面已经提到，（在<code>CONFIG SET</code>命令讲解的实例），此处我们来看看第二种方式设置密码。</p>
<p>首先需要进入Redis的安装目录，然后修改配置文件<code>redis.conf</code>。根据<code>grep</code>命令的结果，使用vi编辑器修改<code># requirepass foobared</code> 为<code>requirepass test123</code>，然后保存退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep -n requirepass /etc/redis/redis.conf</div><div class="line">$ sudo vim /etc/redis/redis.conf</div></pre></td></tr></table></figure>
<h3 id="重启redis-server-与redis-cli"><a href="#重启redis-server-与redis-cli" class="headerlink" title="重启redis-server 与redis-cli"></a>重启redis-server 与redis-cli</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重启redis server。</span></div><div class="line">$ sudo service redis-server restart</div></pre></td></tr></table></figure>
<p>进入到redis-cli交互界面进行验证</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ redis-cli</div><div class="line">&gt; info</div><div class="line">&gt; auth <span class="built_in">test</span>123</div><div class="line">&gt; info</div><div class="line">&gt; <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p>结果表明第一次<code>info</code>命令失败，在<code>auth</code>认证之后<code>info</code>命令正常返回。最后退出<code>redis-cli</code>。</p>
<p>另外一种密码认证方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ redis-cli <span class="_">-a</span> <span class="built_in">test</span>123</div><div class="line">&gt; info</div></pre></td></tr></table></figure>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制配置和使用都比较简单，通过主从复制可以允许多个slave server拥有和master server相同的数据库副本。从服务器只能读，不能写。</p>
<p>Redis主从复制特点：</p>
<ol>
<li>master可以拥有多个slave;</li>
<li>多个slave可以连接同一个master外，还可以连接到其他的slave。（当master宕机后，相连的slave转变为master）;</li>
<li>主从复制不会阻塞master，再同步数据时，master可以继续处理client请求;</li>
<li>提高了系统的可伸缩性。</li>
</ol>
<p>Redis主从复制的过程：</p>
<ol>
<li>Slave与master建立连接，发送sync同步命令;</li>
<li>Master会启动一个后台进程，将数据库快照保存到文件中，同时Master主进程会开始收集新的写命令并缓存;</li>
<li>后台完成保存后，就将此文件发送给Slave;</li>
<li>Slave将此文件保存到磁盘上。</li>
</ol>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令，当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; multi</div><div class="line">&gt; <span class="built_in">set</span> name a</div><div class="line">&gt; <span class="built_in">set</span> name b</div><div class="line">&gt; <span class="built_in">exec</span></div><div class="line">&gt; get name</div></pre></td></tr></table></figure>
<p><img src="/images/redis/multi.png" alt="multi"></p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p>
<p>Redis支持两种持久化方式：</p>
<ol>
<li><code>snapshotting</code>（快照），将数据存放到文件里，默认方式。<br>是将内存中的数据已快照的方式写入到二进制文件中，默认文件<code>dump.rdb</code>，可以通过配置设置自动做快照持久化的方式。可配置Redis在n秒内如果超过m个key被修改就自动保存快照。<ul>
<li><code>save 900 1</code>: 900秒内如果超过1个key被修改，则发起快照保存;</li>
<li><code>save 300 10</code>: 300秒内如果超过10个key被修改，则快照保存.</li>
</ul>
</li>
<li><code>Append-only file</code>（缩写为<code>aof</code>），将读写操作存放到文件中。</li>
</ol>
<blockquote>
<p>Note: 由于快照方式在一定间隔时间做一次，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</blockquote>
<p><code>aof</code>比快照方式有更好的持久化性，是由于使用<code>aof</code>时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p>
<p>由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉redis我们想要通过<code>fsync</code>函数强制os写入到磁盘的时机。</p>
<p>配置文件中的可配置参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">appendonly   yes     //启用aof持久化方式</div><div class="line">#appendfsync  always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化</div><div class="line">appendfsync   everysec  //每秒中写入磁盘一次，在性能和持久化方面做了很好的折中</div><div class="line">#appendfsync  no     //完全依赖os，性能最好，持久化没有保证</div></pre></td></tr></table></figure>
<p>在redis-cli的命令中，SAVE命令是将数据写入磁盘中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">help</span> save</div><div class="line">&gt; save</div></pre></td></tr></table></figure>
<h2 id="虚拟内存的使用"><a href="#虚拟内存的使用" class="headerlink" title="虚拟内存的使用"></a>虚拟内存的使用</h2><p>虚拟内存管理在2.6及之上版本取消了，本文安装的的是3.2.0版本的redis ，所以配置文件中并没有虚拟内存管理功能的配置选项。此处仅仅是大概介绍一下。</p>
<p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其他的访问数据，尤其对于redis这样的内存数据库，内存总是不够用的。除了分隔到多个redis server外，提高数据库的容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。</p>
<p>通过配置vm相关的<code>redis.config</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vm-enable  yes                   #开启vm功能</div><div class="line">vm-swap-file    /tmp/redis.swap  #交换出来的value保存的文件路径</div><div class="line">vm-max-memory    10000000        #redis使用的最大内存上线</div><div class="line">vm-page-size   32       #每个页面的大小32字节</div><div class="line">vm-pages     123217729    #最多使用多小个页面</div><div class="line">vm-max-threads     4        #用于执行value对象换入的工作线程数量</div></pre></td></tr></table></figure>
<hr>
<p>参考</p>
<ul>
<li><a href="http://redis.io/" target="_blank" rel="external">Redis官网</a></li>
<li><a href="http://www.redis.cn/" target="_blank" rel="external">Redis中文网站</a></li>
<li><a href="http://redisdoc.com/" target="_blank" rel="external">Redis命令参考</a></li>
<li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">Redis | 菜鸟教程</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java序列化学习]]></title>
      <url>http://wangzzu.github.io/2016/05/21/java-serializable/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要是对Java序列化学习的一些总结，一来是方便自己以后查阅，二来是希望通过本文能给他人带来一些帮助。</p>
<h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>Java提供了一种对象序列化的机制，在该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以再从文件中读取出来，并且对它进行反序列化，也就是说，可以根据对象的类型信息、对象的数据、还有对象中的数据类型可以在内存中新建该对象。</p>
<p>在实际的应用中，我们为什么需要对象序列化机制呢？因为在一般情况下，只有当JVM进程处于运行时，JVM建立的对象才可能存在，也就是说，这些对象的生命周期不会比JVM进程的生命周期更长。但是在现实的应用中，有时需要在JVM进程停止运行之后能够保存(持久化)指定的对象，并且在将来某个时刻重新读取被保存的对象，或者我们希望将一个进程创建的对象传送到另一个JVM进程中。Java的对象序列化机制就能够帮助我们实现这些功能（这就意味着序列化机制是可以自动弥补不同操作系统之间的差异）。</p>
<p>一般来说，对象的序列化主要有两种用途：</p>
<ul>
<li>把对象的字节序列持久化到硬盘，通常保存在一个文件中；</li>
<li>在网络上传输对象的字节序列；</li>
</ul>
<p>我们在使用Java对象序列化时，会把对象的状态保存为一组字节序列，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的<strong>状态</strong>，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量，因为静态变量是类的状态。</p>
<p>这个整个过程都是Java虚拟机（JVM）独立完成的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>但是一个类的对象如果要想序列化成功，必须满足两个条件：</p>
<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性<strong>必须注明是短暂</strong>的。</li>
</ul>
<p>如果你想知道一个Java标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现<code>java.io.Serializable</code>接口即可。</p>
<h1 id="序列化实现的示例"><a href="#序列化实现的示例" class="headerlink" title="序列化实现的示例"></a>序列化实现的示例</h1><ul>
<li>对象序列化时，首先要创建某个<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，只需要调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>（对象化序列是基于字节的，因要使用<code>InputStream</code>和<code>OutputStream</code>继承层次结构）；</li>
<li>对象反序列化时，需要将一个<code>InputStream</code>对象封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>方法；</li>
</ul>
<p>对象序列化时，不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内包含的每个这样的引用进行追踪，并保存那些对象，这种情况有时被称为“对象网”。</p>
<p>这里我们先建立一个对象<code>Person</code>，如下（<a href="https://github.com/wangzzu/java_learn/tree/master/java_thinking/src/javabasic/serialize" target="_blank" rel="external">示例参考</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person.java</span></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">private</span> Gender gender;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Gender gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">		<span class="keyword">this</span>.id = (<span class="keyword">new</span> Random()).nextInt(<span class="number">10</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Gender <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Gender gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">", "</span> + age + <span class="string">", "</span> + gender + <span class="string">", "</span> + id + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面，我们在一个进程里对其进行序列化，然后再反序列化出该对象（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Serialize.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Serialize.java</span></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Person p1 = <span class="keyword">new</span> Person(<span class="string">"wm0"</span>, <span class="number">10</span>, Gender.MALE);</div><div class="line">		Person p2 = <span class="keyword">new</span> Person(<span class="string">"wm1"</span>, <span class="number">18</span>, Gender.MALE);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"p1 = "</span> + p1);</div><div class="line">		ObjectOutputStream out = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 写入本地文件</span></div><div class="line">			out.writeObject(<span class="string">"Person1 storage\n"</span>);</div><div class="line">			out.writeObject(p1);</div><div class="line">			out.close(); <span class="comment">// Also flushes output</span></div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 从本地文件读取</span></div><div class="line">			String s = <span class="keyword">null</span>;</div><div class="line">			Person p11 = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				s = (String) in.readObject();</div><div class="line">				p11 = (Person) in.readObject();</div><div class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p11);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"\n"</span>+ <span class="string">"p2 = "</span> + p2);</div><div class="line">			ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream(); <span class="comment">// 将数据写入缓冲区</span></div><div class="line">			ObjectOutputStream out2 = <span class="keyword">new</span> ObjectOutputStream(bout);</div><div class="line">			out2.writeObject(<span class="string">"Person2 storage\n"</span>);</div><div class="line">			out2.writeObject(p2);</div><div class="line">			out2.flush();</div><div class="line">			ObjectInputStream in2 = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray())); <span class="comment">// 通过toByteArray()获取数据</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				s = (String) in2.readObject();</div><div class="line">				Person p22 = (Person) in2.readObject();</div><div class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p22);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一点要注意的是：反序列化Person对象时，需要要能找到<code>Person.class</code>，否者就会抛出<code>ClassNotFoundException</code>的异常。</p>
<h1 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h1><p>通过上面的例子，我们可以看出序列化的使用，其实还是很简单的，但是，如果我们有特殊的需要那又该怎么办呢？下面我们介绍几种序列化的控制机制。</p>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p>如果我们希望对象的一部分被序列化，而另一部分不被序列化；或者一个对象被还原之后，某子对象需要重新创建，从而不必将该子对象序列化。在这种情况下，我们可以通过实现<code>Externalization</code>接口——该接口实现<code>Serializable</code>接口，同时增加两个方法：<code>writeExternal()</code>和<code>readExternal()</code>，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作。</p>
<p>这与恢复<code>Serializable</code>对象不同，对于<code>Serializable</code>对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。但是对于一个<code>Externalization</code>对象，所有普通的默认构造器都会被调用（包括字段定义时的初始化），然后调用<code>readExternal()</code>。</p>
<blockquote>
<p>必须要注意这一点：所有默认的构造器都会被调用，才能使<code>Externalization</code>对象产生正确的行为。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Blip3.java</span></div><div class="line"><span class="keyword">import</span> java.io.Externalizable;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutput;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">private</span> String s; <span class="comment">// No initialization</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3 Constructor"</span>);</div><div class="line">		<span class="comment">// s, i not initialized</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3(String x, int a)"</span>);</div><div class="line">		s = x;</div><div class="line">		i = a;</div><div class="line">		<span class="comment">// s &amp; i initialized only in non-default constructor.</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> s + i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3.writeExternal"</span>);</div><div class="line">		<span class="comment">// You must do this:</span></div><div class="line">		out.writeObject(s);</div><div class="line">		out.writeInt(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Blip3.readExternal"</span>);</div><div class="line">		<span class="comment">// You must do this:</span></div><div class="line">		s = (String) in.readObject();</div><div class="line">		i = in.readInt();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</div><div class="line">		Blip3 b3 = <span class="keyword">new</span> Blip3(<span class="string">"A String "</span>, <span class="number">47</span>);</div><div class="line">		System.out.println(b3);</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Blip3.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Saving object:"</span>);</div><div class="line">		o.writeObject(b3);</div><div class="line">		o.close();</div><div class="line">		<span class="comment">// Now get it back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Blip3.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Recovering b3:"</span>);</div><div class="line">		b3 = (Blip3) in.readObject();</div><div class="line">		System.out.println(b3);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* Output:</span></div><div class="line">* Constructing objects:</div><div class="line">* Blip3(String x, int a)</div><div class="line">* A String 47</div><div class="line">* Saving object:</div><div class="line">* Blip3.writeExternal</div><div class="line">* Recovering b3:</div><div class="line">* Blip3 Constructor</div><div class="line">* Blip3.readExternal</div><div class="line">* A String 47</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>在上面的例子中，字段<code>s</code>和<code>i</code>只会在第二个构造器中初始化，而不是在默认的构造器中初始化。这意味着假如不在<code>readExternal()</code>中初始化<code>s</code>和<code>i</code>，<code>s</code>就会为<code>null</code>，而<code>i</code>就会为零（因为在创建对象的第一步中将对象的存储空间清理为0）。如果我们把<code>writeExternal()</code>方法中两行注释掉，对象还原后，<code>s</code>是<code>null</code>，而<code>i</code>是零。</p>
<p>我们如果从一个<code>Externalization</code>对象继承，通常需要调用基类版本的<code>writeExternal()</code>和<code>readExternal()</code>来为基类组件提供恰当的存储和恢复功能。</p>
<p>因此，为了正常运行，我们不仅需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalization</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据。</p>
<h2 id="Transient关键字"><a href="#Transient关键字" class="headerlink" title="Transient关键字"></a>Transient关键字</h2><p>在进行序列化控制时，可能某个特定子对象不想让Java的序列化机制自动保存和恢复。如果子对象表示的是我们不希望将其序列化的敏感信息（如密码），那么我们就会面临这种情况。即使对象中的这些信息是<code>private</code>属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问到它。</p>
<p>有两种方法可以实现上述要求：</p>
<ol>
<li>将类实现<code>Externalizable</code>接口，这样的话，没有任何东西是可以自动序列化，并且可以在<code>writeExternal()</code>内部只对所需部门进行显式的序列化；</li>
<li>如果在操作的是一个<code>Serializable</code>对象，那么所有序列化操作都会自动进行，为了能够进行控制，可以用<code>transient</code>关键字逐个字段地关闭序列化，这个关键字的意思就是<strong>不用麻烦你保存或者回复数据——我自己会处理的</strong>。</li>
</ol>
<p><a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Login.java" target="_blank" rel="external">示例</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Login.java</span></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="comment">//: io/Logon.java</span></div><div class="line"><span class="comment">//Demonstrates the "transient" keyword.</span></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</div><div class="line">	<span class="keyword">private</span> String username;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String password;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name, String pwd)</span> </span>&#123;</div><div class="line">		username = name;</div><div class="line">		password = pwd;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"logon info: \n   username: "</span> + username + <span class="string">"\n   date: "</span> + date + <span class="string">"\n   password: "</span> + password;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		Login a = <span class="keyword">new</span> Login(<span class="string">"Hulk"</span>, <span class="string">"myLittlePony"</span>);</div><div class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Logon.out"</span>));</div><div class="line">		o.writeObject(a);</div><div class="line">		o.close();</div><div class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// Delay</span></div><div class="line">		<span class="comment">// Now get them back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Logon.out"</span>));</div><div class="line">		System.out.println(<span class="string">"Recovering object at "</span> + <span class="keyword">new</span> Date());</div><div class="line">		a = (Login) in.readObject();</div><div class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="comment">/*</span></div><div class="line">* logon a = logon info:</div><div class="line">*   username: Hulk</div><div class="line">*    date: Tue May 17 11:11:28 CST 2016</div><div class="line">*    password: myLittlePony</div><div class="line">* Recovering object at Tue May 17 11:11:29 CST 2016</div><div class="line">* logon a = logon info:</div><div class="line">*    username: Hulk</div><div class="line">*    date: Tue May 17 11:11:28 CST 2016</div><div class="line">*    password: null</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以看到，其中的<code>date</code>和<code>username</code>域是一般的（不是<code>transient</code>的），所以它们会被自动序列化。而<code>password</code>是<code>transient</code>的，所以不会被自动保存到磁盘；另外，自动序列化机制也不会尝试去恢复它。当对象被恢复时，<code>password</code>域就会变成<code>null</code>。我们还可以发现，<code>date</code>字段也是从存储到了磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
<blockquote>
<p>由于实现<code>Externalizable</code>接口的对象在默认情况下不保存它们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用。</p>
</blockquote>
<h2 id="重写writeObject-和readObject-方法"><a href="#重写writeObject-和readObject-方法" class="headerlink" title="重写writeObject()和readObject()方法"></a>重写writeObject()和readObject()方法</h2><p>如果不是特别坚持使用<code>Externalizable</code>接口，那么还有一种方法。我们可以实现<code>Serializable</code>接口，并添加<code>writeObject()</code>和<code>readObject()</code>方法。这样一旦对象被序列化或者被反序列化还原，就会自动地分别调用这两个方法，而不是使用默认的序列化机制。（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/SerialCtl.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SerialCtl.java</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCtl</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String a;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String b;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SerialCtl</span><span class="params">(String aa, String bb)</span> </span>&#123;</div><div class="line">		a = <span class="string">"Not Transient: "</span> + aa;</div><div class="line">		b = <span class="string">"Transient: "</span> + bb;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> a + <span class="string">" "</span> + b;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 自定义该方法，这里要注意方法时private</div><div class="line">	 * 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了它自己的writeObject()。</div><div class="line">	 * 如果是这样，就跳过正常的序列化过程并调用它的writeObject()</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> stream</div><div class="line">	 * <span class="doctag">@throws</span> IOException</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		stream.defaultWriteObject(); <span class="comment">// 执行默认的writeObject()</span></div><div class="line">		stream.writeObject(b); <span class="comment">// transient字段需要明确保存和</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		stream.defaultReadObject(); <span class="comment">// 执行默认的readObject()</span></div><div class="line">		b = (String) stream.readObject(); <span class="comment">// transient字段需要明确恢复</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">		SerialCtl sc = <span class="keyword">new</span> SerialCtl(<span class="string">"Test1"</span>, <span class="string">"Test2"</span>);</div><div class="line">		System.out.println(<span class="string">"Before:\n"</span> + sc);</div><div class="line">		ByteArrayOutputStream buf = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(buf);</div><div class="line">		o.writeObject(sc);</div><div class="line">		<span class="comment">// Now get it back:</span></div><div class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf.toByteArray()));</div><div class="line">		SerialCtl sc2 = (SerialCtl) in.readObject();</div><div class="line">		System.out.println(<span class="string">"After:\n"</span> + sc2);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">* Before:</div><div class="line">* Not Transient: Test1 Transient: Test2</div><div class="line">* After:</div><div class="line">* Not Transient: Test1 Transient: Test2</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>上述的例子中，非transient字段由<code>defaultReadObject</code>保存，而transient字段必须在程序中明确保存和恢复。</p>
<h2 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h2><p>前面我们也已经提到过，静态变量是不会被序列化的，这里我们通过一个例子来看一下（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StaticTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id=<span class="number">10</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</div><div class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/static.out"</span>));</div><div class="line">			o.writeObject(<span class="keyword">new</span> StaticTest());</div><div class="line">			o.close();</div><div class="line">			StaticTest.id=<span class="number">0</span>;</div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/static.out"</span>));</div><div class="line">			StaticTest staticTest = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				staticTest = (StaticTest) in.readObject();</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(staticTest.id);</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* output:</div><div class="line">* 0</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>程序输出的结果为修改之后的结果，正如我们前面所述一样，对象序列化时并不会序列化静态变量，这一点可以这样理解：对象序列化是序列化对象的状态，而静态变量是类变量，也就是类的状态。因此，<strong>对象序列化并不保存静态变量</strong>。</p>
<h2 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h2><p>这里我们通过一个例子来看一下Java序列化机制的存储规则，主要是多次写入同一个对象的情况（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StoreTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</div><div class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/store.out"</span>));</div><div class="line">			Person person=<span class="keyword">new</span> Person(<span class="string">"matt1"</span>,<span class="number">20</span>,Gender.MALE);</div><div class="line">			o.writeObject(person);</div><div class="line">			person.setAge(<span class="number">22</span>);</div><div class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</div><div class="line">			o.writeObject(person);</div><div class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</div><div class="line">			o.close();</div><div class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/store.out"</span>));</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Person person1= (Person) in.readObject();</div><div class="line">				System.out.println(person1.getAge());</div><div class="line">				Person person2= (Person) in.readObject();</div><div class="line">				System.out.println(person2.getAge());</div><div class="line">				System.out.println(person1==person2);</div><div class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Output:</div><div class="line">* 232</div><div class="line">* 237</div><div class="line">* 20</div><div class="line">* 20</div><div class="line">* true</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>在上述示例中，对于同一个对象，在修改完年龄值后又重新将该实例对象序列化到文件。通过运行的结果我们可以发现：</p>
<ul>
<li>第二次将对象序列化到文件之后，文件的大小只增加了5个字节的大小；</li>
<li>第二次序列化的对象年龄值已经修改为22，但是从反序列化的结果来看，该实例对象的年龄值并未改变。</li>
</ul>
<p>大家是不是感觉到非常的奇怪，通过下面的两点解释之后，大家可能就会明白这其中的原因了：</p>
<ol>
<li>因为写入的是同一个对象，Java序列化机制为了节省磁盘空间，当写入文件的为同一个对象时，并不会将对象的内容再次进行存储，而只是再次存储一份引用，上面增加的5个字节的存储空间就是新增的引用和一些控制信息的空间，从反序列化的结果也可以看出，两个引用指向的是同一个对象；</li>
<li>虽然第二次存储时将年龄修改为22，但是因为Java序列化机制在第二次序列化同一个对象时，并保存具体的数据，只是保存了第一次的引用，所以反序列化时，得到的对象都是第一次序列化的对象。</li>
</ol>
<h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>这里可以可以参考<a href="http://ych0108.iteye.com/blog/2256640" target="_blank" rel="external">Java中序列化的serialVersionUID作用</a>一文。</p>
<p>这里我们就简单说一下序列化ID的作用：</p>
<p><code>serialVersionUID</code>用来表明类的不同版本间的兼容性。它有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的<code>serialVersionUID</code>；而在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的<code>serialVersionUID</code>。</li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置<code>serialVersionUID</code>，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了<code>serialVersionUID</code>，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10058164.html" target="_blank" rel="external">Java编程思想 第4版</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="external">Java序列化的高级认识</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java容器学习]]></title>
      <url>http://wangzzu.github.io/2016/05/13/java-collection/</url>
      <content type="html"><![CDATA[<p>Java的容器类，在程序中经常被用，而且也是在面试中经常被问到的部分，笔者近段就被问到过n次了，所以这里就根据网上的一些资料，并结合着openJDK的源码对这些容器类好好总结一下。</p>
<h1 id="Java中的容器"><a href="#Java中的容器" class="headerlink" title="Java中的容器"></a>Java中的容器</h1><p>在Java（以JDK1.7为例）中，如果一个程序包含固定数量的且生命周期已知的对象，那么我们可以使用数组来保存这些对象。但是一般情况下，我们在写程序时不知道需要保存多少个对象，对于这种情况，Java的实用类库中提供了一套相当完整的容器类来解决这个问题，其中基本的类型是：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ol>
<p>这些容器类也称为集合类。</p>
<p>对于它们之间的联系：我是这样理解的，首先Map是一个K-V对的集合（关联数组）：</p>
<ol>
<li>key的集合组成了一个Set，因为key是不允许重复的，且Map不会保存key的插入顺序，所以key可组成一个set；</li>
<li>value的集合组成了一个List，因为value是完全可以重复的，Map会根据key的值来获取value，这些value（如果当key是int型时）就组成了一个List（当然List并不是根据Map实现的）。</li>
</ol>
<p>上面的三种集合类只是提供了三个基本的接口，实际使用的集合类主要还是在它们的子类，下面这个图比较清楚地介绍了这三种容器类的常用子类（图片来自<a href="http://stackoverflow.com/questions/3317381/what-is-the-difference-between-collection-and-list-in-java" target="_blank" rel="external">StackOverFlow</a>）</p>
<p><img src="/images/java/collection.png" alt="collection"></p>
<blockquote>
<p>注：图片并没有把所有的继承与接口实现全部表示出来，只是列出了主要的部分，比如：<code>class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code>，而<code>class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set</code>，而<code>AbstractCollection&lt;E&gt; implements Collection</code>，全部的继承与接口实现机制比较复杂，这里只画出了它们的主要部分，这样方便我们看到这些集合类之间的联系与区别。</p>
</blockquote>
<p>对于集合类的分析，这里我们主要从以下几个部分去分析：</p>
<ol>
<li>原理：底层如何实现；</li>
<li>性能：分析这个集合类在具体操作上的复杂度<ul>
<li>插入：插入是如何实现的，性能如何；</li>
<li>删除：删除是如何实现的，性能如何；</li>
<li>读取：读取是如何实现的，性能如何；</li>
</ul>
</li>
<li>其他：比如集合类存储对象时，HashMap里需要重写<code>hash()</code>和<code>equals()</code>等性质。</li>
</ol>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>首先这里先介绍一下List集合类，List集合存储的是对象的引用或者基本数据类型，而且存储都是<strong>有序</strong>的，并且<strong>可以重复</strong>。下面分别介绍三种常见的List类。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/ArrayList.java" target="_blank" rel="external">ArrayList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认的数组长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// transient关键字主要是用于定制序列化方面</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">	<span class="comment">// 知道数组长度的情况下初始化数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 动态增加数组的长度，每次动态增加(oldCapacity &gt;&gt; 1)</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 获取元素，先检查index是否在范围，然后直接以数组的方式取出</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 修改给定位置的一个元素值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        E oldValue = elementData(index);</div><div class="line">        elementData[index] = element;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   	<span class="comment">// 在list的最后添加一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在给定位置添加一个元素（随机插入），这时候需要将该位置后面的所有元素移位</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        rangeCheckForAdd(index);</div><div class="line"></div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 移出给定位置的一个元素（随机删除），这时候也需要将该位置后面的所有元素移位</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 移出第一个符合要求的元素（需要从最前面开始遍历list）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对代码的分析，下面总结一下ArrayList（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/ArrayListTest.java" target="_blank" rel="external">测试代码</a>）：</p>
<ul>
<li>原理：基于<strong>数组</strong>来实现（顺序存储的线性表）</li>
<li>特点：<ol>
<li>动态数组，每次插入时都会检查数组长度是否够用，不够用时需要进行扩大，每次会将数组的长度增加$\frac{N}{2}$，也就是新建一个数组，然后将原来数组的元素拷贝进去；</li>
<li>ArrayList是List接口的可变数组的实现；</li>
<li>非同步；</li>
<li>添加、删除操作时，每次都需要把该索引右边的数组整体移动，性能较差，所以ArrayList更擅长随机访问数组，但是在数组中间进行插入或删除元素时较慢；</li>
<li>内部实现时，使用了<code>transient</code>修饰数组，这保证系统序列化ArrayList对象时不会直接序列化<code>elementData</code>数组，而是通过ArrayList提供的<code>writeObject</code>、<code>readObject</code>方法定制序列化。</li>
</ol>
</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Vector.java" target="_blank" rel="external">Vector</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Object[] elementData;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement; <span class="comment">// 数组动态增加时的步长</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化list，可以设置步长</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list最后添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">        elementData[elementCount++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在给定位置添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        insertElementAt(element, index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 随机插入元素的实际操作方法，这里也需要移动整个数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (index &gt; elementCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</div><div class="line">        &#125;</div><div class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</div><div class="line">        elementData[index] = obj;</div><div class="line">        elementCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除给定位置的元素，也需要整体移动数组</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取给定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (E) elementData[index];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Vector与ArrayLis很相似，ArrayList与Vector的大部分方法都是相同，只是Vector添加了<code>synchronized</code>，也就是说，Vector是ArrayList的线程安全版本，但是在序列化方面，ArrayList比Vector更安全。</p>
<ul>
<li>原理：基于<strong>数组</strong>实现</li>
<li>特点：<ol>
<li>同步的（方法大都是<code>synchronized</code>的）；</li>
<li>每次扩大时可以通过参数设置扩大的步长;</li>
<li>对于Vector，没有使用<code>transient</code>修饰数组，而且Vector只提供了一个<code>writeObject</code>方法，并未完全实现定制序列化。</li>
</ol>
</li>
</ul>
<p>它有一个子类为Stack（线程安全），对于栈，不要求线程安全时，可以使用<code>ArrayDeque</code>实现。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 指向第一个节点</span></div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 指向最后一个节点</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素e添加到list的头部</span></div><div class="line"></div><div class="line">    <span class="comment">//调用上一个私有方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        linkFirst(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素添加到list的尾部</span></div><div class="line"></div><div class="line">    <span class="comment">// 在节点succ前添加一个元素e</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert succ != null;</span></div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">        succ.prev = newNode;</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pred.next = newNode;</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除头节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除尾节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list尾部添加元素的实际操作</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">        last = newNode;</div><div class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            l.next = newNode;</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在list最后面添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        linkLast(e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给定位置添加元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        checkPositionIndex(index);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index == size)</div><div class="line">            linkLast(element);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            linkBefore(element, node(index)); <span class="comment">//调用这个方法</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除给定的节点</span></div><div class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert x != null;</span></div><div class="line">        <span class="keyword">final</span> E element = x.item;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">            first = next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            prev.next = next;</div><div class="line">            x.prev = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">            last = prev;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            next.prev = prev;</div><div class="line">            x.next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        x.item = <span class="keyword">null</span>;</div><div class="line">        size--;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据索引返回该位置的Node（这个方法会经常调用，通过遍历的方法找到该位置）</span></div><div class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">            Node&lt;E&gt; x = first;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">                x = x.next;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;E&gt; x = last;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">                x = x.prev;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除指定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        checkElementIndex(index);</div><div class="line">        <span class="keyword">return</span> unlink(node(index));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回指定位置的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        checkElementIndex(index);</div><div class="line">        <span class="keyword">return</span> node(index).item;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：基于<strong>双向链表</strong>实现的（链式存储的线性表）</li>
<li>特点：<ol>
<li>在获取元素的索引时，需要去<strong>遍历</strong>链表来获取索引（也就是<code>node()</code>方法）。</li>
<li>它的插入和删除操作比ArrayList更加高效（主要是对于List中间的删除或添加，因为ArrayList需要整体移动右边数组），也正是由于它是基于链表实现的，所以随机访问的效率要比ArrayList差。</li>
<li>非同步；</li>
<li>实现了List和Deque接口，既可以做双向链表使用，又可以做队列使用，还可以做栈使用;</li>
<li>也可以进行定制序列化。</li>
</ol>
</li>
</ul>
<blockquote>
<p>Deque接口是双端队列，既可以作为栈也可以作为队列。</p>
</blockquote>
<p>关于LinkedList，笔者做一个test，使用LinkedList分别做链表、队列和栈，参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/LinkedListTest.java" target="_blank" rel="external">测试代码</a>。</p>
<blockquote>
<p>Notice: <strong>fail-fast 机制</strong>是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件（<code>ConcurrentModificationException</code>）。fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用 fail-fast机制的集合，建议使用<code>java.util.concurrent</code>包下的类去取代<code>java.util</code>包下的类。</p>
</blockquote>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map一种经常用的容器类型，它存储的是K-V键值对。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>先讲一下最常用的HashMap吧，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashMap.java" target="_blank" rel="external">HashMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认的长度，这里是16，要求必须是2的次方</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认的负载因子</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div><div class="line"></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// map中的长度</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="comment">// 根据给定大小和负载因子初始化map</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = initialCapacity;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// 添加KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">            inflateTable(threshold);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(value);</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// key相等（hash值还有实际值相等）时，替换value</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(hash, key, value, i); <span class="comment">// 将&lt;key, value&gt;添加到i索引处</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将KV对添加到给定位置的Entry链上</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">            bucketIndex = indexFor(hash, table.length);</div><div class="line">        &#125;</div><div class="line">        createEntry(hash, key, value, bucketIndex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key获取相应的value值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key找到给KV对象</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key删除该元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际删除该Entry链元素的实际操作</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        Entry&lt;K,V&gt; prev = table[i];</div><div class="line">        Entry&lt;K,V&gt; e = prev;</div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                modCount++;</div><div class="line">                size--;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    table[i] = next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.next = next;</div><div class="line">                e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">            &#125;</div><div class="line">            prev = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Google上找到了一张关于关于HashMap数据存储图，如下所示</p>
<p><img src="/images/java/hashmap.png" alt="hashmap"></p>
<ul>
<li>原理： 基于<strong>拉链法的散列表</strong>（数组和链表的结合），数组的每个元素都是一个链表的引用，对象的存储位置跟key的hash值有关。</li>
<li>特点：<ol>
<li>允许存放null键和null值；</li>
<li>HashMap数组的长度总是2的n次方（这样才能高效地利用数组空间的存储）；</li>
<li>当key的hash值相同，而值不同时，会添加到链表里，key值相同时，就会覆盖原kv对的value值；</li>
<li><code>java.util.HashMap</code>不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出<code>ConcurrentModificationException</code>，这就是所谓fail-fast策略；</li>
<li>HashMap在底层吧K-V当成一个整体进行处理，这个整体就是一个Entry对象。</li>
</ol>
</li>
<li>缺点： Hashmap数据有可能出现分布不均匀的情况这样就会影响查询效率，这跟HashCode算法和具体数据有关系，一般需要重写HashCode算法。</li>
<li>性能<ol>
<li>负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的总容量(initialCapacity)，当loadFactor达到指定值或者0.75时候，HashMap的总容量自动扩展一倍，以此类推。</li>
<li>负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</li>
<li>负载因子是对时间和空间成本上的一种折衷。增大负载因袭可以减少Hash表所占用的内存空间，但会增加查询时间，而查询是HashMap中对频繁的操作；减少负载因子会提高数据查询的性能，但会增加Hash表所占用的内存空间。</li>
</ol>
</li>
</ul>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Hashtable.java" target="_blank" rel="external">Hashtable</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">    <span class="comment">// 创建Hashtable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">            initialCapacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">        initHashSeedAsNeeded(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认是11，与有所HashMap不同</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 查看是否包含某个KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key查找KV对的value值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 能分配的最大数组长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 增加数组的长度</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">        Entry&lt;K,V&gt;[] oldMap = table;</div><div class="line"></div><div class="line">        <span class="comment">// overflow-conscious code</span></div><div class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            newCapacity = MAX_ARRAY_SIZE;</div><div class="line">        &#125;</div><div class="line">        Entry&lt;K,V&gt;[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">        <span class="keyword">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);</div><div class="line"></div><div class="line">        table = newMap;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = old;</div><div class="line">                old = old.next;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                    e.hash = hash(e.key);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">                e.next = newMap[index];</div><div class="line">                newMap[index] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加元素，与HashMap类似</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Make sure the value is not null</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            hash = hash(key);</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除元素，如果该key不存在，则返回null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = hash(key);</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                modCount++;</div><div class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">                    prev.next = e.next;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tab[index] = e.next;</div><div class="line">                &#125;</div><div class="line">                count--;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：数组+链表（与HashMap一样）</li>
<li>特点：<ol>
<li>和HashMap一样，Hashtable也是一个基于拉链法实现的散列表，它存储的内容是键值对；</li>
<li>Hashtable继承于Dictionary类，实现了Map, Cloneable, java.io.Serializable接口；</li>
<li>线程安全；</li>
<li>比较老的类，命名也没有遵循现在Java的驼峰法；</li>
<li>Hashtable的key和value都不允许为null；</li>
</ol>
</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123; <span class="comment">// 继承HashMap</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header; <span class="comment">// 头元素</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">// 设置迭代顺序，可以设置插入顺序（false）或者访问顺序（true）</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(m);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        header.before = header.after = header;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实际上调用HashMap的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        e.recordAccess(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap的数据的存储方式如下图所示（图片来自<a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="external">LinkedHashMap</a>）：</p>
<p><img src="/images/java/linkedhashmap.png" alt="LinkedHashMap"></p>
<blockquote>
<p>Note：途中蓝色箭头的指针是<code>Entry</code>对象的<code>next</code>指针，而黑色箭头的指针是双向链表的<code>before</code>和<code>after</code>指针。</p>
</blockquote>
<ul>
<li>原理：数组+双向链表（有before、after两个指针，所以可以保留插入或访问顺序）</li>
<li>特点：<ol>
<li>LinkedHashMap是HashMap的一个子类，它<strong>保留插入的顺序</strong>， 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap；</li>
<li>LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的<strong>双向链接列表</strong>。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序；</li>
<li>非同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步；</li>
<li>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序；</li>
<li>如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表；</li>
<li>底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性；</li>
<li>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序；</li>
<li>LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序；</li>
<li>允许使用null值和null键；</li>
</ol>
</li>
</ul>
<p>关于迭代顺序可以参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/LinkedHashMapTest.java" target="_blank" rel="external">测试代码</a></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>对于线程安全的情况，在不考虑性能问题的时候，我们的解决方案有Hashtable或者Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个hash表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。 但是Java为我们提供了封装好的线程安全的集合类，这些类在<code>java.util.concurrent</code>包内，这里我们介绍一个常用的map子类——ConcurrentHashMap。</p>
<p>源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/concurrent/ConcurrentHashMap.java" target="_blank" rel="external">ConcurrentHashMap</a>，这里就不再介绍 ConcurrentHashMap的源码了。</p>
<p>先看一下ConcurrentHashMap的结构，如下图所示</p>
<p><img src="/images/java/concurrenthashmap.png" alt="concurrenthashmap"></p>
<p>在ConcurrentHashMap内有几个重要的内部类分别是：</p>
<ol>
<li><code>HashEntry</code>类：用来封装散列映射表中的键值对，HashEntry的学习可以类比着 HashMap中的Entry。我们的存储键值对的过程中，散列的时候如果发生“碰撞”，将采用<strong>拉链法</strong>来处理碰撞：把碰撞的 HashEntry 对象链接成一个链表；</li>
<li><code>Segment</code>类：Segment 的类定义为<code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</code>，其继承于 ReentrantLock类，从而使得 Segment对象可以充当锁的角色。Segment中包含HashEntry的数组，其可以守护其包含的若干个桶（HashEntry的数组）。Segment 在某些意义上有点类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</li>
</ol>
<ul>
<li>原理：数组+链表，每个数组元素是一个类似于HashMap结构的segment，每个segment又是一个数组和链表的形式，这样在对某个segment操作时，就可以锁住该segment，不影响对其他segment的操作。</li>
<li>特点：<ol>
<li>ConcurrentHashMap的实现是依赖于Java内存模型；</li>
<li>本质也是数组和链表，ConcurrentHashMap数据结构为一个Segment数组，Segment的数据结构为HashEntry的数组，而HashEntry存的是我们的键值对，可以构成链表，默认的Segment是16个，通过key的hash值与16取余确定在哪个桶。</li>
<li>ConcurrentHashMap的结构中包含的Segment的数组，在默认的并发级别会创建包含16个Segment对象的数组。</li>
<li>执行put方法的时候，会需要<strong>加锁</strong>来完成，在put操作时锁定的是一个Segment而不是整个ConcurrentHashMap。</li>
<li>ConcurrentHashMap不允许空值。该方法首先有一个Segment的引用s，然后会通过hash()方法对key进行计算，得到哈希值；继而通过调用Segment的put(K key, int hash, V value, boolean onlyIfAbsent)方法进行存储操作。</li>
<li>在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</li>
</ol>
</li>
</ul>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ol>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeMap.java" target="_blank" rel="external">TreeMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">// 比较器，不设置时使用key的自然顺序</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        comparator = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以设置比较器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.comparator = comparator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        comparator = <span class="keyword">null</span>;</div><div class="line">        putAll(m);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        comparator = m.comparator();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 插入方法，这个是红黑树中非常重要的方法，根据定制的比较器将插入的元素放在合适的位置</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; t = root;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">            size = <span class="number">1</span>;</div><div class="line">            modCount++;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> cmp;</div><div class="line">        Entry&lt;K,V&gt; parent;</div><div class="line">        <span class="comment">// split comparator and comparable paths</span></div><div class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                parent = t;</div><div class="line">                cmp = cpr.compare(key, t.key);</div><div class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                    t = t.left;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                    t = t.right;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> t.setValue(value);</div><div class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                parent = t;</div><div class="line">                cmp = k.compareTo(t.key);</div><div class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                    t = t.left;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                    t = t.right;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> t.setValue(value);</div><div class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            parent.left = e;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            parent.right = e;</div><div class="line">        fixAfterInsertion(e);</div><div class="line">        size++;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除KV对</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; p = getEntry(key);</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        V oldValue = p.value;</div><div class="line">        deleteEntry(p);</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据key找到对应的Entry对象，熟悉二叉树的人应该很熟悉这里的结构</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 很多话方法都会调用这个比较方法（这个方法设置为了final，是不允许修改的）</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</div><div class="line">            : comparator.compare((K)k1, (K)k2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>特点：<ol>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的；</li>
<li>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合；</li>
<li>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合；</li>
<li>TreeMap 实现了Cloneable接口，意味着它能被克隆；</li>
<li>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化；</li>
<li>TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的；</li>
<li>可以重写<code>comparable</code>。</li>
</ol>
</li>
<li>性能：<ol>
<li>因为底层是使用红黑树保存集合中的Entry对象，这也就意味着TreeMap对于添加元素、取出元素的性能要比HashMap低。当TreeMap添加元素时，需要通过循环找到新增Entry的插入位置，因此比较耗性能；当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，也比较耗性能；</li>
<li>TreeMap的优势在于：TreeMap中的所有Entry都是按key根据指定排序规则（可以根据重写的<code>comparable</code>定制排序规则）操持有序状态。</li>
</ol>
</li>
</ul>
<p>这里我做了一个测试，使用TreeMapTest（及其自定义排序形式）与HashMap做一下对比（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/TreeMapTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.TreeMap;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 5/13/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">		HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">		treeMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		treeMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		treeMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		treeMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator tree = treeMap.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"TreeMap:"</span>);</div><div class="line">		<span class="keyword">while</span> (tree.hasNext()) &#123;</div><div class="line">			Object key = tree.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap.get(key));</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">		TreeMap&lt;String,String&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;String,String&gt;(<span class="keyword">new</span> Comparator()&#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				String a = (String)o1;</div><div class="line">				String b = (String)o2;</div><div class="line">				<span class="keyword">return</span> -a.compareTo(b);</div><div class="line">			&#125;&#125;);</div><div class="line">		treeMap1.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		treeMap1.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		treeMap1.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		treeMap1.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator tree1 = treeMap1.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"\nTreeMap（根据value排序）:"</span>);</div><div class="line">		<span class="keyword">while</span> (tree1.hasNext()) &#123;</div><div class="line">			Object key = tree1.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap1.get(key));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		hashMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</div><div class="line">		hashMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</div><div class="line">		hashMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</div><div class="line">		hashMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</div><div class="line">		Iterator hash = hashMap.keySet().iterator();</div><div class="line">		System.out.println(<span class="string">"\nHashMap:"</span>);</div><div class="line">		<span class="keyword">while</span> (hash.hasNext()) &#123;</div><div class="line">			Object key = hash.next();</div><div class="line">			System.out.println(key.toString() + <span class="string">" "</span> + hashMap.get(key));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Output:</div><div class="line">* TreeMap:</div><div class="line">* a wm0</div><div class="line">* b wm1</div><div class="line">* c wm2</div><div class="line">* d wm3</div><div class="line">*</div><div class="line">* TreeMap（根据value排序）:</div><div class="line">* d wm3</div><div class="line">* c wm2</div><div class="line">* b wm1</div><div class="line">* a wm0</div><div class="line">*</div><div class="line">* HashMap:</div><div class="line">* d wm3</div><div class="line">* b wm1</div><div class="line">* c wm2</div><div class="line">* a wm0</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>下面开始介绍Set了，Set是不保存重复元素的集合。当保存对象引用，一般情况下，对象需要重写<code>equals()</code>和<code>hashCode()</code>方法，不重写的话，就会使用对应Map（HashMap，TreeMap）的判断方法。</p>
<p>因为Set集合类的底层实现大都与前面的类似，所以下面会介绍稍微简洁一些。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>先介绍一下HashSet，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashSet.java" target="_blank" rel="external">HashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// 使用HashMap实现</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">// map中默认的value值</span></div><div class="line"></div><div class="line">    <span class="comment">// 构造方法都是借助与HashMap实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 感觉这个应该是老方法，构造对象时是无法使用这个方法的</span></div><div class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加元素，这个方法本质上还是调用了HashMap的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> map.containsKey(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码中，我们可以看到，HashSet的实现其实非常简单，他只是封装了一个HashMap对象来存储所有的集合元素。所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储了一个<code>PRESENT</code>，它是一个静态的Object对象。</p>
<ul>
<li>原理：HashSet底层使用HashMap来保存所有元素（value出存储了一个静态的Object对象）。</li>
<li>特点：<ol>
<li>HashSet实现了Set接口，它不允许集合中有重复的值;</li>
<li>HashSet的随机读取和写入还是很快的，同样也会出现与HashMap一样的问题，即有可能出现数据不均匀的情况；</li>
<li>重写<code>equals()</code>和<code>hashCode()</code>方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象;</li>
<li>当向Set添加元素时，如果与Set中的某一个元素比较时，当<code>equals()</code>比较返回true和<code>hashCode()</code>的返回值相等时，此时，元素就会添加失败（并不会覆盖Set中的元素，因为在HashMap中，遇到这种情况，只是覆盖value，不会覆盖key，而HashSet是基于HashMap实现的，所以元素也并不会被覆盖，只是会添加失败）；</li>
</ol>
</li>
</ul>
<p>下面我们看一个三个测试用例，来说明使用HashSet存储对象引用时，重写<code>equals()</code>和<code>hashCode()</code>方法的重要性。</p>
<p>Test1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name=name;</div><div class="line">		<span class="keyword">this</span>.age=age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Output: false</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Test2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name=name;</div><div class="line">		<span class="keyword">this</span>.age=age;</div><div class="line">	&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</div><div class="line">			Person per = (Person) o;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age == per.age &amp;&amp; <span class="keyword">this</span>.name.equals(per.name);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 因为两个对象的hash值不同，这样就会当作两个对象来处理。</div><div class="line">* Output: false</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>Test3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</div><div class="line">			Person per = (Person) o;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> name.hashCode();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</div><div class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写的equals和hashCode方法的返回值必须保持一致，当两个类的hashCode()返回值相同时，</div><div class="line">* 它们通过equals()方法的比较也应该相同。</div><div class="line">* Output: true</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>还是先看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedHashSet.java" target="_blank" rel="external">LinkedHashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 实际上是调用了HashSet中的default方法（该方法只能在包内或同一个文件内部调用），实际使用LinkedHashMap实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原理：继承于HashSet、又基于LinkedHashMap来实现。</li>
<li>特点：<ol>
<li>是一个Set的实现，所以它其中存的肯定不是键值对，而是值；</li>
<li>与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双向链接列表。 此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序；</li>
<li>非同步。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步；</li>
<li>继承于HashSet、又基于LinkedHashMap（父类HashSet实现时专门为其提供了一个LinkedHashMap的构造方法）来实现的。</li>
</ol>
</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeSet.java" target="_blank" rel="external">TreeSet</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</div><div class="line">        <span class="keyword">this</span>.m = m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        addAll(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(s.comparator());</div><div class="line">        addAll(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上面的源码可知，TreeSet底层采用一个<code>NavigableMap</code>来保存TreeSet集合的元素。但实际上，由于<code>NavigableMap</code>只是一个接口，因此底层依然是使用了TreeMap来包含Set集合中的所有元素。TreeSet里绝大多数方法都是直接使用TreeMap的方法来实现的，因此在上面的源码只列出简单的TreeSet的构造方法。</p>
<ul>
<li>原理：基于TreeMap实现的。</li>
<li>特点：TreeSet中的所有元素总是根据指定排序规则保存有序状态（可以自定义TreeSet的排序规则）。</li>
</ul>
<p>下面给一个例子（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/set/TreeSetTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.TreeSet;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by matt on 5/13/16.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">		treeSet.add(<span class="string">"wm0"</span>);</div><div class="line">		treeSet.add(<span class="string">"wm1"</span>);</div><div class="line">		treeSet.add(<span class="string">"matt0"</span>);</div><div class="line">		treeSet.add(<span class="string">"matt1"</span>);</div><div class="line">		Iterator tree=treeSet.iterator();</div><div class="line">		System.out.println(<span class="string">"HashSet(默认排序规则):"</span>);</div><div class="line">		<span class="keyword">while</span> (tree.hasNext())&#123;</div><div class="line">			System.out.println(tree.next());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		TreeSet&lt;String&gt; treeSet1 = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator()&#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				String a = (String)o1;</div><div class="line">				String b = (String)o2;</div><div class="line">				<span class="keyword">return</span> -a.compareTo(b);</div><div class="line">			&#125;&#125;);</div><div class="line">		treeSet1.add(<span class="string">"wm0"</span>);</div><div class="line">		treeSet1.add(<span class="string">"wm1"</span>);</div><div class="line">		treeSet1.add(<span class="string">"matt0"</span>);</div><div class="line">		treeSet1.add(<span class="string">"matt1"</span>);</div><div class="line">		System.out.println(<span class="string">"\nHashSet(向反的默认排序规则):"</span>);</div><div class="line">		Iterator tree1=treeSet1.iterator();</div><div class="line">		<span class="keyword">while</span> (tree1.hasNext())&#123;</div><div class="line">			System.out.println(tree1.next());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* HashSet(默认排序规则):</div><div class="line">* matt0</div><div class="line">* matt1</div><div class="line">* wm0</div><div class="line">* wm1</div><div class="line">*</div><div class="line">* HashSet(向反的默认排序规则):</div><div class="line">* wm1</div><div class="line">* wm0</div><div class="line">* matt1</div><div class="line">* matt0</div><div class="line">* /</div></pre></td></tr></table></figure>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><p>这里理出一些常见的面试题，大部分题并未给出准确的回答，大家可以根据前面的分析自行总结。</p>
<ol>
<li>ArrayList VS Vector</li>
<li>ArrayList VS LinkedList<ul>
<li>ArrayList和LinkedList是两个集合 类，用于存储一系列的对象引用(references)。一般大家都知道ArrayList和LinkedList的大致区别：</li>
</ul>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要进行遍历。</li>
<li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动部分数据。</li>
</ol>
</li>
<li>说你知道的几个Java集合类：list、set、queue、map实现类。<ul>
<li>Map接口<br>映射。主要存储一组组具有映射关系的数据，映射关系主要用key/value的键值对形式表示，一组键值对构成了Map的内部类Entry，所以可以把Map当做由Entry构成的集合。</li>
<li>List接口<br>表。这个表可以是数组实现的ArrayList，也可以是链表实现的LinkedList。比较古老的实现是Vector，现在不推荐使用，包括它的子类Stack，尽管它是线程安全的。List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。</li>
<li>Queue接口<br>模拟”队列”这种数据结构</li>
<li>Set 接口<br>Set是只有Key值，value值为NULL的一个特殊的Map。 只能通过iterator访问元素。</li>
</ul>
</li>
<li>Java中的队列都有哪些，有什么区别。</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高？</li>
<li>HashMap与HashTable的区别？<ol>
<li>继承的父类不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap，它们都实现了Map接口。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现；</li>
<li>key和value是否允许出现null值。HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException；</li>
<li>线程安全不同，Hashtable中的几乎所有的public的方法都是synchronized的，而有些方法也是在内部通过synchronized代码块来实现。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理；</li>
<li>是否提供contains方法，HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同；</li>
<li>内部实现使用的数组初始化和扩容方式不同，HashTable中hash数组默认大小是11，增加的方式是 $old*2+1$，HashMap中hash数组的默认大小是16，而且一定是2的指数；</li>
<li>两个遍历方式的内部实现上不同，Hashtable、HashMap都使用了 Iterator，Hashtable还保留了Enumeration的方式 ；</li>
<li>hash值不同，哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。</li>
</ol>
</li>
<li>HashMap冲突很厉害，最差性能，你会怎么解决?从$O(n)$提升到$\log{n}$。</li>
<li>HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</li>
<li>Hash冲突怎么办？哪些解决散列冲突的方法？<ol>
<li>基于<strong>拉链法</strong>的散列表</li>
</ol>
<ul>
<li>原理：数组+链表（HashMap的实现方式）</li>
<li>特点：</li>
</ul>
<ol>
<li>方法：一，根据散列值查找相应的链表；二，沿着链表查找相应的键；</li>
<li>性能：对于一张含有M条链表和N个键的散列表中，未命中查找和插入操所需的比较次数都为$~\frac{N}{M}$。</li>
<li>基于<strong>线性探测法</strong>的散列表</li>
</ol>
<ul>
<li>原理：用大小为M的<strong>数组</strong>保存N个键值对（$M&gt;N$）。利用空位，也称为开放地址散列表。</li>
<li>特点：当发生碰撞时，直接检查散列表的下一个位置（索引值加1），会有三种结果：</li>
</ul>
<ol>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ol>
<ul>
<li>缺点：进行删除操作时，删除键右边的所有键（连在一起）需要重新插入散列表。</li>
</ul>
</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写。</li>
<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现。</li>
<li>常用的hash算法有哪些？<ul>
<li>除法hash：求余；</li>
<li>乘法hash；</li>
</ul>
</li>
<li>什么是一致性哈希？（参考<a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="external">五分钟理解一致性Hash算法</a>）<br>为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题。<br>判定哈希算法好坏的四个定义：<ol>
<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用；</li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。；</li>
<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性；</li>
<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷；<br>在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点：<strong>虚拟节点</strong>（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列.</li>
</ol>
</li>
<li>ReHash<br>ReHash的过程其实是空间和时间的双重重大损失，ReHash的过程其实就是一个动态扩容的过程，而哈希表的扩容是个空间和时间消耗都非常惊人的内部操作。<ol>
<li>原来当我们对哈希结构的容器进行扩容时，散列表内部要重新new一个更大的数组，然后把原来数组的内容拷贝到新数组，并进行重新散列；</li>
<li>new出来的这个更大的新数组容量有多大也是一门学问，一般来说，新数组的大小会设置成原数组双倍大小的相近的一个素数</li>
</ol>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/" target="_blank" rel="external">Java集合学习指南</a></li>
<li><a href="http://www.cnblogs.com/leesf456/tag/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">Java集合框架学习</a></li>
<li><a href="http://item.jd.com/10064252.html" target="_blank" rel="external">突破Java程序员基本功的16课</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中对象的内存使用学习]]></title>
      <url>http://wangzzu.github.io/2016/05/07/java-object-memory/</url>
      <content type="html"><![CDATA[<p>本文的内容来自《算法 第四版》，上次看这一部分的时候应该是一年前了，不过因为昨天在面试中，被问到String对象在内存是如何存储，虽然之前看过这方面的内容，对这还有一点模糊印象，但终究没想起来，所以就想再看一下，顺便写成博客，方便以后查看。</p>
<p>本文主要介绍在Java中，对象、数组、字符串在内存是如何存储的，它们需要占用多少内存。</p>
<h1 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h1><p>要想知道一个对象使用的内存量，需要将所有实例变量使用的内存与对象本身的开销（一般是16个字节）相加。这些开销包括一个指向对象的类的引用、垃圾收集信息以及同步信息。另外，一般内存的使用都会被填充为8个字节（64位计算机中的机器字）的倍数。如下图所示，对于一个<code>Integer</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/integer.png" alt="int"></p>
<p>一个<code>Integer</code>对象会使用24字节（16个字节的对象开销，4个字节用于保存它的int值以及4个填充字节）。</p>
<p>一个<code>Date</code>对象（如下图）需要使用32字节：16个字节的对象开销，3个int实例变量各需4个字节，以及4个填充字节。</p>
<p><img src="/images/2016-05-07-java-object-mem/date.png" alt="date"></p>
<p>对象的引用一般都是一个内存地址，因此会使用8个字节。</p>
<p>例如对于一个<code>Counter</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/counter.png" alt="counter"></p>
<p>它需要32字节：16个字节的对象开销，8个字节用于它的String型实例变量（<strong>一个引用</strong>），4字节用于int实例变量，以及4个填充字节。</p>
<p>当我们说明一个引用所占的内存时，我们会单独说它所指向的对象所占用的内存，因此，这个内存使用总量并没有包含String对象所使用的内存。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在java中，数组一般被实现为对象，它们一般都会因为记录长度而需要额外的内存。</p>
<p>一个原始数据类型的数组一般需要24字节的头信息（如下）和保存值所需的引用。</p>
<ol>
<li>16个字节的对象开销；</li>
<li>4个字节用于保存长度；</li>
<li>4个填充字节。</li>
</ol>
<p>下面分别介绍一下<code>int[]</code>、<code>double[]</code>、对象数组和二维数组的内存占用情况。</p>
<p><img src="/images/2016-05-07-java-object-mem/array.png" alt="array"></p>
<h2 id="int值的数组"><a href="#int值的数组" class="headerlink" title="int值的数组"></a>int值的数组</h2><p>一个含有N个int值的数组需要使用$24+4N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="double值的数组"><a href="#double值的数组" class="headerlink" title="double值的数组"></a>double值的数组</h2><p>一个含有N个double值的数组需要使用$24+8N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h2><p>一个对象的数组就是一个对象的引用的数组，所以我们应该在对象所需的内存之外再加上引用所需的内存。例如，对于一个含有N个<code>Date</code>对象的数组需要使用24字节（头信息）加上$8N$字节（所有的引用）加上每个对象的32字节，总共$24+40N$。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>对于二维数组而言，它就是一个数组的数组（每个数组都是一个对象）。例如：一个$M*N$的double类型的二维数组需要使用24字节（头信息）加上$8M$字节（所有元素数组的引用）加上$24M$字节（所有元素的开销）加上$8MN$字节（$M$个长度为$N$的double类型的数组），总和共$8MN+32M+24$字节。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>一个String对象</p>
<p><img src="/images/2016-05-07-java-object-mem/string.png" alt="string"></p>
<p>String的标准实现含有4个<strong>实例变量</strong>：</p>
<ul>
<li>一个指向字符数组的引用（8字节）；</li>
<li>三个int值（4个字节）<ol>
<li>第一个int值：字符数组中的偏移量；</li>
<li>第二个int值：一个计数器，也就是字符串的长度，以上图为例，对象所表示的字符串由<code>value[offset]</code>到<code>value[offset+count-1]</code>中的字符组成；</li>
<li>第三个int值：散列值。</li>
</ol>
</li>
</ul>
<p>因此，每个String对象都会使用40字节（16字节表示对象，三个int实例变量各需4个字节，加上数组引用的8个字节和4个填充字节）。这是除字符数组之外字符所需的内存空间，所有字符所需的内存需要另记，因为String的char数组常常是在多个字符串之间共享的。因为String对象是不可变的，这种设计使String的实现能够在多个对象都含有相同的<code>value[]</code>数组时节省内存。</p>
<h1 id="字符串的值和子字符串"><a href="#字符串的值和子字符串" class="headerlink" title="字符串的值和子字符串"></a>字符串的值和子字符串</h1><p>字符串和子字符串的例子如下所示：</p>
<p><img src="/images/2016-05-07-java-object-mem/substring.png" alt="substring"></p>
<p>一个长度为N的String对象一般需要使用40字节（String对象本身）加上$24+2N$字节（字符数组），总共$64+2N$字节。但在处理字符串时经常会和子字符串打交道，所以Java对字符串的表示希望能够避免复制字符串中的字符。</p>
<p>当调用<code>substring()</code>方法时，就创建了一个新的String对象（40字节），但它仍然重用了相同的<code>value[]</code>数组，因此该字符串的子字符串只会使用40字节的内存。含有原始字符串的字符数组的别名存在于子字符串中，字符串对象的偏移量和长度域标记了子字符串的位置。</p>
<p>这些基础机制能够有效地帮助我们估计大量程序对内存的使用情况，但是很多复杂的因素仍然会使这个任务变得困难，这就得看一下JVM方面的书籍了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11098789.html" target="_blank" rel="external">算法 第四版</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google Java Style]]></title>
      <url>http://wangzzu.github.io/2016/04/22/google-java-style/</url>
      <content type="html"><![CDATA[<p>这份文档是Google Java编程风格规范的定义。在平时编写代码时应该养成一个良好的习惯，按照这个标准去编写容易维护的代码。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。</p>
<h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>源文件编码格式为：<strong>UTF-8</strong>。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(<code>0x20</code>，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="特殊转义序列"><a href="#特殊转义序列" class="headerlink" title="特殊转义序列"></a>特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(<code>\b</code>,<code>\t</code>,<code>\n</code>, <code>\f</code>, <code>\r</code>,<code>&quot;</code>,<code>&#39;</code>及<code>\</code>)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p>
<h3 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如<code>∞</code>)，还是使用等价的Unicode转义符(比如<code>\u221e</code>)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含（按顺序地）：</p>
<ol>
<li>许可证版权信息（如果需要的情况下）；</li>
<li>package语句；</li>
<li>import语句；</li>
<li>一个顶级类（只有一个）；</li>
</ol>
<p><em>以上每个部分用一个空行隔开。</em></p>
<h2 id="许可证或版权信息"><a href="#许可证或版权信息" class="headerlink" title="许可证或版权信息"></a>许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h2><p><strong>package语句不换行</strong>，列限制并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><ul>
<li>import<strong>不要使用通配符</strong>，不要出现类似这样的import语句：<code>import java.util.*</code>；</li>
<li>import语句<strong>不要换行</strong>，每个import语句独立成行；</li>
<li>顺序与间距：import语句分为以下几组，按照这个顺序，每组由一个空行分隔。<ol>
<li>所有的静态类导入独立成组；</li>
<li><code>com.google</code> imports；</li>
<li>第三的包。每个包为一组，字典序，如<code>andriod</code>，<code>com</code>，<code>junit</code>，<code>org</code>，<code>sun</code>.</li>
<li><code>java</code> imports;</li>
<li><code>javax</code> imports.</li>
</ol>
</li>
</ul>
<p>组内不空行，按字典序排序。</p>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><h3 id="只有一个顶级类声明"><a href="#只有一个顶级类声明" class="headerlink" title="只有一个顶级类声明"></a>只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>
<p>例如：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>
<h3 id="类成员顺序"><a href="#类成员顺序" class="headerlink" title="类成员顺序"></a>类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以<strong>某种逻辑</strong>去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h3 id="重载：永不分离"><a href="#重载：永不分离" class="headerlink" title="重载：永不分离"></a>重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><h3 id="使用大括号"><a href="#使用大括号" class="headerlink" title="使用大括号"></a>使用大括号</h3><p>当大括号与<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>语句一起使用，即使只有一条语句（或者是空），也应该把大括号写上。</p>
<h3 id="非空块"><a href="#非空块" class="headerlink" title="非空块"></a>非空块</h3><p>对于非空块和块状结构，主要有以下几个原则：</p>
<ul>
<li>在左大括号前不换行；</li>
<li>左大括号后换行；</li>
<li>右大括号前换行；</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//示例</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (condition()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                something();</div><div class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</div><div class="line">                recover();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="空块"><a href="#空块" class="headerlink" title="空块"></a>空块</h3><p>这里主要有两种情况：</p>
<ul>
<li>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行；</li>
</ul>
<ul>
<li>但是也有例外的情况：如果它是一个多块语句的一部分(<code>if/else</code>或 <code>try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不换行</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="块缩进：2个空格"><a href="#块缩进：2个空格" class="headerlink" title="块缩进：2个空格"></a>块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加<strong>2个空格</strong>，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。（不过一般情况大家用的都是4个，这个的话看个人喜好，感觉只要统一就可以了）</p>
<h2 id="一行一个语句"><a href="#一行一个语句" class="headerlink" title="一行一个语句"></a>一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="列限制：80或100"><a href="#列限制：80或100" class="headerlink" title="列限制：80或100"></a>列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ul>
<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考);</li>
<li><code>package</code>和<code>import</code>语句;</li>
<li>注释中那些可能被剪切并粘贴到shell中的命令行.</li>
</ul>
<h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(<strong>80或100</strong>个字符)而被分为多行，我们称之为<strong>自动换行</strong>(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h3 id="从哪里断开"><a href="#从哪里断开" class="headerlink" title="从哪里断开"></a>从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ul>
<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
<li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ul>
<h3 id="自动换行时缩进至少-4个空格"><a href="#自动换行时缩进至少-4个空格" class="headerlink" title="自动换行时缩进至少+4个空格"></a>自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><h3 id="垂直空白"><a href="#垂直空白" class="headerlink" title="垂直空白"></a>垂直空白</h3><p>以下情况需要使用<strong>一个空行</strong>：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<br>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>
<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>
<h3 id="水平空白"><a href="#水平空白" class="headerlink" title="水平空白"></a>水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和<code>Javadoc</code>用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
<li>在任何左大括号前(<code>{</code>)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
<li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
<li><code>catch</code>块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
<li><code>foreach</code>语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则<strong>双斜杠(//)两边都要空格</strong>。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li><p>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</p>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
</li>
</ol>
<h3 id="水平对齐：不做要求"><a href="#水平对齐：不做要求" class="headerlink" title="水平对齐：不做要求"></a>水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 未对齐</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></div><div class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></div><div class="line"><span class="comment">// 对齐</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// permitted, but future edits</span></div><div class="line"><span class="keyword">private</span> Color color; <span class="comment">// may leave it unaligned</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h2 id="用小括号来限定组：推荐"><a href="#用小括号来限定组：推荐" class="headerlink" title="用小括号来限定组：推荐"></a>用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。（把所有优先级表全部记下来是比较困难的）</p>
<h2 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</div></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="每次只声明一个变量"><a href="#每次只声明一个变量" class="headerlink" title="每次只声明一个变量"></a>每次只声明一个变量</h4><p><strong>不要使用组合声明</strong>，比如<code>int a, b</code>;。</p>
<h4 id="局部变量需要时才声明，并尽快进行初始化"><a href="#局部变量需要时才声明，并尽快进行初始化" class="headerlink" title="局部变量需要时才声明，并尽快进行初始化"></a>局部变量需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组初始化：可写成块状结构"><a href="#数组初始化：可写成块状结构" class="headerlink" title="数组初始化：可写成块状结构"></a>数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>,</div><div class="line">     <span class="number">1</span>,</div><div class="line">     <span class="number">2</span>,</div><div class="line">     <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">     <span class="number">0</span>, <span class="number">1</span>,</div><div class="line">     <span class="number">2</span>, <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<h4 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>与其它块状结构一致，<code>switch</code>块中的内容缩进为2个空格。</p>
<p>每个<code>switch</code>标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h4 id="Fall-through：注释"><a href="#Fall-through：注释" class="headerlink" title="Fall-through：注释"></a>Fall-through：注释</h4><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (input) &#123;</div><div class="line">     <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">     <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">         prepareOneOrTwo();</div><div class="line">         <span class="comment">// fall through</span></div><div class="line">     <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">         handleOneTwoOrThree();</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">     <span class="keyword">default</span>:</div><div class="line">         handleLargeNumber(input);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="default的情况要写出来"><a href="#default的情况要写出来" class="headerlink" title="default的情况要写出来"></a>default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>
<h3 id="注解-Annotations"><a href="#注解-Annotations" class="headerlink" title="注解(Annotations)"></a>注解(<code>Annotations</code>)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解<strong>独占一行</strong>。这些换行不属于自动换行，因此缩进级别不变。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</div></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="块注释风格"><a href="#块注释风格" class="headerlink" title="块注释风格"></a>块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* This is // And so /* Or you can</div><div class="line">* okay. // is this. * even do this. */</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
<h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>类和成员的<code>modifiers</code>如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></div></pre></td></tr></table></figure>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="对所有标识符都通用的规则"><a href="#对所有标识符都通用的规则" class="headerlink" title="对所有标识符都通用的规则"></a>对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>,<code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>
<h2 id="标识符类型的规则"><a href="#标识符类型的规则" class="headerlink" title="标识符类型的规则"></a>标识符类型的规则</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>包名<strong>全部小写</strong>，连续的单词只是<strong>简单地连接</strong>起来，不使用下划线。</p>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，<strong>全部字母大写，用下划线分隔单词</strong>。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态<code>final</code>字段，但不是所有静态<code>final</code>字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Constants</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>); <span class="comment">// because Joiner is immutable</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</div><div class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</div><div class="line"></div><div class="line"><span class="comment">// Not constants</span></div><div class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</div><div class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</div></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="非常量字段名"><a href="#非常量字段名" class="headerlink" title="非常量字段名"></a>非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="局部变量名"><a href="#局部变量名" class="headerlink" title="局部变量名"></a>局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是<code>final</code>和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="类型变量名"><a href="#类型变量名" class="headerlink" title="类型变量名"></a>类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h2 id="驼峰式命名法-CamelCase"><a href="#驼峰式命名法-CamelCase" class="headerlink" title="驼峰式命名法(CamelCase)"></a>驼峰式命名法(<code>CamelCase</code>)</h2><p>驼峰式命名法：</p>
<ol>
<li>大驼峰式命名法(<code>UpperCamelCase</code>);</li>
<li>小驼峰式命名法(<code>lowerCamelCase</code>)。</li>
</ol>
<p>有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ol>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ol>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Prose form Correct Incorrect</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="string">"XML HTTP request"</span> XmlHttpRequest XMLHTTPRequest</div><div class="line"><span class="string">"new customer ID"</span> newCustomerId newCustomerID</div><div class="line"><span class="string">"inner stopwatch"</span> innerStopwatch innerStopWatch</div><div class="line"><span class="string">"supports IPv6 on iOS?"</span> supportsIpv6OnIos supportsIPv6OnIOS</div><div class="line"><span class="string">"YouTube importer"</span> YouTubeImporter</div><div class="line">YoutubeImporter*</div></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>
</blockquote>
<h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="Override：能用则用"><a href="#Override：能用则用" class="headerlink" title="@Override：能用则用"></a><code>@Override</code>：能用则用</h2><p>只要是合法的，就把<code>@Override</code>注解给用上。</p>
<h2 id="捕获的异常：不能忽视"><a href="#捕获的异常：不能忽视" class="headerlink" title="捕获的异常：不能忽视"></a>捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>
<p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     <span class="keyword">int</span> i = Integer.parseInt(response);</div><div class="line">     <span class="keyword">return</span> handleNumericResponse(i);</div><div class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</div><div class="line">     <span class="comment">// it's not numeric; that's fine, just continue</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> handleTextResponse(response);</div></pre></td></tr></table></figure>
<blockquote>
<p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     emptyStack.pop();</div><div class="line">     fail();</div><div class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态成员：使用类进行调用"><a href="#静态成员：使用类进行调用" class="headerlink" title="静态成员：使用类进行调用"></a>静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Foo aFoo = ...;</div><div class="line">Foo.aStaticMethod(); <span class="comment">// good</span></div><div class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></div><div class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></div></pre></td></tr></table></figure>
<h2 id="Finalizers-禁用"><a href="#Finalizers-禁用" class="headerlink" title="Finalizers: 禁用"></a><code>Finalizers</code>: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Multiple lines of Javadoc text are written here,</div><div class="line">* wrapped normally...</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></div></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="Javadoc标记"><a href="#Javadoc标记" class="headerlink" title="Javadoc标记"></a>Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="摘要片段"><a href="#摘要片段" class="headerlink" title="摘要片段"></a>摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="哪里需要使用Javadoc"><a href="#哪里需要使用Javadoc" class="headerlink" title="哪里需要使用Javadoc"></a>哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个<code>public</code>和<code>protected</code>成员处使用Javadoc，以下是一些例外：</p>
<h3 id="例外：不言自明的方法"><a href="#例外：不言自明的方法" class="headerlink" title="例外：不言自明的方法"></a>例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
</blockquote>
<h3 id="例外：重写"><a href="#例外：重写" class="headerlink" title="例外：重写"></a>例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p>
<h3 id="可选的Javadoc"><a href="#可选的Javadoc" class="headerlink" title="可选的Javadoc"></a>可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Java Style</a></li>
<li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Style编程指南</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[postgres安装]]></title>
      <url>http://wangzzu.github.io/2016/04/14/postgres-install/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下在linux（CentOS7.1）下postgres的安装，后续的一篇博文会着重的介绍一下SQL操作。</p>
<p>注：</p>
<ul>
<li>#：超级用户提示符</li>
<li>$：普通用户提示符</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install postgresql</div><div class="line">$ sudo yum install pgadmin3</div><div class="line"></div><div class="line">$ su postgres <span class="comment">#切换psql用户下</span></div><div class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></div></pre></td></tr></table></figure>
<p>修改用户postgres密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo passwd postgres <span class="comment">#重置新密码</span></div></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /var/lib/pgsql/data      #创建pgsql的数据库目录</div><div class="line"># cd /var/lib/pgsql</div><div class="line"># chown postgres.postgres data     #改变目录的所属用户用组</div><div class="line"># su postgres                     #切换到postgres，不然初始化不了</div><div class="line"></div><div class="line">initdb -E UTF-8 -D /var/lib/pgsql/data --locale=en_US.UTF-8 -U postgres -W  #在postgres下，初始化数据库(初始化过程中，需要输入root密码)</div></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件，修改postgresql.conf的目的是修改连接权限；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># vim /var/lib/pgsql/data/postgresql.conf</span></div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listen_addresses = <span class="string">'*'</span>     <span class="comment">#监听所有ip的连接，默认是本机 ip，当然也可以设置局域网ip</span></div><div class="line">port = 5432             <span class="comment">#这个不开也行，默认就是5432端口</span></div></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/pg_hba.conf</code>文件，修改pg_hba.conf的目的是设置谁才可以操作数据服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /var/lib/pgsql/data/pg_hba.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD</span></div><div class="line"><span class="comment"># "local" is for Unix domain socket connections only</span></div><div class="line"><span class="built_in">local</span>   all         all                               trust</div><div class="line"><span class="comment"># IPv4 local connections:</span></div><div class="line">host    all         all         127.0.0.1/32          <span class="literal">true</span></div><div class="line">host    all         all         0.0.0.0/0             <span class="literal">true</span>   <span class="comment">#这一行我加的，所有IP和用户，密码对都可以连接</span></div><div class="line"><span class="comment"># IPv6 local connections:</span></div><div class="line">host    all         all         ::1/128               <span class="literal">true</span></div></pre></td></tr></table></figure>
<h1 id="psql使用"><a href="#psql使用" class="headerlink" title="psql使用"></a>psql使用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># systemctl start postgresql.service</div><div class="line"># or</div><div class="line"># service postgresql start</div></pre></td></tr></table></figure>
<p>但是出现了一个问题：</p>
<p><img src="/images/2016-04-14-postgresql/1.png" alt="startFailed"></p>
<p>使用<code>systemctl status postgresql.service</code>查看日志信息：</p>
<p><img src="/images/2016-04-14-postgresql/fail.png" alt="fail"></p>
<p>检查：</p>
<ul>
<li><p>配置防火墙，在<code>/etc/sysconfig/iptables</code>中添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT //postgresql的端口是5432</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</div></pre></td></tr></table></figure>
</li>
<li><p>然后设置<code>systemctl enable postgresql.service</code> 来设置<code>/usr/lib/systemd/system/postgresql.service</code>文件。</p>
</li>
</ul>
<p>成功启动的psql如下所示：</p>
<p><img src="/images/2016-04-14-postgresql/status.png" alt="status"></p>
<p>通过<code>netstat -tpnl | grep 5432</code>来查看5432端口的情况。</p>
<p><img src="/images/2016-04-14-postgresql/port.png" alt="port"></p>
<h2 id="添加用户和数据库"><a href="#添加用户和数据库" class="headerlink" title="添加用户和数据库"></a>添加用户和数据库</h2><p>推荐两个学习的网站：</p>
<ul>
<li><a href="http://developer.51cto.com/art/201401/426437.htm" target="_blank" rel="external">psql学习网站</a></li>
<li><a href="http://www.yiibai.com/html/postgresql/" target="_blank" rel="external">psql教程</a></li>
</ul>
<p>首先，在linux下进入到<code>postgres</code>用户名下，然后进入到postgres的控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># su postgres</div><div class="line">psql</div></pre></td></tr></table></figure>
<p>这样就进入了<strong>数据库的控制台</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#不要忘记每句话后的";"，建立数据库用户时，首先linux系统下要有user用户(adduser user )，然后才可以再把user用户指定为数据库的用户。</span></div><div class="line"></div><div class="line">CREATE USER matt WITH PASSWORD <span class="string">'123456'</span>;<span class="comment">#创建数据库用户matt，并设置密码</span></div><div class="line"></div><div class="line">CREATE DATABASE bank OWNER matt;<span class="comment">#创建数据库bank，并指定该数据库的所有者为matt</span></div><div class="line"></div><div class="line">GRANT ALL PRIVILEGES ON DATABASE bank to matt;<span class="comment">#将test数据库的所有权限都赋给用户matt，否则用户matt只能登陆控制台，没有任何数据库操作权限</span></div><div class="line"></div><div class="line">\q <span class="comment">#退出控制台（ctrl+D）</span></div></pre></td></tr></table></figure>
<p>控制台命令：</p>
<ul>
<li><strong>\h</strong>：查看SQL命令的解释，比如\h select。</li>
<li><strong>\?</strong>：查看psql命令列表。</li>
<li><strong>\l</strong>：列出所有数据库。</li>
<li><strong>\c [database_name]</strong>：连接其他数据库。</li>
<li><strong>\d</strong>：列出当前数据库的所有表格。</li>
<li><strong>\d [table_name]</strong>：列出某一张表格的结构。</li>
<li><strong>\du</strong>：列出所有用户。</li>
<li><strong>\e</strong>：打开文本编辑器。</li>
<li><strong>\conninfo</strong>：列出当前数据库和连接的信息</li>
</ul>
<h2 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">psql -U matt <span class="_">-d</span> bank -h 127.0.0.1 -p 5432<span class="comment">#上面命令的参数含义如下：-U指定用户，-d指定数据库，-h指定服务器，-p指定端口。</span></div><div class="line"><span class="comment"># or</span></div><div class="line">psql -U matt <span class="_">-d</span> bank</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 建立四张表，不要忘记最后面的“；”号</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(customer_name <span class="built_in">char</span>(<span class="number">20</span>), customer_street <span class="built_in">char</span>(<span class="number">30</span>), customer_city <span class="built_in">char</span>(<span class="number">30</span>), primary <span class="keyword">key</span>(customer_name));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> branch(branch_name <span class="built_in">char</span>(<span class="number">15</span>), branch_city <span class="built_in">char</span>(<span class="number">30</span>), assets <span class="built_in">numeric</span>(<span class="number">16</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(branch_name));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(account_number <span class="built_in">char</span>(<span class="number">10</span>), branch_name <span class="built_in">char</span>(<span class="number">15</span>), balance <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(account_number));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> depositor(customer_name <span class="built_in">char</span>(<span class="number">20</span>), account_number <span class="built_in">char</span>(<span class="number">10</span>), primary <span class="keyword">key</span>(customer_name, account_number));</div></pre></td></tr></table></figure>
<p>其他的SQL命令会后续的博客中详细介绍。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="连接数据库失败"><a href="#连接数据库失败" class="headerlink" title="连接数据库失败"></a>连接数据库失败</h2><p>错误为<code>org.postgresql.util.PSQLException: FATAL: password authentication failed for user &quot;postgres&quot;</code>。<br>打开Postgresql安装目录下的data文件夹，找到pg_hba.conf文件并打开。修改认证方式，将md5改为trust，然后保存。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TYPE DATABASE USER CIDR-ADDRESS METHOD</span></div><div class="line"><span class="comment"># IPv4 local connections:</span></div><div class="line">host all all 127.0.0.1/32 trust<span class="comment">#md5改为trust</span></div><div class="line">host all all 0.0.0.0/0 trust</div></pre></td></tr></table></figure>
<p>参考<a href="http://blog.chinaunix.net/uid-26149100-id-3189230.html" target="_blank" rel="external">Postgresql常见问题</a>。</p>
<h2 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h2><p>有可能是电脑的端口5432的TCP/IP允许没有开启。</p>
<h2 id="JAVA接口"><a href="#JAVA接口" class="headerlink" title="JAVA接口"></a>JAVA接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">table_insert</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">         Connection c = <span class="keyword">null</span>;</div><div class="line">         Statement stmt = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">         <span class="keyword">long</span> time= <span class="number">201503292255L</span>;</div><div class="line">         <span class="keyword">int</span> client_id=<span class="number">4</span>;</div><div class="line">         <span class="keyword">int</span> server_id=<span class="number">3</span>;</div><div class="line">         <span class="keyword">int</span> server_location=<span class="number">110000</span>;</div><div class="line">         String WebName=<span class="string">"other"</span>;</div><div class="line">         <span class="keyword">int</span> count=<span class="number">1000</span>;</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             Class.forName(<span class="string">"org.postgresql.Driver"</span>);</div><div class="line">             c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://192.168.81.136:5432/postgres"</span>,<span class="string">"postgres"</span>,<span class="string">"psql"</span>);</div><div class="line">             c.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">             System.out.println(<span class="string">"Opened database successfully"</span>);</div><div class="line"></div><div class="line">             stmt = c.createStatement();</div><div class="line"></div><div class="line">             <span class="comment">//String sql = "INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( 201503292255, 1, 3, 110000,'others', 2);";</span></div><div class="line"></div><div class="line">             <span class="comment">//String sql="INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( "+time+", "+client_id+", "+server_id+", "+server_location+", '"+WebName+"'"+", "+count+");";</span></div><div class="line"></div><div class="line">             String sql=<span class="string">"UPDATE traffic SET count="</span>+count+<span class="string">" WHERE time="</span>+time+<span class="string">" AND client_id="</span>+client_id+<span class="string">" AND server_id="</span>+server_id+<span class="string">" AND server_location="</span>+server_location+<span class="string">" AND web_name= '"</span>+WebName+<span class="string">"';"</span>;</div><div class="line">             stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">             stmt.close();<span class="comment">//必须从要有对应关闭数据库的操作，否则会出现问题</span></div><div class="line">             c.commit();</div><div class="line">             <span class="comment">//c.close();</span></div><div class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">             System.err.println( e.getClass().getName()+<span class="string">": "</span>+ e.getMessage() );</div><div class="line">             System.exit(<span class="number">0</span>);</div><div class="line">         &#125;</div><div class="line">         System.out.println(<span class="string">"Records created successfully"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里必须要有数据库关闭的操作。</p>
<h2 id="连接数过多"><a href="#连接数过多" class="headerlink" title="连接数过多"></a>连接数过多</h2><p><code>So many clients alreay！</code>.<br>查看的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--控制台下输入</span></div><div class="line"></div><div class="line"><span class="comment">--当前总共正在使用的连接数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> pg_stat_activity;</div><div class="line"><span class="comment">--显示系统允许的最大连接数</span></div><div class="line"><span class="keyword">show</span> max_connections;</div><div class="line"><span class="comment">--显示系统保留的用户数</span></div><div class="line"><span class="keyword">show</span> superuser_reserved_connections ;</div></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件的<code>max_connections</code>，默认为100.但是更多的时候需要考虑的是为什么数据库的连接会那么多，一般情况下是自己的程序出错了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://blog.51yip.com/pgsql/1520.html" target="_blank" rel="external">Postgres安装介绍</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper之学习笔记]]></title>
      <url>http://wangzzu.github.io/2016/04/13/zookeeper-learn/</url>
      <content type="html"><![CDATA[<p>Zookeeper的重要性及应用的广泛性，这里就不再叙述了，本文是学习<a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南</a>的基础上进行的总结，当然本文大部分内容来自此书，中间会穿插一些个人的理解。本文主要分以下几块进行详述。</p>
<blockquote>
<ul>
<li>ZooKeeper介绍</li>
<li>Zookeeper安装与运行</li>
<li>ZooKeeper组成员关系</li>
<li>ZooKeeper服务</li>
<li>ZooKeeper应用</li>
</ul>
</blockquote>
<h1 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h1><p><a href="https://zookeeper.apache.org/" target="_blank" rel="external">官网</a>对其介绍的原话如下：</p>
<blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.</p>
</blockquote>
<p>总结一下就是，Zookeeper分布式服务框架是一个用来解决分布式应用中经常遇到的一些数据管理问题（如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等）的中央服务。</p>
<p>对于一个分布式系统最困难的事情之一就是如何处理<strong>部分失败</strong>（partial failure）。当一条message在网络中的两个节点之间传送时，如果出现了网络错误，发送者无法知道接收者是否已经接收到了这条message。接收者有可能在发生错误之前收到这个message，也有可能没有收到，还有可能接收者已经挂掉。发送者获得真实情况的一般解决方案就是：重新连接接收者，然后发起询问。这就是部分失败：即我们甚至不知道一个操作是否已经完成。</p>
<p>Zookeeper正是为了解决这个问题而应运而生的，当然Zookeeper并不能完全根除部分失败，当然它也不会隐藏这部分的失败。ZooKeeper具有以下几个特点：</p>
<ul>
<li>简单：它的核心是一个精简的文件系统，它提供一些简单的操作和一些额外的抽象操作；</li>
<li>富有表现力：ZooKeeper可以用于实现多种协议和数据结构；</li>
<li>高可用性：可避免单点故障；</li>
<li>采用耦合交互方式：在交互过程中，参与者不需要彼此了解，进程在不了解其他进程的情况下就能够彼此发现并进行交互；</li>
<li>是一个资源库：它是一个开源共享存储库，能使程序员免于编写这类通用的协议。</li>
<li>高性能：对于写操作而言，Zookeeper的基准测试吞吐量已经超过每秒10000个操作，对于常规的读操作，吞吐量更高。</li>
</ul>
<h1 id="Zookeeper的安装与运行"><a href="#Zookeeper的安装与运行" class="headerlink" title="Zookeeper的安装与运行"></a>Zookeeper的安装与运行</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="external">Zookeeper镜像上</a>下载Zookeeper安装包（这里以<code>zookeeper-3.4.6.tar.gz</code>为例）。这里给出一般Zookeeper的安装与运行的方法，很多实际生成环境中，我们都是使用CDH集成的Zookeeper，这样的话安装与运行就完全可以通过图形化界面操作了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解压</span></div><div class="line">tar -zxvf zookeeper-3.4.6.tar.gz -C /opt</div><div class="line"><span class="comment"># 复制配置文件</span></div><div class="line">cp /opt/zookeeper/zoo_sample.cfg /opt/zookeeper/zoo.cfg</div></pre></td></tr></table></figure>
<p>修改配置文件<code>zoo.cfg</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dataDir=/opt/zookeeper/data</div><div class="line">dataLogDir=/opt/zookeeper/logs</div><div class="line">clientPort=2181</div><div class="line">tickTime=2000</div><div class="line">initLimit=5</div><div class="line">syncLimit=2</div><div class="line">server.1=zookeeper1:2888:3888</div><div class="line">server.2=zookeeper2:2888:3888</div><div class="line">server.3=zookeeper3:2888:3888</div></pre></td></tr></table></figure>
<p>首先需要在<code>dataDir</code>目录下，新建一个名为<code>myid</code>的文件，这个文件的作用是指定这个服务器的ID，服务器ID在集合体中是唯一的，并且取值范围在1到255之间。下面再分别介绍一下其他几个参数的意义：</p>
<ul>
<li>dataDir：数据目录；</li>
<li>dataLogDir：日志目录；</li>
<li>clientPort：客户端连接端口；</li>
<li>tickTime：Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳（它也是Zookeeper中的基本时间单位）；</li>
<li>initLimit：设定了允许所有follower（下面会介绍）与leader进行连接并同步的时间，它是tickTime的整数倍；</li>
<li>syncLimit：设定了一个follower与leader进行同步的时间，也是tickTime的整数倍；</li>
<li>server.n=hostname:port1:port2：n的值就是服务器的ID，port1是follower用来连接leader的端口，port2是用于leader选举。总结起来就是，2181用于客户端连接，对于leader来说，2888端口用于follower连接，3888端口用于leader选举阶段的其他服务器连接。</li>
</ul>
<h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2><p>启动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh start</div></pre></td></tr></table></figure>
<p>停止：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh stop</div></pre></td></tr></table></figure>
<h1 id="ZooKeeper组成员关系"><a href="#ZooKeeper组成员关系" class="headerlink" title="ZooKeeper组成员关系"></a>ZooKeeper组成员关系</h1><p>Zookeeper是一个具有高可用性的高性能协调服务。</p>
<h2 id="组成员关系"><a href="#组成员关系" class="headerlink" title="组成员关系"></a>组成员关系</h2><p>Zookeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，但是这个文件系统中没有文件和目录，而是统一使用节点（node）的概念，成为<strong>znode</strong>。znode既可以作为保存数据的容器（如：文件），也可以作为保存其他znode的容器（如：目录）。所有的znode构成一个层次化的命名空间。一种自然的建立组成员列表的方式就是利用这个层次结构，如下图所示，首先创建一个以组名（<code>/zk</code>）为节点的znode作为父节点，然后以组成员（<code>/zk/node1</code>、<code>/zk/node2</code>、<code>/zk/node3</code>）为节点名来创建作为子节点的znode。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/group.png" alt="group"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>本例通过一个小项目来介绍Zookeeper的API使用。工程项目参见<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/groupexample" target="_blank" rel="external">ZooKeeperGroupExample</a>.</p>
<p>这里是使用maven建立的工程，pom文件中jar包的依赖内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5-cdh5.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h3><p>本程序是在Zookeeper中新建表示组的znode，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateGroup</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">	<span class="keyword">private</span> ZooKeeper zk;</div><div class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		zk = <span class="keyword">new</span> ZooKeeper(hosts, SESSION_TIMEOUT, <span class="keyword">this</span>);</div><div class="line">		connectedSignal.await();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</div><div class="line">			connectedSignal.countDown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName;</div><div class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		System.out.println(<span class="string">"CreateGroup: Created"</span> + createdPath);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		zk.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		CreateGroup createGroup = <span class="keyword">new</span> CreateGroup();</div><div class="line">		createGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		createGroup.create(args[<span class="number">1</span>]);</div><div class="line">		createGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序的主要接口有：</p>
<ul>
<li><code>new ZooKeeper()</code>:实例化一个新的Zookeeper类的对象，这个类负责维护客户端和Zookeeper服务之间的联系。它有三个参数<ol>
<li>Zookeeper服务的主机地址（可指定端口，默认是2181）；</li>
<li>以毫秒为单位的会话超时参数；</li>
<li>一个<code>Watcher</code>对象的实例，<code>Watcher</code>对象接收来自Zookeeper的回调，以获得各种事件的通知。</li>
</ol>
</li>
<li><code>zk.create()</code>:创建一个新的Zookeeper的znode。它有四个参数：<ol>
<li>路径（字符串表示）；</li>
<li>znode的内容（字节数组，本例中都使用null值）；</li>
<li>ACL（访问控制列表）；</li>
<li>创建znode的类型，有短暂和持久两种。</li>
</ol>
</li>
</ul>
<p>当一个Zookeeper实例新建时，会启动一个线程连接到Zookeeper服务，它对构造函数是立即返回的，因此在新建的Zookeeper对象之前一定要等待其与Zookeeper服务之间连接成功。这里使用<code>CountDownLatch</code>来阻止使用的Zookeeper对象。当客户端与Zookeeper建立连接之后，<code>Watcher</code>的<code>process()</code>方法会被调用，参数表示一个连接的事件。在接收到一个连接事件（以<code>Watcher.Event.KeeperState</code>的枚举类型值<code>SyncConnected</code>来表示）时，我们通过调用<code>CountDownLatch</code>的<code>countDown()</code>方法来递减它的计数器。锁存器（latch）被创建时带有一个值为1的计数器，用于表示它在释放所有线程之前需要发生的事件数。在调用一次<code>countDown()</code>方法之后，计数器的值变为0，则<code>await()</code>方法返回。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.CreateGroup zkIP matt</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CreateGroup: Created/matt</div></pre></td></tr></table></figure>
<h3 id="创建组成员"><a href="#创建组成员" class="headerlink" title="创建组成员"></a>创建组成员</h3><p>下面我们编写一个用于注册组成员的程序，每个组成员将作为一个程序运行，并且加入到组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于等待建立与Zookeeper连接的辅助类</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT=<span class="number">5000</span>;</div><div class="line">	<span class="keyword">protected</span> ZooKeeper zk;</div><div class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</div><div class="line">		zk=<span class="keyword">new</span> ZooKeeper(hosts,SESSION_TIMEOUT,<span class="keyword">this</span>);</div><div class="line">		connectedSignal.await();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(event.getState()== Event.KeeperState.SyncConnected)&#123;</div><div class="line">			connectedSignal.countDown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span>  InterruptedException</span>&#123;</div><div class="line">		zk.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码与<code>CreateGroup</code>的很类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用于将组成员加入到组中</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(String groupName, String memberName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName + <span class="string">"/"</span> + memberName;</div><div class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		System.out.println(<span class="string">"Created "</span> + createdPath);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		JoinGroup joinGroup = <span class="keyword">new</span> JoinGroup();</div><div class="line">		joinGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		joinGroup.join(args[<span class="number">1</span>], args[<span class="number">2</span>]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>CreateMode.PERSISTENT</code>也可以设置为<code>CreateMode.EPHEMERAL</code>，当设置为<code>EPHEMERAL</code>时，也就意味着这个znode是一个短暂的znode，一旦关闭客户端，子节点的znode就会从父节点的znode中删除。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm1</div><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm2</div><div class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm3</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Created /matt/wm1</div><div class="line">Created /matt/wm2</div><div class="line">Created /matt/wm3</div></pre></td></tr></table></figure>
<h3 id="列出组成员"><a href="#列出组成员" class="headerlink" title="列出组成员"></a>列出组成员</h3><p>这段程序的目标是，在给出Zookeeper地址和父节点znode的情况下，列出该父节点znode的子节点znode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</div><div class="line">		String path = <span class="string">"/"</span> + groupName;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;String&gt; children = zk.getChildren(path, <span class="keyword">false</span>);</div><div class="line">			<span class="keyword">if</span> (children.isEmpty()) &#123;</div><div class="line">				System.out.printf(<span class="string">"No members in group %s\n"</span>, groupName);</div><div class="line">				System.exit(<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> (String child : children) &#123;</div><div class="line">				System.out.println(child);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</div><div class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		ListGroup listGroup = <span class="keyword">new</span> ListGroup();</div><div class="line">		listGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		listGroup.list(args[<span class="number">1</span>]);</div><div class="line">		listGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是调用了<code>zk.getChildren()</code>来打印出一个znode的子节点列表，调用参数为该znode的路径和设为false的观察标志。如果在一个znode上设置了观察标志，那么一旦该znode的状态改变，关联的观察（<code>Watcher</code>）会被触发。在这里我们没有使用观察，但是在查看一个znode的子节点时，也可以设置观察，让应用程序接收到组成员加入、退出和组被删除的有关通知。</p>
<p><code>KeeperException.NoNodeException</code>代表了组znode不存在的异常。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.ListGroup 192.168.80.23 matt</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wm1</div><div class="line">wm2</div><div class="line">wm3</div></pre></td></tr></table></figure>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p>这里给出一个删除znode的程序，它需要支持一级目录的递归删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException,InterruptedException</span>&#123;</div><div class="line">		String path=<span class="string">"/"</span>+groupName;</div><div class="line"></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			List&lt;String&gt; children=zk.getChildren(path,<span class="keyword">false</span>);</div><div class="line">			<span class="keyword">for</span>(String child: children)&#123;</div><div class="line">				zk.delete(path+<span class="string">"/"</span>+child,-<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">			zk.delete(path,-<span class="number">1</span>);</div><div class="line">		&#125;<span class="keyword">catch</span> (KeeperException.NoNodeException e)&#123;</div><div class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		DeleteGroup deleteGroup=<span class="keyword">new</span> DeleteGroup();</div><div class="line">		deleteGroup.connect(args[<span class="number">0</span>]);</div><div class="line">		deleteGroup.delete(args[<span class="number">1</span>]);</div><div class="line">		deleteGroup.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zookeeper对象提供了<code>delete()</code>的方法，该方法有两个参数：</p>
<ol>
<li>路径；</li>
<li>版本号：如果所提供的版本号与znode的版本号一致，则Zookeeper会删除这个znode，这是一种乐观枷锁方式，使客户端能够检测出对znode的修改冲突，这里将版本号设置为-1，可以绕过这个版本检测机制，不管znode的版本号是什么而直接将其删除。</li>
</ol>
<p>Zookeeper不支持递归的删除操作，所以在删除父节点之前必须删除其子节点。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp zookeeperexample.jar groupexample.DeleteGroup 192.168.80.23 matt</div></pre></td></tr></table></figure>
<p>通过Zookeeper客户端看到的变化如下图（处理过之后的图）所示：</p>
<p><img src="/images/2016-04-13-zookeeper-learn/zk.png" alt="zk"></p>
<h1 id="ZooKeeper服务"><a href="#ZooKeeper服务" class="headerlink" title="ZooKeeper服务"></a>ZooKeeper服务</h1><p>这里主要通过数据模型、操作、实现、一致性、会话和状态来介绍。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Zookeeper维护着一个树形层次结构，树中的节点被称为znode。znode可以用与存储数据，并且有一个与之关联的ACL。</p>
<ol>
<li>Zookeeper被设计用来协调服务（通常是小数据文件），而不是用于大容量数据存储，因此一个znode能存储的数据被限制在1MB以内；</li>
<li>znode的数据访问具有<strong>原子性</strong>：客户端在读取一个znode数据时，要么读取到所有的数据，要么读操作失败，不会只读到部分数据。同样，写操作将替换znode存储的所有数据（Zookeeper不支持添加操作）；</li>
<li>znode通过路径被引用：Zookeeper中使用的路径必须是绝对路径，而且所有的路径必须是规范的，即每条路径只有唯一的一种表示方式，不支持路径解析；</li>
<li>Zookeeper的路径与URI不同，前者在Java API中通过（<code>java.lang.String</code>）来使用，而后者通过Hadoop <code>Path</code>类（或<code>java.net.URI</code>）来使用。</li>
</ol>
<h3 id="短暂znode"><a href="#短暂znode" class="headerlink" title="短暂znode"></a>短暂znode</h3><p>znode有两种类型，znode的类型在创建时确定并且之后不能再修改。</p>
<ol>
<li>短暂的：在创建短暂znode的客户端会话结束时，Zookeeper会将该短暂znode删除（短暂的znode不能有子节点）；<br>应用：对于那些需要知道特定时刻有哪些分布式资源可用的应用来说，使用短暂znode是一种理想的选择。</li>
<li>持久的：持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除。</li>
</ol>
<h3 id="顺序号"><a href="#顺序号" class="headerlink" title="顺序号"></a>顺序号</h3><ul>
<li>概念<ul>
<li>顺序（sequential）znode是指名称中包含ZooKeeper指定顺序号的znode。</li>
</ul>
</li>
<li>设置<ul>
<li>如果在创建znode时设置了顺序标识，那么该znode名称之后便会附加一个值，这个值由一个单调递增的<strong>计数器</strong>（由父节点维护）所添加的。</li>
</ul>
</li>
<li>举例<ul>
<li>如果一个客户端请求创建一个名为<code>/a/b-</code>的顺序znode，则所创建znode的名字可能是<code>/a/b-3</code>。如果稍后，另外一个名为<code>/a/b-</code>的顺序znode被创建，计数器会给出一个更大的值来保证znode名称的唯一性，例如：<code>/a/b-5</code>。在 Java 的 API 中，顺序 znode 的实际路径会作为 create() 调用的返回值被传回到客户端。</li>
</ul>
</li>
<li>应用<ul>
<li>在一个分布式系统中，顺序号可以被用于为所有的时间进行全局排序，这样客户端就可以通过顺序号来推断事件的顺序。今后的共享锁就是利用该原理。</li>
</ul>
</li>
</ul>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>znode以某种方式发生变化时，<strong>观察</strong>（Watch）机制可以让客户端得到通知。可以针对Zookeeper服务的操作来设置观察，该服务的其他操作可以触发观察。</p>
<p>注意：</p>
<ul>
<li>观察只触发一次，为了得到多次收到通知，客户端需要重新注册所需的观察。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>如下表，Zookeeper中有9种基本操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>创建一个 znode （必须要有父节点）</td>
</tr>
<tr>
<td>delete</td>
<td>删除一个 znode （该 znode不能有任何子节点）</td>
</tr>
<tr>
<td>exists</td>
<td>测试一个 znode 是否存在并且查询它的元数据</td>
</tr>
<tr>
<td>getACL,setACL</td>
<td>获取/设置一个 znode 的 ACL</td>
</tr>
<tr>
<td>getChildren</td>
<td>获取一个 znode 的子节点列表</td>
</tr>
<tr>
<td>getData，setData</td>
<td>获取/设置一个 znode 所保存的数据</td>
</tr>
<tr>
<td>sync</td>
<td>将客户端的 znode 视图与 Zookeeper 同步</td>
</tr>
</tbody>
</table>
<p>Zookeeper 中的更新操作时有条件的，在使用<code>delete</code>或<code>setData</code>操作时必须提供被更新 znode 的版本号（可以通过 exists 操作获得）。如果版本号不匹配，则更新操作会失败。更新操作时非阻塞操作，因此一个更新失败的客户端（由于其他进程同时在更新同一个 znode）可以决定是否重试，或执行其他操作，并不会因此而阻塞其他进程的执行。</p>
<p>虽然 Zookeeper 可以被看作是一个文件系统，但出于简单性的需求，有一些文件系统的基本操作被它摒弃了。由于 Zookeeper 中的文件较小并且总是被整体读写，因此没有必要提供打开、关闭或查找操作。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>对于 Zookeeper 客户端来说，主要由两种语言绑定 (binging) 可以使用：Java 和 C；当然也可以使用 Perl、Python 和 REST 的 contrib 绑定。对于每一种绑定语言来说，在执行操作时都可以选择同步执行或异步执行（提供两种不同的API）。</p>
<p>同步API与异步API的区别：</p>
<ul>
<li>同步API：使用同步API每个线程都会阻塞进程，知道该操作返回；</li>
<li>异步API：允许以流水线方式处理请求，这在某些情况下可以提供更好的吞吐量。</li>
</ul>
<h3 id="观察触发器"><a href="#观察触发器" class="headerlink" title="观察触发器"></a>观察触发器</h3><p>在<code>exists</code>、<code>getChildren</code>和<code>getData</code>这些读操作上可以设置观察，这些观察可以被写操作<code>create</code>、<code>delete</code>和<code>setData</code> 触发。ACL 相关的操作不参与触发任何观察。当一个观察被触发时会产生一个观察事件，这个观察和触发它的操作共同决定着观察事件的类型。</p>
<ul>
<li>当所观察的znode被创建子节点、删除或其他数据更新时，设置在<code>exists</code>操作上的观察将会被触发。</li>
<li>当所观察的znode被删除或其更新时，设置在<code>getData</code>上的观察将会被触发，创建znode不会触发<code>getData</code>上的观察，因为getData操作成功执行的前提是znode必须已经在。</li>
<li>当所观察的znode的一个子节点被创建或删除时，或观察的znode自己被删时，设置在<code>getChildren</code>操作上的观察将会被触发。</li>
</ul>
<p>设置监视器的操作及对应的触发器</p>
<p><img src="/images/2016-04-13-zookeeper-learn/watch.png" alt="watch"></p>
<ul>
<li>NodeCreated:节点创建事件；</li>
<li>NodeDeleted：代表znode被删除事件；</li>
<li>NodeDataChanged：节点数据改变事件；</li>
<li>NodeChildrenChanged：节点的子节点改变事件；</li>
</ul>
<p>注意：</p>
<ul>
<li>对于NodeCreated和NodeDeleted事件，可以通过路径来判断哪一个节点被创建或删除；</li>
<li>对于NodeChildrenChanged事件，需要重新调用<code>getChildren</code>来获取新的子节点列表来判断哪一个子节点被修改；</li>
<li>对于NodeDataChanged事件，需要调用<code>getData</code>来获取最新的数据；</li>
<li>对于上述第二、三种情况，从收到观察事件到执行操作期间，znode的状态可能会发生变化。</li>
</ul>
<h3 id="ACL-列表"><a href="#ACL-列表" class="headerlink" title="ACL 列表"></a>ACL 列表</h3><p>每个 znode 被创建时都会有一个 ACL 列表，用于决定谁可以对它执行何种操作。ACL 依赖于 Zookeeper 的客户端身份验证机制。Zookeeper 提供了一下几种身份验证方式：</p>
<ul>
<li>digest ：通过用户名和密码来识别客户端；</li>
<li>host：通过客户端的主机名（hostname）来识别客户端；</li>
<li>ip : 通过客户端的 IP 地址来识别客户端。</li>
</ul>
<p>在建议一个 Zookeeper 会话之后，客户端可以对自己进行身份验证。虽然 znode 的 ACL 列表会要求所有的客户端是经过验证的，但 Zookeeper 的身份验证过程却是可选的，客户端必须自己进行身份验证来支持对 znode 的访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用digest模式（用户和密码）进行身份验证</span></div><div class="line">zk.addAuthInfo(<span class="string">"digest"</span>,<span class="string">"tom:secret"</span>.getBytes());</div><div class="line"></div><div class="line"><span class="comment">//给域example.com下的客户端对某个znode的读权限，可以使用host模式、example.com的ID和READ权限在该znode上设置一个ACL</span></div><div class="line"><span class="keyword">new</span> ACL(Perms.READ,<span class="keyword">new</span> Id(<span class="string">"host"</span>,<span class="string">"example.com"</span>));</div></pre></td></tr></table></figure>
<p>ACL权限如下表：</p>
<table>
<thead>
<tr>
<th>ACL权限</th>
<th>允许的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>create（子节点）</td>
</tr>
<tr>
<td>READ</td>
<td>getChildren/getData</td>
</tr>
<tr>
<td>WRITE</td>
<td>setData</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（子节点）</td>
</tr>
<tr>
<td>ADMIN</td>
<td>setACL</td>
</tr>
</tbody>
</table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里先介绍一下Zookeeper在实际环境中使用时两种不同的运行模式：</p>
<ol>
<li>独立模式（standalone mode）<ul>
<li>只有一个ZooKeeper服务器，这种模式比较简单，适用于测试环境，但是不能保证高可用性和恢复性；</li>
</ul>
</li>
<li>复制模式（replicated mode）<ul>
<li>运行于一个计算机集群上，这个计算机集群被称为一个”集合体“（ensemble）,ZooKeeper通过复制模式来实现高可用性，只要集合体中有半数以上的机器处于可用状态，他就可以提供服务；</li>
<li>对于一个有5个节点的集合体中，最多可以容忍两台机器出现故障，这里要注意的是对于6个节点的集合体也是只能够容忍2台机器出现故障。</li>
</ul>
</li>
</ol>
<p>ZooKeeper要做的事情就是：确保对znode树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p>
<p>Zookeeper使用了<strong>Zab协议</strong>，该协议包括两个可以无限重复的阶段：</p>
<ol>
<li>阶段1：leader选举<ul>
<li>集合体中的所有机器通过一个选择过程来选出一台被称为“领导者”（leader）的机器，其他的机器被称为”跟随者“（follower）。一旦半数以上（或指定数量）的follower已经将其状态与leader同步，则标明这个阶段已经完成。</li>
</ul>
</li>
<li>阶段2: 原子广播<ol>
<li>所有的写请求都会被转发给leader，再由leader将更新广播给follwer；</li>
<li>当半数以上的follower已经将修改持久化之后，leader才会提交这个更新，然后客户端才会收到一个更新成功的响应。</li>
<li>这个用来打成共识的协议被设计成具有原子性，因此每个修改要么成功要么失败。</li>
</ol>
</li>
</ol>
<p>注意：</p>
<ul>
<li>如果leader出现故障，其余的机器会选出另外一个leader，并和新的leader继续提供服务。之后，如果之前的leader恢复正常，它就变成了一个follower（leader选举工程很快，根据<a href="http://zookeeper.apache.org/doc/current/zookeeperOver" target="_blank" rel="external">目前的结果</a>，大概只需要200ms）；</li>
<li>在更新内存中的znode树之前，集合体中的所有机器都会被先将更新写入磁盘。</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>理解 Zookeeper 的实现基础有助于理解其服务所提供的一致性保证。在集合体中所使用的术语leader和follower是恰当的，它们表名了一点，即一个follower可能滞后于leader几个更新。这也表名了一个现实情况，在一个修改被提交之前，只需要集合体中半数以上机器已经将该修改持久化即可。对 Zookeeper 来说，理想的情况就是将客户端都连接到与leader状态一致的服务器上，每个客户端都有连接到leader，但客户端对此无法控制，甚至它自己都无法知道是否连接到leader。参见下图</p>
<p><img src="/images/2016-04-13-zookeeper-learn/service.png" alt="service"></p>
<p>每一个对 znode 树的更新都被赋予一个全局唯一的 ID，称为<strong>zxid</strong> （代表 “Zookeeper Transaction ID”）。Zookeeper决定了分布式系统中的顺序，它对所有的更新进行排序，如果 zxid z1 小于 z2，则 z1 一定发生在 z2 之前。</p>
<p>在 Zookeeper 的设计中，以下几点考虑保证了数据的一致性。</p>
<ol>
<li>顺序一致性<ul>
<li>来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将 znode z 的值更新为 a，在之后的操作中，它又将 z 的值更新为 b ，则没有客户端能够在看到 z 的值是 b 之后再看到值 a（如果没有其他对于 z 的更新）。</li>
</ul>
</li>
<li>原子性<ul>
<li>更新要么成功，要么失败，不会存在部分成功或失败的结果。如果失败了，则不会有客户端看到这个更新的结果。</li>
</ul>
</li>
<li>单一系统映像<ul>
<li>一个客户端无论连接到具体哪一台服务器上，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。当一台服务器出故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有状态滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器将状态赶上故障服务器。</li>
</ul>
</li>
<li>持久性（可靠性）<ul>
<li>一个更改一旦成功，其结果就会被持久化并且不会被撤。这表明更新不会受到服务器故障的影响。</li>
</ul>
</li>
<li>及时性<ul>
<li>任何客户端所看到的系统视图的滞后都是有限的，不会超过几十秒，这意味着与其允许一个客户端看到非常陈旧的数据，还不如将服务器关闭，强迫该客户端连接到到一个状态较新的服务器。</li>
</ul>
</li>
</ol>
<p>由于性能的原因，所有的读操作都是从 Zookeeper 服务器的内存获得数据，它们不参与写操作的全局排序。如果客户端之间通过 Zookeeper 之外的机制进行通信，则客户端可能会发现它们所看到的 Zookeeper 状态是不一致的。</p>
<p>可以使用<code>sync</code>操作，保证任何后续的操作都在服务器的<code>sync</code>操作完成之后才执行。客户端使用<code>sync</code>操作来使自己保持最新的状态。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>每个 Zookeeper 客户端的配置中都包括集合体中服务器的列表。在启动时，客户端会尝试连接到列表中的一台服务器。如果连接失败，它会尝试连接另一台服务器，以此类推，直到成功与一台服务器建立连接或因为所有 Zookeeper 服务器都不可用而失败。</p>
<p>一旦客户端与一台 Zookeeper 服务器建立连接，这台服务器就会为该客户端创建一个新的会话。每个会话都会有一个超时的时间设置，这个设置由创建会话的应用来设定。如果服务器在超过时间段内没有收到任何请求，则相应的会话会过期。一旦一个会话已经过期，就无法重新被打开，并且任何与该会话相关联的短暂 znode 都会丢失。会话通常会长期存在，而会话过期则是一种比较罕见的事件，但对于应用来说，如何处理会话过期仍是非常重要的。</p>
<p>只要一个会话空闲超过一定时间，都可以通过客户端发送 ping 请求（也称为心跳）来保持会话不过期。（ping 请求是由 Zookeeper 的客户端库自动发送，因此在你的代码中不需要考虑如何维护会话）。这个时间长度的设置应当足够低，以便能够检测出服务器故障（由读超时体现），并且能够在会话超时的时间段内重新连接到另外一台服务器。</p>
<p>Zookeeper 客户端可以自动地进行故障切换，切换至另一台 Zookeeper 服务器，并且关键的是，在另一台服务器接替故障服务器之后，所有的会话（和相关的短暂 znode）仍然是有效的。</p>
<p>在故障切换过程中，应用程序将收到断开连接和连接至服务的通知。当客户端断开连接时，观察通知将无法发送；但是当客户端成功恢复连接后，这些延迟的通知还会被发送。当然，在客户端重新连接至另一台服务器的过程中，如果应用程序试图执行一个操作，这个操作将会失败。这充分说明在真实的 Zookeeper 应用中处理连接丢失异常的重要性。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在 Zookeeper 中有几个时间参数。<strong>滴答 (tickTime)</strong> 参数定义了 ZooKeeper 中的基本时间周期。</p>
<p>其他设置都是根据 滴答 (tickTime) 参数来定义的，或至少受它的限制。例如，会话超时 (session timeout) 参数的值不可以小于 2 个 滴答 (tickTime) 并且不可以大于 20 个 滴答 (tickTime)。如果你试图将会话超时参数设置在这个范围之外，它将会被自动修改到这个范围之内。</p>
<p>通常将 滴答 (tickTime) 参数设置为 2 秒 (2000毫秒)，对应于允许的会话超时范围是 4 到 40 秒。在选择会话超时设置时有几点需要考虑。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>ZooKeeper 对象在其生命周期中会经历几种不同的状态，如下图。你可以在任何时刻通过 <code>getState()</code> 方法来查询对象的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">getState</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>Status被定义为代表Zookeeper对象在不同状态的枚举类型值（一个Zookeeper的实例在一个时刻只能处于一种状态）。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/status.png" alt="status"></p>
<ul>
<li>一个新建的Zookeeper实例处于<code>CONNECTING</code>状态。</li>
<li>一旦建立连接，他就会进入<code>CONNECTED</code>状态。</li>
<li>一个对象在进入<code>CONNECTED</code>状态时，观察对象会收到一个<code>WatchedEvent</code>通知，其中<code>KeeperState</code>的值是<code>SyncConnected</code>。</li>
<li>Zookeeper实例可以断开，然后重新连接到Zookeeper服务，此时它的状态就在<code>CONNECTED</code>和<code>CONNECTING</code>之间转换。</li>
<li>如果<code>close()</code>方法被调用或出现会话超时，Zookeeper实例就会转换到第三个状态<code>CLOSED</code>。一旦处于<code>CLOSED</code>状态，Zookeeper对象就不再被认为是活跃的，并且不能再用。</li>
</ul>
<p>Zookeeper的观察对象有两个作用：</p>
<ul>
<li>它可以用来获得Zookeeper状态变化的相关通知；</li>
<li>它还可以用来获得znode变化的相关通知。</li>
</ul>
<h1 id="ZooKeeper应用"><a href="#ZooKeeper应用" class="headerlink" title="ZooKeeper应用"></a>ZooKeeper应用</h1><h2 id="配置服务示例"><a href="#配置服务示例" class="headerlink" title="配置服务示例"></a>配置服务示例</h2><p>配置服务是分布式系统应用所需要的基本服务之一，它可以使集群中的机器共享配置信息中的那些公共部分。也就是说，Zookeeper可以作为一个具有高可用性的配置服务存储器，允许分布式应用的参与者检索和更新配置文件。</p>
<p>这里我们编写这样一个应用示例（完整代码参考<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/updateexample" target="_blank" rel="external">Zookeeper Update Example</a>），这里有两个假设来简化我们的示例：</p>
<ol>
<li>所需存储的配置数据是字符串，关键字是znode的路径，因此我们在znode上存储了一个键值对；</li>
<li>在任何时候只有一个客户端会执行更新操作。</li>
</ol>
<p>首先我们在<code>ActiveKeyValueStore</code>的类中编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> groupexample.ConnectionWatcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveKeyValueStore</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String path, String value)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		Stat stat = zk.exists(path, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</div><div class="line">			zk.create(path, value.getBytes(CHARSET), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			zk.setData(path, value.getBytes(CHARSET), -<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">(String path, Watcher watcher)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] data = zk.getData(path, watcher, <span class="keyword">null</span><span class="comment">/*stat*/</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(data, CHARSET);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面有两个关键方法：</p>
<ul>
<li><code>write()</code>：将一个关键字及其值写入Zookeeper；</li>
<li><code>read()</code>：读取Zookeeper中的配置属性。</li>
</ul>
<p>Zookeeper的<code>getData()</code>方法有三个参数：</p>
<ol>
<li>路径；</li>
<li>一个观察对象；</li>
<li>一个Stat对象.</li>
</ol>
<p>其中，Stat对象由<code>getData()</code>方法返回的值填充，用来将信息传回给调用者，通过这个方法，调用者可以获得一个znode的数据和元数据，但在本例中，由于我们对元数据不感兴趣，因此将Stat参数设为null。</p>
<p>下面我们编写一个用于更新配置属性值的类<code>ConfigUpdater</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigUpdater</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/matt"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</div><div class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigUpdater</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</div><div class="line">		store.connect(hosts);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">			String value = random.nextInt(<span class="number">100</span>) + <span class="string">" "</span>;</div><div class="line">			store.write(PATH, value);</div><div class="line">			System.out.printf(<span class="string">"Set %s to %s \n"</span>, PATH, value);</div><div class="line">			TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		ConfigUpdater configUpdater=<span class="keyword">new</span> ConfigUpdater(args[<span class="number">0</span>]);</div><div class="line">		configUpdater.run();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>run()</code>方法在随机时间将随机值更新到<code>/matt</code>znode中。</p>
<p>下面我们通过一个<code>ConfigWatcher</code>类初始化一个实例，然后在<code>dirplayConfig()</code>方法中调用<code>read()</code>显示它所读取到的配置信息的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigWatcher</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</div><div class="line">		store.connect(hosts);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayConfig</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</div><div class="line">		String value = store.read(ConfigUpdater.PATH, <span class="keyword">this</span>);</div><div class="line">		System.out.printf(<span class="string">"Read %s as %s.\n"</span>, ConfigUpdater.PATH, value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				displayConfig();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				System.out.println(<span class="string">"Interrupted. exiting."</span>);</div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">				System.out.printf(<span class="string">"KeeperException: %s. Exiting.\n"</span>, e);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		ConfigWatcher configWatcher = <span class="keyword">new</span> ConfigWatcher(args[<span class="number">0</span>]);</div><div class="line">		configWatcher.displayConfig();</div><div class="line"></div><div class="line">		Thread.sleep(Long.MAX_VALUE);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 两个控制台分别运行以下命令</span></div><div class="line">java -cp zookeeperexample.jar updateexample.ConfigUpdater zkIP</div><div class="line">java -cp zookeeperexample.jar updateexample.ConfigWatcher zkIp</div></pre></td></tr></table></figure>
<p>这里要注意<code>ConfigWatcher</code>只能收到最近的一个更新，而不是收到所有的更新，每当<code>ConfigWatcher</code>调用时，就会收到最近的一个更新。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在前面的两个例子，我们经常会看到<code>InterruptedException</code>和<code>KeeperException</code>这两种类型的异常，下面，我们就详细讲述一下。</p>
<h3 id="InterruptedException异常"><a href="#InterruptedException异常" class="headerlink" title="InterruptedException异常"></a>InterruptedException异常</h3><p>如果操作被中断，则会有一个<code>InterruptedException</code>异常。在Java中，有一个取消阻塞方法的标准机制，即针对存在阻塞方法的线程调用<code>interrupt()</code>。一个成功的取消操作将产生一个<code>InterruptedException</code>异常。Zookeeper也遵循这一机制，因此你可以使用这种方法来取消一个Zookeeper操作。使用了Zookeeper的类或者库时，通常就会传播<code>InterruptedException</code>异常，使客户端取消它们的操作。</p>
<p><code>InterruptedException</code>异常并不意味着故障，只是表明相应的操作被取消了而已。</p>
<h3 id="KeeperException异常"><a href="#KeeperException异常" class="headerlink" title="KeeperException异常"></a>KeeperException异常</h3><p>如果ZooKeeper服务器发出一个错误信号或与服务器存在通信问题，抛出的则是<code>KeeperException</code>异常。</p>
<ul>
<li>针对不同的错误情况，<code>KeeperException</code>异常存在不同的子类。<br>例如:　<code>KeeperException.NoNodeException</code>是<code>KeeperException</code>的一个子类，如果你试图针对一个不存在的znode执行操作，抛出的则是该异常。</li>
<li>每一个<code>KeeperException</code>异常的子类都对应一个关于错误类型信息的代码。<br>例如:　<code>KeeperException.NoNodeException</code>异常的代码是<code>KeeperException.Code.NONODE</code>.</li>
</ul>
<p>有两种方法被用来处理<code>KeeperException</code>异常：</p>
<ol>
<li>捕捉<code>KeeperException</code>异常，并且通过检测它的代码来决定采取何种补救措施；</li>
<li>另一种是捕捉等价的<code>KeeperException</code>子类，并且在每段捕捉代码中执行相应的操作。</li>
</ol>
<p>KeeperException异常分为三大类</p>
<h4 id="1-状态异常"><a href="#1-状态异常" class="headerlink" title="1.状态异常"></a>1.状态异常</h4><p>当一个操作因不能被应用于znode树而导致失败时，就会出现状态异常。状态异常产生的原因通常是在同一时间有另外一个进程正在修改znode。例如，如果一个znode先被另外一个进程更新了，根据版本号执行<code>setData()</code>操作的进程就会失败，并收到一个<code>KeeperException.BadVersionException</code>异常，这是因为版本号不匹配。程序员通常都知道这种冲突总是存在的，也都会编写代码来进行处理。</p>
<p>一些状态异常会指出程序中的错误，例如<code>KeeperException.NoChildrenForEphemeralsException</code>异常，试图在短暂znode下创建子节点时就会抛出该异常。</p>
<h4 id="2-可恢复异常"><a href="#2-可恢复异常" class="headerlink" title="2.可恢复异常"></a>2.可恢复异常</h4><p>可恢复的异常是指那些应用程序能够在同一个ZooKeeper会话中恢复的异常。一个可恢复的异常是通过<code>KeeperException.ConnectionLossException</code>来表示的，它意味着已经丢失了与ZooKeeper的连接。ZooKeeper会尝试重新连接，并且在大多数情况下重新连接会成功，并确保会话是完整的。</p>
<p>但是ZooKeeper不能判断与<code>KeeperException.ConnectionLossException</code>异常相关的操作是否成功执行。这种情况就是部分失败的一个例子。这时程序员有责任来解决这种不确定性，并且根据应用的情况来采取适当的操作。在这一点上，就需要对<strong>幂等(idempotent)操作</strong>和<strong>非幂等(Nonidempotent)操作</strong>进行区分。</p>
<ul>
<li>幂等操作:指那些一次或多次执行都会产生相同结果的操作，例如读请求或无条件执行的<code>setData</code>操作。对于幂等操作，只需要简单地进行重试即可。</li>
<li>非幂等操作:就不能盲目地进行重试，因为它们多次执行的结果与一次执行是完全不同的。程序可以通过在znode的路径和它的数据中编码信息来检测是否非幂等操怍的更新已经完成。</li>
</ul>
<h4 id="3-不可恢复的异常"><a href="#3-不可恢复的异常" class="headerlink" title="3.不可恢复的异常"></a>3.不可恢复的异常</h4><p>在某些情况下，ZooKeeper会话会失效——也许因为超时或因为会话被关闭，两种情况下都会收到<code>KeeperException.SessionExpiredException</code>异常，或因为身份验证失败，<code>KeeperException.AuthFailedException</code>异常。无论上述哪种情况，所有与会话相关联的短暂znode都将丢失，因此应用程序需要在重新连接到ZooKeeper之前重建它的状态。</p>
<p>到这里，对Zookeeper的主要内容已经讲述差不多了，希望对大家能有所帮助。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南第二版</a></li>
<li><a href="https://zookeeper.apache.org/" target="_blank" rel="external">Apache Zookeeper</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index" target="_blank" rel="external">ZooKeeper WIKI</a></li>
<li><a href="http://zookeeper.apache.org/doc/current/index.html" target="_blank" rel="external">ZooKeeper 3.4Documentation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Thrift之学习笔记]]></title>
      <url>http://wangzzu.github.io/2016/04/07/thrift-learn/</url>
      <content type="html"><![CDATA[<p>本文主要是对Thrift学习的一些总结，主要讲述了Thrift的开发、基本数据类型服务类型的介绍，然后会通过两个例子来学习如何使用Thrift进行开发，同时会介绍Thrift在大数据框架方面的应用。</p>
<h2 id="thrift-介绍"><a href="#thrift-介绍" class="headerlink" title="thrift 介绍"></a>thrift 介绍</h2><p>Apache Thrift 是由 Facebook 开发的一种远程服务调用（RPC Remote Procedure Call）的框架。下面应用官网的一句话对其进行介绍：</p>
<blockquote class="blockquote-center">IThe Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.</blockquote>

<p>简而言之，Thrift是一种支持多语言的软件框架，在各个服务之间的RPC通信领域应用非常广泛。<strong>RPC</strong>（远程过程调用）是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。（参考<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">远程过程调用</a>）。</p>
<p>Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk和OCaml）,并由生成的代码负责RPC协议层和传输层的实现。</p>
<h3 id="Thrift安装"><a href="#Thrift安装" class="headerlink" title="Thrift安装"></a>Thrift安装</h3><p>安装可以参考<a href="https://thrift.apache.org/docs/install/" target="_blank" rel="external">Apache Thrift Install</a>，我使用的是CentOS7.1，直接使用yum安装即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装</span></div><div class="line">$ sudo yum install thrift</div><div class="line"></div><div class="line"><span class="comment">#查看版本</span></div><div class="line">$ thrift -version</div><div class="line"></div><div class="line"><span class="comment"># Output： Thrift version 0.9.1</span></div></pre></td></tr></table></figure>
<h2 id="Thrift-Type"><a href="#Thrift-Type" class="headerlink" title="Thrift Type"></a>Thrift Type</h2><p>使用Thrift时，涉及到了<code>.thrift</code>文件（也就是服务）的编写，因此，需要了解一下Thrift Types，它包含了基本类型，自定义的结构体，容器，异常等。关于这部分，<a href="http://wuchong.me/blog/2015/10/07/thrift-induction/" target="_blank" rel="external">Thrift 入门</a>这篇文章，总结很不错，我这里也就直接使用了拿来主义，首稍微有些修改。</p>
<h3 id="基本类型（Base-Types）"><a href="#基本类型（Base-Types）" class="headerlink" title="基本类型（Base Types）"></a>基本类型（Base Types）</h3><ul>
<li>bool: 布尔变量（A boolean value, one byte）；</li>
<li>byte: 8位有符号整数（A signed byte）；</li>
<li>i16: 16位有符号整数（A 16-bit signed integer）；</li>
<li>i32: 32位有符号整数（A 32-bit signed integer）；</li>
<li>i64: 64位有符号整数（A 64-bit signed integer）；</li>
<li>double: 64位浮点数（A 64-bit floating point number）；</li>
<li>binary: byte数组（A byte array）；</li>
<li>string: 字符串（Encoding agnostic text or binary string）；</li>
</ul>
<p><em>Note：Thrift 不支持无符号整数，因为有些语言也不支持无符号整数，比如Java</em></p>
<h3 id="容器类型（Containers）"><a href="#容器类型（Containers）" class="headerlink" title="容器类型（Containers）"></a>容器类型（Containers）</h3><ul>
<li>list<t>: 一系列由T类型的数据组成的有序列表，元素可以重复；</t></li>
<li>set<t>: 一系列由T类型的数据组成的无序集合，元素不可重复</t></li>
<li>map<t1,t2>: 一个字典结构，key为T1类型，value为T2类型；</t1,t2></li>
</ul>
<p><em>Note：这些集合中的元素可以是除了服务的任何Thrift类型（包括结构体和异常）。</em></p>
<h3 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h3><p>结构体中包含一系列的强类型域，等同于无继承的class。可以看出struct写法很类似C语言的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct Example &#123;</div><div class="line">  1:i32 number=10,</div><div class="line">  2:i64 bigNumber,</div><div class="line">  3:list&lt;double&gt; decimals,</div><div class="line">  4:string name=&quot;thrifty&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可选与必选"><a href="#可选与必选" class="headerlink" title="可选与必选"></a>可选与必选</h3><p>Thrift提供两个关键字<code>required</code>，<code>optional</code>，分别用于表示对应的字段时必填的还是可选的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct People &#123;</div><div class="line">    1: required string name;</div><div class="line">    2: optional i32 age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表示name是必填的，age是可选的。</p>
<h3 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h3><p>在一个结构体中，如果field之间的关系是互斥的，即<strong>只能有一个field</strong>被使用被赋值。在这种情况下，我们可以使用<code>union</code>来声明这个结构体，而不是一堆堆optional的field，语意上也更明确了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">union JavaObjectArg &#123;</div><div class="line">  1: i32 int_arg;</div><div class="line">  2: i64 long_arg;</div><div class="line">  3: string string_arg;</div><div class="line">  4: bool bool_arg;</div><div class="line">  5: binary binary_arg;</div><div class="line">  6: double double_arg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异常-Exceptions"><a href="#异常-Exceptions" class="headerlink" title="异常(Exceptions)"></a>异常(Exceptions)</h3><p>可以自定义异常类型，所定义的异常会继承对应语言的异常基类，例如java，就会继承 <code>java.lang.Exception</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">exception InvalidOperation &#123;</div><div class="line">  1: i32 what,</div><div class="line">  2: string why</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="服务-service"><a href="#服务-service" class="headerlink" title="服务(service)"></a>服务(service)</h3><p>Thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">service Hello&#123;</div><div class="line">  string helloString(1:string para)</div><div class="line">  i32 helloInt(1:i32 para)</div><div class="line">  bool helloBoolean(1:bool para)</div><div class="line">  void helloVoid()</div><div class="line">  string helloNull()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h3><p>Thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键字namespace定义命名空间，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">namespace java service.demo</div></pre></td></tr></table></figure>
<p>注意末尾不能有分号，由此生成的代码，其包路径结构为<code>service.demo</code>.</p>
<h2 id="Thrift支持的数据传输格式、数据传输方式和服务模型"><a href="#Thrift支持的数据传输格式、数据传输方式和服务模型" class="headerlink" title="Thrift支持的数据传输格式、数据传输方式和服务模型"></a>Thrift支持的数据传输格式、数据传输方式和服务模型</h2><h3 id="协议（传输格式）"><a href="#协议（传输格式）" class="headerlink" title="协议（传输格式）"></a>协议（传输格式）</h3><ul>
<li>TBinaryProtocol： 二进制格式；</li>
<li>TCompactProtocol：高效率的、密集的二进制编码格式进行数据传输；</li>
<li>TJSONProtocol：JSON格式；</li>
<li>TSimpleJSONProtocol：提供JSON只写协议, 生成的文件很容易通过脚本语言解析；</li>
<li>TDebugProtocol：使用易懂的可读的文本格式，以便于debug。</li>
</ul>
<h3 id="传输层（数据传输方式）"><a href="#传输层（数据传输方式）" class="headerlink" title="传输层（数据传输方式）"></a>传输层（数据传输方式）</h3><ul>
<li>TSocket：阻塞式socker；</li>
<li>TFramedTransport：使用非阻塞方式，以frame为单位进行传输。</li>
<li>TFileTransport：以文件形式进行传输。</li>
<li>TMemoryTransport：将内存用于I/O. java实现时内部实际使用了简单的ByteArrayOutputStream。</li>
<li>TZlibTransport：使用zlib进行压缩， 与其他传输方式联合使用。当前无java实现。</li>
<li>TNonblockingTransport —— 使用非阻塞方式，用于构建异步客户端</li>
</ul>
<h3 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h3><ul>
<li>TSimpleServer：单线程服务器端使用标准的阻塞式 I/O，简单的单线程服务模型，常用于测试；</li>
<li>TThreadPoolServer：多线程服务模型，使用标准的阻塞式IO；</li>
<li>TNonblockingServer：多线程服务模型，使用非阻塞式IO（需使用TFramedTransport数据传输方式）。</li>
</ul>
<h2 id="Thrift-简单使用"><a href="#Thrift-简单使用" class="headerlink" title="Thrift 简单使用"></a>Thrift 简单使用</h2><p>这里我们使用两个Thrift的示例来讲述Thrift的使用，第一例子比较简单，类似于Hello World这种。第二例子，我们会使用阻塞单线程多线程、非阻塞、半同步半阻塞等方式。</p>
<p>这里Maven工程的<code>pom.xml</code>文件的配置为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Thrift之Hello-World"><a href="#Thrift之Hello-World" class="headerlink" title="Thrift之Hello World"></a>Thrift之Hello World</h3><p>本例是一个简单Thrift示例，具体代码参见<a href="https://github.com/wangzzu/java_learn/tree/master/thrift/src/main/java/matt/thrifthello" target="_blank" rel="external">thrifthello</a></p>
<h4 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h4><p>我们来编写一个thrift文件，定义服务端的接口定义个服务接口（<code>hello.thrift</code>）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">namespace java hello.thrift</div><div class="line">service Hello&#123;</div><div class="line"> string helloString(1:string para)</div><div class="line"> i32 helloInt(1:i32 para)</div><div class="line"> bool helloBoolean(1:bool para)</div><div class="line"> void helloVoid()</div><div class="line"> string helloNull()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们定义了5个不同的接口，接着使用Thrift对文件进行编译，产生对应的程序文件，以Java为例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift —gen java hello.thrift</div></pre></td></tr></table></figure>
<p>命令执行完成后，就会在<code>gen-java/hello/thrift</code>生成一个Hello.java的文件，将这个java文件放到<code>hello/thrift</code>中。</p>
<h4 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2.接口实现"></a>2.接口实现</h4><p>前面只是定义了接口的签名，现在我们来对接口进行实现，实现类需要实现<code>Hello.Iface</code>接口，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> matt.thrifthello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.thrift.TException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span>.<span class="title">Iface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helloBoolean</span><span class="params">(<span class="keyword">boolean</span> para)</span> <span class="keyword">throws</span> TException </span>&#123;</div><div class="line">        System.out.printf(<span class="string">"hello true/false"</span>);</div><div class="line">        <span class="keyword">return</span> para;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helloInt</span><span class="params">(<span class="keyword">int</span> para)</span> <span class="keyword">throws</span> TException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello times: "</span> + para);</div><div class="line">        <span class="keyword">return</span> para;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloNull</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello null"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloString</span><span class="params">(String para)</span> <span class="keyword">throws</span> TException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello "</span> + para);</div><div class="line">        <span class="keyword">return</span> para;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloVoid</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-服务端代码的实现"><a href="#3-服务端代码的实现" class="headerlink" title="3.服务端代码的实现"></a>3.服务端代码的实现</h4><p>下面来编写服务器端的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> matt.thrifthello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.thrift.TProcessor;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TThreadPoolServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TServerSocket;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置服务端口为 9527</span></div><div class="line">            TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(<span class="number">9527</span>);</div><div class="line">            <span class="comment">// 关联处理器与 Hello 服务的实现</span></div><div class="line">            TProcessor processor = <span class="keyword">new</span> Hello.Processor(<span class="keyword">new</span> HelloServiceImpl());</div><div class="line">            TServer server = <span class="keyword">new</span> TThreadPoolServer(<span class="keyword">new</span> TThreadPoolServer.Args(serverTransport).processor(processor));</div><div class="line"></div><div class="line">            System.out.println(<span class="string">"Start server on port 9527..."</span>);</div><div class="line">            server.serve();</div><div class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-客户端的实现"><a href="#4-客户端的实现" class="headerlink" title="4.客户端的实现"></a>4.客户端的实现</h4><p>下面来编写客户端的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> matt.thrifthello;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.thrift.TException;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TSocket;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransport;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置调用的服务地址为本地，端口为 9527</span></div><div class="line">            TTransport transport = <span class="keyword">new</span> TSocket(<span class="string">"localhost"</span>, <span class="number">9527</span>);</div><div class="line">            transport.open();</div><div class="line">            <span class="comment">// 设置传输协议为 TBinaryProtocol</span></div><div class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</div><div class="line">            Hello.Client client = <span class="keyword">new</span> Hello.Client(protocol);</div><div class="line">            <span class="comment">// 调用服务的 helloVoid 方法，向server发送数据</span></div><div class="line">            client.helloVoid();</div><div class="line"></div><div class="line">            transport.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>代码完成后，可以先运行<code>HelloServiceServer</code>（会一直运行，需要手动关闭），然后再运行<code>HelloServiceClient</code>（调用一次<code>helloVoid()</code>方法之后，就会退出，不过可以重复运行，这样就可以在server端看到多次输出了），就可以在<code>HelloServiceServer</code>的输出结果中看到客户端打印的<code>Hello World</code>字符串。</p>
<h3 id="Thrift之Account"><a href="#Thrift之Account" class="headerlink" title="Thrift之Account"></a>Thrift之Account</h3><p>本例是关于用户帐号的示例，会涉及到用户帐号的添加登陆注册以及查询等，详细的代码参考<a href="https://github.com/wangzzu/java_learn/tree/master/thrift/src/main/java/matt/thrift/account" target="_blank" rel="external">Thrift_Account</a>.</p>
<h4 id="1-接口定义-1"><a href="#1-接口定义-1" class="headerlink" title="1.接口定义"></a>1.接口定义</h4><p>这里我们编写一个thrift文件，定义服务接口，先定义一个操作状态有两种选项登陆或者注册；然后定一个结构体User，它有四个属性；再声明一个自定义的异常类，最后定义服务接口的一些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">namespace java matt.thrift.account</div><div class="line"></div><div class="line">enum Operation&#123;</div><div class="line">	LOGIN=1,</div><div class="line">	REGISTER=2</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct User&#123;</div><div class="line">	1: required i32 userId,</div><div class="line">	2: required string username,</div><div class="line">	3: required string password,</div><div class="line">	4: Operation op</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception InvalidOperation&#123;</div><div class="line">	1: i32 code,</div><div class="line">	2: string reason</div><div class="line">&#125;</div><div class="line"></div><div class="line">service Account&#123;</div><div class="line">	void addUser(1:User user) throws (1: InvalidOperation e)</div><div class="line">	User queryUser(1:i32 id)</div><div class="line">	list&lt;User&gt; queryUserList()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着对Thrift对文件进行编译，产生对应的程序文件，以Java为例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">thrift —gen java Account.thrift</div><div class="line">``</div><div class="line"></div><div class="line">命令执行完成后，就会在`gen-java/matt/thrift/account`生成多个java的文件，将这些java文件放到`matt/thrift/account`中。</div><div class="line"></div><div class="line"><span class="comment">#### 2.接口实现</span></div><div class="line"></div><div class="line">这里定义`AccountService`类来实现`Account.Iface`接口，主要实现了三个方法。</div><div class="line"></div><div class="line">```java</div><div class="line">package matt.thrift.account;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line"></div><div class="line">public class AccountService implements Account.Iface &#123;</div><div class="line">	private static Map&lt;String, String&gt; namePw = new HashMap&lt;&gt;();</div><div class="line">	private static Map&lt;String, Integer&gt; nameId = new HashMap&lt;&gt;();</div><div class="line">	private static Map&lt;String, Operation&gt; nameOp = new HashMap&lt;&gt;();</div><div class="line">	private static Map&lt;Integer, String&gt; idname = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void addUser(User user) throws TException &#123;</div><div class="line">		int id = user.getUserId();</div><div class="line">		String name = user.getUsername();</div><div class="line">		String pass = user.getPassword();</div><div class="line">		Operation op = user.getOp();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (name == null || name.length() == 0) &#123;</div><div class="line">			throw new InvalidOperation(100, <span class="string">"The name should not be empty!"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (namePw.containsKey(name)) &#123;</div><div class="line">			throw new InvalidOperation(101, <span class="string">"The name has been used, please change the name!"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (nameId.containsValue(id) || id &lt;= 0) &#123;</div><div class="line">			throw new InvalidOperation(102, <span class="string">"The id has been used or the id is invalid, please change the id!"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (op == Operation.LOGIN) &#123;</div><div class="line">			String password = namePw.get(name);</div><div class="line">			<span class="keyword">if</span> (password != null &amp;&amp; password.equals(pass)) &#123;</div><div class="line">				System.out.println(<span class="string">"Login success!! Hello "</span> + name);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				System.out.println(<span class="string">"Login failed!! please check your username and password"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Operation.REGISTER) &#123;</div><div class="line">			<span class="keyword">if</span> (namePw.containsKey(name)) &#123;</div><div class="line">				System.out.println(<span class="string">"The username "</span> + name + <span class="string">" has been registered, please change one."</span>);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				namePw.put(name, pass);</div><div class="line">				nameId.put(name, id);</div><div class="line">				nameOp.put(name, op);</div><div class="line">				idname.put(id, name);</div><div class="line">				System.out.println(<span class="string">"Register success!! Hello "</span> + name);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			throw new InvalidOperation(103, <span class="string">"unknown operation: "</span> + op.getValue());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public User queryUser(int id) throws TException &#123;</div><div class="line">		System.out.println(id);</div><div class="line">		<span class="keyword">if</span> (idname.containsKey(id)) &#123;</div><div class="line">			User user = new User();</div><div class="line">			user.userId = id;</div><div class="line">			String name = idname.get(id);</div><div class="line">			user.username = name;</div><div class="line">			user.password = namePw.get(name);</div><div class="line">			user.op = nameOp.get(name);</div><div class="line">			<span class="built_in">return</span> user;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"The id: "</span> + id + <span class="string">" does not exist!"</span>);</div><div class="line">			User user = new User();</div><div class="line">			user.userId = 0;</div><div class="line">			user.username = <span class="string">""</span>;</div><div class="line">			user.password = <span class="string">"123456"</span>;</div><div class="line">			user.op = Operation.LOGIN;</div><div class="line">			<span class="built_in">return</span> user;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public List&lt;User&gt; queryUserList() throws TException &#123;</div><div class="line">		List&lt;User&gt; list = new ArrayList&lt;User&gt;();</div><div class="line">		<span class="keyword">for</span> (String name : namePw.keySet()) &#123;</div><div class="line">			User user = new User();</div><div class="line">			user.userId = nameId.get(name);</div><div class="line">			user.username = name;</div><div class="line">			user.password = namePw.get(name);</div><div class="line">			user.op = nameOp.get(name);</div><div class="line">			list.add(user);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> list;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-服务端代码的实现-1"><a href="#3-服务端代码的实现-1" class="headerlink" title="3.服务端代码的实现"></a>3.服务端代码的实现</h4><p>这里是服务器端的实现，主要使用多种方式来实现，这几种方式实现的差别是使用API的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> matt.thrift.account;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.thrift.TProcessor;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TCompactProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.THsHaServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TNonblockingServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TSimpleServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.server.TThreadPoolServer;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TFramedTransport;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TNonblockingServerTransport;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TServerSocket;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServer</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8090</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 简单服务器类型 阻塞单线程</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> matt</div><div class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</div><div class="line">	 * <span class="doctag">@throws</span> 无</div><div class="line">	 *             void</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSimpleServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建trsnaport 阻塞通信</span></div><div class="line">			TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port);</div><div class="line">			<span class="comment">// 创建protocol</span></div><div class="line">			TBinaryProtocol.Factory protocol = <span class="keyword">new</span> TBinaryProtocol.Factory();</div><div class="line">			<span class="comment">// 将processor transport protocol设入到服务器server中</span></div><div class="line">			TServer.Args args = <span class="keyword">new</span> TServer.Args(serverTransport);</div><div class="line">			args.processor(tprocessor);</div><div class="line">			args.protocolFactory(protocol);</div><div class="line">			<span class="comment">// 定义服务器类型 设定参数</span></div><div class="line">			TServer server = <span class="keyword">new</span> TSimpleServer(args);</div><div class="line">			<span class="comment">// 开启服务</span></div><div class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</div><div class="line">			server.serve();</div><div class="line">		&#125; <span class="keyword">catch</span> (TTransportException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 多线程服务器 阻塞多线程</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> matt</div><div class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</div><div class="line">	 * <span class="doctag">@throws</span> 无</div><div class="line">	 *             void</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThreadPoolServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建processor</span></div><div class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建transport 阻塞通信</span></div><div class="line">			TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port);</div><div class="line">			<span class="comment">// 创建protocol 数据传输协议</span></div><div class="line">			TBinaryProtocol.Factory protocol = <span class="keyword">new</span> TBinaryProtocol.Factory();</div><div class="line">			TThreadPoolServer.Args args = <span class="keyword">new</span> TThreadPoolServer.Args(serverTransport);</div><div class="line">			args.processor(tprocessor);</div><div class="line">			args.protocolFactory(protocol);</div><div class="line">			<span class="comment">// 创建服务器类型 多线程</span></div><div class="line">			TServer server = <span class="keyword">new</span> TThreadPoolServer(args);</div><div class="line">			<span class="comment">// 开启服务</span></div><div class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</div><div class="line">			server.serve();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 非阻塞I/O</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> matt</div><div class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</div><div class="line">	 * <span class="doctag">@throws</span> 无</div><div class="line">	 *             void</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTNonblockingServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建processor</span></div><div class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建transport 非阻塞 nonblocking</span></div><div class="line">			TNonblockingServerTransport serverTransport = <span class="keyword">new</span> TNonblockingServerSocket(port);</div><div class="line">			<span class="comment">// 创建protocol 数据传输协议</span></div><div class="line">			TCompactProtocol.Factory protocol = <span class="keyword">new</span> TCompactProtocol.Factory();</div><div class="line">			<span class="comment">// 创建transport 数据传输方式 非阻塞需要用这种方式传输</span></div><div class="line">			TFramedTransport.Factory transport = <span class="keyword">new</span> TFramedTransport.Factory();</div><div class="line">			TNonblockingServer.Args args = <span class="keyword">new</span> TNonblockingServer.Args(serverTransport);</div><div class="line">			args.processor(tprocessor);</div><div class="line">			args.transportFactory(transport);</div><div class="line">			args.protocolFactory(protocol);</div><div class="line">			<span class="comment">// 创建服务器 类型是非阻塞</span></div><div class="line">			TServer server = <span class="keyword">new</span> TNonblockingServer(args);</div><div class="line">			<span class="comment">// 开启服务</span></div><div class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</div><div class="line">			server.serve();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 半同步半异步的非阻塞I/O</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTHsHaServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建processor</span></div><div class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建transport 非阻塞</span></div><div class="line">			TNonblockingServerTransport serverTransport = <span class="keyword">new</span> TNonblockingServerSocket(port);</div><div class="line">			<span class="comment">// 非阻塞需要的传输方式</span></div><div class="line">			TFramedTransport.Factory transport = <span class="keyword">new</span> TFramedTransport.Factory();</div><div class="line">			<span class="comment">// 数据传输协议</span></div><div class="line">			TCompactProtocol.Factory protocol = <span class="keyword">new</span> TCompactProtocol.Factory();</div><div class="line">			<span class="comment">// 创建半同步半异步服务</span></div><div class="line">			THsHaServer.Args args = <span class="keyword">new</span> THsHaServer.Args(serverTransport);</div><div class="line">			args.processor(tprocessor);</div><div class="line">			args.transportFactory(transport);</div><div class="line">			args.protocolFactory(protocol);</div><div class="line">			<span class="comment">// 创建 服务类型</span></div><div class="line">			TServer server = <span class="keyword">new</span> THsHaServer(args);</div><div class="line">			<span class="comment">// 开启服务</span></div><div class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</div><div class="line">			server.serve();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">		<span class="comment">// 开启简单服务器</span></div><div class="line">		<span class="comment">// AccountServer.startSimpleServer();</span></div><div class="line">		<span class="comment">// 开启多线程服务器</span></div><div class="line">		<span class="comment">// AccountServer.startThreadPoolServer();</span></div><div class="line">		<span class="comment">// 非阻塞I/O</span></div><div class="line">		AccountServer.startTNonblockingServer();</div><div class="line">		<span class="comment">// 半同步半异步的非阻塞I/O</span></div><div class="line">		<span class="comment">// AccountServer.startTHsHaServer();</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-客户端的实现-1"><a href="#4-客户端的实现-1" class="headerlink" title="4.客户端的实现"></a>4.客户端的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> matt.thrift.account;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TCompactProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TProtocol;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TFramedTransport;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TSocket;</div><div class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransport;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountClient</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String ip = <span class="string">"localhost"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8090</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> time_out = <span class="number">30000</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 使用阻塞式socket</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> matt</div><div class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</div><div class="line">	 * <span class="doctag">@throws</span> 无</div><div class="line">	 *             void</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSimpleClient</span><span class="params">()</span> </span>&#123;</div><div class="line">		TTransport transport = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建Transport</span></div><div class="line">			transport = <span class="keyword">new</span> TSocket(ip, port, time_out);</div><div class="line">			<span class="comment">// 创建TProtocol</span></div><div class="line">			TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</div><div class="line">			<span class="comment">// 基于TTransport和TProtocol创建Client</span></div><div class="line">			Account.Client client = <span class="keyword">new</span> Account.Client(protocol);</div><div class="line">			transport.open();</div><div class="line"></div><div class="line">			<span class="comment">// 正常添加用户</span></div><div class="line">			User user1 = <span class="keyword">new</span> User(<span class="number">001</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user1);</div><div class="line">			User user2 = <span class="keyword">new</span> User(<span class="number">002</span>, <span class="string">"matt2"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user2);</div><div class="line">			User user3 = <span class="keyword">new</span> User(<span class="number">003</span>, <span class="string">"matt3"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user3);</div><div class="line">			User user4 = <span class="keyword">new</span> User(<span class="number">004</span>, <span class="string">"matt4"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user4);</div><div class="line">			User user5 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user5);</div><div class="line"></div><div class="line">			<span class="comment">// 查看全部用户</span></div><div class="line">			List&lt;User&gt; list = client.queryUserList();</div><div class="line">			System.out.println(<span class="string">"There are "</span> + list.size() + <span class="string">" users in total."</span>);</div><div class="line">			<span class="keyword">for</span> (User user : list) &#123;</div><div class="line">				System.out.println(user.userId + <span class="string">" "</span> + user.username + <span class="string">" "</span> + user.password);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 查询用户</span></div><div class="line">			User userq1 = client.queryUser(<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (userq1 != <span class="keyword">null</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"Query: "</span> + userq1.userId + <span class="string">" "</span> + userq1.username + <span class="string">" "</span> + userq1.password);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				System.out.println(<span class="string">"The id: 1 does not exist!"</span>);</div><div class="line">			&#125;</div><div class="line">			User userq2 = client.queryUser(<span class="number">8</span>);</div><div class="line">			<span class="keyword">if</span> (userq2 != <span class="keyword">null</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"Query: "</span> + userq2.userId + <span class="string">" "</span> + userq2.username + <span class="string">" "</span> + userq2.password);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				System.out.println(<span class="string">"The id: 8 does not exist!"</span>);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 登陆用户</span></div><div class="line">			User users = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.LOGIN);</div><div class="line">			client.addUser(users);</div><div class="line"></div><div class="line">			<span class="comment">// 添加异常用户</span></div><div class="line">			User user6 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">""</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name=null</span></div><div class="line">			client.addUser(user6);</div><div class="line">			User user7 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name存在</span></div><div class="line">			client.addUser(user7);</div><div class="line">			User user8 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt6"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// id异常</span></div><div class="line">			client.addUser(user8);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 非阻塞</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@author</span> matt</div><div class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</div><div class="line">	 * <span class="doctag">@throws</span> 无</div><div class="line">	 *             void</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startNonblockingClient</span><span class="params">()</span> </span>&#123;</div><div class="line">		TTransport transport = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(ip, port));</div><div class="line">			TCompactProtocol protocol = <span class="keyword">new</span> TCompactProtocol(transport);</div><div class="line">			Account.Client client = <span class="keyword">new</span> Account.Client(protocol);</div><div class="line">			transport.open();</div><div class="line"></div><div class="line">			<span class="comment">// 正常添加用户</span></div><div class="line">			User user1 = <span class="keyword">new</span> User(<span class="number">001</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user1);</div><div class="line">			User user2 = <span class="keyword">new</span> User(<span class="number">002</span>, <span class="string">"matt2"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user2);</div><div class="line">			User user3 = <span class="keyword">new</span> User(<span class="number">003</span>, <span class="string">"matt3"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user3);</div><div class="line">			User user4 = <span class="keyword">new</span> User(<span class="number">004</span>, <span class="string">"matt4"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user4);</div><div class="line">			User user5 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</div><div class="line">			client.addUser(user5);</div><div class="line"></div><div class="line">			<span class="comment">// 查看全部用户</span></div><div class="line">			List&lt;User&gt; list = client.queryUserList();</div><div class="line">			System.out.println(<span class="string">"There are "</span> + list.size() + <span class="string">" users in total."</span>);</div><div class="line">			<span class="keyword">for</span> (User user : list) &#123;</div><div class="line">				System.out.println(user.userId + <span class="string">" "</span> + user.username + <span class="string">" "</span> + user.password);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 查询用户</span></div><div class="line">			User userq1 = client.queryUser(<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (!userq1.username.equals(<span class="string">""</span>)) &#123;</div><div class="line">				System.out.println(<span class="string">"Query: "</span> + userq1.userId + <span class="string">" "</span> + userq1.username + <span class="string">" "</span> + userq1.password);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				System.out.println(<span class="string">"The id: 1 does not exist!"</span>);</div><div class="line">			&#125;</div><div class="line">			User userq2 = client.queryUser(<span class="number">8</span>);</div><div class="line">			<span class="keyword">if</span> (!userq2.username.equals(<span class="string">""</span>)) &#123;</div><div class="line">				System.out.println(<span class="string">"Query: "</span> + userq2.userId + <span class="string">" "</span> + userq2.username + <span class="string">" "</span> + userq2.password);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				System.out.println(<span class="string">"The id: 8 does not exist!"</span>);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 登陆用户</span></div><div class="line">			User users = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.LOGIN);</div><div class="line">			client.addUser(users);</div><div class="line"></div><div class="line">			<span class="comment">// 添加异常用户</span></div><div class="line">			User user6 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">""</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name=null</span></div><div class="line">			client.addUser(user6);</div><div class="line">			User user7 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name存在</span></div><div class="line">			client.addUser(user7);</div><div class="line">			User user8 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt6"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// id异常</span></div><div class="line">			client.addUser(user8);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// AccountClient.startSimpleClient();</span></div><div class="line">		AccountClient.startNonblockingClient();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>代码完成后，可以先运行<code>AccountServer</code>（会一直运行，需要手动关闭），然后再运行<code>AccountClient</code>。</p>
<p>上面程序服务器端的运行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Starting the Account server...</div><div class="line">Register success!! Hello matt1</div><div class="line">Register success!! Hello matt2</div><div class="line">Register success!! Hello matt3</div><div class="line">Register success!! Hello matt4</div><div class="line">Register success!! Hello matt5</div><div class="line">1</div><div class="line">8</div><div class="line">The id: 8 does not exist!</div></pre></td></tr></table></figure>
<p>客户端运行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">There are 5 users in total.</div><div class="line">1 matt1 123456</div><div class="line">3 matt3 123456</div><div class="line">2 matt2 123456</div><div class="line">5 matt5 123456</div><div class="line">4 matt4 123456</div><div class="line">Query: 1 matt1 123456</div><div class="line">The id: 8 does not exist!</div><div class="line">InvalidOperation(code:101, reason:The name has been used, please change the name!)</div><div class="line">	at matt.thrift.account.Account$addUser_result$addUser_resultStandardScheme.read(Account.java:1165)</div><div class="line">	at matt.thrift.account.Account$addUser_result$addUser_resultStandardScheme.read(Account.java:1)</div><div class="line">	at matt.thrift.account.Account$addUser_result.read(Account.java:1101)</div><div class="line">	at org.apache.thrift.TServiceClient.receiveBase(TServiceClient.java:86)</div><div class="line">	at matt.thrift.account.Account$Client.recv_addUser(Account.java:93)</div><div class="line">	at matt.thrift.account.Account$Client.addUser(Account.java:80)</div><div class="line">	at matt.thrift.account.AccountClient.startNonblockingClient(AccountClient.java:135)</div><div class="line">	at matt.thrift.account.AccountClient.main(AccountClient.java:151)</div></pre></td></tr></table></figure>
<h2 id="Thrift结构"><a href="#Thrift结构" class="headerlink" title="Thrift结构"></a>Thrift结构</h2><p>Thrift包含了一个完整的堆栈结构用于构建客户端和服务器端，下面描述了Thrift的整体的架构。</p>
<p><img src="/images/2016-04-07-thrift/thrift.png" alt="selection_sort"></p>
<ul>
<li>黄色部分：是用户实现的业务逻辑；</li>
<li>褐色部分：是根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架；</li>
<li>红色部分：是根据 Thrift 文件生成代码实现数据的读写操作；</li>
<li>TProtocol：是协议层, 定义数据传输格式，可以为二进制或者XML等；</li>
<li>TTransport：是传输层，定义数据传输方式，可以为TCP/IP传输，内存共享或者文件共享等。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://thrift.apache.org/" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="http://thrift-tutorial.readthedocs.org/en/latest/index.html" target="_blank" rel="external">Thrift Tutorial</a></li>
<li><a href="http://dongxicheng.org/recommend/" target="_blank" rel="external">董的博客 五.Apache Thrift</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li>
<li><a href="https://diwakergupta.github.io/thrift-missing-guide/" target="_blank" rel="external">Thrift: The Missing Guide</a></li>
<li><a href="http://zhaozhiming.github.io/blog/2015/01/25/hello-thrift/" target="_blank" rel="external">Apache Thrift的简单代码示例</a></li>
<li><a href="http://wuchong.me/blog/2015/10/07/thrift-induction/" target="_blank" rel="external">Thrift 入门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从Jekyll转向Hexo]]></title>
      <url>http://wangzzu.github.io/2016/03/30/hexo-set/</url>
      <content type="html"><![CDATA[<p>之前的博客，是使用Jekyll搭建的，因为学过一些ruby，也会一些ruby on rails，所以对Jekyll有天生的好感，看不上wordpress、hexo之类的。不过后来当我看到了hexo的next主题时，被它的简洁所吸引，因此决定转向hexo，本文记录使用hexo构建博客的方法（PS；我只是一个搬运工，针对Linux用户而言）。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装Hexo需要三步，需要安装以下三个部分：</p>
<ul>
<li>Git</li>
<li>Node.js</li>
<li>Hexo</li>
</ul>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p><a href="https://git-scm.com/downloads" target="_blank" rel="external">下载地址</a></p>
<ul>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git</code>;</li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git</code>;</li>
</ul>
<h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>安装Node.js的最佳方式是使用<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></p>
<p>nvm安装的两种方式：</p>
<ul>
<li>cURL: <code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code>;</li>
<li>Wget: <code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code>;</li>
</ul>
<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。（<code>$</code>代表在当前普通用户下执行命令）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvm install 4</div></pre></td></tr></table></figure>
<p>当然也可以通过<a href="https://nodejs.org/en/download/" target="_blank" rel="external">下载</a>安装。</p>
<h4 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>到这里Hexo已经安装完毕了，下面讲一下如何使用。</p>
<h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>通过下列命令，Hexo会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init /home/matt/wangzzuB<span class="built_in">log</span></div><div class="line">$ <span class="built_in">cd</span> /home/matt/wangzzuB<span class="built_in">log</span></div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹<code>/home/matt/wangzzuBlog</code>的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure>
<p><strong><code>_config.yml</code></strong></p>
<p>它与Jekyll中的<code>_config.yml</code>功能类似，对博客网站进行一下配置。</p>
<p><strong><code>package.json</code></strong></p>
<p>这里面是安装的应用程序的信息，EJS, Stylus 和 Markdown renderer 已默认安装，我们可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"hexo"</span>: &#123;</div><div class="line">    <span class="attr">"version"</span>: <span class="string">""</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</div><div class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</div><div class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</div><div class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</div><div class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</div><div class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</div><div class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</div><div class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</div><div class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>source</code></strong></p>
<p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong><code>themes</code></strong></p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>文件夹，Hexo会根据主题来生成静态页面。</p>
<h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><p>这里可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo中文文档</a>，这里讲述的非常详细。</p>
<h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h3><p>参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo 指令</a>。</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init [folder]</div></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<p>草稿的使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo new draft <span class="string">"new draft"</span> <span class="comment">#新建草稿</span></div><div class="line">$ hexo publish [layout] &lt;title&gt; <span class="comment">#变成正式文章</span></div></pre></td></tr></table></figure>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d, –deploy</td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w, –watch</td>
<td>监视文件变动</td>
</tr>
</tbody>
</table>
<h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;filename&gt;</div></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div><div class="line">$ hexo server -p 4040</div></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="external">http://localhost:4000/。</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g, –generate</td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo render &lt;file1&gt; [file2] ...</div></pre></td></tr></table></figure>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o, –output</td>
<td>设置输出路径</td>
</tr>
</tbody>
</table>
<h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure>
<p>从其他博客系统 迁移内容。</p>
<h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure>
<p>列出网站资料。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo version</div></pre></td></tr></table></figure>
<p>显示 Hexo 版本。</p>
<h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h2><p>Hexo博客的主题有很多种，可以参考<a href="https://hexo.io/themes/" target="_blank" rel="external">Themes</a>，个人比较喜欢Next主题，下面给出一些Next主题配置的一些资料，本文就不再详述了。</p>
<ul>
<li>Next主题的基本配置可以参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next WIKI</a>，这个网站基本上讲述已经非常清晰了。</li>
<li>这个博文——<a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="external">动动手指，NexT主题与Hexo更搭哦（基础篇）</a>配着图片进行讲述如何配置使用。</li>
<li>这篇介绍如何统计阅读量<a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a>。</li>
<li>这位博主由一系列关于Hexo配置的博文，非常推荐——<a href="http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/" target="_blank" rel="external">动动手指，给你的Hexo站点添加最近访客（多说篇）</a>。</li>
</ul>
<h2 id="Jekyll迁移到Hexo"><a href="#Jekyll迁移到Hexo" class="headerlink" title="Jekyll迁移到Hexo"></a>Jekyll迁移到Hexo</h2><p>把 <code>_posts</code> 文件夹内的所有文件复制到 <code>source/_posts</code> 文件夹，并在 <code>_config.yml</code> 中修改 <code>new_post_name</code> 参数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_post_name: :year-:month-:day-:title.md</div></pre></td></tr></table></figure>
<p>然后进行生成静态文件，部署网站即可。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><a href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/" target="_blank" rel="external">Hexo 正确添加 RSS 订阅</a></li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next WIKI</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">文档 | Hexo</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="external">动动手指，NexT主题与Hexo更搭哦（基础篇）</a></li>
<li><a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/" target="_blank" rel="external">动动手指，给你的Hexo站点添加最近访客（多说篇）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法总结]]></title>
      <url>http://wangzzu.github.io/2016/03/26/algorithm-sort/</url>
      <content type="html"><![CDATA[<p>排序算法是算法中基础的部分，也是面试中经常被问到的地方。因此，根据对《算法》和《算法导论》关于这部分的学习，做一下总结，以后再遇到排序方面的问题就可以直接看一下博文就行了（文中算法用java实现）。</p>
<blockquote>
<ul>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>冒泡排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
</blockquote>
<h1 id="性能评估指标"><a href="#性能评估指标" class="headerlink" title="性能评估指标"></a>性能评估指标</h1><ol>
<li>运行时间：<strong>排序的成本模型</strong>：在研究排序算法时，需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。</li>
<li>额外的内存使用：排序算法分为两种：除了函数调用的栈和固定数目的实例变量之外无需额外内存的<code>原地排序算法</code>，以及需要额外内存空间存储另一份数组副本的其他排序算法。</li>
</ol>
<p>代码中使用基本方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    Comparable tmp = a[i];</div><div class="line">    a[i] = a[j];</div><div class="line">    a[j] = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</div><div class="line">        System.out.print(a[i] + <span class="string">" "</span>)</div><div class="line">    System.out.println();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//默认按升序排列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>先找到数组中最小的那个元素；</li>
<li>将它和数组中第一个元素交换位置（如果第一个元素是自己，和自己交换）；</li>
<li>在剩下的数组中找到最小的元素，将它和第二个元素交换位置，以此类推。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (less(a[j], a[min]))</div><div class="line">                min = j;</div><div class="line">        &#125;</div><div class="line">        exch(a, i, min);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Selection.java" target="_blank" rel="external">Selection.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之选择排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Selection_sort_animation.gif" alt="selection_sort"></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>对于长度为$N$的数组，选择排序需要大约$\frac{N^2}{2}$次比较和$N$次交换；</li>
<li>最好的情况：已经有序，交换$0$次；</li>
<li>最坏的情况：逆序，交换$N-1$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>运行时间与输入无关，即使对于一个有序数组，依然需要扫描全部元素而且运行时间与随机数组一样；</li>
<li>数据移动是最少的。交换次数与数组大小成线性关系。</li>
</ol>
</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span>(less(a[j], a[j - <span class="number">1</span>]))</div><div class="line">                exch(a, j, j - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Insertion.java" target="_blank" rel="external">Insertion.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Insertion_sort_animation.gif" alt="Insertion_sort"></p>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>平均来说，插入排序的复杂度为$O(n^2)$;</li>
<li>最好的情况：已经有序，只需要比较操作$N-1$次即可；</li>
<li>最坏的情况：逆序，需要比较$\frac{N*(N-1)}{2}$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>插入排序很适合部分有序的数组和规模较小的数组；</li>
<li>插入排序不适合对于数据量比较大的排序应用.</li>
</ol>
</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>也称为递减增量排序算法，它是对插入排序的一种快速算法，插入排序相当于$h=1$的情况。（希尔排序的思想是使数组中任意间隔为h的元素都是有序的）</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位。</li>
</ol>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><p>算法最重要的部分是<strong>步长</strong>，当步长为1时就是插入排序。</p>
<ol>
<li>最开始以一定的步长进行排序；</li>
<li>然后会继续以一定步长进行排序；</li>
<li>最终算法以步长为1进行排序。</li>
</ol>
<p>当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>步长的设置，影响着希尔排序算法的复杂度，具体可参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>，这里给出一个步长序列与复杂度的关系表：</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/shell.png" alt="shell"></p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</div><div class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</div><div class="line">                exch(a, j, j - h);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        h = h / <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Shell.java" target="_blank" rel="external">Shell.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_shellsort_anim.gif" alt="shellsort"></p>
<h2 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：参见上表</li>
<li>特点：<ol>
<li>排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。</li>
</ol>
</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序是一种简单的排序算法。它每次去从开始去比较两个元素，如果顺序错误就交换过来，当比较到最后一个元素时，就会把最小（最大）的元素找出来；然后在重复比较，前面已经找到的就不再参与比较。元素越小（大）的元素会经过交换慢慢“浮”到数列顶端。</p>
<h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N=a.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</div><div class="line">                exch(a,i,i-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        N--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Bubble.java" target="_blank" rel="external">Bubble.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Bubble_sort_animation.gif" alt="Bubble_sort"></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原地归并排序"><a href="#原地归并排序" class="headerlink" title="原地归并排序"></a>原地归并排序</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>对两个有序数组进行归并。</p>
<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h3><p>原地归并排序主要是对于有序数组而言，这里只需要额外申请一段数据空间，来进行合并数组即可（迭代法）。</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//迭代法(第一个有序数组为lo~mid，第二个有序数组为mid+1~hi)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = lo;</div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</div><div class="line">        aux[k] = a[k];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">        <span class="keyword">if</span> (i &gt; mid)</div><div class="line">            a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)</div><div class="line">            a[k] = aux[i++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))</div><div class="line">            a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            a[k] = aux[i++];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>首先要知道原地归并排序算法，这个是将两个有序的数组归并到一个数组中，然后使用递归算法，每次都对对并一半的数据（直到把数据间隔减少到1为止，从上往下切分）进行归并排序，这样就是递归地调用归并排序。</p>
<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列分成两部分，然后对部分分别进行归并；</li>
<li>再将这部分分成两部分进行归并；</li>
<li>重复步骤2，直到把每部分分成为大小为1的数组。</li>
</ol>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">    sort(a, lo, mid);</div><div class="line">    sort(a, mid + <span class="number">1</span>, hi);</div><div class="line">    merge(a, lo, mid, hi);<span class="comment">// 归并两个有序数组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li>对于长度为N的任意数组，自顶向下的归并排序需要$\frac{N\lg{N}}{2} $至$N\lg{N}$次比较；</li>
<li>对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组$6NlgN$次。</li>
</ol>
<ul>
<li>缺点：其辅助数组所使用的额外空间和N的大小成正比。</li>
</ul>
<h2 id="自低向上"><a href="#自低向上" class="headerlink" title="自低向上"></a>自低向上</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>从最下面的长度为1数组开始往上进行合并，直到最后数组变成两个有序数组，再进行最后依次合并。</p>
<h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将序列每相邻两个数字进行归并操作，形成$ \lfloor\frac{n}{2}\rfloor$个序列，排序后每个序列包含两个元素；</li>
<li>将上述序列再次归并，形成$\lfloor\frac{n}{4}\rfloor$个序列，每个序列包含四个元素；</li>
<li>重复步骤2，直到所有元素排序完毕。</li>
</ol>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = a.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz)</div><div class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li>对于长度为N的任意数组，自低向上的归并排序需要$\frac{N\lg{N}}{2}$至$N\lg{N}$次比较，最多需要访问数组$6N\lg{N}$次。</li>
<li>与自顶向下是相同的，只是顺序不同而已。</li>
</ol>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>分治思想，将数组分成两个子数组，独自进行排序。最简单的递归切分：指针i从数组的最左端开始扫描直到找到一个大于等于它的元素，指针j从数组的最右端开始扫描直到找到一个小于等于它的元素，然后交换它们的位置，直到指针相遇。</p>
<p>注意：</p>
<ol>
<li>终止循环：一个常见的错误就是没有考虑到数组中可能包含和切分元素的值相同的其他元素。</li>
</ol>
<h2 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素;</li>
<li>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大;</li>
<li>此时基准元素在其排好序后的正确位置;</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ol>
<h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> l = low;</div><div class="line">    <span class="keyword">int</span> h = high;</div><div class="line">    Comparable key = a[l];</div><div class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</div><div class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(key, a[h]))</div><div class="line">            h--;</div><div class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</div><div class="line">            exch(a, l, h);</div><div class="line">            l++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(a[l], key))</div><div class="line">            l++;</div><div class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</div><div class="line">            exch(a, l, h);</div><div class="line">            h--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (l &gt; low)</div><div class="line">        sort(a, low, l - <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (h &lt; high)</div><div class="line">        sort(a, l + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Quick.java" target="_blank" rel="external">Quick.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E9.81.B8.E6.93.87.E7.9A.84.E9.97.9C.E9.80.A3.E6.80.A7" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_quicksort_anim.gif" alt="quick_sort"></p>
<h2 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h2><ol>
<li>快速排序的内循环会用一个递增的索引将数组元素和一个定值进行比较，其他的几种排序还需要再内循环中移动元素；</li>
<li>它的比较次数较少；</li>
<li>排序的效率取决于切分的效果，而不是切分元素的值，最好的效果是每次都能将数组对半分，在切分不平衡时，程序就会变得比较低效；</li>
<li>对于长度为N的无重复数组排序，快速排序平均需要～$2N\ln{N}$次比较（以及$\frac{1}{6}$次交换）；</li>
<li>快速排序最多需要约$\frac{n^2}{2}$次比较，随机打乱数组可以预防这种情况（当切分时，每次两个子数组之一为空才会出现这种情况）；</li>
<li>三向切分：主要对于有大量元素相等的情况。</li>
</ol>
<h2 id="快排算法改进"><a href="#快排算法改进" class="headerlink" title="快排算法改进"></a>快排算法改进</h2><ol>
<li>小数组时（$h_i&lt;lo+M$），切换到插入排序。对于小数组，快排比插入排序要慢；</li>
<li>三取样切分。使用子数组的一小部分的中位数来切分数组，这样做得到切分效果更好，但是代价是需要计算中位数；</li>
<li>三向切分，主要是对于有重复元素的情况下，将数组切分为三部分，分别是小于，等于和大于切分元素的数组元素。</li>
</ol>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>先构造一个最大堆（最小堆），然后将根节点的最大值（最小值）与最后一位交换，再对第一位进行下沉（上浮）操作，依次类推（下次与倒数第二位进行交换），最后得到的数组即为有序数组。</p>
<p>最大堆的特点：</p>
<ol>
<li>一棵大小为$N$的完全二叉树的高度为不小于的$\lg{N}$最小整数；</li>
<li>当一棵二叉树的每个节点都大于等于它的两个子节点时，被称为<strong>堆有序</strong>；</li>
<li>根节点是最大的节点；</li>
<li>对于节点$i$，左移一位算出$2i$节点（即为左子节点），左移一位并在低位加1得到$2i+1$节点（右子节点），右移一位得到$\lfloor\frac{i}{2}\rfloor$（父节点）。</li>
</ol>
<h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] pq)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> N = pq.length;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</div><div class="line">			sink(pq, k, N);</div><div class="line">		<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">			exch(pq, <span class="number">1</span>, N);</div><div class="line">			N--;</div><div class="line">			sink(pq, <span class="number">1</span>, N);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) &#123;</div><div class="line">				<span class="keyword">if</span> (j &lt; N &amp;&amp; less(pq, j, j + <span class="number">1</span>))</div><div class="line">					j++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (!less(pq, k, j))</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			exch(pq, k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Comparable swap = pq[i - <span class="number">1</span>];</div><div class="line">		pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</div><div class="line">		pq[j - <span class="number">1</span>] = swap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Heap.java" target="_blank" rel="external">Heap.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_heapsort_anim.gif" alt="heap_sort"></p>
<h2 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>构造堆的时间复杂度为$O(n)$；</li>
<li>堆排序的时间复杂度为$O(n\lg{n})$;</li>
</ol>
</li>
<li>特点：<ol>
<li>排序算法使用的是最大堆，最小堆通常用于优先队列（当然也可以反过来）；</li>
<li>将一个数组构造为一个最大堆时，使用递归循环通过下沉（<code>sink</code>方法）将所有有子节点的父节点下沉到给定位置，它的时间复杂度为<code>O(n)</code>；</li>
<li>最大优先队列的一个典型应用就是共享计算机系统中的作业调度。</li>
</ol>
</li>
</ul>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>对于每个输入元素x，确定小于x的元素个数，利用这个信息可以直接把x放在输出数组中的位置上了。</p>
<h2 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h2><p>参考<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">CountingSort</a>，其步骤为：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从$C$中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第$C(i)$项，每放一个元素就将$C(i)$减去1。</li>
</ol>
<h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</div><div class="line">	<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</div><div class="line">	<span class="keyword">int</span> min = a[<span class="number">0</span>];</div><div class="line">	<span class="keyword">int</span> max = a[<span class="number">0</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</div><div class="line">		<span class="keyword">if</span> (i &gt; max)</div><div class="line">			max = i;</div><div class="line">		<span class="keyword">if</span> (i &lt; min)</div><div class="line">			min = i;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> size = max - min + <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">		c[a[i] - min]++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c.length; i++) &#123;</div><div class="line">		c[i] = c[i] + c[i - <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		b[--c[a[i] - min]] = a[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/CountingSort.java" target="_blank" rel="external">CountingSort.java</a></p>
<h2 id="性能分析-7"><a href="#性能分析-7" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>时间复杂度为O(k+n).</li>
</ol>
</li>
<li>特点：<ol>
<li>用运算确定次序，而非比较来确定；</li>
<li><strong>稳定</strong>：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。</li>
</ol>
</li>
</ul>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序直到最高位排序完成以后，数列就变成了一个有序序列。</p>
<h2 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h2><p>对于$n$个$d$位数，每个数位有k个可能的取值（比如十进制数每位有10个可能的取值）。</p>
<ol>
<li>先按最低位对数进行排序（可以是计数排序）；</li>
<li>再次低位进行排序</li>
<li>重复第2步，直到最后一步按照最高位进行排序。</li>
</ol>
<p>从最低位开始排序，保证排序算法的稳定性（如果遇到该位数值相同的话，就按输入顺序）。可以参考<a href="http://baike.baidu.com/view/1170573.htm#1" target="_blank" rel="external">百度百科之基数排序</a>中例子。</p>
<h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">// d最大值多少位</span></div><div class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> m = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span>[][] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</div><div class="line">	<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">	<span class="keyword">while</span> (m &lt;= d) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</div><div class="line">			<span class="keyword">int</span> lsd = (i / n) % <span class="number">10</span>;</div><div class="line">			tmp[lsd][num[lsd]] = i;</div><div class="line">			num[lsd]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (num[i] != <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; j++) &#123;</div><div class="line">					a[index] = tmp[i][j];</div><div class="line">					index++;</div><div class="line">				&#125;</div><div class="line">				num[i] = <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		n *= <span class="number">10</span>;</div><div class="line">		index = <span class="number">0</span>;</div><div class="line">		m++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/RadixSort.java" target="_blank" rel="external">RadixSort.java</a></p>
<h2 id="性能分析-8"><a href="#性能分析-8" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>使用稳定排序方法耗时$O(k+n)$，那么就可以在$O(d*(k+n))$时间内将这些数排好序。</li>
</ol>
</li>
<li>特点：<ol>
<li>基数排序利用的计数排序不是原址排序，而快排是原址排序。</li>
</ol>
</li>
</ul>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>也即是箱排序。</p>
<h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><p>将数组分到有限数量的桶子里。每个桶子再个别排序。</p>
<h2 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>设置一个合适数量的数组作为空桶子；</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子里；</li>
<li>对每个不是空桶子进行排序；</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>排序效果如下图所示（原图来自<a href="http://baike.baidu.com/link?url=0bNJEspxIkXRmUyeUSZPfOG5N2YcfhFT00DXysI-k0IVGq7IkaGxs1ronj3iQasuVTLrEvIY3A_POP3V8eTWma" target="_blank" rel="external">百度百科之桶排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/bucketSort.jpg" alt="bucket_sort"></p>
<h2 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> n = a.length;</div><div class="line">	<span class="keyword">int</span> bask[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];</div><div class="line">	<span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">		max = max &gt; (Integer.toString(a[i]).length()) ? max : (Integer.toString(a[i]).length());</div><div class="line">	&#125;</div><div class="line">	String str;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">			str = <span class="string">""</span>;</div><div class="line">			<span class="keyword">if</span> (Integer.toString(a[j]).length() &lt; max) &#123;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max - Integer.toString(a[j]).length(); k++)</div><div class="line">					str += <span class="string">"0"</span>;</div><div class="line">			&#125;</div><div class="line">			str += Integer.toString(a[j]);</div><div class="line">			bask[str.charAt(i) - <span class="string">'0'</span>][index[str.charAt(i) - <span class="string">'0'</span>]++] = a[j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index[j]; k++) &#123;</div><div class="line">				a[pos++] = bask[j][k];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</div><div class="line">			index[x] = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/BucketSort.java" target="_blank" rel="external">BucketSort.java</a></p>
<h2 id="性能分析-9"><a href="#性能分析-9" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li>复杂度分析：<ol>
<li>平均时间复杂度为 $O(k+n)$；</li>
<li>最差时间复杂度：$O(n^2)$;</li>
<li>最差空间复杂度：$O(k*n)$；</li>
</ol>
</li>
<li>特点：<ol>
<li>感觉相当于先进行hash，然后再进行排序，这种思想在海量数据排序中经常会使用到。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="算法性能总结"><a href="#算法性能总结" class="headerlink" title="算法性能总结"></a>算法性能总结</h1><table>
<thead>
<tr>
<th>算法名称</th>
<th>平均时间复杂度</th>
<th>最坏情况时间复杂度</th>
<th>最好情况时间复杂度</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n\lg{n})$ ~ $O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^{1.3})$</td>
<td>$ O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$ O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自底向上归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$O(n\lg{n}) $</td>
<td>$ O(n) $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$ O(n\lg{n}) $</td>
<td>$O(n)  $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n^2)$</td>
<td>$O(nlgn)$</td>
<td>$O(\lg{n})$ ~ $O(n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}$)</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$ O(n+k) $</td>
<td></td>
<td></td>
<td>$O(n + k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(k*n)$</td>
<td></td>
<td></td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n^2)$</td>
<td></td>
<td></td>
<td>$ O(k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?ie=UTF8&amp;qid=1458988861&amp;sr=8-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法 第四版》</a></li>
<li><a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY/ref=sr_1_3?ie=UTF8&amp;qid=1458988861&amp;sr=8-3&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法导论 第三版》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科之排序</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java工程师成神之路【转】]]></title>
      <url>http://wangzzu.github.io/2016/03/22/java-learn/</url>
      <content type="html"><![CDATA[<p>原文转自<a href="http://www.hollischuang.com/archives/489" target="_blank" rel="external">Java工程师成神之路</a>，并对原文根据自己的学习及经验做了一些修改。</p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p>先推荐一个网址<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Code Style for Java</a>，这是Google出的一个关于Java代码规范化的文章，代码规范化的好处及重要性这里就不再叙述了，希望大家都能按照这个要求去写代码，这样才能写出真正易读的优秀代码。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><ul>
<li>Java内存管理;</li>
<li>Java堆和栈;</li>
<li>垃圾回收</li>
</ul>
<p>学习资料：</p>
<ul>
<li><a href="http://www.jcp.org/en/jsr/detail?id=133" target="_blank" rel="external">Java Community Process</a></li>
<li><a href="http://ifeve.com/jmm-faq/" target="_blank" rel="external">并发编程网之Java内存模型</a></li>
</ul>
<h2 id="了解JVM各种参数及调优"><a href="#了解JVM各种参数及调优" class="headerlink" title="了解JVM各种参数及调优"></a>了解JVM各种参数及调优</h2><h3 id="学习使用Java工具"><a href="#学习使用Java工具" class="headerlink" title="学习使用Java工具"></a>学习使用Java工具</h3><ul>
<li>jps；</li>
<li>jstack；</li>
<li>jmap；</li>
<li>jconsole；</li>
<li>jinfo；</li>
<li>jhat；</li>
<li>javap …</li>
</ul>
<p>学习资料：</p>
<p><a href="http://kenai.com/projects/btrace" target="_blank" rel="external">http://kenai.com/projects/btrace</a><br><a href="http://www.crashub.org/" target="_blank" rel="external">http://www.crashub.org/</a><br><a href="https://github.com/taobao/TProfiler" target="_blank" rel="external">https://github.com/taobao/TProfiler</a><br><a href="https://github.com/CSUG/HouseMD" target="_blank" rel="external">https://github.com/CSUG/HouseMD</a><br><a href="http://wiki.cyclopsgroup.org/jmxterm" target="_blank" rel="external">http://wiki.cyclopsgroup.org/jmxterm</a><br><a href="https://github.com/jlusdy/TBJMap" target="_blank" rel="external">https://github.com/jlusdy/TBJMap</a></p>
<h3 id="学习Java诊断工具"><a href="#学习Java诊断工具" class="headerlink" title="学习Java诊断工具"></a>学习Java诊断工具</h3><p><a href="http://www.eclipse.org/mat/" target="_blank" rel="external">http://www.eclipse.org/mat/</a><br><a href="http://visualvm.java.net/oqlhelp.html" target="_blank" rel="external">http://visualvm.java.net/oqlhelp.html</a></p>
<h3 id="自己编写各种outofmemory，stackoverflow程序"><a href="#自己编写各种outofmemory，stackoverflow程序" class="headerlink" title="自己编写各种outofmemory，stackoverflow程序"></a>自己编写各种outofmemory，stackoverflow程序</h3><ul>
<li>HeapOutOfMemory</li>
<li>Young OutOfMemory</li>
<li>MethodArea OutOfMemory</li>
<li>ConstantPool OutOfMemory</li>
<li>DirectMemory OutOfMemory</li>
<li>Stack OutOfMemory</li>
<li>Stack OverFlow</li>
</ul>
<h3 id="使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题"><a href="#使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题" class="headerlink" title="使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题"></a>使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题</h3><ul>
<li>当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志</li>
<li>当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="external">http://docs.oracle.com/javase/specs/jvms/se7/html/</a><br><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="external">http://www.cs.umd.edu/~pugh/java/memoryModel/</a><br><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p>
<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><ul>
<li>java.lang.String</li>
<li>java.lang.Integer</li>
<li>java.lang.Long</li>
<li>java.lang.Enum</li>
<li>java.math.BigDecimal</li>
<li>java.lang.ThreadLocal</li>
<li>java.lang.ClassLoader &amp; java.net.URLClassLoader</li>
<li>java.util.ArrayList &amp; java.util.LinkedList</li>
<li>java.util.HashMap &amp; java.util.LinkedHashMap &amp; java.util.TreeMap</li>
<li>java.util.HashSet &amp; java.util.LinkedHashSet &amp; java.util.TreeSet</li>
</ul>
<h3 id="熟悉Java中各种变量类型"><a href="#熟悉Java中各种变量类型" class="headerlink" title="熟悉Java中各种变量类型"></a>熟悉Java中各种变量类型</h3><h3 id="熟悉Java-String的使用，熟悉String的各种函数"><a href="#熟悉Java-String的使用，熟悉String的各种函数" class="headerlink" title="熟悉Java String的使用，熟悉String的各种函数"></a>熟悉Java String的使用，熟悉String的各种函数</h3><h3 id="熟悉Java中各种关键字"><a href="#熟悉Java中各种关键字" class="headerlink" title="熟悉Java中各种关键字"></a>熟悉Java中各种关键字</h3><h3 id="学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景"><a href="#学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景" class="headerlink" title="学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景"></a>学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景</h3><ul>
<li>Java实现对Array/List排序</li>
<li>java.uti.Arrays.sort()</li>
<li>java.util.Collections.sort()</li>
<li>Java实现对List去重</li>
<li>Java实现对List去重，并且需要保留数据原始的出现顺序</li>
<li>Java实现最近最少使用cache，用LinkedHashMap</li>
</ul>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><ul>
<li>Java NIO，并学会使用java.io.*</li>
<li>java.nio.*</li>
<li>nio和reactor设计模式</li>
<li>文件编码，字符集</li>
<li>几种不同I/O类型（与UNIX网络编程模式做对比）</li>
</ul>
<h3 id="Java反射与javassist反射与工厂模式"><a href="#Java反射与javassist反射与工厂模式" class="headerlink" title="Java反射与javassist反射与工厂模式"></a>Java反射与javassist反射与工厂模式</h3><ul>
<li>java.lang.reflect.*</li>
</ul>
<h3 id="Java序列化java-io-Serializable"><a href="#Java序列化java-io-Serializable" class="headerlink" title="Java序列化java.io. Serializable"></a>Java序列化<code>java.io. Serializable</code></h3><ul>
<li>什么是序列化，为什么序列化</li>
<li>序列化与单例模式</li>
<li>google序列化protobuf</li>
</ul>
<h3 id="虚引用，弱引用，软引用java-lang-ref"><a href="#虚引用，弱引用，软引用java-lang-ref" class="headerlink" title="虚引用，弱引用，软引用java.lang.ref.*"></a>虚引用，弱引用，软引用java.lang.ref.*</h3><ul>
<li>这些引用概念、区别使用；</li>
<li>实验这些引用的回收</li>
</ul>
<h3 id="熟悉Java系统属性java-util-Properties"><a href="#熟悉Java系统属性java-util-Properties" class="headerlink" title="熟悉Java系统属性java.util.Properties"></a>熟悉Java系统属性java.util.Properties</h3><h3 id="熟悉Annotation用法java-lang-annotation"><a href="#熟悉Annotation用法java-lang-annotation" class="headerlink" title="熟悉Annotation用法java.lang.annotation.*"></a>熟悉Annotation用法java.lang.annotation.*</h3><h3 id="JMSjavax-jms"><a href="#JMSjavax-jms" class="headerlink" title="JMSjavax.jms.*"></a>JMSjavax.jms.*</h3><h3 id="JMXjava-lang-management-、javax-management"><a href="#JMXjava-lang-management-、javax-management" class="headerlink" title="JMXjava.lang.management.、javax.management."></a>JMXjava.lang.management.<em>、javax.management.</em></h3><h3 id="泛型和继承，泛型和擦除"><a href="#泛型和继承，泛型和擦除" class="headerlink" title="泛型和继承，泛型和擦除"></a>泛型和继承，泛型和擦除</h3><h3 id="1-2-15-自动拆箱装箱与字节码"><a href="#1-2-15-自动拆箱装箱与字节码" class="headerlink" title="1.2.15. 自动拆箱装箱与字节码"></a>1.2.15. 自动拆箱装箱与字节码</h3><h3 id="实现Callback"><a href="#实现Callback" class="headerlink" title="实现Callback"></a>实现Callback</h3><h3 id="java-lang-Void类使用"><a href="#java-lang-Void类使用" class="headerlink" title="java.lang.Void类使用"></a>java.lang.Void类使用</h3><h3 id="Java-Agent，premain函数java-lang-instrument"><a href="#Java-Agent，premain函数java-lang-instrument" class="headerlink" title="Java Agent，premain函数java.lang.instrument"></a>Java Agent，premain函数java.lang.instrument</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li>Junit，<a href="http://junit.org/" target="_blank" rel="external">http://junit.org/</a></li>
<li>Jmockit，<a href="https://code.google.com/p/jmockit/" target="_blank" rel="external">https://code.google.com/p/jmockit/</a></li>
<li>djUnit，<a href="http://works.dgic.co.jp/djunit/" target="_blank" rel="external">http://works.dgic.co.jp/djunit/</a></li>
</ul>
<h3 id="Java实现通过正则表达式提取一段文本中的电子邮件，并将-替换为-输出java-lang-util-regex"><a href="#Java实现通过正则表达式提取一段文本中的电子邮件，并将-替换为-输出java-lang-util-regex" class="headerlink" title="Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出java.lang.util.regex.*"></a>Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出java.lang.util.regex.*</h3><h3 id="学习使用常用的Java工具库commons-lang-commons-…"><a href="#学习使用常用的Java工具库commons-lang-commons-…" class="headerlink" title="学习使用常用的Java工具库commons.lang, commons.*…"></a>学习使用常用的Java工具库commons.lang, commons.*…</h3><ul>
<li>guava-libraries</li>
<li>netty、jetty（storm、hadoop、spark也用到了）</li>
</ul>
<h3 id="什么是API-amp-SPI"><a href="#什么是API-amp-SPI" class="headerlink" title="什么是API&amp;SPI"></a>什么是API&amp;SPI</h3><p><a href="http://en.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="external">http://en.wikipedia.org/wiki/Application_programming_interface</a><br><a href="http://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="external">http://en.wikipedia.org/wiki/Service_provider_interface</a></p>
<h3 id="参考资料JDK-src-zip-源代码"><a href="#参考资料JDK-src-zip-源代码" class="headerlink" title="参考资料JDK src.zip 源代码"></a>参考资料JDK src.zip 源代码</h3><p><a href="http://openjdk.java.net/" target="_blank" rel="external">http://openjdk.java.net/</a><br><a href="http://commons.apache.org/" target="_blank" rel="external">http://commons.apache.org/</a><br><a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">https://code.google.com/p/guava-libraries/</a><br><a href="http://netty.io/" target="_blank" rel="external">http://netty.io/</a><br><a href="http://stackoverflow.com/questions/2954372/difference-between-spi-and-api" target="_blank" rel="external">http://stackoverflow.com/questions/2954372/difference-between-spi-and-api</a><br><a href="http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java" target="_blank" rel="external">http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java</a></p>
<h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><h3 id="阅读源代码-1"><a href="#阅读源代码-1" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><p>阅读源代码，并学会使用</p>
<ul>
<li>java.lang.Thread</li>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.util.concurrent.locks.ReentrantLock</li>
<li>java.util.concurrent.locks.ReentrantReadWriteLock</li>
<li>java.util.concurrent.atomic.Atomic*</li>
<li>java.util.concurrent.Semaphore</li>
<li>java.util.concurrent.CountDownLatch</li>
<li>java.util.concurrent.CyclicBarrier</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
<li>java.util.concurrent.Executors</li>
</ul>
<h3 id="学习使用线程池，自己设计线程池需要注意什么"><a href="#学习使用线程池，自己设计线程池需要注意什么" class="headerlink" title="学习使用线程池，自己设计线程池需要注意什么"></a>学习使用线程池，自己设计线程池需要注意什么</h3><h3 id="锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么"><a href="#锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么" class="headerlink" title="锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么"></a>锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么</h3><h3 id="synchronized的作用是什么，synchronized和lock"><a href="#synchronized的作用是什么，synchronized和lock" class="headerlink" title="synchronized的作用是什么，synchronized和lock"></a>synchronized的作用是什么，synchronized和lock</h3><h3 id="sleep和wait"><a href="#sleep和wait" class="headerlink" title="sleep和wait"></a>sleep和wait</h3><h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><h3 id="写一个死锁的程序"><a href="#写一个死锁的程序" class="headerlink" title="写一个死锁的程序"></a>写一个死锁的程序</h3><h3 id="什么是守护线程，守护线程和非守护线程的区别以及用法"><a href="#什么是守护线程，守护线程和非守护线程的区别以及用法" class="headerlink" title="什么是守护线程，守护线程和非守护线程的区别以及用法"></a>什么是守护线程，守护线程和非守护线程的区别以及用法</h3><h3 id="volatile关键字的理解C-volatile关键字和Java-volatile关键字"><a href="#volatile关键字的理解C-volatile关键字和Java-volatile关键字" class="headerlink" title="volatile关键字的理解C++ volatile关键字和Java volatile关键字"></a>volatile关键字的理解C++ volatile关键字和Java volatile关键字</h3><p>happens-before语义<br>编译器指令重排和CPU指令重排<br><a href="http://en.wikipedia.org/wiki/Memory_ordering" target="_blank" rel="external">http://en.wikipedia.org/wiki/Memory_ordering</a><br><a href="http://en.wikipedia.org/wiki/Volatile_variable" target="_blank" rel="external">http://en.wikipedia.org/wiki/Volatile_variable</a><br><a href="http://preshing.com/20130702/the-happens-before-relation/" target="_blank" rel="external">http://preshing.com/20130702/the-happens-before-relation/</a></p>
<h3 id="以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？"><a href="#以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？" class="headerlink" title="以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？"></a>以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">    count++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="解释一下下面两段代码的差别-代码1"><a href="#解释一下下面两段代码的差别-代码1" class="headerlink" title="解释一下下面两段代码的差别// 代码1"></a>解释一下下面两段代码的差别// 代码1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">    count++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代码2</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">    count.getAndIncrement();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料http-book-douban-com-subject-10484692"><a href="#参考资料http-book-douban-com-subject-10484692" class="headerlink" title="参考资料http://book.douban.com/subject/10484692/"></a>参考资料<a href="http://book.douban.com/subject/10484692/" target="_blank" rel="external">http://book.douban.com/subject/10484692/</a></h3><p><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></p>
<h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="Java底层知识"><a href="#Java底层知识" class="headerlink" title="Java底层知识"></a>Java底层知识</h2><h3 id="学习了解字节码、class文件格式"><a href="#学习了解字节码、class文件格式" class="headerlink" title="学习了解字节码、class文件格式"></a>学习了解字节码、class文件格式</h3><p><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a><br><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="external">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br><a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></p>
<h3 id="写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码："><a href="#写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：" class="headerlink" title="写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码："></a>写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  i += <span class="number">1</span>;</div><div class="line">  i *= <span class="number">1</span>;</div><div class="line">  System.out.println(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  编译后读取class文件输出以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void main(java.lang.String[]);</div><div class="line">Code:</div><div class="line"> Stack=2, Locals=2, Args_size=1</div><div class="line"> 0:   iconst_0</div><div class="line"> 1:   istore_1</div><div class="line"> 2:   iinc    1, 1</div><div class="line"> 5:   iload_1</div><div class="line"> 6:   iconst_1</div><div class="line"> 7:   imul</div><div class="line"> 8:   istore_1</div><div class="line"> 9:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line"> 12:  iload_1</div><div class="line"> 13:  invokevirtual   #3; //Method java/io/PrintStream.println:(I)V</div><div class="line"> 16:  return</div><div class="line">LineNumberTable:</div><div class="line"> line 4: 0</div><div class="line"> line 5: 2</div><div class="line"> line 6: 5</div><div class="line"> line 7: 9</div><div class="line"> line 8: 16</div></pre></td></tr></table></figure>
<h3 id="CPU缓存，L1，L2，L3和伪共享"><a href="#CPU缓存，L1，L2，L3和伪共享" class="headerlink" title="CPU缓存，L1，L2，L3和伪共享"></a>CPU缓存，L1，L2，L3和伪共享</h3><p><a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches/" target="_blank" rel="external">http://duartes.org/gustavo/blog/post/intel-cpu-caches/</a><br><a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" target="_blank" rel="external">http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html</a></p>
<h3 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h3><h3 id="熟悉位运算用位运算实现加、减、乘、除、取余"><a href="#熟悉位运算用位运算实现加、减、乘、除、取余" class="headerlink" title="熟悉位运算用位运算实现加、减、乘、除、取余"></a>熟悉位运算用位运算实现加、减、乘、除、取余</h3><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://book.douban.com/subject/1138768/" target="_blank" rel="external">http://book.douban.com/subject/1138768/</a><br><a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">http://book.douban.com/subject/6522893/</a><br><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="实现AOPCGLIB和InvocationHandler的区别"><a href="#实现AOPCGLIB和InvocationHandler的区别" class="headerlink" title="实现AOPCGLIB和InvocationHandler的区别"></a>实现AOPCGLIB和InvocationHandler的区别</h3><p><a href="http://cglib.sourceforge.net/" target="_blank" rel="external">http://cglib.sourceforge.net/</a><br>动态代理模式<br>Javassist实现AOP<br><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="external">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br>ASM实现AOP<br><a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></p>
<h3 id="使用模板方法设计模式和策略设计模式实现IOC"><a href="#使用模板方法设计模式和策略设计模式实现IOC" class="headerlink" title="使用模板方法设计模式和策略设计模式实现IOC"></a>使用模板方法设计模式和策略设计模式实现IOC</h3><h3 id="不用synchronized和lock，实现线程安全的单例模式"><a href="#不用synchronized和lock，实现线程安全的单例模式" class="headerlink" title="不用synchronized和lock，实现线程安全的单例模式"></a>不用synchronized和lock，实现线程安全的单例模式</h3><h3 id="nio和reactor设计模式"><a href="#nio和reactor设计模式" class="headerlink" title="nio和reactor设计模式"></a>nio和reactor设计模式</h3><h3 id="参考资料http-asm-ow2-org"><a href="#参考资料http-asm-ow2-org" class="headerlink" title="参考资料http://asm.ow2.org/"></a>参考资料<a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></h3><p><a href="http://cglib.sourceforge.net/" target="_blank" rel="external">http://cglib.sourceforge.net/</a><br><a href="http://www.javassist.org/" target="_blank" rel="external">http://www.javassist.org/</a></p>
<h2 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h2><h3 id="Java-RMI，Socket，HttpClient"><a href="#Java-RMI，Socket，HttpClient" class="headerlink" title="Java RMI，Socket，HttpClient"></a>Java RMI，Socket，HttpClient</h3><h3 id="用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304"><a href="#用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304" class="headerlink" title="用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304"></a>用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304</h3><ul>
<li>实现可并发下载一个文件</li>
<li>使用线程池处理客户端请求</li>
<li>使用nio处理客户端请求</li>
<li>支持简单的rewrite规则</li>
<li>上述功能在实现的时候需要满足“开闭原则”</li>
</ul>
<h3 id="了解nginx和apache服务器的特性并搭建一个对应的服务器"><a href="#了解nginx和apache服务器的特性并搭建一个对应的服务器" class="headerlink" title="了解nginx和apache服务器的特性并搭建一个对应的服务器"></a>了解nginx和apache服务器的特性并搭建一个对应的服务器</h3><p><a href="http://nginx.org/" target="_blank" rel="external">http://nginx.org/</a><br><a href="http://httpd.apache.org/" target="_blank" rel="external">http://httpd.apache.org/</a></p>
<h3 id="用Java实现FTP、SMTP协议"><a href="#用Java实现FTP、SMTP协议" class="headerlink" title="用Java实现FTP、SMTP协议"></a>用Java实现FTP、SMTP协议</h3><h3 id="什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器"><a href="#什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器" class="headerlink" title="什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器"></a>什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器</h3><p>搭建一个 Squid 或 Apache Traffic Server 服务器<br><a href="http://www.squid-cache.org/" target="_blank" rel="external">http://www.squid-cache.org/</a><br><a href="http://trafficserver.apache.org/" target="_blank" rel="external">http://trafficserver.apache.org/</a><br><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="external">http://en.wikipedia.org/wiki/Domain_Name_System</a></p>
<h3 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2616.txt</a><br><a href="http://tools.ietf.org/rfc/rfc5321.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc5321.txt</a><br><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Open/closed_principle</a></p>
<h2 id="框架知识spring，spring-mvc，阅读主要源码"><a href="#框架知识spring，spring-mvc，阅读主要源码" class="headerlink" title="框架知识spring，spring mvc，阅读主要源码"></a>框架知识spring，spring mvc，阅读主要源码</h2><p>ibatis，阅读主要源码<br>用spring和ibatis搭建java server</p>
<h2 id="应用服务器知识熟悉使用jboss，https-www-jboss-org-overview"><a href="#应用服务器知识熟悉使用jboss，https-www-jboss-org-overview" class="headerlink" title="应用服务器知识熟悉使用jboss，https://www.jboss.org/overview/"></a>应用服务器知识熟悉使用jboss，<a href="https://www.jboss.org/overview/" target="_blank" rel="external">https://www.jboss.org/overview/</a></h2><ul>
<li>熟悉使用tomcat，<a href="http://tomcat.apache.org/" target="_blank" rel="external">http://tomcat.apache.org/</a></li>
<li>熟悉使用jetty，<a href="http://www.eclipse.org/jetty/" target="_blank" rel="external">http://www.eclipse.org/jetty/</a></li>
</ul>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h2><h3 id="用Java实现以下表达式解析并返回结果（语法和Oracle中的select-sysdate-1-from-dual类似）-sysdate"><a href="#用Java实现以下表达式解析并返回结果（语法和Oracle中的select-sysdate-1-from-dual类似）-sysdate" class="headerlink" title="用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似） sysdate"></a>用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似） sysdate</h3><p> sysdate - 1<br> sysdate - 1/24<br> sysdate - 1/(12*2)</p>
<h3 id="实现对一个List通过DSL筛选-QList"><a href="#实现对一个List通过DSL筛选-QList" class="headerlink" title="实现对一个List通过DSL筛选  QList"></a>实现对一个List通过DSL筛选  QList<map<string, object="">&gt; mapList = new QList<map<string, object="">&gt;;</map<string,></map<string,></h3><p>  mapList.add({“name”: “hatter test”});<br>  mapList.add({“id”: -1,”name”: “hatter test”});<br>  mapList.add({“id”: 0, “name”: “hatter test”});<br>  mapList.add({“id”: 1, “name”: “test test”});<br>  mapList.add({“id”: 2, “name”: “hatter test”});<br>  mapList.add({“id”: 3, “name”: “test hatter”});<br>  mapList.query(“id is not null and id &gt; 0 and name like ‘%hatter%’”);<br>要求返回列表中匹配的对象，即最后两个对象；</p>
<h3 id="用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）："><a href="#用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：" class="headerlink" title="用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）："></a>用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：</h3><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = <span class="number">1</span>;</div><div class="line">var b = <span class="number">2</span>;</div><div class="line">var c = function() &#123;</div><div class="line">  var a = <span class="number">3</span>;</div><div class="line">  println(a);</div><div class="line">  println(b);</div><div class="line">&#125;;</div><div class="line">c();</div><div class="line">println(a);</div><div class="line">println(b);</div></pre></td></tr></table></figure>
<p>输出：<br>3<br>2<br>1<br>2</p>
<h3 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">http://en.wikipedia.org/wiki/Abstract_syntax_tree</a><br><a href="https://javacc.java.net/" target="_blank" rel="external">https://javacc.java.net/</a><br><a href="http://www.antlr.org/" target="_blank" rel="external">http://www.antlr.org/</a></p>
<h2 id="操作系统知识Ubuntu"><a href="#操作系统知识Ubuntu" class="headerlink" title="操作系统知识Ubuntu"></a>操作系统知识Ubuntu</h2><p>Centos<br>使用linux，熟悉shell脚本</p>
<h2 id="数据存储知识"><a href="#数据存储知识" class="headerlink" title="数据存储知识"></a>数据存储知识</h2><h3 id="关系型数据库MySQL"><a href="#关系型数据库MySQL" class="headerlink" title="关系型数据库MySQL"></a>关系型数据库MySQL</h3><ul>
<li>如何看执行计划</li>
<li>如何搭建MySQL主备</li>
<li>binlog是什么</li>
<li>Derby，H2，PostgreSQL</li>
<li>SQLite</li>
</ul>
<h3 id="NoSQLCache"><a href="#NoSQLCache" class="headerlink" title="NoSQLCache"></a>NoSQLCache</h3><ul>
<li>Redis</li>
<li>Memcached</li>
<li>Leveldb</li>
<li>Bigtable</li>
<li>HBase</li>
<li>Cassandra</li>
<li>Mongodb</li>
<li>图数据库</li>
<li>neo4j</li>
</ul>
<h3 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://db-engines.com/en/ranking" target="_blank" rel="external">http://db-engines.com/en/ranking</a><br><a href="http://redis.io/" target="_blank" rel="external">http://redis.io/</a><br><a href="https://code.google.com/p/leveldb/" target="_blank" rel="external">https://code.google.com/p/leveldb/</a><br><a href="http://hbase.apache.org/" target="_blank" rel="external">http://hbase.apache.org/</a><br><a href="http://cassandra.apache.org/" target="_blank" rel="external">http://cassandra.apache.org/</a><br><a href="http://www.mongodb.org/" target="_blank" rel="external">http://www.mongodb.org/</a><br><a href="http://www.neo4j.org/" target="_blank" rel="external">http://www.neo4j.org/</a></p>
<h2 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h2><h3 id="Zookeeper，在linux上部署zk"><a href="#Zookeeper，在linux上部署zk" class="headerlink" title="Zookeeper，在linux上部署zk"></a>Zookeeper，在linux上部署zk</h3><h3 id="Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引"><a href="#Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引" class="headerlink" title="Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引"></a>Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引</h3><h3 id="Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm-hello-world，local和remote模式运行调试storm-topology。"><a href="#Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm-hello-world，local和remote模式运行调试storm-topology。" class="headerlink" title="Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。"></a>Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。</h3><h3 id="Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件"><a href="#Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件" class="headerlink" title="Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件"></a>Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件</h3><p>MapReduce：部署JobTracker，TaskTracker，编写mr job<br>Hive：部署hive，书写hive sql，得到结果<br>Presto：类hive，不过比hive快，非常值得学习</p>
<h3 id="分布式日志收集flume，kafka，logstash"><a href="#分布式日志收集flume，kafka，logstash" class="headerlink" title="分布式日志收集flume，kafka，logstash"></a>分布式日志收集flume，kafka，logstash</h3><h3 id="数据挖掘，mahout"><a href="#数据挖掘，mahout" class="headerlink" title="数据挖掘，mahout"></a>数据挖掘，mahout</h3><h3 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a><br><a href="https://lucene.apache.org/solr/" target="_blank" rel="external">https://lucene.apache.org/solr/</a><br><a href="https://github.com/nathanmarz/storm/wiki" target="_blank" rel="external">https://github.com/nathanmarz/storm/wiki</a><br><a href="http://hadoop.apache.org/" target="_blank" rel="external">http://hadoop.apache.org/</a><br><a href="http://prestodb.io/" target="_blank" rel="external">http://prestodb.io/</a><br><a href="http://flume.apache.org/，http://logstash.net/，http://kafka.apache.org/" target="_blank" rel="external">http://flume.apache.org/，http://logstash.net/，http://kafka.apache.org/</a><br><a href="http://mahout.apache.org/" target="_blank" rel="external">http://mahout.apache.org/</a></p>
<h2 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h2><h3 id="什么是DES、AES"><a href="#什么是DES、AES" class="headerlink" title="什么是DES、AES"></a>什么是DES、AES</h3><h3 id="什么是RSA、DSA"><a href="#什么是RSA、DSA" class="headerlink" title="什么是RSA、DSA"></a>什么是RSA、DSA</h3><h3 id="什么是MD5，SHA1"><a href="#什么是MD5，SHA1" class="headerlink" title="什么是MD5，SHA1"></a>什么是MD5，SHA1</h3><h3 id="什么是SSL、TLS，为什么HTTPS相对比较安全"><a href="#什么是SSL、TLS，为什么HTTPS相对比较安全" class="headerlink" title="什么是SSL、TLS，为什么HTTPS相对比较安全"></a>什么是SSL、TLS，为什么HTTPS相对比较安全</h3><h3 id="什么是中间人攻击、如果避免中间人攻击"><a href="#什么是中间人攻击、如果避免中间人攻击" class="headerlink" title="什么是中间人攻击、如果避免中间人攻击"></a>什么是中间人攻击、如果避免中间人攻击</h3><h3 id="什么是DOS、DDOS、CC攻击"><a href="#什么是DOS、DDOS、CC攻击" class="headerlink" title="什么是DOS、DDOS、CC攻击"></a>什么是DOS、DDOS、CC攻击</h3><h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><h3 id="什么是CSS攻击"><a href="#什么是CSS攻击" class="headerlink" title="什么是CSS攻击"></a>什么是CSS攻击</h3><h3 id="什么是SQL注入攻击"><a href="#什么是SQL注入攻击" class="headerlink" title="什么是SQL注入攻击"></a>什么是SQL注入攻击</h3><h3 id="什么是Hash碰撞拒绝服务攻击"><a href="#什么是Hash碰撞拒绝服务攻击" class="headerlink" title="什么是Hash碰撞拒绝服务攻击"></a>什么是Hash碰撞拒绝服务攻击</h3><h3 id="了解并学习下面几种增强安全的技术"><a href="#了解并学习下面几种增强安全的技术" class="headerlink" title="了解并学习下面几种增强安全的技术"></a>了解并学习下面几种增强安全的技术</h3><p><a href="http://www.openauthentication.org/" target="_blank" rel="external">http://www.openauthentication.org/</a><br>HOTP <a href="http://www.ietf.org/rfc/rfc4226.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc4226.txt</a><br>TOTP <a href="http://tools.ietf.org/rfc/rfc6238.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc6238.txt</a><br>OCRA <a href="http://tools.ietf.org/rfc/rfc6287.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc6287.txt</a><br><a href="http://en.wikipedia.org/wiki/Salt_(cryptography" target="_blank" rel="external">http://en.wikipedia.org/wiki/Salt_(cryptography</a>)</p>
<h3 id="用openssl签一个证书部署到apache或nginx"><a href="#用openssl签一个证书部署到apache或nginx" class="headerlink" title="用openssl签一个证书部署到apache或nginx"></a>用openssl签一个证书部署到apache或nginx</h3><h3 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cryptographic_hash_function</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="external">http://en.wikipedia.org/wiki/Block_cipher</a><br><a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="external">http://en.wikipedia.org/wiki/Public-key_cryptography</a><br><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">http://en.wikipedia.org/wiki/Transport_Layer_Security</a><br><a href="http://www.openssl.org/" target="_blank" rel="external">http://www.openssl.org/</a><br><a href="https://code.google.com/p/google-authenticator/" target="_blank" rel="external">https://code.google.com/p/google-authenticator/</a></p>
<h1 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a>扩展篇</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="云计算，分布式，高可用，可扩展"><a href="#云计算，分布式，高可用，可扩展" class="headerlink" title="云计算，分布式，高可用，可扩展"></a>云计算，分布式，高可用，可扩展</h3><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p><a href="https://linuxcontainers.org/" target="_blank" rel="external">https://linuxcontainers.org/</a><br><a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="external">http://www.linux-kvm.org/page/Main_Page</a><br><a href="http://www.xenproject.org/" target="_blank" rel="external">http://www.xenproject.org/</a><br><a href="https://www.docker.io/" target="_blank" rel="external">https://www.docker.io/</a></p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><a href="http://www.nagios.org/" target="_blank" rel="external">http://www.nagios.org/</a><br><a href="http://ganglia.info/" target="_blank" rel="external">http://ganglia.info/</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><a href="http://www.linuxvirtualserver.org/" target="_blank" rel="external">http://www.linuxvirtualserver.org/</a></p>
<h3 id="学习使用"><a href="#学习使用" class="headerlink" title="学习使用"></a>学习使用</h3><p>git<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a><br><a href="https://git.oschina.net/" target="_blank" rel="external">https://git.oschina.net/</a></p>
<h3 id="学习使用-1"><a href="#学习使用-1" class="headerlink" title="学习使用"></a>学习使用</h3><p>maven<a href="http://maven.apache.org/" target="_blank" rel="external">http://maven.apache.org/</a></p>
<h3 id="学习使用-2"><a href="#学习使用-2" class="headerlink" title="学习使用"></a>学习使用</h3><p>gradle<a href="http://www.gradle.org/" target="_blank" rel="external">http://www.gradle.org/</a></p>
<h3 id="学习一个小语种语言"><a href="#学习一个小语种语言" class="headerlink" title="学习一个小语种语言"></a>学习一个小语种语言</h3><ul>
<li>Groovy</li>
<li>Scala</li>
<li>LISP, Common LISP, Schema, Clojure</li>
<li>R</li>
<li>Julia</li>
<li>Lua</li>
<li>Ruby</li>
</ul>
<h3 id="尝试了解编码的本质了解以下概念"><a href="#尝试了解编码的本质了解以下概念" class="headerlink" title="尝试了解编码的本质了解以下概念"></a>尝试了解编码的本质了解以下概念</h3><p>ASCII, ISO-8859-1<br>GB2312, GBK, GB18030<br>Unicode, UTF-8<br>不使用 String.getBytes() 等其他工具类/函数完成下面功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    String str = <span class="string">"Hello, 我们是中国人。"</span>;</div><div class="line">    <span class="keyword">byte</span>[] utf8Bytes = toUTF8Bytes(str);</div><div class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"f.txt"</span>);</div><div class="line">    fos.write(utf8Bytes);</div><div class="line">    fos.close();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toUTF8Bytes(String str) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想一下上面的程序能不能写一个转GBK的？<br>写个程序自动判断一个文件是哪种编码</p>
<h3 id="尝试了解时间的本质时区-amp-冬令时、夏令时"><a href="#尝试了解时间的本质时区-amp-冬令时、夏令时" class="headerlink" title="尝试了解时间的本质时区 &amp; 冬令时、夏令时"></a>尝试了解时间的本质时区 &amp; 冬令时、夏令时</h3><p><a href="http://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="external">http://en.wikipedia.org/wiki/Time_zone</a><br>ftp://ftp.iana.org/tz/data/asia<br><a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80</a><br>闰年<br><a href="http://en.wikipedia.org/wiki/Leap_year" target="_blank" rel="external">http://en.wikipedia.org/wiki/Leap_year</a><br>闰秒<br>ftp://ftp.iana.org/tz/data/leapseconds<br>System.currentTimeMillis() 返回的时间是什么</p>
<h3 id="参考资料-7"><a href="#参考资料-7" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://git-scm.com/" target="_blank" rel="external">http://git-scm.com/</a><br><a href="http://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">http://en.wikipedia.org/wiki/UTF-8</a><br><a href="http://www.iana.org/time-zones" target="_blank" rel="external">http://www.iana.org/time-zones</a></p>
<h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><h3 id="JavaScript知识"><a href="#JavaScript知识" class="headerlink" title="JavaScript知识"></a>JavaScript知识</h3><h4 id="什么是prototype修改代码，使程序输出“1-3-5”："><a href="#什么是prototype修改代码，使程序输出“1-3-5”：" class="headerlink" title="什么是prototype修改代码，使程序输出“1 3 5”："></a>什么是prototype修改代码，使程序输出“1 3 5”：</h4><p><a href="http://jsfiddle.net/Ts7Fk/" target="_blank" rel="external">http://jsfiddle.net/Ts7Fk/</a></p>
<h4 id="什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This-is-button-1”，如何修改："><a href="#什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This-is-button-1”，如何修改：" class="headerlink" title="什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改："></a>什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改：</h4><p><a href="http://jsfiddle.net/FDPj3/1/" target="_blank" rel="external">http://jsfiddle.net/FDPj3/1/</a></p>
<h4 id="了解并学习一个JS框架jQuery"><a href="#了解并学习一个JS框架jQuery" class="headerlink" title="了解并学习一个JS框架jQuery"></a>了解并学习一个JS框架jQuery</h4><p>ExtJS<br>ArgularJS</p>
<h4 id="写一个Greasemonkey插件"><a href="#写一个Greasemonkey插件" class="headerlink" title="写一个Greasemonkey插件"></a>写一个Greasemonkey插件</h4><p><a href="http://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="external">http://en.wikipedia.org/wiki/Greasemonkey</a></p>
<h4 id="学习node"><a href="#学习node" class="headerlink" title="学习node."></a>学习node.</h4><p>js<a href="http://nodejs.org/" target="_blank" rel="external">http://nodejs.org/</a></p>
<h4 id="学习html5ArgularJS，"><a href="#学习html5ArgularJS，" class="headerlink" title="学习html5ArgularJS，"></a>学习html5ArgularJS，</h4><p><a href="https://docs.angularjs.org/api" target="_blank" rel="external">https://docs.angularjs.org/api</a></p>
<h3 id="参考资料-8"><a href="#参考资料-8" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.ecmascript.org/" target="_blank" rel="external">http://www.ecmascript.org/</a><br><a href="http://jsfiddle.net/" target="_blank" rel="external">http://jsfiddle.net/</a><br><a href="http://jsbin.com/" target="_blank" rel="external">http://jsbin.com/</a><br><a href="http://runjs.cn/" target="_blank" rel="external">http://runjs.cn/</a><br><a href="http://userscripts.org/" target="_blank" rel="external">http://userscripts.org/</a></p>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><ul>
<li>《深入Java虚拟机》</li>
<li>《深入理解Java虚拟机》</li>
<li>《Effective Java》</li>
<li>《七周七语言》</li>
<li>《七周七数据》</li>
<li>《Hadoop技术内幕》</li>
<li>《Hbase In Action》</li>
<li>《Mahout In Action》</li>
<li>《这就是搜索引擎》</li>
<li>《Solr In Action》</li>
<li>《深入分析Java Web技术内幕》</li>
<li>《大型网站技术架构》</li>
<li>《高性能MySQL》</li>
<li>《算法导论》</li>
<li>《计算机程序设计艺术》</li>
<li>《代码大全》</li>
<li>《JavaScript权威指南》</li>
</ul>
<hr>
<h1 id="想要说的"><a href="#想要说的" class="headerlink" title="想要说的"></a>想要说的</h1><p>之所以要转载这篇文章，是感觉在做了一年多Java开发之后，发现自己很多的基础知识掌握得很不好，尤其是在面试中发现了自己很多的问题，所以准备系统再去学习一下，好好补补基础部分。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka之消息传输]]></title>
      <url>http://wangzzu.github.io/2016/03/09/kafka-transmit/</url>
      <content type="html"><![CDATA[<p>问题研究：</p>
<ol>
<li>研究Kafka consumer和broker之间的数据传输方式？</li>
<li>Kafka是如何保证可靠性？</li>
<li>消费机制是consumer pull还是broker push？, 如果是push的话，kafka是否知道数据传输成功</li>
</ol>
<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>昨天整理完<a href="http://wangzzu.github.io/2016/03/08/kafka-store">Kafka之数据存储</a>之后，今天决定再把笔记中kafka消息传输部分整理一下，逐步去完善kafka系列的博文。本文中讲述的kafka是<code>0.8.1</code>版，目前最新版的<code>0.9.0</code>版把consumer的<code>The high-level Consumer API</code>和<code>The SimpleConsumer API</code>结合到了一起，这个是最新版的变化的最大之处，这个以后再讲（本来打算分两篇讲解consumer的，看来这样写了）。</p>
<h2 id="1-消息传递机制"><a href="#1-消息传递机制" class="headerlink" title="1.消息传递机制"></a>1.消息传递机制</h2><p>kafka在保证消息在producer和consumer之间的传输，主要有以下几种可能的delivery guaratee:</p>
<ul>
<li><strong>At most once</strong>：消息可能会丢，但绝不会重复传输;</li>
<li><strong>At least one</strong>：消息绝不会丢，但可能会重复传输;</li>
<li><strong>Exactly once</strong>：每条消息肯定会被传输一次且仅传输一次.</li>
</ul>
<p><strong>producer到broker端</strong>，当kafka的producer向broker发送消息时，一旦这条消息被commit，因为有replication的存在，它就不会丢失。但如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经commit，（这一点有点像向一个自动生成primary key的数据库表中插入数据，虽然Kafka无法确定网络故障期间发生了什么，但是producer可以生成一种类似于primary key的东西，发生故障时幂等性的retry多次，这样就做到了Exactly one。这一feature可能会在kafka未来的版本中实现），目前默认的情况下，一条消息从producer到broker是确保了At least once，但可通过设置producer异步发送实现At most once（可以在<code>request.required.acks</code>中设置）。</p>
<p><strong>broker到consumer端</strong>（对于heigh level API），consumer在从broker读取消息后，可以选择commit，该操作会在zookeeper中存储下该consumer在该partition下读取消息的offset。该consumer下一次再读该partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将consumer设置为autocommit，即consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了Exactly once。但实际上实际使用中consumer并非读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。下面介绍以下这两种情况的区别：</p>
<ol>
<li>读完消息先commit再处理消息。这种模式下，如果consumer在commit后还没来得及处理消息就crash了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于At most once；</li>
<li>读完消息先处理再commit。这种模式下，如果处理完了消息在commit之前consumer crash了，下次重新开始工作时还会处理刚刚未commit的消息，实际上该消息已经被处理过了。这就对应于At least once。</li>
</ol>
<p>如果一定要做到Exactly once，就需要协调offset和实际操作的输出。精典的做法是引入<strong>两阶段提交</strong>。如果能让offset和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer拿到数据后可能把数据放到HDFS，如果把最新的offset和数据本身一起写到HDFS，那就可以保证数据的输出和offset的更新要么都完成，要么都不完成，间接实现Exactly once。（目前就high level API而言，offset是存于Zookeeper中的，无法存于HDFS，而low level API的offset是由自己去维护的，可以将之存于HDFS中）。</p>
<p>总之，kafka默认保证At least once，并且允许通过设置producer异步提交来实现At most once。而Exactly once要求与目标存储系统协作，幸运的是kafka提供的offset可以使用这种方式非常直接非常容易。</p>
<h2 id="2-消费机制"><a href="#2-消费机制" class="headerlink" title="2. 消费机制"></a>2. 消费机制</h2><ul>
<li><strong>Topic</strong>：Topic在逻辑上可以认为是一个queue，每条消息必须指定它的topic，可以简单理解为把这条消息放进哪个queue里；</li>
<li><strong>partition</strong>：为了使kafka的吞吐率可以水平扩展，物理上把topic分成为一个或多个partition，每个partition物理上对应一个文件夹，该文件夹下存储这个partition的所有消息和索引文件。</li>
</ul>
<p>kafka消费高效率的原因：</p>
<ul>
<li>顺序写入磁盘；</li>
<li>broker是无状态的，不需要锁机制；</li>
</ul>
<h3 id="2-1-磁盘顺序写入"><a href="#2-1-磁盘顺序写入" class="headerlink" title="2.1.磁盘顺序写入"></a>2.1.磁盘顺序写入</h3><p>一个和磁盘性能有关的关键事实是：磁盘驱动器的吞吐量跟寻到延迟是相背离的，也就是说，线性写的速度远远大于随机写。比如：在一个6 7200rpm SATA RAID-5 的磁盘阵列上线性写的速度大概是600M/秒，但是随机写的速度只有100K/秒，两者相差将近6000倍。线性读写在大多数应用场景下是可以预测的，因此，操作系统利用read-ahead和write-behind技术来从大的数据块中预取数据，或者将多个逻辑上的写操作组合成一个大写物理写操作中（<a href="http://blog.csdn.net/suifeng3051/article/details/48053965" target="_blank" rel="external">Kafka设计原理详解</a>）。</p>
<h3 id="2-2-broker的无状态"><a href="#2-2-broker的无状态" class="headerlink" title="2.2.broker的无状态"></a>2.2.broker的无状态</h3><p>kafka在为每个consuemr group保留一些metadata信息（当前消费的position，即offset），这个offset由consumer控制，正常情况下consumer会在消费完一条消息后线性增加这个offset。因此，在一些情况下，kafka可以重新设置offset来重新消费一些信息。因为offset由consumer控制，所以broker是无状态的，它不需要标记哪些消息被哪些consumer消费过了，不需要通过broker去保证同一个consumer group只有一个consumer能消费同一条信息，因此不需要锁机制。</p>
<h4 id="2-2-1-replica"><a href="#2-2-1-replica" class="headerlink" title="2.2.1.replica"></a>2.2.1.replica</h4><p>先说一下kafka为何需要Replication，在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p>
<ul>
<li>如果Producer使用同步模式则Producer会在尝试重新发送<code>message.send.max.retries</code>（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成本应发往该Broker的数据的丢失，后者会造成数据的阻塞。</li>
<li>如果Producer使用异步模式，则Producer会尝试重新发<code>送message.send.max.retries</code>（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。</li>
</ul>
<p>由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。 　　</p>
<p>当一个topic有多个partition，而每个partition又有多个replica时，kafka的Replica算法如下：</p>
<ol>
<li>将所有Broker（假设共有n个Broker）和待分配的Partition排序；</li>
<li>将第i个Partition分配到第<code>i mod n</code>个Broker上；</li>
<li>将第i个Partition的第j个Replica分配到第<code>(i + j) mod n</code>个Broker上。</li>
</ol>
<p>下面我们举一个例子，假设topic有3个partition，而每个partition又有3个replica，此时Broker有4个节点，Replica分配效果图如下：</p>
<p><img src="/images/2016-03-08-KafkaTransmit/broker.png" alt="broker"></p>
<h4 id="2-2-2-leader"><a href="#2-2-2-leader" class="headerlink" title="2.2.2.leader"></a>2.2.2.leader</h4><p>接着，我们再说一下kafka为何需要Leader Election。</p>
<p>在引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p>
<p>因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一台宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（$N×N$条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的机率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p>
<p>leader的性质有以下几条：</p>
<ul>
<li>每个partition都有一个leader，所有的读写操作都在leader上完成；</li>
<li>一般情况下，partition大于等于broker的数量，并且所有partition的leader均匀分布在broker上，follower上的日志和其leader上的完全一样。</li>
<li>leader会track <code>in sync</code>的node list。如果一个follower宕机或者落后太多(超过预定值)，leader就把它从<code>in sync list</code>中移除。</li>
</ul>
<ul>
<li>一条消息只有被<code>in sync list</code>里的所有follower都从leader复制过来才会被认为已提交（避免了一些数据写入了leader，但还没来得及被任何follower复制就宕机了而造成数据丢失）。对于producer而言，它可以选择是否等待消息commit，这可以通过<code>request.required.acks</code>来设置，这种机制确保了只要<code>in sync list</code>有一个或一个以上的follower，一条被commit的消息就不会丢失。</li>
</ul>
<p>同步复制与异步复制的区别：</p>
<ul>
<li><strong>同步复制</strong>，要求alive状态的follower都复制完，这条消息才会被commit，这种复制方式极大的影响了吞吐率；</li>
<li><strong>异步复制</strong>，follower异步地从leader复制数据，数据只要被写入log就认为已经commit，这种情况下如果follower都落后于leader，而leader都落后于leader，而leader突然宕机则会丢失数据。</li>
</ul>
<p>kafka判断一台broker是否alive的条件有两个：</p>
<ul>
<li>broker必须维护与zookeeper的session（zookeeper的心跳机制）；</li>
<li>follower必须能够及时将leader的writting复制过来，不能落后太多（在<code>config/server.properties</code>设置，如下）；</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#If a replica falls more than this many messages behind the leader, the leader will remove the follower from ISR and treat it as dead</div><div class="line">replica.lag.max.messages=4000</div><div class="line">#If a follower hasn't sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead</div><div class="line">replica.lag.time.max.ms=10000</div></pre></td></tr></table></figure>
<p>而kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。kafka使用了<code>in sync list</code>的方式，很好的均衡了确保数据不丢失以及吞吐率，follower可以批量的从leader复制数据，这样极大的提高复制能力（批量写入磁盘），极大地减少了follower与leader的差距。</p>
<p>这里介绍一下kafka的<strong>ISR(in-sync replicas)模式</strong>。kafka在zookeeper中动态地维护了一个ISR，这个ISR里的所有Replica都跟的上了leader，只有ISR成员才有被选为leader的可能。在这种模式下，对于f+1个Replica，一个Partition能在保证不丢失（已经commit）的前提下容忍f个Replica的失败。在大多数场景下，这种模式是非常有利的。</p>
<p><strong>当leader宕机的情况，leader election算法</strong></p>
<p>这种情况是很复杂的，当leader宕机时，我们需要在follower中选举出新的leader。因为follower可能落后于许多或者宕机了，所以必须保证“最新”的follower作为leader。一个基本的原则就是，如果leader不在了，新的leader必须拥有原来的leader commit的所有消息。这就需要做一个折衷，如果leader标明一条消息被commit前等待更多的follower确认，那它die之后就会有更多的leader可以作为新的leader，但这也会造成吞吐率的下降。</p>
<p>常见的leader election算法有：</p>
<ul>
<li><a href="http://blog.cloudera.com/blog/2012/10/quorum-based-journaling-in-cdh4-1/" target="_blank" rel="external">HDFS的HA feature</a></li>
<li><a href="http://web.stanford.edu/class/cs347/reading/zab.pdf" target="_blank" rel="external">zookeeper的Zzb</a></li>
<li><a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf" target="_blank" rel="external">zookeeper的Viewstamped Replication</a></li>
<li><a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf" target="_blank" rel="external">zookeeper的Raft</a></li>
<li><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=66814" target="_blank" rel="external">MS的PacificA算法</a></li>
</ul>
<p>kafka使用的leader elcetion算法与微软的Pacifica算法相似，就是上面所讲述的<code>ISR</code>模式。kafka在zookeeper中动态地维护了一个<code>ISR</code>set，这个set里的所有replica都跟上了leader，只有ISR里的成员才有被选为leader的可能。在这种模式下，对于f+1个replica，一个topic在保证不丢失已经commit的消息的前提下最多可以容忍f个replica的失败。</p>
<p><strong>如何处理所有Replica都不工作的情况</strong></p>
<p>前面已经提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某个Partition的所有Replica都宕机了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p>
<ul>
<li>等待ISR中的任一个Replica“活”过来，并且选它作为Leader；</li>
<li>选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader。
　</li>
</ul>
<p>这就需要在可用性和一致性当中作出一个简单的折衷。如果一定要等待ISR中的Replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有Replica都无法“活”过来了，或者数据都丢失了，这个Partition将永远不可用。选择第一个“活”过来的Replica作为Leader，而这个Replica不是ISR中的Replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为Leader而作为consumer的数据源（前文有说明，所有读写都由Leader完成）。Kafka0.8.*使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</p>
<p><strong>如何选举Leader</strong></p>
<p>最简单最直观的方案是，所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>
<p>但是该方法会有3个问题： 　　</p>
<ul>
<li>split-brain，这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致；</li>
<li>herd effect，如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整；</li>
<li>Zookeeper负载过重，每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</li>
</ul>
<p>Kafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个<strong>controller</strong>，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>
<h3 id="2-3-consumer的reblance"><a href="#2-3-consumer的reblance" class="headerlink" title="2.3.consumer的reblance"></a>2.3.consumer的reblance</h3><p>kafka保证同一个consumer group中只有一个consumer会消费某条消息，实际上，kafka保证的事稳定状态下每一个consumer实例只会消费某一个或特定partition的数据，而某个partition的数据只会被某一个特定的consumer实例所消费。</p>
<p>这样设计的优点：</p>
<ul>
<li>每个consumer不用都跟broker进行大量的通信，减少通信开销，降低了分配难度；</li>
<li>同一个partition里的数据是有序的，保证每个partition里的数据是有序被消费的。</li>
</ul>
<p>设计的缺点：</p>
<ul>
<li>无法让同一个group里的consumer均匀消费数据。</li>
</ul>
<p>consumer的<strong>reblance算法</strong>如下（去看源码分析）：</p>
<ul>
<li>Sort $PT$ (all partitions in topic T)</li>
<li>Sort $CG$(all consumers in consumer group G)</li>
<li>Let i be the index position of $C_{i}$ in $CG$ and let $N=\lceil\frac{size(PT)}{size(CG)}\rceil$</li>
<li>Remove current entries owned by $C_{i}$ from the partition owner registry</li>
<li>Assign partitions from $iN$ to $(i+1)N-1$ to consumer $C_{i}$</li>
<li>Add newly assigned partitions to the partition owner registry</li>
</ul>
<p>consumer的<strong>reblance算法</strong>如下：</p>
<ol>
<li>对topic下的所有partition进行排序，结果记为$PT$；</li>
<li>对订阅这个topic的Group下的所有consumer进行排序，记为$CG$；</li>
<li>记i为CG中的idex，第i个consumer记为$C_{i}$，$N=\lceil\frac{size(PT)}{size(CG)}\rceil$；</li>
<li>解除原来$C_{i}$对分配的Partition的消费权；</li>
<li>将第 $iN$ 到 $(i+1)N-1$个partitions重新分配给$C_{i}$.</li>
</ol>
<p>目前consumer rebalance的控制策略是由每一个consumer通过Zookeeper完成的。具体的<strong>控制方式</strong>如下（去看源码分析）：</p>
<ul>
<li>Register itself in the consumer id registry under its group.</li>
<li>Register a watch on changes under the consumer id registry.</li>
<li>Register a watch on changes under the broker id registry.</li>
<li>If the consumer creates a message stream using a topic filter, it also registers a watch on changes under the broker topic registry.</li>
<li>Force itself to rebalance within in its consumer group.</li>
</ul>
<p>在这种策略下，每一个consumer或者broker的增加或者减少都会触发consumer rebalance。因为每个consumer只负责调整自己所消费的partition，为了保证整个consumer group的一致性，所以当一个consumer触发了rebalance时，该consumer group内的其它所有consumer也应该同时触发rebalance</p>
<p>这样的缺点是：</p>
<ul>
<li>Herd effect，任何broker或者consumer的增减都会触发所有的consumer的rebalance；</li>
<li>Split Brain，每个consumer分别单独通过Zookeeper判断哪些partition down了，那么不同consumer从Zookeeper“看”到的view就可能不一样，这就会造成错误的reblance尝试。而且有可能所有的consumer都认为rebalance已经完成了，但实际上可能并非如此。</li>
</ul>
<p>根据Kafka官方文档，Kafka作者正在考虑在还未发布的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+0.9+Consumer+Rewrite+Design" target="_blank" rel="external">0.9.x版本</a>中使用中心协调器(coordinator)。大体思想是选举出一个broker作为<code>coordinator</code>，由它watch Zookeeper，从而判断是否有partition或者consumer的增减，然后生成rebalance命令，并检查是否这些rebalance在所有相关的consumer中被执行成功，如果不成功则重试，若成功则认为此次rebalance成功（这个过程跟replication controller非常类似，所以我很奇怪为什么当初设计replication controller时没有使用类似方式来解决consumer rebalance的问题）</p>
<h2 id="3-pull"><a href="#3-pull" class="headerlink" title="3.pull"></a>3.pull</h2><p>参<a href="http://mp.weixin.qq.com/s?__biz=MzA4MzEzNjA0NA==&amp;mid=222594584&amp;idx=1&amp;sn=d64e5f5768ce48bd0bee1824b30fb1e3&amp;scene=0#rd" target="_blank" rel="external">流式计算-kafka（一）</a></p>
<p>作为一个message system，kafka遵循了传统的方式，选择由kafka的producer向broker push信息，而consumer从broker pull信息。</p>
<p>consumer获取消息，可以使用两种方式：push或pull模式。下面我们简单介绍一下这两种区别：</p>
<p><strong>push模式</strong></p>
<p>常见的push模式如storm的消息处理，由spout负责消息的推送。该模式下需要一个中心节点，负责消息的分配情况（哪段消息分配给consumer1，哪段消息分配给consumer2），同时还要监听consumer的ack消息用于判断消息是否处理成功，如果在timeout时间内为收到响应可以认为该consumer挂掉，需要重新分配sonsumer上失败的消息。这种模式有个问题，不太容易实现我们想要的消息回放功能，因为理想情况下由consumer决定我到底要消费什么，而这种模式完全由master决定。</p>
<p><strong>pull模式</strong></p>
<p>如上图模式，该模式为pull模式，由consumer决定消息的消费情况，这种模式有一个好处是我们不需要返回ack消息，因为当consumer申请消费下一批消息时就可以认为上一批消息已经处理完毕，也不需要处理超时的问题，consumer可以根据自己的消费能力来消费消息。但这个还有一个问题，如何保证处理的消息的不会重复呢，kafka具体做法就是增加队列的并发度（partition），可以一个partition对准一个consumer。</p>
<p>综上，kafka的consumer之所以没有采用push模式，是因为push模式很难适应消费者速率不同的消费者而且很难实现消息的回放功能，因为消息发送速率是由broker决定的。push模式的目标就是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞，而pull模式则可以根据consumer的消费能力以适当的速率消费message。</p>
<p>pull与push的区别</p>
<p>pull技术：</p>
<ul>
<li>客户机向服务器请求信息；</li>
<li>kafka中，consuemr根据自己的消费能力以适当的速率消费信息；</li>
</ul>
<p>push技术：</p>
<ul>
<li>服务器主动将信息发往客户端的技术；</li>
<li>push模式的目标就是尽可能以最快的速率传递消息。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://developer.51cto.com/art/201501/464491_all.htm" target="_blank" rel="external">发布&amp;订阅的消息系统Kafka的深度解析</a></li>
<li><a href="http://www.jasongj.com/2015/08/09/KafkaColumn4/" target="_blank" rel="external">Kafka Consumer设计解析</a></li>
<li><a href="http://blog.csdn.net/suifeng3051/article/details/48053965" target="_blank" rel="external">Kafka设计与原理详解</a></li>
<li><a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" target="_blank" rel="external">kafka设计解析2</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka之数据存储]]></title>
      <url>http://wangzzu.github.io/2016/03/08/kafka-store/</url>
      <content type="html"><![CDATA[<p>本文主要讲述以下两部分内容：</p>
<ul>
<li>kafka数据的存储方式；</li>
<li>kafka如何通过offset查找message。</li>
</ul>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>写介绍kafka的几个重要概念（可以参考之前的博文<a href="http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka">Kafka的简单介绍</a>）：</p>
<ul>
<li><strong>Broker</strong>：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群；</li>
<li><strong>Topic</strong>：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发；</li>
<li><strong>Partition</strong>：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队；</li>
<li><strong>Segment</strong>：每个partition又由多个segment file组成；</li>
<li><strong>offset</strong>：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息；</li>
<li><strong>message</strong>：这个算是kafka文件中最小的存储单位，即是 a commit log。</li>
</ul>
<p>kafka的message是以topic为基本单位，不同topic之间是相互独立的。每个topic又可分为几个不同的partition，每个partition存储一部的分message。topic与partition的关系如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/topic.png" alt="topic"></p>
<p>其中，partition是以文件夹的形式存储在具体Broker本机上。</p>
<h3 id="2-partition中的数据文件"><a href="#2-partition中的数据文件" class="headerlink" title="2.partition中的数据文件"></a>2.partition中的数据文件</h3><p>有了上面的介绍，下面我们开始介绍Topic中partition的数据文件类型。</p>
<h4 id="2-1-segment中的文件"><a href="#2-1-segment中的文件" class="headerlink" title="2.1.segment中的文件"></a>2.1.segment中的文件</h4><p>对于一个partition（在Broker中以文件夹的形式存在），里面又有很多大小相等的segment数据文件（这个文件的具体大小可以在<code>config/server.properties</code>中进行设置），这种特性可以方便old segment file的快速删除。</p>
<p>下面先介绍一下partition中的segment file的组成：</p>
<ul>
<li>segment file <strong>组成</strong>：由2部分组成，分别为index file和data file，这两个文件是一一对应的，后缀”.index”和”.log”分别表示索引文件和数据文件；</li>
<li>segment file <strong>命名规则</strong>：partition的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset,ofsset的数值最大为64位（long类型），20位数字字符长度，没有数字用0填充。如下图所示：</li>
</ul>
<p><img src="/images/2016-03-07-KafkaMessage/segment.png" alt="segment"></p>
<p>关于segment file中index与data file对应关系图，这里我们选用网上的一个图片，如下所示：</p>
<p><img src="/images/2016-03-07-KafkaMessage/index.png" alt="index"></p>
<p>segment的索引文件中存储着大量的元数据，数据文件中存储着大量消息，索引文件中的元数据指向对应数据文件中的message的物理偏移地址。以索引文件中的<code>3，497</code>为例，在数据文件中表示第3个message（在全局partition表示第368772个message），以及该消息的物理偏移地址为497。</p>
<p>注：Partition中的每条message由offset来表示它在这个partition中的偏移量，这个offset并不是该Message在partition中实际存储位置，而是逻辑上的一个值（如上面的3），但它却唯一确定了partition中的一条Message（可以认为offset是partition中Message的id）。</p>
<h4 id="2-2-message文件"><a href="#2-2-message文件" class="headerlink" title="2.2.message文件"></a>2.2.message文件</h4><p>message中的物理结构为：</p>
<p><img src="/images/2016-03-07-KafkaMessage/message.png" alt="message"></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 byte offset</td>
<td>在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td>
</tr>
<tr>
<td>4 byte message size</td>
<td>message大小</td>
</tr>
<tr>
<td>4 byte CRC32</td>
<td>用crc32校验message</td>
</tr>
<tr>
<td>1 byte “magic”</td>
<td>表示本次发布Kafka服务程序协议版本号</td>
</tr>
<tr>
<td>1 byte “attributes”</td>
<td>表示为独立版本、或标识压缩类型、或编码类型</td>
</tr>
<tr>
<td>4 byte key length</td>
<td>表示key的长度,当key为-1时，K byte key字段不填</td>
</tr>
<tr>
<td>K byte key</td>
<td>可选</td>
</tr>
<tr>
<td>value bytes payload</td>
<td>表示实际消息数据</td>
</tr>
</tbody>
</table>
<h4 id="2-3-数据文件的内部实现方法"><a href="#2-3-数据文件的内部实现方法" class="headerlink" title="2.3.数据文件的内部实现方法"></a>2.3.数据文件的内部实现方法</h4><p>Partition数据文件包含了若干上述格式的message，按照offset由小到大排列在一起，它实现的类是FileMessageSet，类图如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/filemessageset.png" alt="filemessageset"></p>
<p>它的主要方法如下：</p>
<ul>
<li><strong>append</strong>: 把给定的ByteBufferMessageSet中的Message写入到这个数据文件中。</li>
<li><strong>searchFor</strong>: 从指定的startingPosition开始搜索，找到第一个Message判断其offset是大于或者等于指定的offset，并返回其在文件中的位置Position。它的实现方式是从startingPosition开始读取12个字节，分别是当前MessageSet的offset和size。如果当前offset小于指定的offset，那么将position向后移动LogOverHead+MessageSize（其中LogOverHead为offset+messagesize，为12个字节）。</li>
<li><strong>read</strong>：准确名字应该是slice，它截取其中一部分返回一个新的FileMessageSet。它不保证截取的位置数据的完整性。</li>
<li><strong>sizeInBytes</strong>: 表示这个FileMessageSet占有了多少字节的空间。</li>
<li><strong>truncateTo</strong>: 把这个文件截断，这个方法不保证截断位置的Message的完整性。</li>
<li><strong>readInto</strong>: 从指定的相对位置开始把文件的内容读取到对应的ByteBuffer中。</li>
</ul>
<h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h4><h4 id="3-1-遇到的问题"><a href="#3-1-遇到的问题" class="headerlink" title="3.1.遇到的问题"></a>3.1.遇到的问题</h4><p>我们首先试想一下，如果对于Kafka的一个topic而言，如果topic的partition中只有一个数据文件的话会怎么样？</p>
<ul>
<li>新数据是添加在文件末尾（调用FileMessageSet的append方法），不论文件数据文件有多大，这个操作永远都是O(1)的。</li>
<li>查找某个offset的Message（调用FileMessageSet的searchFor方法）是顺序查找的。因此，如果数据文件很大的话，查找的效率就低。</li>
</ul>
<h4 id="3-2-如何去解决这个问题"><a href="#3-2-如何去解决这个问题" class="headerlink" title="3.2.如何去解决这个问题"></a>3.2.如何去解决这个问题</h4><p>由上述我们知道，如果在topic的partition中只有一个数据文件的话，Kafka插入的效率虽然很高，但是查找的效率非常低，那么Kafka在内部是如何解决查找效率的的问题呢？对于这个问题，Kafka有两大法宝：分段和索引。</p>
<p><strong>数据文件的分段</strong></p>
<p>这个是比较好理解的，加入有100条message，它们的offset是从0到99，假设将数据文件分为5端，第一段为0-19，第二段为20-39，依次类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</p>
<p><strong>为数据文件建索引</strong></p>
<p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的message了，但是这依然需要顺序扫描才能找到对应offset的message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为<code>.index</code>。</p>
<p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p>
<ul>
<li><strong>相对offset</strong>：因为数据文件分段以后，每个数据文件的起始offset不为0，相对offset表示这条message相对于其所属数据文件中最小的offset的大小。举例，分段后的一个数据文件的offset是从20开始，那么offset为25的message在index文件中的相对offset就是25-20 = 5。存储相对offset可以减小索引文件占用的空间。</li>
<li><strong>position</strong>：表示该条message在数据文件中的绝对位置。只要打开文件并移动文件指针到这个position就可以读取对应的message了。</li>
</ul>
<p>在kafka中，索引文件的实现类为OffsetIndex，它的类图如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/offsetindex.png" alt="offsetindex"></p>
<p>主要的方法有：</p>
<ul>
<li>append方法：添加一对offset和position到index文件中，这里的offset将会被转成相对的offset。</li>
<li>lookup：用二分查找的方式去查找小于或等于给定offset的最大的那个offset</li>
</ul>
<h4 id="3-3-通过offset查找message"><a href="#3-3-通过offset查找message" class="headerlink" title="3.3.通过offset查找message"></a>3.3.通过offset查找message</h4><p>假如我们想要读取offset=368776的message（见前面的第三个图），需要通过下面2个步骤查找。</p>
<ol>
<li><strong>查找segment file</strong><br>00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1.同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset <strong>二分查找</strong>文件列表，就可以快速定位到具体文件。<br>当offset=368776时定位到00000000000000368769.index|log</li>
<li>通过segment file<strong>查找message</strong><br>通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</li>
</ol>
<p>segment index file并没有为数据文件中的每条message建立索引，而是采取稀疏索引存储方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，通过map可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p>
<p>总结：</p>
<p>Kafka高效文件存储设计特点：</p>
<ul>
<li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li>
<li>通过索引信息可以快速定位message和确定response的最大大小。</li>
<li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</li>
<li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/jewes/article/details/42970799" target="_blank" rel="external">Kafka的Log存储解析</a></li>
<li><a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kakfa文件存储那些事</a></li>
<li><a href="http://blog.csdn.net/jewes/article/details/42744855" target="_blank" rel="external">Kafka的通讯协议</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce之Shuffle过程详述]]></title>
      <url>http://wangzzu.github.io/2016/03/02/hadoop-shuffle/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>MapReduce作为Hadoop的编程框架，对于大数据开发或者想要接触大数据开发的开发者来说，是必须要掌握的，它是一种经典大数据计算框架，现在有很多开源项目的内部实现都会直接或间接地借鉴了MR过程的实现。我在经过了一些hadoop项目的开发，然后前几天又系统地学习MapReduc内部实现过程，尤其是学习中间的Shuffle过程之后，准备对这一块做一下总结，希望这篇文章能给需要的人带来一些帮助（文中Shuffle的分析还是以Hadoop1.0为例，这个跟2.0的区别并不是很大）。</p>
<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>对于MapReduce作业，完整的作业运行流程，这里借用刘军老师的<a href="http://item.jd.com/11315351.html" target="_blank" rel="external">Hadoop大数据处理</a>中的一张图：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/hadoop.png" alt="hadoop"></p>
<p>完整过程应该是分为7部分，分别是：</p>
<ol>
<li>作业启动：开发者通过控制台启动作业；</li>
<li>作业初始化：这里主要是切分数据、创建作业和提交作业，与第三步紧密相联；</li>
<li>作业/任务调度：对于1.0版的Hadoop来说就是JobTracker来负责任务调度，对于2.0版的Hadoop来说就是Yarn中的Resource Manager负责整个系统的资源管理与分配，Yarn可以参考IBM的一篇博客<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-yarn/" target="_blank" rel="external">Hadoop新MapReduce框架Yarn详解</a>；</li>
<li>Map任务；</li>
<li>Shuffle；</li>
<li>Reduce任务；</li>
<li>作业完成：通知开发者任务完成。</li>
</ol>
<p>而这其中最主要的MapReduce过程，主要是第4、5、6步三部分，这也是本篇博客重点讨论的地方，详细作用如下：</p>
<ol>
<li><strong>Map</strong>:数据输入,做初步的处理,输出形式的中间结果；</li>
<li><strong>Shuffle</strong>:按照partition、key对中间结果进行排序合并,输出给reduce线程；</li>
<li><strong>Reduce</strong>:对相同key的输入进行最终的处理,并将结果写入到文件中。</li>
</ol>
<p>这里先给出官网上关于这个过程的经典流程图：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/mapreduce.png" alt="mapreduce"></p>
<p>上图是把MapReduce过程分为两个部分，而实际上从两边的Map和Reduce到中间的那一大块都属于Shuffle过程，也就是说，Shuffle过程有一部分是在Map端，有一部分是在Reduce端，下文也将会分两部分来介绍Shuffle过程。</p>
<p>对于Hadoop集群，当我们在运行作业时，大部分的情况下，map task与reduce task的执行是分布在不同的节点上的，因此，很多情况下，reduce执行时需要跨节点去拉取其他节点上的map task结果，这样造成了集群内部的网络资源消耗很严重，而且在节点的内部，相比于内存，磁盘IO对性能的影响是非常严重的。如果集群中运行的作业有很多，那么task的执行对于集群内部网络的资源消费非常大。因此，我们对于MapRedue作业Shuffle过程的期望是：</p>
<ul>
<li>完整地从map task端拉取数据到Reduce端；</li>
<li>在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗；</li>
<li>减少磁盘IO对task执行的影响。</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>在进行海量数据处理时，外存文件数据<strong>I/O访问</strong>会成为一个制约系统性能的瓶颈，因此，Hadoop的Map过程实现的一个重要原则就是：<strong>计算靠近数据</strong>，这里主要指两个方面：</p>
<ol>
<li>代码靠近数据：<ul>
<li>原则：本地化数据处理（locality），即一个计算节点尽可能处理本地磁盘上所存储的数据；</li>
<li>尽量选择数据所在DataNode启动Map任务；</li>
<li>这样可以减少数据通信，提高计算效率；</li>
</ul>
</li>
<li>数据靠近代码：<ul>
<li>当本地没有数据处理时，尽可能从同一机架或最近其他节点传输数据进行处理（host选择算法）。</li>
</ul>
</li>
</ol>
<p>下面，我们分块去介绍Hadoop的Map过程，map的经典流程图如下：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/map-shuffle.png" alt="map-shuffle"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ol>
<li>map task只读取split分片，split与block（hdfs的最小存储单位，默认为64MB）可能是一对一也能是一对多，但是对于一个split只会对应一个文件的一个block或多个block，不允许一个split对应多个文件的多个block；</li>
<li>这里切分和输入数据的时会涉及到InputFormat的文件切分算法和host选择算法。</li>
</ol>
<p>文件切分算法，主要用于确定InputSplit的个数以及每个InputSplit对应的数据段。FileInputFormat以文件为单位切分生成InputSplit，对于每个文件，由以下三个属性值决定其对应的InputSplit的个数：</p>
<ul>
<li>goalSize： 它是根据用户期望的InputSplit数目计算出来的，即totalSize/numSplits。其中，totalSize为文件的总大小；numSplits为用户设定的Map Task个数，默认情况下是1；</li>
<li>minSize：InputSplit的最小值，由配置参数<code>mapred.min.split.size</code>确定，默认是1；</li>
<li>blockSize：文件在hdfs中存储的block大小，不同文件可能不同，默认是64MB。</li>
</ul>
<p>这三个参数共同决定InputSplit的最终大小，计算方法如下：</p>
<p><code>splitSize=max{minSize, min{gogalSize,blockSize}}</code></p>
<p>FileInputFormat的host选择算法参考《Hadoop技术内幕-深入解析MapReduce架构设计与实现原理》的p50.</p>
<h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><ul>
<li>作用：将map的结果发送到相应的reduce端，总的partition的数目等于reducer的数量。</li>
<li>实现功能：<ol>
<li>map输出的是key/value对，决定于当前的mapper的part交给哪个reduce的方法是：mapreduce提供的Partitioner接口，对key进行hash后，再以reducetask数量取模，然后到指定的job上（<strong>HashPartitioner</strong>，可以通过<code>job.setPartitionerClass(MyPartition.class)</code>自定义）。</li>
<li>然后将数据写入到内存缓冲区，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。key/value对以及Partition的结果都会被写入缓冲区。在写入之前，key与value值都会被序列化成字节数组。</li>
</ol>
</li>
<li>要求：负载均衡，效率；</li>
</ul>
<h2 id="spill（溢写）：sort-amp-combiner"><a href="#spill（溢写）：sort-amp-combiner" class="headerlink" title="spill（溢写）：sort &amp; combiner"></a>spill（溢写）：sort &amp; combiner</h2><ul>
<li>作用：把内存缓冲区中的数据写入到本地磁盘，在写入本地磁盘时先按照partition、再按照key进行排序（<code>quick sort</code>）；</li>
<li>注意：<ol>
<li>这个spill是由<strong>另外单独的线程</strong>来完成，不影响往缓冲区写map结果的线程；</li>
<li>内存缓冲区默认大小限制为100MB，它有个溢写比例（<code>spill.percent</code>），默认为0.8，当缓冲区的数据达到阈值时，溢写线程就会启动，先锁定这80MB的内存，执行溢写过程，maptask的输出结果还可以往剩下的20MB内存中写，互不影响。然后再重新利用这块缓冲区，因此Map的内存缓冲区又叫做<strong>环形缓冲区</strong>（两个指针的方向不会变，下面会详述）；</li>
<li>在将数据写入磁盘之前，先要对要写入磁盘的数据进行一次<strong>排序</strong>操作，先按<code>&lt;key,value,partition&gt;</code>中的partition分区号排序，然后再按key排序，这个就是<strong>sort操作</strong>，最后溢出的小文件是分区的，且同一个分区内是保证key有序的；</li>
</ol>
</li>
</ul>
<p><strong>combine</strong>：执行combine操作要求开发者必须在程序中设置了combine（程序中通过<code>job.setCombinerClass(myCombine.class)</code>自定义combine操作）。</p>
<ul>
<li>程序中有两个阶段可能会执行combine操作：<ol>
<li>map输出数据根据分区排序完成后，在写入文件之前会执行一次combine操作（前提是作业中设置了这个操作）；</li>
<li>如果map输出比较大，溢出文件个数大于3（此值可以通过属性<code>min.num.spills.for.combine</code>配置）时，在merge的过程（多个spill文件合并为一个大文件）中还会执行combine操作；</li>
</ol>
</li>
<li>combine主要是把形如<code>&lt;aa,1&gt;,&lt;aa,2&gt;</code>这样的key值相同的数据进行计算，计算规则与reduce一致，比如：当前计算是求key对应的值求和，则combine操作后得到<code>&lt;aa,3&gt;</code>这样的结果。</li>
<li>注意事项：不是每种作业都可以做combine操作的，只有满足以下条件才可以：<ol>
<li>reduce的输入输出类型都一样，因为combine本质上就是reduce操作；</li>
<li>计算逻辑上，combine操作后不会影响计算结果，像求和就不会影响；</li>
</ol>
</li>
</ul>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><ul>
<li>merge过程：当map很大时，每次溢写会产生一个spill_file，这样会有多个spill_file，而最终的一个map task输出只有一个文件，因此，最终的结果输出之前会对多个中间过程进行多次溢写文件（spill_file）的合并，此过程就是merge过程。也即是，待Map Task任务的所有数据都处理完后，会对任务产生的所有中间数据文件做一次合并操作，以确保一个Map Task最终只生成一个中间数据文件。</li>
<li>注意：<ol>
<li>如果生成的文件太多，可能会执行多次合并，每次最多能合并的文件数默认为10，可以通过属性<code>min.num.spills.for.combine</code>配置；</li>
<li>多个溢出文件合并时，会进行一次排序，排序算法是<strong>多路归并排序</strong>；</li>
<li>是否还需要做combine操作，一是看是否设置了combine，二是看溢出的文件数是否大于等于3；</li>
<li>最终生成的文件格式与单个溢出文件一致，也是按分区顺序存储，并且输出文件会有一个对应的索引文件，记录每个分区数据的起始位置，长度以及压缩长度，这个索引文件名叫做<code>file.out.index</code>。</li>
</ol>
</li>
</ul>
<h2 id="内存缓冲区"><a href="#内存缓冲区" class="headerlink" title="内存缓冲区"></a>内存缓冲区</h2><ol>
<li>在Map Task任务的业务处理方法map()中，最后一步通过<code>OutputCollector.collect(key,value)</code>或<code>context.write(key,value)</code>输出Map Task的中间处理结果，在相关的<code>collect(key,value)</code>方法中，会调用<code>Partitioner.getPartition(K2 key, V2 value, int numPartitions)</code>方法获得输出的key/value对应的分区号(分区号可以认为对应着一个要执行Reduce Task的节点)，然后将<code>&lt;key,value,partition&gt;</code>暂时保存在内存中的MapOutputBuffe内部的环形数据缓冲区，该缓冲区的默认大小是100MB，可以通过参数<code>io.sort.mb</code>来调整其大小。</li>
<li>当缓冲区中的数据使用率达到一定阀值后，触发一次Spill操作，将环形缓冲区中的部分数据写到磁盘上，生成一个临时的Linux本地数据的spill文件；然后在缓冲区的使用率再次达到阀值后，再次生成一个spill文件。直到数据处理完毕，在磁盘上会生成很多的临时文件。</li>
<li>缓存有一个阀值比例配置，当达到整个缓存的这个比例时，会触发spill操作；触发时，map输出还会接着往剩下的空间写入，但是写满的空间会被锁定，数据溢出写入磁盘。当这部分溢出的数据写完后，空出的内存空间可以接着被使用，形成像环一样的被循环使用的效果，所以又叫做<strong>环形内存缓冲区</strong>；</li>
<li>MapOutputBuffe内部存数的数据采用了两个索引结构，涉及三个环形内存缓冲区。下来看一下两级索引结构：</li>
</ol>
<p><img src="/images/2016-03-02-HadoopShuffle/buffer.jpg" alt="buffer"></p>
<p><strong>写入到缓冲区的数据采取了压缩算法 <a href="http://www.cnblogs.com/edisonchou/p/4298423.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4298423.html</a></strong><br>这三个环形缓冲区的含义分别如下：</p>
<ol>
<li><strong>kvoffsets</strong>缓冲区：也叫偏移量索引数组，用于保存<code>key/value</code>信息在位置索引 <code>kvindices</code> 中的偏移量。当 <code>kvoffsets</code> 的使用率超过 <code>io.sort.spill.percent</code> (默认为80%)后，便会触发一次 SpillThread 线程的“溢写”操作，也就是开始一次 Spill 阶段的操作。</li>
<li><strong>kvindices</strong>缓冲区：也叫位置索引数组，用于保存 <code>key/value</code> 在数据缓冲区 <code>kvbuffer</code> 中的起始位置。</li>
<li><strong>kvbuffer</strong>即数据缓冲区：用于保存实际的 <code>key/value</code> 的值。默认情况下该缓冲区最多可以使用 <code>io.sort.mb</code> 的95%，当 <code>kvbuffer</code> 使用率超过 <code>io.sort.spill.percent</code> (默认为80%)后，便会出发一次 SpillThread 线程的“溢写”操作，也就是开始一次 Spill 阶段的操作。</li>
</ol>
<p>写入到本地磁盘时，对数据进行排序，实际上是对<strong>kvoffsets</strong>这个偏移量索引数组进行排序。</p>
<h1 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h1><p>Reduce过程的经典流程图如下：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/reduce-shuffle.png" alt="reduce-shuffle"></p>
<h2 id="copy过程"><a href="#copy过程" class="headerlink" title="copy过程"></a>copy过程</h2><ul>
<li>作用：拉取数据；</li>
<li>过程：Reduce进程启动一些数据copy线程(<code>Fetcher</code>)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为这时map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。</li>
<li>默认情况下，当整个MapReduce作业的所有已执行完成的Map Task任务数超过Map Task总数的5%后，JobTracker便会开始调度执行Reduce Task任务。然后Reduce Task任务默认启动<code>mapred.reduce.parallel.copies</code>(默认为5）个MapOutputCopier线程到已完成的Map Task任务节点上分别copy一份属于自己的数据。 这些copy的数据会首先保存的内存缓冲区中，当内冲缓冲区的使用率达到一定阀值后，则写到磁盘上。</li>
</ul>
<p><strong>内存缓冲区</strong></p>
<ul>
<li>这个内存缓冲区大小的控制就不像map那样可以通过<code>io.sort.mb</code>来设定了，而是通过另外一个参数来设置：<code>mapred.job.shuffle.input.buffer.percent（default 0.7）</code>， 这个参数其实是一个百分比，意思是说，shuffile在reduce内存中的数据最多使用内存量为：0.7 × <code>maxHeap of reduce task</code>。</li>
<li>如果该reduce task的最大heap使用量（通常通过<code>mapred.child.java.opts</code>来设置，比如设置为-Xmx1024m）的一定比例用来缓存数据。默认情况下，reduce会使用其heapsize的70%来在内存中缓存数据。如果reduce的heap由于业务原因调整的比较大，相应的缓存大小也会变大，这也是为什么reduce用来做缓存的参数是一个百分比，而不是一个固定的值了。</li>
</ul>
<h2 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h2><ul>
<li>Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比 map 端的更为灵活，它基于 JVM 的<code>heap size</code>设置，因为 Shuffle 阶段 Reducer 不运行，所以应该把绝大部分的内存都给 Shuffle 用。</li>
<li>这里需要强调的是，merge 有三种形式：1)内存到内存  2)内存到磁盘  3)磁盘到磁盘。默认情况下第一种形式是不启用的。当内存中的数据量到达一定阈值，就启动内存到磁盘的 merge（图中的第一个merge，之所以进行merge是因为reduce端在从多个map端copy数据的时候，并没有进行sort，只是把它们加载到内存，当达到阈值写入磁盘时，需要进行merge） 。这和map端的很类似，这实际上就是溢写的过程，在这个过程中如果你设置有Combiner，它也是会启用的，然后在磁盘中生成了众多的溢写文件，这种merge方式一直在运行，直到没有 map 端的数据时才结束，然后才会启动第三种磁盘到磁盘的 merge （图中的第二个merge）方式生成最终的那个文件。</li>
<li>在远程copy数据的同时，Reduce Task在后台启动了两个后台线程对内存和磁盘上的数据文件做合并操作，以防止内存使用过多或磁盘生的文件过多。</li>
</ul>
<h2 id="reducer的输入文件"><a href="#reducer的输入文件" class="headerlink" title="reducer的输入文件"></a>reducer的输入文件</h2><ul>
<li>merge的最后会生成一个文件，大多数情况下存在于磁盘中，但是需要将其放入内存中。当reducer 输入文件已定，整个 Shuffle 阶段才算结束。然后就是 Reducer 执行，把结果放到 HDFS 上。</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://vdisk.weibo.com/u/1853811305" target="_blank" rel="external">北邮刘军老师的Hadoop课件</a></li>
<li><a href="http://blog.csdn.net/dianacody/article/details/39502917" target="_blank" rel="external">分Map和Redcue两部分介绍</a></li>
<li><a href="http://flyingdutchman.iteye.com/blog/1879642" target="_blank" rel="external">内存缓冲区的介</a></li>
<li>内存缓冲区以及map的各个阶段介绍:<a href="http://xigan.blog.51cto.com/5200121/1163820" target="_blank" rel="external">mapreduce shuffle过程问答</a></li>
<li><a href="http://blog.csdn.net/ebay/article/details/45722263" target="_blank" rel="external">MapReduce详细过程</a></li>
<li><a href="http://zheming.wang/hadoop-mapreduce-zhi-xing-liu-cheng-xiang-jie.html" target="_blank" rel="external">http://zheming.wang/hadoop-mapreduce-zhi-xing-liu-cheng-xiang-jie.html</a></li>
<li>hadoop中的一些压缩算法，<a href="http://www.cnblogs.com/edisonchou/p/4298423.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4298423.html</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Travel to Nanjing | 元旦南京之旅]]></title>
      <url>http://wangzzu.github.io/2016/01/14/TravelToNanjing/</url>
      <content type="html"><![CDATA[<p>这篇文章是我2016年的第一篇博客，之前本来想着新年的开篇应该写一篇掉炸天的技术博客，最后，想了想，还是准备写篇旅行博客吧，因为这次南京游玩不仅仅是旅行。</p>
<h2 id="1-Day1"><a href="#1-Day1" class="headerlink" title="1.Day1"></a>1.Day1</h2><p>第一天应该是最辛苦的，因为去的地方比较多，有：玄武湖，狮子桥，中山陵，明孝陵，美龄宫，秦淮河和夫子庙。大家出去玩的时候一定要穿双舒服的鞋（就是走很多路也不会磨脚的那种），这点要切记，森哥（一同去玩的朋友）就是因为这导致第一天就把脚磨破，再后面两天几非常惨了。</p>
<p>南京火车站南出口一出来就是玄武湖，只不过这天雾霾比较大，景色没有想象中得好。如果南京的空气要是好些的话，还确实是座宜居的城市，在玄武湖的周围有一个专门跑步的跑道，我本身比较喜欢跑步，所以我是特别喜欢这种湖边跑道，要是自己以后能住在湖边，而湖边又有跑道，那该多么幸福！我之所以会羡慕这种城市，可能主要我是北方人的原因，越是缺少什么东西越是喜欢什么吧。好了，先放几张图。</p>
<p>南京火车站南出站口</p>
<p><img src="/images/2016-01-14-TraveToNanJing/nanjing.jpg" alt="nanjing"></p>
<p>火车站对面的玄武湖</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu.jpg" alt="xuanwuhu"></p>
<p>去往玄武湖其中一个岛的小桥（旭桥，来自百度地图），还有森哥的背景</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu3.jpg" alt="xuanwuhu3"></p>
<p>小岛上的景色还是不错的</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu2.jpg" alt="xuanwuhu2"></p>
<p>接下来，我们就是南京很有名的小吃街——湖南路狮子桥，去吃了一家南京本地的饭店——南京大排档，总体感觉还不错吧，算是比较有特色的当地饭店，没有吃的话，还是推荐去吃一下，就是里面椅子不太舒服不能往后靠。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi1.jpg" alt="meishi1"></p>
<p>吃完饭之后，我就坐车直接去了中山陵，到中山陵的时候就已经快一点了，这个时候中山陵的人已经很多了，如果要是还想去明孝陵，美龄宫，灵谷寺的话就得抓紧时间了，我们当时再去完中山陵之后，就去了明孝陵，然后又去了美龄宫，去完美龄宫就已经到五点多了，灵谷寺就没时间玩了。下面又是晒图的时候了。</p>
<p>2016元旦的中山陵</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshan1.jpg" alt="zhongshan1"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshan2.jpg" alt="zhongshan2"></p>
<p>中山陵这边的天气还是很不错的，虽然此时南京市区都环绕在中度污染之中，在这钟山风景区空气竟然没那么糟，还能清晰地看到蓝天白云。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshanling3.jpg" alt="zhongshanling3"></p>
<p>明孝陵的方城明楼，还是能感受帝王的气派的，城楼都盖了几百年了，依然屹立不倒，与现在的豆腐渣工程形成鲜明对比</p>
<p><img src="/images/2016-01-14-TraveToNanJing/mingxiaoling.jpg" alt="mingxiaoling"></p>
<p>美龄宫，也曾经是中国的权利中心之一吧</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meilinggong.jpg" alt="meilinggong"></p>
<p>在去完美龄宫之后，我们就基本上没有力气，也没有时间再去灵谷寺和音乐台了，所以就选择了回市区吃饭，本来想着去吃鸭血粉丝的，但是离我们下车的地方太远了，所以就去吃了一个抄手，然后又去吃了南京一家比较有名的笑云开灌汤包。吃完之后就直接奔向了夫子庙。由于是晚上，手机的照相功能又一般般，选两张稍微好看一点的照片吧。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/fuzimiao.jpg" alt="fuzimiao"></p>
<p>夫子庙的聚贤楼，之所以晒这个，主要是因为这张照片感觉照得还不错，其他的照片就不好意思拿出手了。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/fuzimiao2.jpg" alt="fuzimiao2"></p>
<p>经过昨天一晚的长途奔波（北京到南京的硬座）和今天一天的到处转悠，我这天的运动步数也达到了4W+步，第一次取得了微信运动的第一名。晚上就直接住在好友祥子学校（东大九龙湖校区）附近了，祥子很给力，把住宿什么的都给我们安排好了，非常感谢哈。</p>
<h2 id="2-Day2"><a href="#2-Day2" class="headerlink" title="2.Day2"></a>2.Day2</h2><p>因为昨天太过劳累，今天直接睡到了早上9点，然后起床去东大食堂吃点，吃完早饭之后就直接坐地铁准备去南京博物院了，南京博物院号称仅次于故宫博物院和上海博物院的全国第三大博物院，尤其以其民国馆最著名，所以我们准备花半天的时间转。</p>
<p>在进博物院之前，我们先去一家南京本地很出名的糕点店——芳婆糕点去买了中午饭，我们去买饭的时候已经快上午11点了，但是还有很多人在排队。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi2.jpg" alt="meishi2"></p>
<p>买完饭之后，我们直接奔向博物院，先来张博物院的正门。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/bowuyuan.jpg" alt="bowuyuan"></p>
<p>其他的像博物馆里江南的历史这里就不在说了，晒几张民国馆的照片吧。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo1.jpg" alt="minguo1"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo2.jpg" alt="minguo2"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo3.jpg" alt="minguo3"></p>
<p>转完博物院之后就已经三点多了，这时候我们就直接坐车去了总统府，到总统府的时候就已经快4点了，就要停止卖票了。要注意总统府停止卖票时间是<strong>下午4点</strong>，5店闭馆，也就是说我们只有一个小时的时间去转,这点去的时候人还是超多的，尤其到了那个有总统办公室的大楼，人超多，还没看清就被挤出去了。因为时间比较紧，我们转完中间和东边部分之后，西边的地方还没有转完，人家就已经要闭馆了，所以要去总统府的话一定要<strong>早点</strong>去。</p>
<p>总统府的大门，出来后照的，门口有卖明信片的，比总统府里和民国馆里卖得便宜</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu.jpg" alt="zongtongfu"></p>
<p>著名“天下为公”，第一次听说这个词，是在《走向共和》里看到，这也是我第一次对孙中山这个人有了稍微深入一点的了解，之前的了解全是从历史课本里得到，了解得很片面，不过依然认为孙中山还是非常伟大的，每个人都会有缺点，但是这些缺点也不能掩盖他的伟大。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu2.jpg" alt="zongtongfu2"></p>
<p>这个好像会议室，具体的忘了。。。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu3.jpg" alt="zongtongfu3"></p>
<p>下面这张是在总统府西边那边顺便照的一张，因为比较时间比较紧，并没有怎么转，就选一张作为代表吧</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu4.jpg" alt="zongtongfu4"></p>
<p>再去完总统府之后，我们就直接返回了东大，晚上在东大附近与以前好友们（其中四个在东大读研究生）一起大吃了一顿，非常感谢这几位好朋友的款待。</p>
<h2 id="3-Day3"><a href="#3-Day3" class="headerlink" title="3.Day3"></a>3.Day3</h2><p>前两天基本上把南京比较出名的地方都玩了一遍，所以今天就好好睡了一觉，我跟森哥直接睡到了早上11点才起来，起来之后又在东大吃了中饭，然后就跟着海坤兄一起先去了燕子矶公园，据说在那天气好的话可以看到南京第一长江大桥，而且它离南京第二长江大桥很近。</p>
<p>燕子矶公园，南京第二长江大桥的景色</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang2.jpg" alt="changjiang2"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang2-2.jpg" alt="changjiang2-2"></p>
<p>然后，我们就坐车去了南京第一长江大桥，因为这个桥建造的时间比较长，它的人行道跟自行车道是在一起，而且很窄，电动车非常多，只想说很<strong>危险</strong>，最好还是直接去长江大桥下面的那个什么公园，公园门票是15，可以直接坐电梯坐到桥，要不然就要绕很远的路才能到桥上，而且还很危险。冒着生命危险，终于走到了长江大桥上，不照照片非好汉啊，又一波照片来袭！</p>
<p>傍晚的大桥</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1.jpg" alt="changjiang1"></p>
<p>手机相机处理后的效果</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1-1.jpg" alt="changjiang1-1"></p>
<p>桥前面的石像，桥口还有武警站岗的</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1-2.jpg" alt="changjiang1-2"></p>
<p>看到大桥之后，我们就去了一家叫做石记鸭血粉丝店专门去吃鸭血粉丝，下面是鸭血粉丝的全家桶的图</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi3.jpg" alt="meishi3"></p>
<h2 id="4-好友重逢"><a href="#4-好友重逢" class="headerlink" title="4.好友重逢"></a>4.好友重逢</h2><p>相聚的时间总是短暂的，前面之所以说这次不仅仅旅行，主要是这次更多的是好友的相聚，大学毕业后的（毕业一年半）再次相聚，还感慨颇深的，尤其当在火车站与好友相别，在候车室与森哥相别的时候，心中平添了很多的伤感，下次再聚不知道会是什么时候。三天的相聚，更多的是那种熟悉的感觉，方佛又回到大学时光，让我感到由衷的亲切，这感觉远胜美景千万。希望以后大家还能再一起出去玩，最后附上我们几个合照（另外两位美女就不公开了）。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/hezhao.jpg" alt="hezhao"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于Kafka学习的一些资料]]></title>
      <url>http://wangzzu.github.io/2015/12/21/kafka-learn/</url>
      <content type="html"><![CDATA[<h2 id="kafka一些重要博客参考"><a href="#kafka一些重要博客参考" class="headerlink" title="kafka一些重要博客参考"></a>kafka一些重要博客参考</h2><p>kafka设计部分的文档：</p>
<ul>
<li><a href="http://kafka.apache.org/documentation.html#design" target="_blank" rel="external">官网设计英文版</a></li>
<li><a href="http://www.oschina.net/translate/kafka-design" target="_blank" rel="external">Kafka设计中文版</a></li>
<li><a href="http://blog.csdn.net/lizhitao/article/details/39499283" target="_blank" rel="external">Kafka资源汇总</a></li>
<li><a href="http://www.jasongj.com/tags/Kafka/" target="_blank" rel="external">Json的Kafka深度解析博客</a></li>
</ul>
<p>kafka设计的一些特殊之处：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/145090" target="_blank" rel="external">Kafka源码调研系统1 特色</a></li>
</ul>
<p>kafka的存储：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/152837" target="_blank" rel="external">producer中partition的使用方式</a></li>
</ul>
<p>kafka监控：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/158139" target="_blank" rel="external">Kafka监控之mx4j-tool</a></li>
<li><a href="http://my.oschina.net/u/591402/blog/158150" target="_blank" rel="external">Kafka监控之mx4jLoader</a></li>
<li><a href="http://wangzzu.github.io/2015/12/08/2015-12-8-kafka-monitor/">Kafka监控软件</a></li>
</ul>
<p>Kafka测试：</p>
<ul>
<li><a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines#userconsent#" target="_blank" rel="external">Benchmarking Apache Kafka: 2 Million Writes Per Second (On Three Cheap Machines)</a></li>
</ul>
<p>Kafka源码解析：</p>
<ul>
<li><a href="https://github.com/wyzssw/kafka--summary" target="_blank" rel="external">wyzssw/kafka–summary</a></li>
<li><a href="http://www.cnblogs.com/huxi2b/tag/Kafka/" target="_blank" rel="external">胡夕-Kafka详细代码解释</a></li>
<li><a href="http://zqhxuyuan.github.io/2017/01/01/Kafka-Code-Index/" target="_blank" rel="external">Kafka技术内幕</a></li>
<li><a href="https://www.gitbook.com/book/zqhxuyuan1/kafka/details" target="_blank" rel="external">Kafka源码分析的GitBook</a></li>
</ul>
<p>Kafka最新动态</p>
<ul>
<li>可以关注<a href="http://www.confluent.io/blog" target="_blank" rel="external">confluent博客</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka监控软件介绍]]></title>
      <url>http://wangzzu.github.io/2015/12/08/2015-12-8-kafka-monitor/</url>
      <content type="html"><![CDATA[<h1 id="KafkaOffsetMonitor"><a href="#KafkaOffsetMonitor" class="headerlink" title="KafkaOffsetMonitor"></a>KafkaOffsetMonitor</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li><a href="https://github.com/quantifind/KafkaOffsetMonitor" target="_blank" rel="external">源码下载地址</a></li>
<li><a href="https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar" target="_blank" rel="external">jar下载地址</a></li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>This is a small webapp, you can run it locally or on a server, as long as you have access to the ZooKeeper nodes controlling kafka.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk serveIp1,serveIp2,serveIp3 --port 8080 --refresh 10.seconds --retain 2.days</div></pre></td></tr></table></figure>
<p>The arguments are:</p>
<ul>
<li><strong>ZK</strong>: the ZooKeeper hosts;</li>
<li><strong>port</strong>: on what port will the app be available;</li>
<li><strong>refresh</strong>: how often should the app refresh and store a point in the DB;</li>
<li><strong>retain</strong>: how long should points be kept in the DB;</li>
<li><strong>dbName</strong>: where to store the history (default ‘offsetapp’);</li>
</ul>
<h1 id="Kafka-Manager"><a href="#Kafka-Manager" class="headerlink" title="Kafka Manager"></a>Kafka Manager</h1><p><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="external">源码地址</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://hengyunabc.github.io/kafka-manager-install/" target="_blank" rel="external">Kafka Manager安装</a></p>
<h3 id="sbt安装"><a href="#sbt安装" class="headerlink" title="sbt安装"></a>sbt安装</h3><p><a href="http://www.scala-sbt.org/download.html" target="_blank" rel="external">sbt安装</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl https://bintray.com/sbt/rpm/rpm &gt; bintray-sbt-rpm.repo</div><div class="line">sudo mv bintray-sbt-rpm.repo /etc/yum.repos.d/</div><div class="line">sudo yum install sbt</div></pre></td></tr></table></figure>
<h3 id="下载，编译"><a href="#下载，编译" class="headerlink" title="下载，编译"></a>下载，编译</h3><p>下载，并编译源码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/yahoo/kafka-manager</div><div class="line"><span class="built_in">cd</span> kafka-manager</div><div class="line">sbt clean dist</div></pre></td></tr></table></figure>
<p>生成的包会在<code>kafka-manager/target/universal</code> 下面。生成的包只需要java环境就可以运行了，在部署的机器上不需要安装sbt.</p>
<h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p>打好包好，在部署机器上解压，修改好配置文件，就可以运行了。</p>
<p>解压：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip kafka-manager-1.0-SNAPSHOT.zip</div></pre></td></tr></table></figure></p>
<h2 id="配置运行"><a href="#配置运行" class="headerlink" title="配置运行"></a>配置运行</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改<code>conf/application.conf</code>，把<code>kafka-manager.zkhosts</code>改为自己的zookeeper服务器地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kafka-manager.zkhosts=<span class="string">"localhost:2181"</span></div></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-manager -Dconfig.file=./conf/application.conf -Dhttp.port=8080</div></pre></td></tr></table></figure>
<h3 id="kafka-manager其他方面"><a href="#kafka-manager其他方面" class="headerlink" title="kafka-manager其他方面"></a>kafka-manager其他方面</h3><p>查看帮助</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-manager -h</div></pre></td></tr></table></figure>
<p>后台运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ./kafka-manager -Dconfig.file=../conf/application.conf &gt;/dev/null 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>
<p>默认http端口是9000，可以修改配置文件里的http.port的值，或者通过命令行参数传递：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./kafka-manager -Dhttp.port=9001</div></pre></td></tr></table></figure>
<p>如果不想自己编译源文件，也可以通过下面的地址直接下载，<a href="http://pan.baidu.com/s/1kTtFpGV" target="_blank" rel="external">kafka-manager-1.0-SNAPSHOT.zip下载地址</a></p>
<h1 id="Kafka-web-console"><a href="#Kafka-web-console" class="headerlink" title="Kafka-web-console"></a>Kafka-web-console</h1><p><a href="https://github.com/claudemamo/kafka-web-console" target="_blank" rel="external">源码地址</a></p>
<p>不过这个项目好像不再进行更新了，想了解这个项目的话可以进入github主页去研究研究。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka程序设计之Producer]]></title>
      <url>http://wangzzu.github.io/2015/11/27/kafka-code1/</url>
      <content type="html"><![CDATA[<p>本文主要是介绍一下kafka基于<code>Producer API</code>的程序设计，使用的kafka版本为<code>2.10-0.8.1.1</code>。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在写完<a href="http://wangzzu.github.io/2015/11/13/kafka-install/">Kafka集群的安装与配置</a>和<a href="http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka/">Kafka的简单介绍</a>这两篇博客之后，从本文开始准备介绍一下Kafka的程序设计部分，大概会分为三篇介绍，第一篇是基于<code>Kafka Producer API</code>的程序设计，也就是本文，第二篇是基于<code>Kafka High Level Consumer API</code>的程序设计，第三篇是基于<code>Kafka Simple Consumer API</code>的程序设计。本文主要是根据kafka提供的官方文档来介绍，希望能给刚接触kafka程序设计的初学者提供一些帮助。</p>
<p>我们知道，kafka的基本架构其实非常简单，但kafka作为管道传输为了保证其强大的功能与稳定的性能，kafka在内部实现上是做了非常多的努力的，这些我会在后续的文章中慢慢讲解。然而对大部分人而言重要的就是如何进行程序设计来实现所需的功能，kafka给我们提供了丰富而简介的API接口，本文的例子是通过<a href="https://github.com/apache/kafka/tree/trunk/examples/src/main/java/kafka/examples" target="_blank" rel="external">Kafka Examples</a>中的例子来讲解如何使用这些API接口来进行程序设计。本文中使用的kafka的版本为<code>kafka_2.10-0.8.1.1</code>，并且使用maven建立工程，需要在pom.xml文件加入如下的依赖包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.jms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jdmk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxri<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jmx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面具体讲解一下<code>Producer</code>。</p>
<h2 id="2-实例分析"><a href="#2-实例分析" class="headerlink" title="2.实例分析"></a>2.实例分析</h2><p>Producer是用来把消息发送到Kafka的Broker端，Producer应用非常广泛，在本文中只涉及发送随机消息和本地文件。</p>
<h3 id="2-1-API介绍"><a href="#2-1-API介绍" class="headerlink" title="2.1.API介绍"></a>2.1.API介绍</h3><p>实现Producer程序主要会使用到以下三个类：</p>
<ul>
<li>kafka.producer.ProducerConfig：配置Producer，比如定义metadata.bokers.list、partitioner.class等；</li>
<li>kafka.javaapi.producer.Producer：最主要的类，用来发送消息等；</li>
<li>kafka.producer.KeyedMessage：定义要发送的消息，比如发送到哪个topic的哪个partition等。</li>
</ul>
<h3 id="2-2-示例分析"><a href="#2-2-示例分析" class="headerlink" title="2.2.示例分析"></a>2.2.示例分析</h3><p>借用官方文档<a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+Producer+Example" target="_blank" rel="external">0.8.0 Producer Example</a>中给出的样例程序。</p>
<p>Producer的程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> events = Long.parseLong(args[<span class="number">0</span>]);</div><div class="line">        Random rnd = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"broker1:9092,broker2:9092 "</span>);</div><div class="line">        props.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</div><div class="line">        props.put(<span class="string">"partitioner.class"</span>, <span class="string">"example.producer.SimplePartitioner"</span>);</div><div class="line">        props.put(<span class="string">"request.required.acks"</span>, <span class="string">"1"</span>);</div><div class="line"></div><div class="line">        ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</div><div class="line"></div><div class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> Producer&lt;String, String&gt;(config);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> nEvents = <span class="number">0</span>; nEvents &lt; events; nEvents++) &#123;</div><div class="line">               <span class="keyword">long</span> runtime = <span class="keyword">new</span> Date().getTime();  </div><div class="line">               String ip = <span class="string">"192.168.2."</span> + rnd.nextInt(<span class="number">255</span>);</div><div class="line">               String msg = runtime + <span class="string">",www.example.com,"</span> ip;</div><div class="line">               KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);</div><div class="line">               producer.send(data);</div><div class="line">        &#125;</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Partitioner的程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePartitioner</span> <span class="params">(VerifiableProperties props)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object key, <span class="keyword">int</span> a_numPartitions)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</div><div class="line">        String stringKey = (String) key;</div><div class="line">        <span class="keyword">int</span> offset = stringKey.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</div><div class="line">           partition = Integer.parseInt( stringKey.substring(offset+<span class="number">1</span>)) % a_numPartitions;</div><div class="line">        &#125;</div><div class="line">       <span class="keyword">return</span> partition;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个样例程序实现的功能非常简单，就是发送多条（参数指定）类似于<code>runtime + “,www.example.com,” + “192.168.2.” + rnd.nextInt(255);</code>的消息。通过这个程序可以看出实现Kafka producer功能主要有以下三点需要注意：</p>
<p><strong>Kafka Properties</strong></p>
<p>这是实现代码的第一步，在代码中定义了一个<code>Properties</code>。这个<code>Properties</code>是通过<code>kafka.producer.ProducerConfig</code>将一些参数传递给Producer，告诉Producer如何找到找到集群，怎么序列化消息和消息如何发给Partition等。</p>
<p>样例程序中的这些参数意义为：</p>
<ul>
<li><code>metadata.broker.list</code> 定义Producer为每个Partition选作Leader的broker，应至少有两个，而且这两个broker一定要是开启Kafka服务；</li>
<li><code>serializer.class</code>定义message传送给broker时，应该使用什么类型的序列化方式，但是注意这个类型的编码也一定要能够接受KeyMessage对象定义的类型（Java对象在传输前需要进行序列化）；</li>
<li><code>partitioner.class</code>决定了这个message应该发送给这个topic的哪个Partition（如果程序中为key指定了一个值但是没有定义一个partitioner.class，kafka就会使用默认的partitioner发送到指定的Partition，如果key没有定义，Producer就会把message发送到随机的Partition）；</li>
<li><code>request.required.acks</code>默认是0，可以设置0，1，-1；</li>
</ul>
<p>程序中可以传入的参数参考<a href="http://kafka.apache.org/documentation.html#producerconfigs" target="_blank" rel="external">Producer API</a>，经常使用参数有 <code>producer.type</code>, <code>batch.size</code>, <code>receive.buffer.bytes</code>, <code>send.buffer.bytes</code> 和 <code>acks</code>等。</p>
<p>使用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">props.put(<span class="string">"producer.type"</span>, async);</div><div class="line">props.put(<span class="string">"batch.num.messages"</span>, batch);</div></pre></td></tr></table></figure>
<p><strong>Producer object</strong></p>
<p>再定义完<code>Properties</code>和<code>Producer object</code>之后，下面就是将topic，partition和message传递给<code>KeyedMessage</code>，然后通过producer的<code>send</code>方法将消息发送出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</div><div class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> Producer&lt;String, String&gt;(config);</div><div class="line"><span class="comment">/**</span></div><div class="line">* 数据的处理过程</div><div class="line">*/</div><div class="line">KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);<span class="comment">//KeyedMessage&lt;String, String&gt;(topicName, partitionKey, msg)</span></div><div class="line">producer.send(data);</div></pre></td></tr></table></figure>
<p><strong>自定义Partition</strong></p>
<p>样例代码中的<code>SimplePartitioner</code>是自定义的，PartitionKey的值通过十进制ip地址小数点最后一位与a_numPartitions取余得到。在自定义Partition时，需要在程序（如：<code>props.put(&quot;partitioner.class&quot;, &quot;example.producer.SimplePartitioner&quot;)</code>）中指定Partitioner的位置。</p>
<h2 id="3-实例程序设计"><a href="#3-实例程序设计" class="headerlink" title="3.实例程序设计"></a>3.实例程序设计</h2><p>在解析完样例程序之后，下面我们通过一个实际案例来设计Producer程序。</p>
<h3 id="3-1-实现功能"><a href="#3-1-实现功能" class="headerlink" title="3.1.实现功能"></a>3.1.实现功能</h3><p>程序要实现的功能是监控本地一个文件目录，将此目录中文件数据发送到Kafka的Broker端，并且每当发送完一个文件后就删除该文件，然后当有新的文件传进来之后就发送这个文件。</p>
<h3 id="3-2-程序设计"><a href="#3-2-程序设计" class="headerlink" title="3.2.程序设计"></a>3.2.程序设计</h3><p>本例我们就不在使用自定义的Partition，而直接由参数传入PartitionKey的值。程序设计的思路：</p>
<ol>
<li>监控给定的目录；</li>
<li>如果目录没有文件，sleep一段时间（sleep的时间需要根据具体的应用来设置），返回第1步；</li>
<li>当目录中有文件时，将文件中的数据按行发送；</li>
<li>这个文件发送完，就将该文件删除，继续发送下一个文件，知道目录中文件发送完毕，再返回第1步。</li>
</ol>
<p>根据这个思路，程序主要实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (args.length!=<span class="number">3</span>) &#123;</div><div class="line">			System.err.println(<span class="string">"please input &lt;input&gt; &lt;topic&gt; &lt;partitionKey&gt; "</span>);</div><div class="line">			System.exit(<span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		String input = args[<span class="number">0</span>];</div><div class="line">		String topic = args[<span class="number">1</span>];</div><div class="line">		String partitionKey=args[<span class="number">2</span>];</div><div class="line">		Properties props = <span class="keyword">new</span> Properties();</div><div class="line">		props.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"ip1:9092,ip2:9092"</span>);</div><div class="line">		props.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</div><div class="line">		props.put(<span class="string">"key.serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</div><div class="line"></div><div class="line">		ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</div><div class="line">		BufferedReader reader=<span class="keyword">null</span>;</div><div class="line">		<span class="keyword">int</span> fileLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">		File file = <span class="keyword">new</span> File(inputFold);<span class="comment">//输入目录由参数给定</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> (file.exists()) &#123;</div><div class="line">		    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//一直监控目录</span></div><div class="line">		    	File[] files = file.listFiles();</div><div class="line">			    <span class="keyword">if</span> (files.length == <span class="number">0</span>) &#123;</div><div class="line">			        System.out.println(<span class="string">"文件夹是空的!"</span>);</div><div class="line">			        <span class="keyword">try</span> &#123;</div><div class="line">			            Thread.sleep(<span class="number">60000</span>);<span class="comment">//sleep1min</span></div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">			        <span class="keyword">continue</span>;</div><div class="line">			    &#125; <span class="keyword">else</span> &#123;</div><div class="line">			        <span class="keyword">for</span> (File file2 : files) &#123;</div><div class="line">			        	<span class="keyword">if</span> (file2.isDirectory()) &#123;</div><div class="line">							System.out.println(<span class="string">"有递归目录："</span> + file2.getAbsolutePath());</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							<span class="keyword">try</span> &#123;</div><div class="line">								reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file2.getAbsolutePath())));</div><div class="line">							&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">								System.err.println(<span class="string">"输入文件错误"</span>);</div><div class="line">								System.exit(<span class="number">2</span>);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">							String line=<span class="keyword">null</span>;</div><div class="line">							<span class="keyword">try</span> &#123;</div><div class="line">								line = reader.readLine();</div><div class="line">							&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            					System.err.println(<span class="string">"输入文件错误"</span>);</div><div class="line">            					e.printStackTrace();</div><div class="line">            					System.exit(<span class="number">2</span>);</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">if</span>(line==<span class="keyword">null</span>)</div><div class="line">							&#123;</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">							&#125;</div><div class="line">							KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(topic,partitionKey,line);</div><div class="line">							producer.send(data);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							reader.close();</div><div class="line">						&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">							e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					file2.delete();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">          System.out.println(<span class="string">"目录不存在!"</span>);</div><div class="line">    &#125;</div><div class="line">    producer.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">Kafka Documentation</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+Producer+Example" target="_blank" rel="external">0.8.0 Producer Example</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka的简单介绍]]></title>
      <url>http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是简单地把Kafka的背景，基础知识和应用场景介绍一下，算是一篇入门的文章。</p>
<h2 id="1-kafka介绍"><a href="#1-kafka介绍" class="headerlink" title="1.kafka介绍"></a>1.kafka介绍</h2><p>关于kafka入门的文章最好的就莫过于kafka的<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">官方文档</a>了，这上面对kafka的定义是：</p>
<blockquote>
<p>Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.</p>
</blockquote>
<p>kafka是一个分布式的，可分区的，可备份的日志提交服务，它使用独特的设计实现了一个消息系统的功能。</p>
<p>到底kafka使用什么独特的设计可以让它在消息处理领域独占鳌头呢？这就涉及到kafka的内部机制，这些我会在后续的文章中向大家慢慢介绍，这里先介绍一下kafka集群的基本结构和kafka的一些专业术语。</p>
<h3 id="1-1-kafka集群的基本架构"><a href="#1-1-kafka集群的基本架构" class="headerlink" title="1.1.kafka集群的基本架构"></a>1.1.kafka集群的基本架构</h3><p>一个典型的kafka集群架构如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/kafka.png" alt="kafka"></p>
<p>kafka集群常用的场景就是，producer把日志信息推送（push）到broker节点上，然后consumer（可以是写入到hdfs或者其他的一些应用）再从broker拉取（pull）信息。kafka的push&amp;pull机制如下图所示，具体的这样设计的原因我会在后续的文章中进行介绍。</p>
<p><img src="/images/2015-11-14-kafka-introduce/pull.png" alt="pull"></p>
<p>作为一个message system，kafka遵循了传统的方式，选择由kafka的producer向broker push信息，而consumer从broker pull信息。kafka的consumer之所以没有采用push模式，主要是因为push模式很难适应速率不同的consumer，因为消息发送速率是由broker决定的。push模式的目标就是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞，而pull模式则可以根据consumer的消费能力以适当的速率消费message。</p>
<h3 id="1-2-专业术语"><a href="#1-2-专业术语" class="headerlink" title="1.2.专业术语"></a>1.2.专业术语</h3><p>kafka使用的一些主要的专业术语：</p>
<ul>
<li><strong>Topic</strong>：特指Kafka处理的消息源的不同分类，其实也可以理解为对不同消息源的区分的一个标识；</li>
<li><strong>Partition</strong>：Topic物理上的分组，一个topic可以设置为多个partition，每个partition都是一个有序的队列，partition中的每条消息都会被分配一个有序的id（offset）；</li>
<li><strong>Message</strong>：消息，是通信的基本单位，每个producer可以向一个topic（主题）发送一些消息；</li>
<li><strong>Producers</strong>：消息和数据生产者，向Kafka的一个topic发送消息的过程叫做producers（producer可以选择向topic哪一个partition发送数据）。</li>
<li><strong>Consumers</strong>：消息和数据消费者，接收topics并处理其发布的消息的过程叫做consumer，同一个topic的数据可以被多个consumer接收；</li>
<li><strong>Broker</strong>：缓存代理，Kafka集群中的一台或多台服务器统称为broker。</li>
</ul>
<p>理解了上述概念之后，再来看kafka就容易了。</p>
<h3 id="1-3-kafka的应用场景"><a href="#1-3-kafka的应用场景" class="headerlink" title="1.3.kafka的应用场景"></a>1.3.kafka的应用场景</h3><p>Kafka主要用于处理流式数据。流式数据在web网站应用中非常常见，这些数据包括网站的pv、用户访问了什么内容，搜索了什么内容等。这些数据通常以日志的形式记录下来，然后每隔一段时间进行一次统计处理。Kafka的作用类似于缓存，能够很好地处理实时和离线应用。</p>
<h2 id="2-组件详解"><a href="#2-组件详解" class="headerlink" title="2.组件详解"></a>2.组件详解</h2><h3 id="2-1-topic"><a href="#2-1-topic" class="headerlink" title="2.1.topic"></a>2.1.topic</h3><p>正如前面介绍的，topic是kafka发送消息的一个标识，一般以目录的形式存在，对于一个有三个partition的topic而言，它日志信息结构大概如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/log.png" alt="log"></p>
<p>每一个partition实际上都是一个有序的，不可变的消息序列，producer发送到broker的消息会写入到相应的partition目录下，每个partition都会有一个有序的id（<code>offset</code>），这个offset确定这个消息在partition中的具体位置。</p>
<p>举一个例子，我们在一个kafka集群中建立的名为<code>wangzzu</code>，partition数为3的topic，kafka就会在broker的<code>/tmp/kafka-logs</code>（目录可以修改，可参考我<a href="http://wangzzu.github.io/2015/11/13/kafka-install/">kafka集群安装与配置</a>）新建三个目录，这里我们直接指定将三个partition建立在同一个broker上，如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/topic.png" alt="topic"></p>
<p>当启动producer程序时，就会向kafka集群发送信息，而kafka就会把中间信息存储在这三个目录下，具体的发送方式和消息存储结构会在以后的文章中介绍。</p>
<h3 id="2-2-producer"><a href="#2-2-producer" class="headerlink" title="2.2.producer"></a>2.2.producer</h3><p>producer这部分相比较而言，是比较简单的，就是把消息发送给它所选择的topic，也可以具体指定发给这个topic的哪个一个partition，否则producer就会使用<code>hashing-based partitioner</code>来决定发送到哪个partition，这个问题还是需要多说一些，之前我在测试kafka速度的时候就遇到了这个问题，当我们增加broker的数量时，kafka的发送速度并没有线性增加，最后发现就是因为这个原因，没有指明发送数据到哪个partition，具体的解释我就引用官网<a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ" target="_blank" rel="external">WIKI</a>中给出回答：</p>
<blockquote>
<p>In Kafka producer, a partition key can be specified to indicate the destination partition of the message. By default, a hashing-based partitioner is used to determine the partition id given the key, and people can use customized partitioners also.<br>To reduce # of open sockets, in 0.8.0(<a href="https://issues.apache.org/jira/browse/KAFKA-1017" target="_blank" rel="external">High number of open file handles in 0.8 producer</a>), when the partitioning key is not specified or null, a producer will pick a random partition and stick to it for some time (default is 10 mins) before switching to another one. So, if there are fewer producers than partitions, at a given point of time, some partitions may not receive any data. To alleviate this problem, one can either reduce the metadata refresh interval or specify a message key and a customized random partitioner. For more detail see <a href="http://mail-archives.apache.org/mod_mbox/kafka-dev/201310.mbox/%3CCAFbh0Q0aVh%2Bvqxfy7H-%2BMnRFBt6BnyoZk1LWBoMspwSmTqUKMg%40mail.gmail.com%3E" target="_blank" rel="external">this thread</a></p>
</blockquote>
<h3 id="2-3-consumer"><a href="#2-3-consumer" class="headerlink" title="2.3.consumer"></a>2.3.consumer</h3><p>这里的consumer部分，主要是以<code>High Level Consumer API</code>为例。</p>
<p>consumer是一个抽象的概念，调用<code>Consumer API</code>的程序都可以称作为一个consumer，它从broker端订阅某个topic的消息。如果只有一个consumer的话，该topic（可能含有多个partition）下所有消息都会被这个consumer接收。但是在分布式的环境中，我们可能会遇到这样一种情景，对于一个有多个partition的topic，我们希望启动多个consumer去消费这些partition（如果发送速度较快，一个consumer是无法消费完的），并且要求topic的一条消息只能发给其中一个consumer，不希望这些conusmer出现重复接收一条消息的情况。对于这种情况，我们应该怎么办呢？kafka给我们提供了一种机制，可以很好来适应这种情况，那就是<strong>consumer group</strong>（当然也可以应用在第一种情况，实际上，如果只有一个consumer时，是不需要指定consumer group，这时kafka会自动给这个consumer生成一个group名）。</p>
<p>在调用conusmer API时，一般都会指定一个consumer group，该group订阅的topic的每一条消息都发送到这个group的某一台机器上。借用官网一张图来详细介绍一下这种情况，假如kafka集群有两台broker，集群上有一个topic，它有4个partition，partition 0和1在broker1上，partition 2和3在broker2上，这时有两个consumer group同时订阅这个topic，其中一个group有2个consumer，另一个consumer有4个consumer，则它们的订阅消息情况如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/consumerGroup.png" alt="consumerGroup"></p>
<p>因为group A只有两个consumer，所以一个consumer会消费两个partition；而group B有4个consumer，一个consumer会去消费一个partition。这里要注意的是，kafka可以保证一个<strong>partition内的数据是有序的</strong>，所以group B中的consumer收到的数据是可以保证有序的，但是Group A中的consumer就无法保证了。</p>
<p>group读取topic，<strong>partition分配</strong>机制是：</p>
<ul>
<li>如果group中的consumer数小于topic中的partition数，那么group中的consumer就会消费多个partition；</li>
<li>如果group中的consumer数等于topic中的partition数，那么group中的一个consumer就会消费topic中的一个partition；</li>
<li>如果group中的consumer数大于topic中的partition数，那么group中就会有一部分的consumer处于空闲状态。</li>
</ul>
<h2 id="3-kafka的简单使用"><a href="#3-kafka的简单使用" class="headerlink" title="3.kafka的简单使用"></a>3.kafka的简单使用</h2><p>这部分是利用kafka自带的<code>kafka-console-producer.sh</code>和<code>kafka-console-consumer.sh</code>来发送和接收消息，而具体如何调用 kafka  API使用kafka会在后续的文章中介绍。</p>
<p>首先要启动kafka和建立topic，可参考<a href="http://wangzzu.github.io/2015/05/20/KafkaOrder/">Kafka常用的一些命令</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup bin/kafka-server-start.sh config/server.properties &amp; <span class="comment">#启动kafka，并且使用nohup将日志输出到当前目录的nohup.out中，使用&amp;后台运行</span></div></pre></td></tr></table></figure>
<p>topic还接着使用<code>wangzzu</code>（建立topic命令参考2.1中的图片），下面开启<code>kafka-console-producer.sh</code>并发送几条消息</p>
<p><img src="/images/2015-11-14-kafka-introduce/produce.png" alt="producer"></p>
<p>然后，启动<code>kafka-console-consumer.sh</code>就可以收到我们发送的这几条消息</p>
<p><img src="/images/2015-11-14-kafka-introduce/consumer.png" alt="consumer"></p>
<p>这个就是kafka的最简单的使用情况了。</p>
<p>希望这篇文章对初学者能有所帮助（<code>转载请注明出处</code>）。</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">Kafka官方文档</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka集群的安装与配置]]></title>
      <url>http://wangzzu.github.io/2015/11/13/kafka-install/</url>
      <content type="html"><![CDATA[<p>使用过kafka的童鞋应该都知道，kafka的安装是比较简单的，尤其跟hadoop，storm这类相比。本文就主要介绍kafka集群的安装和配置方法。</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>本人在安装kafka集群时，因为集群已经配置好了CDH的环境，在CDH环境安装kafka就变得非常简单。集群环境如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java版本</td>
<td>java 1.6.0_31</td>
</tr>
<tr>
<td>Linux版本</td>
<td>Centos 6.6</td>
</tr>
<tr>
<td>CDH版本</td>
<td>CDH 5.4.0</td>
</tr>
<tr>
<td>zookeeper版本</td>
<td>Zookeeper 3.4.5-cdh5.4.0</td>
</tr>
</tbody>
</table>
<h1 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h1><h2 id="下载相应kafka版本"><a href="#下载相应kafka版本" class="headerlink" title="下载相应kafka版本"></a>下载相应kafka版本</h2><p>这是kafka的<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="external">官网Download地址</a>，我们安装的kafka版本为<code>2.10-0.8.1.1</code>，就选择下载<code>kafka-0.8.1.1-src.tgz</code>.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个安装就是解压对应的压缩文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf kafka-0.8.1.1-src.tgz</div></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>这里的配置主要是<code>broker</code>的配置，修改<code>kafka-0.8.1.1-src/config/server.properties</code>文件，<a href="http://kafka.apache.org/08/configuration.html" target="_blank" rel="external">参数意义</a>,重要的设置参数，在下面的配置文件我们会加以说明：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></div><div class="line"><span class="comment"># contributor license agreements. See the NOTICE file distributed with</span></div><div class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></div><div class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></div><div class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></div><div class="line"><span class="comment"># the License. You may obtain a copy of the License at</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></div><div class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment"># See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment"># limitations under the License.</span></div><div class="line"><span class="comment"># see kafka.server.KafkaConfig for additional details and defaults</span></div><div class="line"></div><div class="line"><span class="comment">############################# Server Basics #############################</span></div><div class="line"></div><div class="line"><span class="comment"># The id of the broker. This must be set to a unique integer for each broker.</span></div><div class="line">broker.id=1    <span class="comment">#broker的标识，id为正数，kafka集群内不能重复，推荐用ip地址设置</span></div><div class="line"></div><div class="line"><span class="comment">############################# Socket Server Settings #############################</span></div><div class="line"></div><div class="line"><span class="comment"># The port the socket server listens on</span></div><div class="line">port=9092     <span class="comment">#侦听的相应端口，Producer或Consumer在此端口建立连接</span></div><div class="line"></div><div class="line"><span class="comment"># Hostname the broker will bind to. If not set, the server will bind to all interfaces</span></div><div class="line">host.name=192.168.80.1     <span class="comment">#指定broke绑定的网络接口地址</span></div><div class="line"></div><div class="line"><span class="comment"># Hostname the broker will advertise to producers and consumers. If not set, it uses the</span></div><div class="line"><span class="comment"># value for "host.name" if configured. Otherwise, it will use the value returned from</span></div><div class="line"><span class="comment"># java.net.InetAddress.getCanonicalHostName().</span></div><div class="line"><span class="comment">#advertised.host.name=&lt;hostname routable by clients&gt;</span></div><div class="line"></div><div class="line"><span class="comment"># The port to publish to ZooKeeper for clients to use. If this is not set,</span></div><div class="line"><span class="comment"># it will publish the same port that the broker binds to.</span></div><div class="line"><span class="comment">#advertised.port=&lt;port accessible by clients&gt;</span></div><div class="line"></div><div class="line"><span class="comment"># The number of threads handling network requests</span></div><div class="line">num.network.threads=2 <span class="comment">#处理网络请求的线程数</span></div><div class="line"></div><div class="line"><span class="comment"># The number of threads doing disk I/O</span></div><div class="line">num.io.threads=8 <span class="comment">#磁盘读写的线程数</span></div><div class="line"></div><div class="line"><span class="comment"># The send buffer (SO_SNDBUF) used by the socket server</span></div><div class="line">socket.send.buffer.bytes=1048576 <span class="comment">#节点端口使用的发送缓存大小</span></div><div class="line"></div><div class="line"><span class="comment"># The receive buffer (SO_RCVBUF) used by the socket server</span></div><div class="line">socket.receive.buffer.bytes=1048576 <span class="comment">#节点端口使用的接收缓存大小</span></div><div class="line"></div><div class="line"><span class="comment"># The maximum size of a request that the socket server will accept (protection against OOM)</span></div><div class="line">socket.request.max.bytes=104857600 <span class="comment">#节点端口能接收一个请求的最大大小</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">############################# Log Basics #############################</span></div><div class="line"></div><div class="line"><span class="comment"># A comma seperated list of directories under which to store log files</span></div><div class="line"></div><div class="line">log.dirs=/tmp/kafka-logs,/hdfs/data1/tmp/kafka-logs    <span class="comment">#日志文件保存的目录，一台broker上可以设置多个</span></div><div class="line"></div><div class="line"><span class="comment"># The default number of log partitions per topic. More partitions allow greater</span></div><div class="line"><span class="comment"># parallelism for consumption, but this will also result in more files across</span></div><div class="line"><span class="comment"># the brokers.</span></div><div class="line">num.partitions=2     <span class="comment">#此值越大将导致各个Server上同步时需要的延迟越高</span></div><div class="line"></div><div class="line"><span class="comment">############################# Log Flush Policy #############################</span></div><div class="line"></div><div class="line"><span class="comment"># Messages are immediately written to the filesystem but by default we only fsync() to sync</span></div><div class="line"><span class="comment"># the OS cache lazily. The following configurations control the flush of data to disk.</span></div><div class="line"><span class="comment"># There are a few important trade-offs here:</span></div><div class="line"><span class="comment"># 1. Durability: Unflushed data may be lost if you are not using replication.</span></div><div class="line"><span class="comment"># 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.</span></div><div class="line"><span class="comment"># 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to exceessive seeks.</span></div><div class="line"><span class="comment"># The settings below allow one to configure the flush policy to flush data after a period of time or</span></div><div class="line"><span class="comment"># every N messages (or both). This can be done globally and overridden on a per-topic basis.</span></div><div class="line"></div><div class="line"><span class="comment"># The number of messages to accept before forcing a flush of data to disk</span></div><div class="line"><span class="comment">#log.flush.interval.messages=10000     #partition的buffer中，message达到阈值时，将flush到磁盘</span></div><div class="line"></div><div class="line"><span class="comment"># The maximum amount of time a message can sit in a log before we force a flush</span></div><div class="line"><span class="comment">#log.flush.interval.ms=1000</span></div><div class="line"></div><div class="line"><span class="comment">############################# Log Retention Policy #############################</span></div><div class="line"></div><div class="line"><span class="comment"># The following configurations control the disposal of log segments. The policy can</span></div><div class="line"><span class="comment"># be set to delete segments after a period of time, or after a given size has accumulated.</span></div><div class="line"><span class="comment"># A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span></div><div class="line"><span class="comment"># from the end of the log.</span></div><div class="line"></div><div class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></div><div class="line">log.retention.hours=168 <span class="comment">#信息保存时间</span></div><div class="line"></div><div class="line"><span class="comment"># A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span></div><div class="line"><span class="comment"># segments don't drop below log.retention.bytes.</span></div><div class="line"><span class="comment">#log.retention.bytes=1073741824 #logs目录下保存信息的最大大小</span></div><div class="line"></div><div class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></div><div class="line">log.segment.bytes=536870912 <span class="comment">#保存的一个segment file的大小</span></div><div class="line"></div><div class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according</span></div><div class="line"><span class="comment"># to the retention policies</span></div><div class="line">log.retention.check.interval.ms=60000</div><div class="line"></div><div class="line"><span class="comment"># By default the log cleaner is disabled and the log retention policy will default to just delete segments after their retention expires.</span></div><div class="line"><span class="comment"># If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction.</span></div><div class="line">log.cleaner.enable=<span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">############################# Zookeeper #############################</span></div><div class="line"></div><div class="line"><span class="comment"># Zookeeper connection string (see zookeeper docs for details).</span></div><div class="line"><span class="comment"># This is a comma separated host:port pairs, each corresponding to a zk</span></div><div class="line"><span class="comment"># server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".</span></div><div class="line"><span class="comment"># You can also append an optional chroot string to the urls to specify the</span></div><div class="line"><span class="comment"># root directory for all kafka znodes.</span></div><div class="line">zookeeper.connect=192.168.80.1:2181,192.168.80.2:2181,192.168.80.3:2181     <span class="comment">#连接的zookeeper对应的IP和端口</span></div><div class="line"></div><div class="line"><span class="comment"># Timeout in ms for connecting to zookeeper</span></div><div class="line">zookeeper.connection.timeout.ms=1000000</div></pre></td></tr></table></figure>
<p>配置好以上信息之后，单个节点的kafka环境也就配置好了，同样的我们在其他节点也这样安装配置即可。</p>
<p>最后，再补充一点，经过我之前对kafka速度的测试，发现这上面<code>Socket Server Settings</code>下的几个参数对于速度的提升比较重要（<a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">brokerconfigs</a>），根据服务器的配置情况，可以适当增大一些参数，比如我用的集群可以设置为下面这样：</p>
<ul>
<li><code>num.network.threads</code>:20</li>
<li><code>num.io.threads</code>:8</li>
<li><code>socket.send.buffer.bytes</code>:1048576</li>
<li><code>socket.receive.buffer.bytes</code>:1073741824</li>
<li><code>socket.request.max.buytes</code>:1073741824</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[收藏的一些不错的网站]]></title>
      <url>http://wangzzu.github.io/2015/11/12/WebsiteCollect/</url>
      <content type="html"><![CDATA[<p>这篇主要是整理一下自己书签里收藏一些个人感觉不错的网站，它们大都是一些比较小众的网站，因为是技术出身，推荐的很大一部分网站可能都是偏技术类的，这点希望大家能够理解～。</p>
<h1 id="在线教育"><a href="#在线教育" class="headerlink" title="在线教育"></a>在线教育</h1><p>主要是推荐一些我自己用过的，感觉对自己比较有帮助的一些网站，当然免费是最好的了。</p>
<ul>
<li><a href="https://www.coursera.org/" target="_blank" rel="external">Coursera</a>，大名鼎鼎的 Coursera；</li>
<li><a href="https://www.shiyanlou.com/courses/" target="_blank" rel="external">实验楼</a>，这个感觉非常不错，尤其是学习一些技术的基础课程很nice；</li>
<li><a href="http://mooc.guokr.com/" target="_blank" rel="external">MOOC学院</a>，果壳的MOOC学院，课程种类和数量很多，对于想学习国外课程的童鞋来说，简直是福利啊；</li>
<li><a href="http://www.jikexueyuan.com/" target="_blank" rel="external">极客学院</a>，这种类型的网站就有很多了，比如：小象学院等，名气也比较大而且它们的模式基本上也一样，就不再推荐别的了；</li>
<li><a href="http://www.julyedu.com/" target="_blank" rel="external">七月算法</a>，July的公司，不说其它的，他的博客对于找工作还是很有帮助的；</li>
<li><a href="http://www.yiihuu.com/" target="_blank" rel="external">翼虎网</a>，一家关于做创意方面的教学网站；</li>
<li><a href="http://yun.lu/student/homepage" target="_blank" rel="external">云路-在线课堂</a>，目前关于看到课程主要是关于编程以及会计方面，有很大一部分是免费课程；</li>
</ul>
<h1 id="视频及节目"><a href="#视频及节目" class="headerlink" title="视频及节目"></a>视频及节目</h1><p>这些视频的内容比较广泛，应该会涉及到方方面面，都是些很不错的节目，看完也会给人很多的感触。</p>
<ul>
<li><a href="https://www.ted.com/" target="_blank" rel="external">TED</a>，这个大家应该都知道；</li>
<li><a href="http://yixi.tv/" target="_blank" rel="external">一席</a>，这个就是中国版的TED，也是在我看到了方励那个讲座之后才听说的；</li>
<li><a href="http://www.soku.com/search_video/q_%E6%99%93%E6%9D%BE%E5%A5%87%E8%B0%88?f=1&amp;kb=04126020kv41000__%E6%99%93%E6%9D%BE%E5%A5%87%E8%B0%AD&amp;_rp=1447420045800KOVWIn&amp;_rp=1447420045800KOVWIn" target="_blank" rel="external">晓松奇谈</a>，高晓松的一些节目（奇葩说）质量都挺不错，没事的时候可以看一下，也可以弄成音频跑步的时候听听；</li>
<li><a href="http://v.youku.com/v_show/id_XMTM4NDM1ODM3Ng==.html" target="_blank" rel="external">罗辑思维</a>，当然也有很多人并不推荐这个节目，说有些地方根本没有任何逻辑性，可是我个人感觉这个节目还是不错的，可能因为我读书比较少的原因，这个节目确实也弥补了我很多知识的空白；</li>
<li><a href="http://www.iqiyi.com/a_19rrhadzit.html" target="_blank" rel="external">奇葩说</a>，一个网上辩论节目，个人感觉很不错的一个节目，尤其是对于接受了国内那么多年应试教育的童鞋而言，对于一个问题它能让你看到不一样的视角，而不是只有一个正确答案；</li>
</ul>
<h1 id="技术网站"><a href="#技术网站" class="headerlink" title="技术网站"></a>技术网站</h1><p>这类网站都是互联网技术类方面的，内容比较多而且大都是偏基础性的资料，很多都是一些基础知识文档，对于不熟悉某方面但又希望去了解的人还是很不错的选择。</p>
<ul>
<li><a href="http://www.w3school.com.cn/" target="_blank" rel="external">w3school</a>，这个大都是前端方面的，很多技术文档，偏基础；</li>
<li><a href="http://www.runoob.com/" target="_blank" rel="external">菜鸟教程</a>，不仅仅涉及前端，大都也是些基础类的文档；</li>
<li><a href="http://www.yiibai.com/" target="_blank" rel="external">易百教程</a>，大都也是些基础类的文档；</li>
<li><a href="http://www.kancloud.cn/explore" target="_blank" rel="external">看云</a>，最近才发现网站，资料还挺多的，很多都是新型技术，这个网站相当于是把那些厚厚技术类书籍提炼一下，出了一本精简版的，对于我这种不喜欢看厚书的人来说简直是福利；</li>
<li><a href="http://lxw1234.com/" target="_blank" rel="external">lxw的大数据田地</a>，这个专门针对于大数据技术学习的网站；</li>
<li><a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>，这里面的文章质量还是蛮高的；</li>
<li><a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a>，很好的网站；</li>
<li><a href="http://wiki.jikexueyuan.com/#all-project" target="_blank" rel="external">极客学院的WIKI</a>，有很多的技术学习文档；</li>
<li><a href="http://www.slideshare.net/" target="_blank" rel="external">slideshare</a>，这个是的PPT分享的网站，主要是偏技术类，一般一些国际会议或者一些公司技术分享的PPT都会在这上面向大家分享；</li>
</ul>
<h2 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h2><p>一些公司或个人的博客：</p>
<ul>
<li><a href="http://dongxicheng.org/" target="_blank" rel="external">董的博客</a>，偏大数据这一块，业内挺出名的；</li>
<li><a href="http://colobu.com/archives/" target="_blank" rel="external">鸟窝</a>，这个博客的质量还不挺不错的；</li>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的网络日志</a>，很适合入门者，博客言简意骇；</li>
<li><a href="http://www.ibm.com/developerworks/cn/topics/" target="_blank" rel="external">IBM博客</a>，IBM的官方博客，质量很高，推荐；</li>
<li><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术团队博客</a>，涉及到了很多大数据方面的架构和设计;</li>
<li><a href="http://jm.taobao.org/" target="_blank" rel="external">阿里巴巴中间件博客</a>，有很多关于阿里消息中间件RocketMQ的一些内容，以及其它的一些分布式技术；</li>
<li><a href="https://code.facebook.com/" target="_blank" rel="external">Code Facebook</a>，里面有很多前沿的内容，不过需要 fq；</li>
<li><a href="http://mogu.io/" target="_blank" rel="external">蘑菇街的技术博客</a>，里面的文章比较接地气；</li>
<li><a href="https://engineering.linkedin.com/blog" target="_blank" rel="external">LinkedIn Blog</a>，LinkedIn 的一些博客；</li>
</ul>
<h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><ul>
<li><a href="http://www.clctrip.com/" target="_blank" rel="external">草履虫旅行</a>，这个俱乐部，每周都会有一些短途的旅行，假期会有远途旅行，不过这个活动出发地仅仅局限在北京，其他城市还没有涉足，真心很赞的一个俱乐部；</li>
<li><a href="http://www.yerenbang.org/forum.php" target="_blank" rel="external">野人帮</a>，这个主要是对准户外过夜那种，比较有挑战性；</li>
<li><a href="http://www.iqingyi.com/" target="_blank" rel="external">青驿</a>，看别人推荐，还没有用过，感觉还不错。</li>
</ul>
<h1 id="媒体内容类"><a href="#媒体内容类" class="headerlink" title="媒体内容类"></a>媒体内容类</h1><ul>
<li><a href="http://36kr.com/" target="_blank" rel="external">36氪</a>，第一个肯定要推荐36氪，毕竟创始人是我们校友，主要是一些关于互联网圈内发生的一些事情，也经常会介绍一些国内外新兴的互联网创业公司；</li>
<li><a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a>，可以使用Markdown写文章，大家通过文章来交流一些想法；</li>
<li><a href="http://dataunion.org/" target="_blank" rel="external">数盟</a>，暂时把它归于媒体类吧，偏程序员的媒体网站。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>一些挺有用的小网站</p>
<ul>
<li><a href="http://www.zimuku.net/" target="_blank" rel="external">字幕库</a>，美剧迷的福利；</li>
<li><a href="http://www.haitou.cc/" target="_blank" rel="external">海投网</a>，可查看高校工作宣讲会；</li>
<li><a href="https://www.zybuluo.com/" target="_blank" rel="external">作业部落</a>，Markdown的在线编辑器；</li>
<li><a href="https://selfstore.io/" target="_blank" rel="external">selfstore</a>，专门由专业人士翻译国外技术书籍，然后买电子书的网站，当然，它们的翻译质量确实比某些出版社高太多了；</li>
<li><a href="http://www.meetup.com/" target="_blank" rel="external">Meetup</a>，通过Meetup可以组织一些专业的线下活动，像Spark这种线下技术分享活动都会在这上面发布；</li>
</ul>
<blockquote>
<p>注：本文为会一直保持更新，只要遇到一些比较优秀的网站，都会更新到这篇博客上。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java的几个基本类型之间的相互转换]]></title>
      <url>http://wangzzu.github.io/2015/10/27/TheTransformOfJava/</url>
      <content type="html"><![CDATA[<p>之前在写java程序的时候，经常会遇到很多的需要需要转换基础数据类型的情况，然后我就一直去记录这些情况，今天做了一下总结，当然转换的方法肯定不止我写的这些，有的我可能只会写其中的一种，以后再遇到其他的情况的话，我会慢慢来补充，希望这篇文章会对大家能有所帮助。</p>
<hr>
<h1 id="String的转换"><a href="#String的转换" class="headerlink" title="String的转换"></a>String的转换</h1><p>首先介绍一下String类型的转换，一般遇到的情况可能会有以下几种：Strng转int，String转long，String转byte数组，String转float，下面主要介绍这四种情况。</p>
<h2 id="String转int"><a href="#String转int" class="headerlink" title="String转int"></a>String转int</h2><p>把String类型转换为int类型，常用的有以下三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInt</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String number = <span class="string">"123456"</span>;</div><div class="line">		<span class="keyword">int</span> num1 = Integer.parseInt(number);<span class="comment">//使用Integer的parseInt方法</span></div><div class="line">		<span class="keyword">int</span> num2 = <span class="keyword">new</span> Integer(number);<span class="comment">//强制转换</span></div><div class="line">		<span class="keyword">int</span> num3 = Integer.valueOf(number).intValue();<span class="comment">//先转Integer类型，再调用intValue()转为int</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="String转long"><a href="#String转long" class="headerlink" title="String转long"></a>String转long</h2><p>把String类型转换为long类型的方法跟上面的方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToLong</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String number = <span class="string">"1234567890"</span>;</div><div class="line">		<span class="keyword">long</span> num1 = Long.parseLong(number);<span class="comment">//调用Long类型的parseLong方法</span></div><div class="line">		<span class="keyword">long</span> num2 = <span class="keyword">new</span> Long(number);<span class="comment">//强制转换</span></div><div class="line">		<span class="keyword">long</span> num3 = Long.valueOf(number).longValue();<span class="comment">//先转换Long类型，再使用longValue方法转为long</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="String转float"><a href="#String转float" class="headerlink" title="String转float"></a>String转float</h2><p>把String类型转换为float类型的方法也跟上面的类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToFloat</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String number = <span class="string">"1234.202"</span>;</div><div class="line">		<span class="keyword">float</span> num1 = Float.parseFloat(number);<span class="comment">//调用Float的parseFloat方法</span></div><div class="line">		<span class="keyword">float</span> num2 = <span class="keyword">new</span> Float(number);<span class="comment">//强制转换</span></div><div class="line">		<span class="keyword">float</span> num3 = Float.valueOf(number).floatValue();<span class="comment">//先转为Float类型再使用floatValue转为float</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="String转byte"><a href="#String转byte" class="headerlink" title="String转byte[]"></a>String转byte[]</h2><p>String类型转byte数组方法一般使用String类自带的<code>getBytes()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToByte</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] num = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">200</span>];</div><div class="line">		String number = <span class="string">"1234567890"</span>;</div><div class="line">		num = number.getBytes();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里补充一个path类型转换为String类型的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String fileName=path.getFileName().toString();</div></pre></td></tr></table></figure>
<hr>
<h1 id="long类型转换"><a href="#long类型转换" class="headerlink" title="long类型转换"></a>long类型转换</h1><p>long类型的转换，这一部分用的情况也很多，下面介绍几种常见的情况。</p>
<h2 id="long转String"><a href="#long转String" class="headerlink" title="long转String"></a>long转String</h2><p>long类型转String类型，这里主要介绍三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToString</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">long</span> number = <span class="number">1234567890l</span>;</div><div class="line">		String num1 = Long.toString(number);<span class="comment">//Long的tostring方法</span></div><div class="line">		String num2 = String.valueOf(number);<span class="comment">//使用String的valueOf方法</span></div><div class="line">		String num3 = <span class="string">""</span> + number;<span class="comment">//这个应该属于强制转换吧</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="long转int"><a href="#long转int" class="headerlink" title="long转int"></a>long转int</h2><p>long类型转换为int类型，这里也主要介绍三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToInt</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">long</span> number = <span class="number">121121121l</span>;</div><div class="line">		<span class="keyword">int</span> num1 = (<span class="keyword">int</span>) number;<span class="comment">// 强制类型转换</span></div><div class="line">		<span class="keyword">int</span> num2 = <span class="keyword">new</span> Long(number).intValue();<span class="comment">// 调用intValue方法</span></div><div class="line">		<span class="keyword">int</span> num3 = Integer.parseInt(String.valueOf(number));<span class="comment">// 先把long转换位字符串String，然后转换为Integer</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="long与byte数组的相互转换"><a href="#long与byte数组的相互转换" class="headerlink" title="long与byte数组的相互转换"></a>long与byte数组的相互转换</h2><p>一直都感觉byte数组转换比较繁琐，这里也不再叙述，我就给出一篇别人的博客让大家作为参考吧，这里面byte数组与多种数据类型的转换——<a href="http://blog.csdn.net/cshichao/article/details/9813973" target="_blank" rel="external"> java Byte和各数据类型(short,int,long,float,double)之间的转换</a></p>
<hr>
<h1 id="int类型的转换"><a href="#int类型的转换" class="headerlink" title="int类型的转换"></a>int类型的转换</h1><p>int类型的转换也是我们经常使用的情况，下面也主要介绍几种常见的情况。</p>
<h2 id="int转String"><a href="#int转String" class="headerlink" title="int转String"></a>int转String</h2><p>int类型转换为String类型与long转String的类似，一般也有以下三种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToString</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> number = <span class="number">121121</span>;</div><div class="line">		String num1 = Integer.toString(number);<span class="comment">//使用Integer的toString方法</span></div><div class="line">		String num2 = String.valueOf(number);<span class="comment">//使用String的valueOf方法</span></div><div class="line">		String num3 = <span class="string">""</span> + number;<span class="comment">//也是强制转换吧</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="int与Byte的相互转换"><a href="#int与Byte的相互转换" class="headerlink" title="int与Byte的相互转换"></a>int与Byte的相互转换</h2><p>关于int类型与byte[]数组的转换，一般情况下，我们使用条件都是在这里转换过来，在另外一个地方就要转换回来，这里介绍两种int与byte数组互相转换的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//int类型转换为byte[]数组</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByteArray(<span class="keyword">int</span> i) &#123;</div><div class="line">	<span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">	<span class="comment">// 由高位到低位</span></div><div class="line">	result[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">	result[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">	result[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</div><div class="line">	result[<span class="number">3</span>] = (<span class="keyword">byte</span>) (i &amp; <span class="number">0xFF</span>);</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//byte数组转换为int类型</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteArrayToInt</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">	<span class="comment">// 由高位到低位</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">		<span class="keyword">int</span> shift = (<span class="number">4</span> - <span class="number">1</span> - i) * <span class="number">8</span>;</div><div class="line">		value += (bytes[i] &amp; <span class="number">0x000000FF</span>) &lt;&lt; shift;<span class="comment">// 往高位游</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//int类型转换为byte[]数组</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByteArray(<span class="keyword">int</span> x) &#123;</div><div class="line">	<span class="keyword">byte</span>[] bb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">	bb[<span class="number">3</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">24</span>);</div><div class="line">	bb[<span class="number">2</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">16</span>);</div><div class="line">	bb[<span class="number">1</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">8</span>);</div><div class="line">	bb[<span class="number">0</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> bb;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//byte数组转换为int类型</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteArrayToInt</span><span class="params">(<span class="keyword">byte</span>[] bb)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) ((((bb[<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) | ((bb[<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) | ((bb[<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) | ((bb[<span class="number">0</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">0</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="int转long"><a href="#int转long" class="headerlink" title="int转long"></a>int转long</h2><p>int类型转换为long类型的情况并不是大多，这里主要接收几种转换方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToLong</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> number = <span class="number">123111</span>;</div><div class="line">		<span class="keyword">long</span> num1 = (<span class="keyword">long</span>) number;<span class="comment">//强制</span></div><div class="line">		<span class="keyword">long</span> num2 = Long.parseLong(<span class="keyword">new</span> Integer(number).toString());<span class="comment">//先转String再进行转换</span></div><div class="line">		<span class="keyword">long</span> num3 = Long.valueOf(number);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="int转Interger"><a href="#int转Interger" class="headerlink" title="int转Interger"></a>int转Interger</h2><p>int类型转换为Interger类型的情况，我是基本上每怎么遇到过，在这里也上网查询一些资料找到了两种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToInterge</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> number = <span class="number">123456</span>;</div><div class="line">		Integer num1 = Integer.valueOf(number);</div><div class="line">		Integer num2 = <span class="keyword">new</span> Integer(number);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="byte数组的转换"><a href="#byte数组的转换" class="headerlink" title="byte数组的转换"></a>byte数组的转换</h1><p>关于byte数组的转换，上面有几个都是它们只见相互转换的，所以这里就不再介绍那么多，只介绍一个byte数组转换String类型的方法，其他的类型可以通过String类型再进行转换。</p>
<p>byte数组转String类型的方法经常用的可能就是下面这种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToString</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] number = <span class="string">"121121"</span>.getBytes();</div><div class="line">		String num1 = <span class="keyword">new</span> String(number);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>最后简单补充以下Java基本数据类型的一些知识：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>类名称</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>4字节</td>
<td>Interger</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>Short</td>
<td>-32768 ～ 32767</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>Long</td>
<td>-9223372036854775808 ～ 9223372036854775807</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>Byte</td>
<td>-128 ～ 127</td>
</tr>
<tr>
<td>float</td>
<td>4字节</td>
<td>Float</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>Double</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java关键字之final和static]]></title>
      <url>http://wangzzu.github.io/2015/10/17/The-keyword-of-java/</url>
      <content type="html"><![CDATA[<p>本篇文章主要对java中经常使用<code>final</code>和<code>static</code>两个关键字的用法做一下总结，主要参考了《Java编程思想》和网上的一些博客。</p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final应该是程序中经常使用的关键字之一，final关键字使用的对象是：类、方法、变量，下面依次介绍这几种使用final的情况。</p>
<h2 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h2><p>当一个类声明为final类，也就证明这个类是不能够被继承的，即禁止继承，因此final类的成员方法是没有机会被覆盖的，这个final类的功能是完整的。在Java中有很多类是final的，如String、Interger以及其他包装类。</p>
<p>final类的好处：</p>
<ul>
<li>不可变类有很多的好处，它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的开销。</li>
</ul>
<p>下面是final类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span></span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span></span>&#123; <span class="comment">//compilation error: cannot inherit from final class</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h2><p>如果一个类不允许其子类覆盖某个方法，即不能被重写，则可以把这个方法声明为final方法。（类中所有的private方法都隐式的指定为final）。</p>
<p>使用final方法的原因：</p>
<ul>
<li>方法锁定，防止任何继承类修改它的含义，确保在继承中使方法行为保持不变且不被覆盖；</li>
<li>效率，将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转化为内嵌调用（相当于在编译的时候已经静态绑定，不需要在运行时再动态绑定）。</li>
</ul>
<p>下面是final方法的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"f1"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//final方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"f2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;     </div><div class="line">        System.out.println(<span class="string">"Test1父类方法f1被覆盖!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Test2 t=<span class="keyword">new</span> Test2();</div><div class="line">        t.f1(); <span class="comment">//子类重写父类的方法</span></div><div class="line">        t.f2(); <span class="comment">//调用从父类继承过来的final方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h2><p>程序中有些数据的恒定不变是很有必要的，比如：</p>
<ul>
<li>一个永不改变的<strong>编译时常量</strong>；</li>
<li>一个在运行时被初始化的值，而在程序的后面不希望它被改变。</li>
</ul>
<p>这种类型的变量只能被赋值一次，一旦被赋值之后，就不能够再更改了。</p>
<p>有几点要注意的：</p>
<ul>
<li>一个既是static又是final的域只占据一段不能改变的存储空间，一般用大写来表示；</li>
<li>final使数值恒定不变，而当用于对象时，final使引用恒定不变（一旦引用指向一个对象，就无法再把它改为指向另一个对象）；</li>
</ul>
<p>final变量的好处：</p>
<ul>
<li>提高性能，JVM和Java应用程序都会缓存final变量；</li>
<li>final变量可以在安全的在多线程环境下进行共享，而不需要额外的开销。</li>
</ul>
<p>下面是final类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PI = <span class="number">3.14</span>;<span class="comment">//这个变量是只读的</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT; <span class="comment">//final空白,必须在初始化对象的时候赋初值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        INIT = x;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Test t = <span class="keyword">new</span> Test(<span class="number">2</span>);</div><div class="line">        <span class="comment">//t.PI=3.1415;//出错,final变量的值一旦给定就无法改变</span></div><div class="line">        System.out.println(t.INIT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>final数据还有另外三个比较特殊的情况：与static合用，空白final和final参数。</p>
<h3 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h3><p>一个既是static又是final的域只占据一段不能改变的存储空间:</p>
<ul>
<li>对于变量，它表示一旦给定就不可更改，并且可以通过类名直接访问（使用大写和下划线命名）；</li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。</li>
</ul>
<h3 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h3><p>从上面的例子中，我们就可以看到<code>空白final</code>的使用方法，它指的是：被声明为final但又未给出初值的域。无论什么情况下，编译器都确保空白final在使用前必须被初始化（在域的定义处或每个构造器中用表达式对final赋值）。</p>
<h3 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h3><p>Java时允许在参数列表的声明中以声明的方式将参数指明为final。</p>
<ul>
<li>当对象被指明为final时，这就意味着我们无法在方法中更改参数引用所指向的对象。</li>
<li>当基本类型的参数被指明为final时，我们可以读取参数但是无法修改参数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下final关键字的一些重要特点：</p>
<ol>
<li>本地变量必须在声明的时候赋值；</li>
<li>在匿名类中所有变量都必须是final变量；</li>
<li>final方法不能被重写；</li>
<li>final类不能被继承；</li>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误；</li>
<li>接口中声明的所有变量本身是final的；</li>
<li>final方法在编译阶段绑定，称为<strong>静态绑定</strong>(static binding)；</li>
<li><strong>对于集合对象声明为final指的是引用不能被更改</strong>，但是你可以向其中增加，删除或者改变内容；</li>
</ol>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>通常来说，当我们创建类时，就是在描述那个类的外观与行为。除非使用<code>new</code>创建那个类的对象，否则并为获得任何对象。执行<code>new</code>来创建对象时，数据存储空间才被分配，其方法才能被外界调用。</p>
<p>但是，试想在一种情况下，我们只想为某一特定区域分配单一存储空间，而不用去考虑它创建了多少对象。另一种情形是，希望某个方法不与包含它的类的任何对象联系在一起，也就是说，即使没有创建对象，也能够调用这个方法。这就是<code>static</code>关键字主要使用的地方。</p>
<p>static一个很重要的用途就是多个对象可以共享一些存储空间，static关键字使用的对象为：类、方法、代码块。</p>
<p>static关键字有几个需要注意的地方：</p>
<ul>
<li>被static修饰的成员变量和成员方法<strong>独立</strong>于该类的任何对象，它不依赖类的特定实例，被类的所有实例共享；</li>
<li>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例<strong>共享</strong>同一个static变量；</li>
<li>static变量前可以有private修饰，这时就不能使用类名直接访问流。</li>
</ul>
<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：</p>
<ul>
<li>ClassName.Varibale</li>
<li>ClassName.method()</li>
</ul>
<h2 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h2><p>按照是否静态的对类成员变量进行分类可分两种：</p>
<ul>
<li>一种是被static修饰的变量，叫<strong>静态变量</strong>或<strong>类变量</strong>；</li>
<li>另一种是没有被static修饰的变量，叫<strong>实例变量</strong>。</li>
</ul>
<p>两者的区别是：</p>
<ul>
<li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问；</li>
<li>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<p>一般在在对象之间使用共享值和方便访问变量时，就会去使用静态变量。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.j=j;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Test.i="</span> + Test.i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p><strong>静态方法</strong>也叫做<strong>类方法</strong>，静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用<code>this</code>和<code>super</code>关键字，不能直接访问所属类的实例变量和实例方法（因为它们是与具体方法关联的），只能访问所属类的静态成员变量和成员方法。</p>
<p>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>Java中很多使用static的方法，如Math类中所有的方法都是静态的，而一般类内部的static方法也是方便其它类对该方法的调用。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = Test.sum(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"10+10="</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        i = <span class="number">10</span>;</div><div class="line">        System.out.println(<span class="string">"Now in static block."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"test method: i="</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Test.i="</span> + Test.i);</div><div class="line">        <span class="keyword">new</span> Test().test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>下面是关于静态变量和静态方法的一些总结：</p>
<ul>
<li>一个类的静态方法只能访问其静态变量；</li>
<li>一个类的静态方法不能够直接调用非静态方法；</li>
<li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>静态方法不能被非静态方法覆盖；</li>
<li>构造方法不允许声明为 static 的；</li>
<li>局部变量不能使用static修饰。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven之仓库配置]]></title>
      <url>http://wangzzu.github.io/2015/10/14/the-setting-of-repertory-maven/</url>
      <content type="html"><![CDATA[<p>徐晓斌的《Maven实战》，实在是一本很不错的书，本文也是在我读过这本书的仓库一章后，根据自己的经验，做的一个总结。</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>先介绍一个构件和仓库的概念。</p>
<p>构件：在Maven中，任何一个依赖、插件或者项目构建的输出，都是一个构件。如：依赖包是一个构件、编译的插件是一个构件；</p>
<p>仓库：Maven在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p>
<h1 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h1><p>对于Maven来说，仓库只有两种：本地仓库和远程仓库。但是还有一类特殊的远程仓库——私服，它是在局域网内架设的私有仓库服务器。</p>
<p><img src="/images/2015-10-14-theSettingOfRepertoryOfMaven/repertory.jpg" alt="Repertory"></p>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认情况下，不管在window还是在Linux系统上，每一个用户在自己用户目录下都有一个<code>.m2/repository/</code>的仓库目录。</p>
<p>当然，Maven是允许我们自定义本地仓库目录地址的，在Maven的安装目录的<code>conf</code>下找到<code>settings.xml</code>文件，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/home/matt/maven/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样本地仓库就被设置在<code>/home/matt/maven/repo</code>下。</p>
<p>关于<code>settings.xml</code>文件，有一点需要注意的是：</p>
<ul>
<li><code>$M2_HOME/conf/settings.xml</code>：是全局范围的，整台机器上的所有用户都会直接受到该配置的影响；</li>
<li><code>~/.m2/settings.xml</code>：是用户范围的，只有当前用户才会受到该配置的影响（若目录下没有此文件，可将上个<code>settings.xml</code>复制一份到本目录下再去修改）。</li>
</ul>
<h3 id="本地项目安装到本地仓库"><a href="#本地项目安装到本地仓库" class="headerlink" title="本地项目安装到本地仓库"></a>本地项目安装到本地仓库</h3><p>在这个本地项目下，执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clwan install</div></pre></td></tr></table></figure>
<p>Install插件的install目标就是将项目的构建输出文件安装到本地仓库。</p>
<h2 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h2><p>最原始的本地仓库是空的，Maven的安装文件中自带了中央仓库的配置。在Maven的安装目录下的<code>/lib/maven-model-builder-XX.jar</code>的jar包中的<code>pom-4.0.0.xml</code>中有如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置了默认的中央仓库，所有的Maven项目都会继承这个POM，所以都会有这个配置。该中央仓库包含了世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证等。上面的<code>snapshots</code>元素的子元素<code>enabled</code>设置为<code>false</code>，表示不会从该中央仓库下载快照版本的构件。</p>
<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><p>私服是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网用户使用。当Maven需要下载构件的时候，他从私服请求，如果私服不存在当前构件，则从外部的远程仓库缓存到私服上之后再为Maven的下载请求提供服务，此外一些无法从外部仓库下载到的构件也可以手工上传到私服上供大家使用。</p>
<p>它主要有以下几个优点：</p>
<ul>
<li>节省外网带宽；</li>
<li>加速Maven构建；</li>
<li>部署第三方构件（尤其是组织内部的构件）；</li>
<li>提高稳定性，增强控制；</li>
<li>降低中央仓库的负荷。</li>
</ul>
<h1 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h1><h2 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h2><p>很多情况下，默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另外一个远程仓库，可以在<code>POM</code>进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">releases</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure>
<p>关于配置远程仓库，主要有以下几点需要注意：</p>
<ul>
<li>任何仓库的<code>id</code>必须唯一；</li>
<li>在<code>repositories</code>元素下，可以使用<code>repository</code>子元素声明一个或者多个远程仓库；</li>
<li>元素<code>releases</code>和<code>snapshots</code>用来控制Maven对于发布版本构件和快照版构件的下载。</li>
</ul>
<p>对于元素<code>releases</code>和<code>snapshots</code>，除了<code>enabled</code>子元素外，它们还包括另外两个子元素<code>updatePolicy</code>和<code>checksumPolicy</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>updatePolicy</code>:配置Maven从远程仓库检查更新的频率，默认值是<code>daily</code>（<code>never</code>：从不检查、<code>always</code>：每次构建时都检查、<code>interval：X</code>：每隔X分钟检查一次）；</li>
<li><code>checksumPolicy</code>：配置Maven检验和文件的策略，默认值为<code>warn</code>：在执行构建时输出警告信息（<code>ignore</code>：完全忽略校验和错误，<code>fail</code>：遇到校验和错误就让构建失败）。</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>有些远程仓库基于安全的考虑需要提供认证信息才可以访问。配置认证信息需要在<code>settings.xml</code>文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>deploymentRepo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>repouser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>repopwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Maven使用<code>settings.xml</code>文件中并不显而易见的<code>server</code>子元素配置仓库认证信息。</p>
<p>配置认证信息和配置仓库信息不同，仓库信息可以这配置在<code>POM</code>文件中，但是认证信息必须配置在<code>settings.xml</code>文件中。、</p>
<h2 id="部署到远程仓库"><a href="#部署到远程仓库" class="headerlink" title="部署到远程仓库"></a>部署到远程仓库</h2><p>Maven除了对项目进行编译，测试和打包之外，还能将项目部署到仓库中，首先编辑POM文件添加<code>distributionManagementy</code>元素。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Releases Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Snapshots Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>distributionManagement</code>包含<code>repository</code>和<code>snapshotRepository</code>子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。这两个元素下都需要配置<code>id</code>、<code>name</code>和<code>url</code>，<code>id</code>为该仓库的唯一标识，<code>name</code>是为了方便人阅读，关键的<code>url</code>表示该仓库的地址。</p>
<p>配置正确后，执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean deploy</div></pre></td></tr></table></figure>
<p>Maven就会将构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本仓库地址，否则就部署到发布版本仓库地址。</p>
<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的镜像。配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirrorId<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>repositoryId<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://my.repository.com/repo/path<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>&lt;mirrorOf&gt; central&lt;/mirrorOf&gt;</code>表示只为central仓库做镜像，如果想为所有的仓库做镜像那么可以改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>mirrorOf</code>可选择的配置主要有以下几个：</p>
<ul>
<li><strong>*</strong>：配置所有的仓库；</li>
<li><strong>external*</strong>：匹配所有的远程仓库，使用localhost的除外，使用<code>file：//</code>的除外；</li>
<li><strong>repo1,repo2</strong>：匹配仓库repo1和repo2，使用逗号分隔多个仓库；</li>
<li><strong>*,!repo1</strong>：匹配所有的远程仓库除了repo1.</li>
</ul>
<h1 id="仓库的内部机制"><a href="#仓库的内部机制" class="headerlink" title="仓库的内部机制"></a>仓库的内部机制</h1><p>这一部分主要介绍一下Maven仓库的三个内部机制，一个仓库的布局方式，两个是仓库的解析机制和更新策略。</p>
<h2 id="仓库的布局方式"><a href="#仓库的布局方式" class="headerlink" title="仓库的布局方式"></a>仓库的布局方式</h2><p>任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven仓库布局方式。例如，<code>log4j:log4j:1.2.15</code>这一依赖，其对应的仓库路径为<code>log4j/log4j/1.2.15/log4j-1.2.15.jar</code>。该路径与坐标的大致对应关系为<code>groupId/artifactId/version/artifactId-version.packaging</code>。</p>
<p>具体的可以参看Maven参考布局的源码部分，也可以参考<a href="http://www.amazon.cn/Maven%E5%AE%9E%E6%88%98-%E8%AE%B8%E6%99%93%E6%96%8C/dp/B004CLZ7BA/ref=sr_1_1?ie=UTF8&amp;qid=1444818561&amp;sr=8-1&amp;keywords=maven%E5%AE%9E%E6%88%98" target="_blank" rel="external">《Maven实战》</a>P76-77。</p>
<h2 id="仓库解析依赖机制"><a href="#仓库解析依赖机制" class="headerlink" title="仓库解析依赖机制"></a>仓库解析依赖机制</h2><p>Maven是根据怎么的跪着从仓库解析并使用依赖构件的呢？</p>
<p>当本地仓库没有依赖构件的时候，Maven会自动从远程仓库下载相应构件，当依赖版本为快照版本的时候，Maven会自动找到最新的快照。详细的依赖机制为：</p>
<ol>
<li>当依赖的范围是<code>system</code>的时候，Maven直接从本地文件系统解析构件；</li>
<li>根据依赖坐标计算仓库路径后，尝试直接从本地仓库寻找构件，如果发现相应构件，则解析成功;</li>
<li>在本地仓库不存在相应构件的情况下，如果依赖的版本是显式的发布版本构件，如：1.2，2.1等，则遍历所有的远程仓库，发现后，下载并解析使用;</li>
<li>如果依赖的版本是<code>RELEASE</code>或者<code>LATEST</code>，则基于更新策略读取所有远程仓库的元数据<code>groupId/artifactId/mavenmetadata.xml</code>，将其与本地仓库的对应元数据合并后，计算出<code>RELEASE</code>或者<code>LATEST</code>真实的值，然后基于这个真实的值检查本地和远程仓库，如步骤1和3;</li>
<li>如果依赖的版本是<code>SNAPSHOT</code>，则基于更新策略读取所有远程仓库的元数据<code>groupId/artifactId/version/mavenmetadata.xml</code>，将其与本地仓库的对应元数据合并后，得到最新快照版本的值，然后基于该值检查本地仓库，或者从远程仓库下载;</li>
<li>.如果最后解析得到的构件版本是时间戳格式的快照，如：<code>1.4-20091104.121450-121</code>,则复制其时间戳格式的文件到非时间戳格式，如：<code>SNAPSHOT</code>，并使用该非时间戳格式的构件.</li>
</ol>
<p>当依赖的版本不明晰的时候，如:<code>RELEASE</code>,<code>LATEST</code>和<code>SNAPSHOT</code>，Maven就需要基于更新远程仓库的更新策略来检查更新。</p>
<h2 id="仓库的更新策略"><a href="#仓库的更新策略" class="headerlink" title="仓库的更新策略"></a>仓库的更新策略</h2><p>主要有以下几个配置与Maven仓库的更新有关：</p>
<ul>
<li>首先是<code>&lt;releases&gt;&lt;enabled&gt;</code>和<code>&lt;snapshots&gt;&lt;enabled&gt;</code>，只有仓库开启了对于发布版本的支持时，才能访问该仓库的发布版本构件信息，对于快照版本也是同理；</li>
<li>其次要注意的是<br><code>&lt;releases&gt;</code>和<code>&lt;snapshots&gt;</code>的子元素<code>&lt;updatePolicy&gt;</code>，该元素配置了检查更新的频率;</li>
<li>最后，用户还可以从命令行加入参数<code>-U</code>,强制检查更新，使用参数后，Maven就会忽略<code>&lt;updatePolicy&gt;</code>的配置。</li>
</ul>
<p>当Maven检查完更新策略，并决定检查依赖更新的时候，就需要检查仓库元数据<code>maven-metadata.xml</code>。前面提到的<code>RELEASE</code>和<code>LATEST</code>版本，它们分别对应了仓库中存在的该构件的最新发布版本和最新版本(包含快照)，而这两个”最新”是基于<code>groupId/artifactId/maven-metadata.xml</code>计算出来的，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">latest</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">latest</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">release</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">release</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">versions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在XML文件列出了仓库中存在的该构件所有可用的版本，同时<code>latest</code>元素指向了这些版本中最新的那个版本。而<code>release</code>元素指向了这些版本中最新的发布版本。Maven通过合并多个远程仓库及本地仓库的元数据，就能计算出基于所有仓库的<code>latest</code>和<code>release</code>分别是什么，然后再解析具体的构件。</p>
<p> 有几点需要的注意的：</p>
<ul>
<li>在依赖声明中使用LATEST和RELEASE是<strong>不推荐</strong>的做法（因为Maven随时都可能解析到不同的构件，可能今天<code>LATEST</code>是<code>1.3.6</code>,明天就成了<code>1.4.0-SNAPSHOT</code>了，且Maven不会明确告诉用户这样的变化）；</li>
<li>Maven3不再支持在插件配置中使用<code>LATEST</code>和<code>RELEASE</code>；</li>
<li>如果不设置插件版本，其效果就和RELEASE一样，Maven只会解析最新的发布版本构件；</li>
</ul>
<p>当依赖的版本设为<strong>快照版本</strong>的时候，Maven也需要检查更新，这时，Maven会检查仓库元数据<code>groupId/artifactId/version/maven-metadata.xml</code>，这个与发布版本的有所不同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20091214.221414<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>13<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20091214221558<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></div></pre></td></tr></table></figure>
<p>该xml文件的<code>snapshot</code>元素包含<code>timestamp</code>和<code>buildNumber</code>两个子元素，分别代表了这一快照的时间戳和构建号，基于这两个元素可以得到该仓库中此快照的最新构件版本实际为<code>1.4.2-20091213.221414-13</code>。通过合并所有远程仓库和本地仓库的元数据，Maven就能知道所有仓库中该构件的最新快照。</p>
<h1 id="快照版本"><a href="#快照版本" class="headerlink" title="快照版本"></a>快照版本</h1><p>在Maven的世界中，任何一个项目或者构件都必须有自己的版本。版本的值可能是<code>1.0.0,1.3-alpha-4</code>,<code>2.0</code>,<code>2.1-SNAPSHOT</code>或者<code>2.1-20091214.221414-13</code>。其中，<code>1.0</code>、<code>1.3-alpha-4</code>和<code>2.0</code>是稳定的发布版本，而<code>2.1-SNAPSHOT</code>和<code>2.1-20091214.221414-13</code>是不稳定的快照版本。</p>
<p>快照版本对于Maven来说是很重要的，下面举个例子来说明。小张在开发模块A的2.1版本，该版本还未正式发布，与模块A一同开发的还有模块B，它由小张的同事季MM开发，B的功能依赖于A。在开发的过程中，小张需要经常将自己最新的构建输出，交给季MM，供她开发和集成调试，问题是，这个工作如何进行呢？如果不停更新版本2.1.1、2.1.2、2.1.3….呢？首先，小张和季MM两人都需要频繁地更改POM，如果有更多的模块依赖于模块A，就会涉及更多的POM更改；其次，大量的版本其实仅仅包含了微小的差异，这样也会造成为版本号的滥用。</p>
<p>Maven的快照版本机制就是为了解决上述问题。在该例中，小张只需要将模块A的版本设定为<code>2.1-SNAPSHOT</code>，然后发布到私服中，在发布的过程中，Maven会自动为构件打上时间戳。比如:<code>2.1-20091214.221414-13</code>就表示2009年12月14日 22点14分14秒的第13次快照。有了该时间戳，Maven就能随时找到仓库中该构件<code>2.1-SNAPSHOT</code>版本最新的文件。这时，季MM配置对于模块A的<code>2.1-SNAPSHOT</code>版本的依赖，当她构件模块B的时候，Maven会自动从仓库中检查模块A的<code>2.1-SNAPSHOT</code>的最新构件，当发现有更新时便进行下载。默认情况下，Maven每天检查一次更新(由仓库配置的<code>updatePolicy</code>控制)，用户也可以使用命令行-U参数强制让Maven检查更新，如：<code>mvn clean install-U</code>。</p>
<p>基于快照版本机制，小张在构建成功之后才能将构件部署至仓库，而季MM可以完全不用考虑模块A的构建，并且她能确保随时得到模块A的最新可用的快照构件，而这一切都不需要额外的手工操作。</p>
<p>最后要注意的是，快照版本一般只在组织内部的项目或模块间依赖使用，而且项目不应该依赖于组织外部的快照版本依赖（因为快照版本是不稳定的）。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10476794.html" target="_blank" rel="external">Maven实战</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven之依赖]]></title>
      <url>http://wangzzu.github.io/2015/10/11/the-dependency-of-maven/</url>
      <content type="html"><![CDATA[<p>最近一年做项目时，一直在与Maven打交道，在网上也看了很多的博客，也看了《Maven实战》这本书，感觉受益匪浅，但是过一段时间很多东西也会忘记，所以就想根据这本书上看到的，还有自己的经验，写几篇Maven的博客来梳理一下核心点。</p>
<h1 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h1><p>一个依赖包的声明主要包括以下的一些元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>...<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>...<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                ...</div><div class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">                ...</div><div class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        ...</div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>先简单介绍一下上面这几个元素的意义：</p>
<ul>
<li><strong>groupId、artifactId和version</strong>：依赖的基本坐标（这个本文就不在讲解了）；</li>
<li><strong>type</strong>：依赖的类型，对应于项目坐标定义的<code>packaging</code>，一般情况下，该元素不用声明，默认为<code>jar</code>；</li>
<li><strong>scope</strong>：依赖的范围；</li>
<li><strong>optional</strong>：标记依赖是否可选；</li>
<li><strong>exclusions</strong>：用来排除传递性依赖。</li>
</ul>
<h1 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h1><p>Maven依赖的依赖范围有一下几类，分别是：<code>compile</code>、<code>test</code>、<code>provided</code>、<code>runtime</code>、<code>system</code>和<code>import</code>。</p>
<p>之所以Maven会有这么多依赖范围，主要原因是：Maven在编译项目主代码的时候需要使用一套classpath；Maven在编译和执行测试的时候会使用另外一套classpath；Maven实际运行项目的时候，又会使用一套classpath。依赖范围就是用来控制依赖与这三种classpath的关系。</p>
<ul>
<li><strong>compile</strong>：编译依赖范围（默认值），对编译、测试、运行三种classpath都有效；</li>
<li><strong>test</strong>：测试依赖范围，只对测试classpath有效；</li>
<li><strong>provided</strong>：已提供依赖范围，对编译和测试classpath有效；</li>
<li><strong>runtime</strong>：运行时依赖范围，对测试和运行classpath有效；</li>
<li><strong>system</strong>：系统依赖范围，以provided依赖范围一致，但使用<code>system</code>范围时必须通过<code>systemPath</code>元素显示地制定依赖文件的路径；</li>
<li><strong>import</strong>：导入依赖范围，该依赖不会对三种classpath产生实际影响。</li>
</ul>
<p>使用<code>system</code>的例子如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collection<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>system<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>用表格的形式表示以上依赖如下所示：</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>对编译有效</th>
<th>对测试有效</th>
<th>对运行有效</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
</tr>
</tbody>
</table>
<h1 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h1><p><strong>传递性依赖</strong>：比如一个项目<code>account-email</code>有一个compile范围的<code>spring-core</code>依赖，而<code>spring-core</code>有一个compile范围的<code>commons-logging</code>的依赖，那么<code>commons-logging</code>就会成为<code>account-email</code>的compile范围依赖，<code>commons-logging</code>是<code>account-email</code>的一个传递性依赖。</p>
<p>有个传递性依赖机制，在使用<code>account-email</code>的时候就不用去考虑它依赖了什么。明白了传递性依赖，下面就看一下传递性依赖和依赖范围的关系，假设A依赖于B，B依赖于C，我们说A对于B是第一直接依赖范围，B对于C是第二依赖范围，A对于C是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围，如下表所示，最左边一列表示第一直接依赖，最上面一行表示第二直接依赖范围，中间的结果就表示传递性依赖范围。</p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>compile</th>
<th>test</th>
<th>provided</th>
<th>runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>compile</td>
<td>——</td>
<td>——</td>
<td>runtime</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>——</td>
<td>——</td>
<td>test</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>——</td>
<td>provided</td>
<td>provided</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>——</td>
<td>——</td>
<td>runtime</td>
</tr>
</tbody>
</table>
<p>仔细观察上表，我们可以得到以下结论：</p>
<ol>
<li>当第二直接依赖的范围是<code>compile</code>的时候，传递性依赖的范围与第一直接依赖的范围一致；</li>
<li>当第二直接依赖的范围是<code>test</code>的时候，依赖不会得以传递；</li>
<li>当第二直接依赖的范围是<code>provided</code>的时候，只传递第一直接依赖范围也为<code>provided</code>的依赖，且传递性依赖的范围同样为<code>provided</code>；</li>
<li>当第二直接依赖的范围是<code>runtime</code>的时候，传递性依赖的范围与第一依赖的范围一致，但<code>compile</code>例外，此时传递性依赖的范围为<code>runtime</code>。</li>
</ol>
<h1 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h1><p>假如项目A有这样的依赖的关系：A-&gt;B-&gt;C-&gt;X(1.0)，A-&gt;D-&gt;X(2.0)，X是A的传递性依赖，但是有两条路径，那么应该选择哪个版本呢？</p>
<p>Maven依赖调解（Dependency Mediation）有两个原则：</p>
<ul>
<li>路径最近者优先；</li>
<li>第一声明者优先（路径相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用）；</li>
</ul>
<h1 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h1><p>假设有这样一个依赖关系，项目A依赖与项目B，项目B依赖于项目X和Y，B对于X和Y的依赖都是可选依赖：A-&gt;B、B-&gt;X（可选）、B-&gt;Y（可选），那么X、Y就是A的传递性依赖。然而，由于这里X、Y是可选依赖，依赖将不会得以传递。</p>
<p>下面是设置可选依赖的一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </div><div class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;<span class="name">optional</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>一般情况下，不应该使用可选依赖，使用可选依赖的原因是某一个项目实现了多个特性，在面向对象设计中，有个单一职责性原则，意指一个类应该只有一项职责，而不应该糅合太多的功能。当项目需要某个依赖的可选依赖，可以显式地声明这一依赖。</p>
<h1 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h1><p>有时候会出现这样的情况，你的<code>Hibernate</code>依赖于<code>Sun JTA API</code>，但是因为版权原因，<code>Sun JTA API</code>并不在仓库中。而<code>Apache Geronimo</code>项目有一个对应的实现。这时你就可以排除<code>Sun JAT API</code>，再声明<code>Geronimo</code>的<code>JTA API</code>实现，见代码清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 排除对project-c的依赖 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上述代码中，项目A依赖于项目B，但是由于一些原因，不想引入传递性依赖C，而是自己显示声明对于项目C1.0.0版本的依赖。代码中用exclusions元素可以包含<strong>多个</strong>exclusion子元素。需要注意的是声明exslusion的时候只需要groupId和artifactId，而<strong>不需要</strong>version元素(Maven解析后的依赖中，不可能出现groupId和artifactId相同，但是version不同的两个依赖)。</p>
<h1 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h1><p>当我们使用<code>Spring Framework</code>的依赖时，会有许多依赖，如：<code>spring-core:2.5.6.org</code>、<code>org.springframework:spring-beans:2.5.6</code>等，它们是来自同一项目下的不同模块。它们依赖的版本都是相同时，当需要升级<code>Spring Framework</code>时，这些依赖的版本都会一起升级。这时候我们可以用Maven属性的方式来定义一个名为<code>springframework.version</code>的属性，让所有的<code>spring framework</code>子模块都引用它。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--类似于设置一个变量--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>3.1.2.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样当我们需要升级的时候,就只需要改属性值<code>springframework.version</code>就可以了。</p>
<h1 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h1><ul>
<li>使用<code>mvn dependency:list</code>命令可以查看项目已解析的依赖;</li>
<li>使用<code>mvn dependency:tree</code>命令可以查看项目构成的依赖树;</li>
<li>使用<code>mvn dependency:analyze</code>命令可以分析当前项目的依赖.</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10476794.html" target="_blank" rel="external">Maven实战</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Travel to Qinghai Lake | 青海湖骑行之旅]]></title>
      <url>http://wangzzu.github.io/2015/09/27/Travel-to-Qinghai-Lake/</url>
      <content type="html"><![CDATA[<p>今年的青海湖之行给我留下了很美好的回忆，骑行的过程确实是很艰辛，但我们每一个人都按照原计划到达了终点。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一段姑且算作是前言吧。首先介绍一下我自己，我是北京邮电大学的一名研究生，17年毕业，也就是明年就要找工作了，所以今年暑假是学生时代的最后一个暑假了。之前我一直有个梦想，就是想来一段说走就走的旅行，刚好在朋友圈看到朋友经常骑行的照片，而我也是一个热爱旅行、热爱骑行的人，所以就想来一段短期的旅行————去青海。</p>
<h3 id="骑行前准备"><a href="#骑行前准备" class="headerlink" title="骑行前准备"></a>骑行前准备</h3><p>骑行前第一步首先是招募小伙伴。我就在学校的BBS上，发了一个帖子（征友去青海骑行），第二天帖子居然被坛友们顶上了十大，有很多小伙伴跟我的想法一样，我们就很顺利组建了我们的青海小分队。</p>
<p>先说一下骑行的需要的准备的东西：</p>
<ol>
<li><strong>骑行相关物件</strong>：头盔、雨衣、驮包、码表、硅胶坐垫、束带、简易修理工具和备胎（一辆一车至少准备一个备胎，也可以多带几个，大不了回来的时再还给老板）这些都是可以在租车的地方一并租到（顺便宣传一下我们选的<a href="http://www.qinghaihu.cc/ShowGongyi?id=164" target="_blank" rel="external">圣湖单车俱乐部</a>）,墨镜、骑行手套、魔术巾等(这些是需要自己准备的);</li>
<li><strong>旅行需要物品</strong>：现金、手机、身份证、银行卡、相机、充电宝、电池充电器、水壶（喝热水）、报纸、防晒霜（必备，尽量买防晒级别偏高的那种）等；</li>
<li><strong>衣物</strong>：8月不算特别冷，但早晚温差大，下雨的时候还是很冷的，建议带上一件厚外套（冲锋衣）；</li>
<li><strong>药品</strong>：抗高反的药（高原安，红景天）、感冒药（连花清瘟等）、发烧（感康）、肠胃药（藿香正气液）、外伤药（创可贴）等；</li>
<li><strong>食物</strong>：士力架、巧克力、棒棒糖（补充糖），自己再带一些想吃的零食用来路上补充能量。另外，也可以带好充足的食物中午时候找一块合适的地方来野餐。</li>
</ol>
<p>旅行途中需要注意的：</p>
<ul>
<li>一定保护自己的脸，首先涂上防晒霜，然后用魔术巾遮住脸，再带个鸭舌帽，最后套头盔，这样是最保险的（不担心自己脸被晒黑的小伙伴就不用这样了哈）；</li>
<li>以防万一会下雨，可能提前在淘宝买双防雨鞋，要不下雨的话，鞋会被雨水打湿的；</li>
<li>人多的话，住宿可以提前定，不过到地方再找住宿也没事，镇上青旅特别多；</li>
</ul>
<p>下面就是我们当时骑行的行程：</p>
<h3 id="8-1西宁集合"><a href="#8-1西宁集合" class="headerlink" title="8.1西宁集合"></a>8.1西宁集合</h3><p>1号上午11点半，我们一行七人在西宁火车站集合，那天西宁的天气很不错的，一出火车站就能感受到青海火辣的太阳，外面很晒，防晒霜是绝对对不能缺少的。我们人员到齐之后，就在火车站旁边一家川菜馆饭店吃的中饭，大家第一次是在一起吃饭，吃得还是满开心的，那里东西也不贵。下面一张是在西宁汽车站旁边的拍得一张照片。<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-station.jpg" alt="station"></p>
<p>吃完中饭后，我们就在火车站旁边的汽车站买了去西海镇的汽车票，每人25元（回西宁的时候买的票是23一个人，不知道这怎么回事）。西宁汽车站给我的第一印象就是，很安静。虽然汽车站等车的人很多，但是相比于内地而言，非常安静，可能在内地吵杂的环境呆的时间长了，有点不习惯吧。</p>
<p>下午达到西海镇时，西海镇给我的第一个印象是：这是一个很干净、很宁静的一个小镇，西海镇就像是江浙那边的小镇一样，感觉挺发达的，可能因为这是环青海湖的起点，旅游业很发达吧。下面这张是雨后的西海镇：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XihaiZhen.jpg" alt="XihaiZhen"></p>
<p>我们在西海镇下了车之后，我们就跟提前联系的圣湖自行车俱乐部打了电话，老板特别热情，老板娘亲自开车来车站接我们。在俱乐部休整一下之后，基本上就到了该吃晚饭的时间，我们就去了老板推荐的西宁肥牛烤肉去吃烤肉，那里烤肉吃着的确很爽，尤其烤羊排，都是大块的羊肉（烤羊排是80元/斤，有点小贵）。不幸的是在吃烤肉的时候，外面突然下起了暴雨，我们就只能在店里边聊天边吃饭了。暴雨下的快走的也快，等雨停的时候，我们准备赶紧回去，不过就那一会的暴雨，镇中心那一块已经全部被淹了，不得不感慨一下西海镇的水利系统（不过这个问题，貌似全国都一样）。青海的天气变化很快，暴雨过后，天气突然又转晴了。</p>
<p>西海肥牛烤肉的美食：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHFood.jpg" alt="XHFood"></p>
<p>雨后西海镇的镇中心：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHRain.jpg" alt="XHRain"></p>
<p>今天的花费：<br>中饭27，晚饭44，西海镇车费25，水6。</p>
<h3 id="8-2-DAY1-西海镇——江西沟（96-3km）"><a href="#8-2-DAY1-西海镇——江西沟（96-3km）" class="headerlink" title="8.2 DAY1.西海镇——江西沟（96.3km）"></a>8.2 DAY1.西海镇——江西沟（96.3km）</h3><p>今天应该整个行程最兴奋的一天，景色也相当的不错。早上起来我们整理好东西之后，就在西海镇随便找了一家早餐馆吃饭，早上每个早餐店人都很多，这里的早餐还算可以，跟后面的几天比，应该算是最好的，大概人均10块。吃完早饭，买了一些必需品之后（一定、一定、一定要买包<strong>夜用大包</strong>的卫生巾，在屁股上垫上一个，重要的事情说三遍，要不然屁股会非常、非常、非常疼），就向着我们的目标出发了。今天的风景还是很不错的，远处的山可以感受山在云上的感觉。今天天气也不算特别，中间还滴了点小雨。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHStart.jpg" alt="XHSart"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j6.jpg" alt="j6"></p>
<p>Notes：</p>
<ol>
<li>从西海镇出发时，有很多上下坡，下坡很多，也非常刺激，最高的速度可以达到50Km/h；</li>
<li>上午的话，路上可以看到沙漠、草原的景观，不过进去玩的话都是都要收费的；</li>
<li>在快要进入109国道的时候会看到另外一个湖，当地人们好像叫它叫小湖（名字记不太清楚了，大体意思就是比青海湖小的湖），周边有直接通到湖边的小路，不过进去要收费的，每个人10元。这里感觉没必要进去，第三天的时候去湖边应该最爽的，而且去的是真正的青海湖（不是小湖）旁边。</li>
<li>109国道车很多，不过在到二郎剑之前，路的右边一直有一条骑行专用的小路（感觉路上不是特别好，没有前面的路好走），在这条专用路上不必担心车辆的问题。这条小路上有很多专门提供给游客照相的油菜花地，同样进去的话每人10元，可以路边拍几张，当地人可能说你俩句，不过也没什么问题。第四天的时候也有油菜花，不过感觉第一天的油菜花地应该最漂亮的，应该油菜花前面就是湖。</li>
<li>至于过了二郎剑之后，小心点其实也没啥事。</li>
</ol>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh1.jpg" alt="qh1"></p>
<p>旁边的沙漠<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh2.jpg" alt="qh2"></p>
<p>远处的湖：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh3.jpg" alt="qh3"></p>
<p>青海湖的油菜花、很美的油菜花：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh4.jpg" alt="qh4"></p>
<p>骑行专用的小道：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh5.jpg" alt="qh5"></p>
<p>中饭我们是在109国道的丁字路口的一个蒙古包里解决的，我当时吃得是拉面，好像12块钱一碗，不过量很少，吃不饱，吃碗面之后就接着吃了自己带的一些饼干。下面是我们吃饭的那个蒙古包：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh6.jpg" alt="qh6"></p>
<p>下午五点到达江西沟之后，先到提前预定的青年旅舍（<a href="http://hotels.ctrip.com/hotel/1232070.html" target="_blank" rel="external">仓央嘉措青年旅舍</a>），感觉这个青旅一般般吧，我们住的是八人间，60元/人，不过是可以洗澡的。晚饭我们就在江西沟乡镇上找的一家，当时我们是在大众点评上找的，具体叫什么忘了，在那里我们点了牦牛肉（80元/斤）吃，饭菜还可以吧。吃完饭之后，我们就直接回去休息了，然后大概在八点多的时候，突然就开始下暴雨了，而且还下了冰雹，这种大雨在内地应该是很少见的。<br>下面是大块的牦牛肉：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-maoniurou.jpg" alt="maoniurou"></p>
<p>今天的花费：<br>早饭10，中饭14，晚饭47，水10，住宿60。</p>
<h3 id="8-3-Day2-江西沟——黑马河-（50-2km）"><a href="#8-3-Day2-江西沟——黑马河-（50-2km）" class="headerlink" title="8.3 Day2.江西沟——黑马河 （50.2km）"></a>8.3 Day2.江西沟——黑马河 （50.2km）</h3><p>今天是最悲催的一天，早上起来之后依然下着中雨。我们收拾完东西之后，等雨小一点的时候，就赶紧去吃了早饭，江西沟的早饭比较贵，平均一个人都快20了。等我们出发的时候，天气仍然是阴沉沉，还有点小雨，因为我们的行程之前已经全定好了，没有什么备选计划，所以我们打算冒雨前行了。穿上雨衣之后，我们就开始出发了，刚出发之后，就有一名队友的前胎被扎破了，那会雨已经下大了。因为我们没人会修自行车，我们就在路上向其他的骑友求救，骑友们都很热情，马上就有人停下来帮我们换胎了，前胎比较好换，看了一遍之后我们就学会了。修好之后，我们就开始出发，结果过了一会又有两位队友车胎被扎破了，一路上感觉都很曲折。而且这会基本上一直都是中雨，我们身上很鞋上都湿透了（提前在网上买双防雨鞋套非常有必要）。而且下雨骑车的时候尽量骑在白线以内，因为白线外很多小石子，特别容易扎破胎，所以只能占一点机动车车道了。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-Rain.jpg" alt="Rain"></p>
<p>骑到十一点多的时候，我们在路上补充了一些能量，感觉吃到这辈子最好吃的饼干、最好喝的热水、最好吃的士力架。补充完能量后，我们接着骑行，前方又遇到了大堵车，很多时候我们都是在推着自行车走的。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-traffic.jpg" alt="traffic"></p>
<p>中午13点的时候，终于到达了我们定的青旅，因为定的这个青旅离黑马河镇上还有四公里多，结果导致骑在最前面的学长，骑过头了，很悲催，就只能骑回来了。定的这个青旅是八人间65元/人（住蒙古包的话50元/人，蒙古包晚上比较冷，而且是地铺，没有60的住得舒服），名字叫做<a href="http://bnb.qunar.com/city/hainanzangzu/dt-7481/?citytag=hainanzangzu#fromDate=2015-08-02&amp;toDate=2015-08-03&amp;q=%E9%BB%91%E9%A9%AC%E6%B2%B3&amp;filterid=92179149-08a2-4cea-a564-1e83a5abae19&amp;from=bnbDSearch%7Csug&amp;showMap=0&amp;QHFP=KZL_B682D07A&amp;QHPR=1_7_0_0" target="_blank" rel="external">青海湖拉毛叶措天堂牧家宾馆</a>。在青旅里休息一会之后，因为天气的原因，我们就在犹豫还是否去茶卡盐湖，为了不留遗憾，我们最后决定去茶卡盐湖。我们就让青旅的老板帮我联系去茶卡的车，我们6个人包了两辆车（300元/辆），在黑马河镇上买了一些零食以及泡面（晚饭，晚上可能会回来很晚）。在去黑马河的路上，感觉每翻过一座山，天气就不一样，黑马河这边还是阴天，结果翻了一座山之后，在去茶卡的路上都是晴天。到达茶卡镇的时候又遇到了堵车，虽然茶卡是阴天，但是来的人依然是路易不绝，两公里的路走了快一个小时。茶卡的门票是25元/人（学生票，成人票50），茶卡里有卖鞋套，鞋套是没有必要，盐湖里可以直接脱掉鞋下去玩的，不过要注意，湖里有很多黑色的洞，那些洞都很深，我们有一个队友就一下子掉进两次，水都到大腿那。在那呆了两个多小时之后，我们开始返回黑马河，到青旅的时候都快九点了，吃完泡面之后，我们就赶紧睡了。</p>
<p>Notes：</p>
<ul>
<li>黑马黑镇上去茶卡的车很多，基本上都是300一辆；</li>
<li>在茶卡那不用买什么鞋套，晴天比较好看，如果是阴天就差很多了；</li>
<li>下雨天骑车尽量=骑在白线以内，防止小石头扎破胎；</li>
<li>黑马河是青海观看日出的最佳地点（有日出的情况下）；</li>
</ul>
<p>茶卡盐湖：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-chaka.jpg" alt="chaka"></p>
<p>今日花费：<br>早饭19，中饭晚饭34，住宿65，茶卡门票25，包车86。</p>
<h3 id="8-4-Day3-黑马河——刚察县（115km）"><a href="#8-4-Day3-黑马河——刚察县（115km）" class="headerlink" title="8.4 Day3.黑马河——刚察县（115km）"></a>8.4 Day3.黑马河——刚察县（115km）</h3><p>今天应该是最期待的一天，因为黑马河是青海湖看日出的最佳地点，而且今天还是离湖最近的一天，不过今天也是骑行距离最远的一天。队友兵哥哥就是因为害怕骑不完，所以一路上基本上没怎么欣赏风景，一直在骑车，中饭都是带的干粮，结果是最早到达刚察县的。</p>
<p>早上五点多的时候，被师兄喊醒，说想看日出可以看日出了，当时那是一个困，黑马河那天睡的是最安稳的一个觉，但是为了看日出，还是决定起来了。那会天空中最东边有一道光，天空的其他地方都是阴沉沉的。而且那会有转晴的趋势，我们都很期待能看到日出，但是结果还是很令我们失望的，没看到青海湖的日出。带着遗憾我们开始出发了。好在我们出发的时候已经没有雨了，天气开始转晴了。在黑马河镇上吃完早饭（比江西沟便宜一些）之后，我们按着计划出发了。今天的天气非常好，我们看到了最美的青海湖，中间我们在青海湖湖边（去青海湖一个人5块钱）玩了将近一个小时。上午有三四个小时车程风景都特别好，这段路可以稍微骑慢一点，因为过了石乃亥之后，风景就一般了，就可以好好赶路程了，前面的风景还是好好欣赏才能不留遗憾。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh7.jpg" alt="qh7"></p>
<p>那天对我来说，还是挺悲催的，因为那边天气很干燥（感觉比北京要干燥很多，大家一定要多喝水），然后因为下雨的时候有点感冒，今天早上一起来的鼻子就流鼻血了。更悲催的是，在骑车的时候，突然流鼻血了，然后就是用卫生纸边塞着鼻子边骑车。骑到八十多公里时，还躺在草坪上休息半个多小时（那叫一个爽啊）。最后终于在七点多的时候骑到了刚察，我们定的是<a href="http://you.ctrip.com/food/qinghaihu281/151539-food.html#restaurant" target="_blank" rel="external">德吉央宗青年旅舍</a>，这个青旅（50元/人，可以洗澡）还不错。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh13.jpg" alt="qh13"></p>
<p>下面放几张自认为风景不错的照片（包括本人照哈）</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j1.jpg" alt="j1"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j4.jpg" alt="j4"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j5.jpg" alt="j5"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j3.jpg" alt="j3"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j2.jpg" alt="j2"><br>因为刚擦是个县城，住宿的地方、吃饭的地方特别多，晚上就在大众点评上评价比较好的那家店吃的饭。下面这家的美食，很不错的。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food.jpg" alt="food"></p>
<p>今天师兄带的无人机终于派上了用场，下面晒几张师兄用无人机拍的照片。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh8.JPG" alt="qh8"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh9.JPG" alt="qh9"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh10.JPG" alt="qh10"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh11.JPG" alt="qh11"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh12.JPG" alt="qh12"></p>
<p>Notes：</p>
<ul>
<li>在青海一定要多喝水；</li>
<li>今天行程比较远，大家一定要注意好时间，上午风景比较好，大家可以多玩玩，中午过了石乃亥之后就要抓紧时间赶路了；</li>
<li>今天也有几个比较大的坡，大家要注意了，还是多补充点能量，路上有卖西瓜的，大概1块一斤，还挺便宜的；</li>
</ul>
<p>今天的花费：<br>早饭13，中饭13，晚饭44，车胎14，看病59，住宿50。</p>
<h3 id="8-5-Day4-刚察县——西海镇（90km）"><a href="#8-5-Day4-刚察县——西海镇（90km）" class="headerlink" title="8.5 Day4.刚察县——西海镇（90km）"></a>8.5 Day4.刚察县——西海镇（90km）</h3><p>几天的路径虽然不算太长，但是今天是最后一天，而且前面50公里大部分都是在上坡，最蛋疼的是这段距离是逆风，基本上全程逆风，所以今天感觉是最累的，骑到西海镇的时候，我直接躺在床上休息了一个多小时才缓过劲。</p>
<p>第四天的油菜花：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh14.jpg" alt="qh14"></p>
<p>漫漫的长路：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh15.jpg" alt="qh15"></p>
<p>快到西海镇的那个小摊：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh16.jpg" alt="qh16"></p>
<p>晚饭我们是在西宁吃的，是师兄请的客，非常感谢谷歌那位师兄，下面晒几张西宁的美食：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food3.jpg" alt="food3"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food4.jpg" alt="food4"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food2.jpg" alt="food2"></p>
<p>这几天的记录的骑行路线：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qixing.jpg" alt="qixing"></p>
<p>Notes：</p>
<ul>
<li>刚察的早餐挺便宜的，比前面几个镇都好吃、都便宜；</li>
<li>刚出刚察的时候会有一个比较难爬的大坡，这个坡并不是最长的那个坡，中间有个坡当时我直接绝望了，推着上去的，因为又是逆风，所以不是一般的累。</li>
<li>前面三分之一的路还算比较好走，大多是平路，还有一些比较好的风景，而且有一段较长油菜花地，但我感觉没有第一天的油菜花好看。虽然是大都是平路，但逆风的原因，骑着还是很累的。</li>
<li>中间三分之一的路程是最困难的，最令人绝望的路段，这段路程开始进入山地，其间有几个个很长很高的上坡（其中最长有至少有三公里，爬的时候翻过一个山坡之后，发现前面居然还有一个山坡，这个坡真的用惨绝人寰才能形容）。</li>
<li>最后三分之一，也就是最后二十多公里的路段，有个超长的下坡，是这几天最爽的一段，一路狂奔，基本上不用怎么骑，一口气可以跑出二十公里，不过大家还是一定要注意安全的。</li>
</ul>
<p>今日花费：<br>吃饭35（晚饭是师兄请的，很感谢师兄），到西宁车费23，青旅住宿65.</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>这次行程终于圆了我的环骑青海湖的梦，很高兴我当时能找到这几个小伙伴，在这几天里我们一起玩耍，给我留下很深刻的影响。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm之配置文件]]></title>
      <url>http://wangzzu.github.io/2015/07/27/storm-configuration/</url>
      <content type="html"><![CDATA[<p>Storm的配置文件一般存放在<code>$STORM_HOME/conf</code>下，通常名为<code>storm.yaml</code>，它符合yaml格式要求。Storm的配置参数对任务的稳定运行以及吞吐率至关重要，这里介绍一下storm常见的配置项参数。</p>
<h1 id="storm基本配置"><a href="#storm基本配置" class="headerlink" title="storm基本配置"></a>storm基本配置</h1><ul>
<li><strong>storm.local.dir</strong>: nimbus 和supervisor进程存储一些状态信息（conf或者jars）的本地路径，需要每台storm node单独创建该目录并保证该目录有正确的读写权限;</li>
<li><strong>storm.log4j2.conf.dir</strong>： log4j的配置目录;</li>
<li><strong>storm.zookeeper.servers</strong>: storm严重依赖zookeeper存储状态信息，要保证zookeeper的高可用，最好设置多个zk地址;</li>
<li><strong>storm.zookeeper.port</strong>: 默认2181;</li>
<li><strong>storm.zookeeper.root</strong>: 在zookeeper中存储的根目录，如果多个storm集群公用一个zk集群，需要修改其根目录名称即可;</li>
<li><strong>storm.session.timeout</strong>: 默认20s，nimbus和supervisor和zk的session超时时间，如果log中常用sessiontimeout错误，考虑增加其值或者修改gc参数。该值并不能无限设置，zk有自己的最大session时间（默认20 ticktime）；</li>
<li><strong>storm.zookeeper.connection.timeout</strong>：连接超时时间；</li>
<li><strong>storm.zookeeper.retry.times</strong>: 默认5，执行zk操作重试次数；</li>
<li><strong>storm.zookeeper.retry.interval</strong>: 默认1000，即间隔1s；</li>
<li><strong>storm.zookeeper.retry.intervalceiling.millis</strong>: 300000 （5分钟）执行重试的时间间隔最长时间；</li>
<li><strong>storm.messaging.transport</strong>：”backtype.storm.messaging.netty.Context” task之间的消息传输协议，默认使用netty传输；</li>
<li><strong>storm.cluster.mode</strong>: “distributed” storm集群模式；</li>
<li><strong>storm.id</strong>：运行中拓扑的id,由storm name和一个唯一随机数组成；</li>
<li><strong>storm.local.mode.zmq</strong>：Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false；<br>注：Storm严重依赖zookeeper，而且zk在分布式使用中扮演了非常重要的角色。</li>
</ul>
<h1 id="nimbus相关设置"><a href="#nimbus相关设置" class="headerlink" title="nimbus相关设置"></a>nimbus相关设置</h1><ul>
<li><strong>storm.nimbus.retry.times</strong>： 5 nimbus操作的重试次数</li>
<li><strong>storm.nimbus.retry.interval.millis</strong>： 2s 重试间隔</li>
<li><strong>storm.nimbus.retry.intervalceiling.millis</strong>: 60000 最大重试时间 10分钟</li>
<li><strong>nimbus.seeds</strong>: [] 用于leader nimbus发现的nimbus hosts 列表，解决nimbus的单点故障问题，代替了原来的nimbus.host 配置</li>
<li><strong>nimbus.thrift.port</strong>: 6627 nimbus工作的thrift端口，客户端上传jar和提交拓扑的端口（nimbus的thrift监听端口）</li>
<li><strong>nimbus.thrift.threads</strong>: 64 nimbus thrift 线程数目</li>
<li><strong>nimbus.thrift.max_buffer_size</strong>: 1048576 1m</li>
<li><strong>nimbus.childopts</strong>: “-Xmx1024m” nimbus java 进程jvm设置</li>
<li><strong>nimbus.task.timeout.secs</strong>：30 与task没有心跳时多久nimbus可以认为该task已经死掉并且可以重新分配该task</li>
<li><strong>nimbus.supervisor.timeout.secs</strong>: 60 一分钟没有心跳 nimbus可以认为该supervisor已经dead，不会分配新的work</li>
<li><strong>nimbus.monitor.freq.secs</strong>: 10 nimbus多久查询下supervisor心跳信息并且重新分配工作。注意当一台机子曾经挂掉，nimbus会立即采取一些操作</li>
<li><strong>nimbus.reassign</strong>：当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。</li>
<li><strong>nimbus.cleanup.inbox.freq.secs</strong>: 600 多久时间启动清理inbox文件的线程</li>
<li><strong>nimbus.inbox.jar.expiration.secs</strong>: 3600 一个小时 jar过期时间</li>
<li><strong>nimbus.code.sync.freq.secs</strong>: 300 5分钟同步一次未执行的拓扑的代码</li>
<li><strong>nimbus.task.launch.secs</strong>: 120 用于task 第一次启动时的超时时间</li>
<li><strong>nimbus.file.copy.expiration.secs</strong>: 600 上传下载文件超时时间</li>
<li><strong>nimbus.topology.validator</strong>: “backtype.storm.nimbus.DefaultTopologyValidator” 拓扑验证，控制该拓扑是否可以执行</li>
<li><strong>topology.min.replication.count</strong>: 1 当nimbus seeds中该拓扑代码的备份达到最小数目时leader nimbus才可以执行拓扑动作。</li>
<li><strong>topology.max.replication.wait.time.sec</strong>: 60 当代码备份在nimbus list中达到topology.min.replication.count设置的最大等待时间，如果超时，不管有没有最小备份个数，都要执行该拓扑</li>
</ul>
<h1 id="supervisor相关配置"><a href="#supervisor相关配置" class="headerlink" title="supervisor相关配置"></a>supervisor相关配置</h1><ul>
<li><strong>supervisor.slots.ports</strong>: 设置当台机子上可跑的worker数目，每个worker对应一个port，通常情况下多少个cpu core就设置多少个worker，类似与hadoop中nodemanager中slot的设置</li>
<li><strong>supervisor.childopts</strong>: “-Xmx256m” supervisor jvm参数设置</li>
<li><strong>supervisor.worker.start.timeout.secs</strong>: 120 supervisor等待worker启动的最长时间</li>
<li><strong>supervisor.worker.timeout.secs</strong>: 30 worker的最长超时时间</li>
<li><strong>supervisor.worker.shutdown.sleep.secs</strong>: 1秒 supervisor shutdown worker需要等待的时间</li>
<li><strong>supervisor.monitor.frequency.secs</strong>: 3s检查一次worker的心跳确保是否要重启这些worker</li>
<li><strong>supervisor.heartbeat.frequency.secs</strong>: 5s supervisor和nimbus心跳的频率</li>
<li><strong>supervisor.enable</strong>: true supervisor是否要启动分配它的worker</li>
</ul>
<h1 id="worker-配置"><a href="#worker-配置" class="headerlink" title="worker 配置"></a>worker 配置</h1><ul>
<li><strong>worker.childopts</strong>: “-Xmx768m”</li>
<li><strong>worker.gc.childopts</strong>: “” worker gc set 可以被topology.worker.gc.childopts.覆盖</li>
<li><strong>worker.heartbeat.frequency.secs</strong>: 1 worker 和supervisor的heartbeat时间</li>
<li><strong>topology.worker.receiver.thread.count</strong>: 1 每个worker设置的receiver 线程个数</li>
<li><strong>task.heartbeat.frequency.secs</strong>: 3s task向nimbus发送心跳的频率</li>
<li><strong>task.refresh.poll.secs</strong>: 10 多久和其他task同步连接（如果task重新分配，发往该task信息的那些task需要重练他们之间的连接）</li>
</ul>
<h1 id="message传递相关参数"><a href="#message传递相关参数" class="headerlink" title="message传递相关参数"></a>message传递相关参数</h1><ul>
<li><strong>storm.messaging.netty.server_worker_threads</strong>：1， server端接收信息的线程个数</li>
<li><strong>storm.messaging.netty.client_worker_threads</strong>: 1， client端发送信息的线程个数</li>
<li><strong>storm.messaging.netty.buffer_size</strong>: 5M，netty buffer大小</li>
<li><strong>storm.messaging.netty.max_retries</strong>: 300 重试次数</li>
<li><strong>storm.messaging.netty.max_wait_ms</strong>: 1000ms=1s 最大等待时间要大于task launchtime and worker launch time默认120s，重连间隔要大于zk的sessiontimeout 以确保worker是否已挂</li>
<li><strong>storm.messaging.netty.min_wait_ms</strong>: 100</li>
<li><strong>storm.messaging.netty.transfer.batch.size</strong>: 262144 如果netty 发送消息非常忙，client客户端可以batch发送消息，否则尽快的flush消息以减少延迟。</li>
</ul>
<blockquote>
<p>注：我们的使用场景是storm kafka读取kafka里面的数据，发现运行一段时间以后，kafka消费的offset不再更新（2s更新一次消费的offset），spout 中的task不断重启导致offset一直不更新，查看log发现task失败的原因是gc设置不对以致netty连接超时，task会重新分配。在生产环境中应该调大该值，我们在线上设置该值为20s，并且调整worker的gc参数。</p>
</blockquote>
<h1 id="topology相关的设置，-针对特定拓扑的配置"><a href="#topology相关的设置，-针对特定拓扑的配置" class="headerlink" title="topology相关的设置， 针对特定拓扑的配置"></a>topology相关的设置， 针对特定拓扑的配置</h1><p>正如上一讲的，以下参数控制消息是否被完全处理：</p>
<ul>
<li><strong>topology.enable.message.timeouts</strong>: true 保证数据完全处理；</li>
<li><strong>topology.acker.executors</strong>: null 设置acker线程个数；</li>
<li><strong>topology.message.timeout.secs</strong>: 30 当一个消息的处理超时多长时间多少认为该tuple处理失败；</li>
<li><strong>topology.max.spout.pending</strong>: null 当spout 发送一个tuple时会将该tuple放到一个pending list，此字段控制在storm中处理的spout tuple数，可以根据超时时间以及每秒处理的消息数估算；</li>
</ul>
<p>下面这几个参数和拓扑的并行度（parallelism)，并行度的概念就是为该拓扑启动的线程数，TopologyBuilder#setSpout() 和TopologyBuilder#setbolt()中可以指定excutor数目，该excutor是从worker进程spawn的线程，task是处理数据的实际工作单元，跑在一个excutor上。</p>
<ul>
<li><strong>topology.workers</strong>: 1，Config#setNumWorkers，设置worker数，一个worker执行一个拓扑的一个子集任务，其上可以跑多个excutors，可能是多个bolt或者spout；</li>
<li><strong>topology.tasks</strong>: null，top.setNumtasks，设置task数目；</li>
<li><strong>topology.max.task.parallelism</strong>: null，拓扑最大线程数；</li>
</ul>
<p>worker <strong>gc设置</strong></p>
<ul>
<li><strong>topology.worker.childopts</strong>: null；</li>
<li><strong>topology.worker.logwriter.childopts</strong>: “-Xmx64m”；</li>
<li><strong>topology.worker.shared.thread.pool.size</strong>: 4 worker task 共享线程池大小；</li>
</ul>
<p>worker内消息传送的参数，与disruptor相关：</p>
<ul>
<li><strong>topology.executor.receive.buffer.size</strong>: 1024 #batched；</li>
<li><strong>topology.executor.send.buffer.size</strong>: 1024 #individual messages；</li>
<li><strong>topology.transfer.buffer.size</strong>: 1024 # batched；</li>
<li><strong>topology.disruptor.wait.strategy</strong>:com.lmax.disruptor.BlockingWaitStrategy 延迟和吞吐率权衡；</li>
<li><strong>topology.disruptor.wait.timeout.millis</strong>: 1000 延迟和cpu使用权衡，使用长延时时会减少cpu使用，减少等待时间可以保证延时小，但cpu负载高；</li>
</ul>
<p>其他参数配置：</p>
<ul>
<li><strong>topology.debug</strong>: false debug模式关闭；</li>
<li><strong>topology.tick.tuple.freq.secs</strong>: null 用于定时处理逻辑的拓扑使用；</li>
<li><strong>topology.spout.wait.strategy</strong>: “backtype.storm.spout.SleepSpoutWaitStrategy” 两种情形下等待1. no data 2. 达到最大pending大小；</li>
<li><strong>topology.sleep.spout.wait.strategy.time.ms</strong>: 1 sleep时间；</li>
</ul>
<p>drpc logview ui的设置就不介绍了。</p>
<p>通过上面所讲的设置参数，可以发现gc设置和zookeeper设置非常重要，而且在message传输的相关设置中，有一系列参数如：receiver buffer size 、transfer buffer size，transfer buffer size，以及netty receiver thread 和worker receiver count 又有什么关系，上面提到到disruptor是什么东东，还有很多问题。所以在设置参数这个主题下还会再详细介绍下面三个问题：</p>
<ul>
<li>jvm 参数设置和调整，这个对于java程序的稳定运行至关重要（尤其是在大数据平台下，因为目前开源的大数据工具大部分都是java写的，jvm调优是必不可少的;</li>
<li>zookeeper的维护和管理，在hadoop生态系统以及分布式系统中中必不可少的工具</li>
<li>storm worker间和worker内的消息传递，包含disruptor的使用，通过这一节的介绍就会知道buffer size 设置为啥都是2的幂次方，这里buffer size 的单位是字节还是其他等等一些疑惑</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://xstarcd.github.io/wiki/Cloud/storm_config_detail.html" target="_blank" rel="external">Storm配置项详解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Json文件的读取]]></title>
      <url>http://wangzzu.github.io/2015/07/13/json/</url>
      <content type="html"><![CDATA[<p>本人遇到的情况：在一个工程中需要引用另外一个jar包，而引用的jar里有Json配置文件，这里出现了Json文件找不到的错误。这实际上也是java从jar包中读取配置文件的问题。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>取stackoverflow上的一个例子来说明。<br>我们的Json文件为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"pagination"</span>: &#123;</div><div class="line">        <span class="attr">"time"</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">"url"</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">"host"</span>: <span class="number">3</span>,</div><div class="line">        <span class="attr">"serverip"</span>: <span class="number">4</span>,</div><div class="line">        <span class="attr">"clientip"</span>: <span class="number">5</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"separator"</span>: <span class="string">"\t"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是与Json文件对应的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jsonLog</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String separator;</div><div class="line">	<span class="keyword">private</span> Map&lt;String, Integer&gt; map;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeparator</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> separator;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeparator</span><span class="params">(String separator)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.separator = separator;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> map;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.map = map;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目的是将Json文件的内容读取到jsonLog对象中，遇到两个问题：</p>
<ol>
<li>Json文件是存在config目录下，打jar包时如何将Json文件连同config目录一同打入jar包；</li>
<li>Json文件打进jar包，其他工程再引用该jar包时，此时Json所在目录已经变化，如何动态获取Json文件所在位置。</li>
</ol>
<h1 id="打jar包"><a href="#打jar包" class="headerlink" title="打jar包"></a>打jar包</h1><p>这里需要修改Maven工程的pom文件，加入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;build<span class="string">&gt;</span></div><div class="line">	&lt;resources&gt;</div><div class="line">		&lt;resource&gt;</div><div class="line">			&lt;directory&gt;config&lt;/directory&gt;</div><div class="line">				&lt;includes&gt;</div><div class="line">					&lt;include&gt;**/*.json&lt;/include&gt;</div><div class="line">				&lt;/includes&gt;</div><div class="line">			&lt;targetPath&gt;config&lt;/targetPath&gt;</div><div class="line">		&lt;/resource&gt;</div><div class="line">	&lt;/resources&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure>
<p>这几行的意思就是打包时把目录<code>config</code>（directory）下的json文件也打进去，并且放<code>在config</code>（targetPath）目录下。</p>
<h1 id="读取Json文件"><a href="#读取Json文件" class="headerlink" title="读取Json文件"></a>读取Json文件</h1><p>动态获得json文件位置并读取的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">objectMapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">InputStream inputstream = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/config/xx.json"</span>);</div><div class="line">LogConfig config = objectMapper.readValue(inputstream, LogConfig.class);</div></pre></td></tr></table></figure>
<p>通过<code>Class</code>类的<code>getResourceAsStream()</code>方法来获取Json文件，这种方法是专门读取jar中的资源文件的。可参考<a href="http://blog.csdn.net/b_h_l/article/details/7767829" target="_blank" rel="external">java从jar包中读取资源文件</a>一文。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm简单介绍]]></title>
      <url>http://wangzzu.github.io/2015/05/26/the-basis-of-storm/</url>
      <content type="html"><![CDATA[<p>本文是参考网上的博客以及一些书籍根据自己的一些理解整理得到的，主要是为了更好地理解storm的内部机制（当时使用Storm的版本是<code>0.9.3</code>）。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Storm的Topology模型"><a href="#Storm的Topology模型" class="headerlink" title="Storm的Topology模型"></a>Storm的Topology模型</h2><p>一个storm Topology的一般模型为：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-topology.png" alt="topology"></p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>storm中传输的数据类型是tuple，tuple到底是什么？感觉还是用英语来说比较容易理解吧，”A tuple is a named of values where each value can be any type.”  tuple是一个类似于列表的东西，存储的每个元素叫做field（字段）。我们用getString(i)可以获得tuple的第i个字段。而其中的每个字段都可以任意类型的，也可以一个很长的字符串。我们可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String A = tuple.getString(<span class="number">0</span>);</div><div class="line"><span class="keyword">long</span> a= tuple.getLong(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>来拿到我们所需的数据，不过前提你是要知道你的tuple的组成。具体tuple是什么类型，完全取决于自己的程序，取决于spout中nextTuple()方法中emit发送的类型。<br>storm的streams就是一个无限的tuple流，我们可以把storm tuples当做CEP(complex event processing)中events来理解。</p>
<h3 id="spout"><a href="#spout" class="headerlink" title="spout"></a>spout</h3><p>spout是storm topology的数据入口，连接到数据源，将数据转换为一个个tuple，并将tuple作为数据流进行发射。一个spout可以供多个topology使用。通常spouts从外部资源读取元组，然后发射元组到拓扑中（例如，Kestrel队列或Twitter API）。Spouts即可以是可靠的，也可是不可靠的。可靠的spout可以重新执行一个失败元组，但一个不可靠的spout一发射元组就会忘记它。</p>
<p>Spouts可以发射多个流。要发射多个流，使用OutputFieldDeclarer的declareStream方法声明多个流，并在使用SpoutOutputCollector的emit方法时指定流ID。但是由于由spouts和bolts组成的单流应用最为普遍，因此OutputFieldDeclarer提供便利的方法声明一个不需要指定ID的单流，此时，流被分配一个默认ID为“default”。</p>
<p>Spouts的重要方法是nextTuple方法。nextTuple方法发射一个新的元组到拓扑，或如果没有新的元组发射，简单的返回。注意任务spout的nextTuple方法都不要实现成阻塞的，因为storm是在相同的线程中调用spout的方法。</p>
<p>Spout的另外两个重要方法是ack和fail方法。当spout发射的元组被拓扑成功处理时，调用ack方法；当处理失败时，调用fail方法。Ack和fail方法仅被可靠spouts调用。</p>
<h3 id="bolt"><a href="#bolt" class="headerlink" title="bolt"></a>bolt</h3><p>bolt可以理解为计算机程序中的运算或函数，将一个或者多个数据流作为输入，对数据实施运算后，选择性地输出一个或者多个数据流。一个bolt可以订阅(subscribe)多个由spout或其他bolt发射的数据流。</p>
<p>Topology中的所有处理都在bolts中完成。Bolts什么都可以做，如过滤、业务功能、聚合、连接（合并）、访问数据库等等。</p>
<p>Bolts可以做简单的流转换。复杂的流转换经常需要多步完成，因此也需要多个bolts。例如，转换tweets数据流到流行图片数据流至少需要两步：一个bolt 对retweets的图片进行滚动计数，另外的bolt找出Top X（前几位）的图片（你可以用更具伸缩性的方式处理这部分流）。</p>
<p>Bolts可以发射多个流。要发射多个流，使用OutputFieldDeclarer的declareStream方法声明多个流，并在使用SpoutOutputCollector的emit方法时指定流ID。</p>
<p>当你声明一个bolt的输入流时，你总是以另一个组件的指定流作为输入。如果你想订阅另一个组件的所有流，你必须分别订阅每一个流。InputDeclarer提供了使用默认流ID订阅流的语法糖，调用declarer.shuffleGrouping(“1”)订阅组件“1”上的默认流，作用等同于declarer.shuffleGrouping(“1”, DEFAULT_STREAM_ID)。</p>
<p>Bolts的主要方法是execute方法，任务在一个新的元组输入时执行该方法。Bolts使用OutputCollector对象发射新的元组。Bolts必须对每个处理的元组调用OutputCollector的ack方法，因此storm知道这个元组完成处理（并且能最终确定ack原始元组是安全的）。一般情况，处理一个输入元组，基于此元组再发射0-N个元组，然后ack输入元组。Strom提供了一个IBasicBolt接口自动调用ack方法。</p>
<p>在Bolts中载入新的线程进行异步处理。OutputCollector是线程安全的，并随时都可调用它。</p>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>Storm核心的抽象概念是“流”。流是一个分布式并行创建和处理的无界的连续元组（tuple）。流通过一种模式来定义，该模式是给流元组中字段命名。默认情况下，元组可以包含整型、长整型、短整型、字节、字符串、双精度浮点数、单精度浮点数、布尔型和字节数组。您还可以自定义序列化，在元组中使用自定义类型。</p>
<p>而消息流Streams是storm里的最关键的抽象。一个消息流是一个没有边界的tuple序列，而这些tuples会被以一种分布式的方式并行地创建和处理。对消息流的定义主要是对消息流里面的tuple的定义， 我们会给tuple里的每个字段一个名字。 并且不同tuple的对应字段的类型必须一样。 也就是说： 两个tuple的第一个字段的类型必须一样， 第二个字段的类型必须一样， 但是第一个字段和第二个字段可以有不同的类型。 在默认的情况下， tuple的字段类型可以是： integer, long, short, byte, string, double, float, boolean和byte array。 你还可以自定义类型 — 只要你实现对应的序列化器。</p>
<h2 id="storm并发机制"><a href="#storm并发机制" class="headerlink" title="storm并发机制"></a>storm并发机制</h2><p>在 Storm 的间接中提到过,Storm 计算支持在多台机器上水平扩容,通过将计算切分为多个独立的 tasks 在集群上并发执行来实现。在 Storm 中,一个 <strong>task</strong> 可以简单地理解为在集群某节点上运行的一个spout 或者 bolt 实例。</p>
<ul>
<li><p><strong>Nodes</strong>： 指配置在一个 Storm 集群中的服务器,会执行 topology 的一部分运算。一个 Storm 集群可以包括一个或者多个工作 node。</p>
</li>
<li><p><strong>Workers</strong>(JVM虚拟机)：指一个 node 上相互独立运行的 JVM 进程。每个 node 可以配置运行一个或者多个 worker。一个 topology 会分配到一个或者多个 worker 上运行。</p>
</li>
<li><strong>Executeor</strong>：指一个 worker 的 jvm 进程中运行的 Java 线程。多个 task 可以指派给同一个 executer 来执行。除非是明确指定,Storm 默认会给每个 executor 分配一个 task。</li>
<li><strong>Task</strong>：task 是 spout 和 bolt 的 实 例, 它 们 的 nextTuple() 和execute() 方法会被executors 线程调用执行。</li>
</ul>
<h3 id="默认的并发机制"><a href="#默认的并发机制" class="headerlink" title="默认的并发机制"></a>默认的并发机制</h3><p>在我们修改 topology 的并发度之前,先来看默认配置下 topology 是如何执行的。假设<br>我们有一台服务器(node),为 topology 分配了一个 worker,并且每个 executer 执行一个<br>task。我们的 topology 执行过程如下图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node1.png" alt="Node1"></p>
<p>正如在图中看到的,唯一的并发机制出现在线程级。每个任务在同一个 JVM 的不<br>同线程中执行。如何增加并发度以充分利用硬件能力?让我们来增加分配给 topology 的<br>worker 和 executer 的数量。</p>
<h3 id="给topology增加worker"><a href="#给topology增加worker" class="headerlink" title="给topology增加worker"></a>给topology增加worker</h3><p>增加额外的 worker 是增加 topology 计算能力的简单方法。为此 Storm 提供了 API 和修改配置项两种修改方法。无论采取哪种方法,spout 和 bolt 组件都不需要做变更,可以直接复用。<br>为了增加分配给一个 topology 的worker 数量,只需要简单的调用一下Config对象的setNumWorkers()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Config.config = <span class="keyword">new</span> Config();</div><div class="line">config.setNumworkers(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>这样就给 topology 分配了两个 worker 而不是默认的一个。从而增加了 topology 的计算资源,也更有效的利用了计算资源。我们还可以调整 topology 中的 executor 个数以及每个 executor 分配的 task 数量。</p>
<h3 id="配置executor和task"><a href="#配置executor和task" class="headerlink" title="配置executor和task"></a>配置executor和task</h3><p>我们已经知道,Storm 给 topology 中定义的每个组件建立一个 task,默认的情况下,每个 task 分配一个 executor。Storm 的并发机制 API 对此提供了控制方法,允许设定每个task 对应的 executor 个数和每个 executor 可执行的 task 的个数。<br>在定义数据流分组时,可以设置给一个组件指派的 executor 的数量。为了说明这个功能,修改 topology 的定义代码,设置 SentenceSpout 并发为两个 task,每个 task 指派各自的 executor 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">builder.setSpout (SENTENCE_SPOUT_ID, spout, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>如果只使用一个 worker,topology 的执行如下图所示：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node2.png" alt="Node2"></p>
<p>我们给语句分割 bolt SplitSentenceBolt 设置 4 个 task 和 2 个 executor。每个executor 线程指派 2 个 task 来执行(4/2=2)。还将配置单词计数 bolt 运行四个 task,每个task 由一个 executor 线程执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">builder.setBolt(SPLIT_BOLT_ID, splitBolt, <span class="number">2</span>).setNumTasks(<span class="number">4</span>).shuffleGrouping(SENTENCE_SPOUT_ID);</div><div class="line"></div><div class="line">builder.setBolt(COUNT_BOLT_ID, countBolt, <span class="number">4</span>).fieldsGrouping(SPLIT_SPOUT_ID, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div></pre></td></tr></table></figure>
<p>在2个worker的情况下，topology的执行如图所示：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node3.png" alt="Node3"></p>
<p>要重点指出的是,当 topology 执行在本地模式时,增加 worker 的数量不会达到提高速度的效果。因为 topology 在本地模式下是在同一个 JVM 进程中执行的,所以只有增加 task 和 executor 的并发度配置才会生效。Storm 的本地模式提供了接近集群模式的模拟,对开发是否有帮助。但程序在投入生产环境之前,必须在真实的集群环境下进行测试。</p>
<h2 id="数据流分组"><a href="#数据流分组" class="headerlink" title="数据流分组"></a>数据流分组</h2><p>Storm 定义了七种内置数据流分组的方式:</p>
<ul>
<li><strong>Shuffle grouping</strong>(随即分组)：这种方式会随机分发 tuple 给 bolt 的各个 task,每个bolt 实例接收到的相同数量的 tuple;</li>
<li><strong>Fields grouping</strong>(按字段分组)：根据指定字段的值进行分组。比如说,一个数据流根据“ word ”字段进行分组,所有具有相同“ word ”字段值的 tuple 会路由到同一个 bolt 的 task 中；</li>
<li><strong>All grouping</strong>(全复制分组)：将所有的 tuple 复制后分发给所有 bolt task。每个订阅数据流的 task 都会接收到 tuple 的拷贝；</li>
<li><strong>Globle Grouping</strong>(全局分组)：这种分组方式将所有的 tuples 路由到唯一一个 task 上。Storm 按照最小的 task ID 来选取接收数据的 task。注意,当使用全局分组方式时,设置 bolt 的 task 并发度是没有意义的,因为所有 tuple 都转发到同一个 task 上了。使用全局分组的时候需要注意,因为所有的 tuple 都转发到一个 JVM 实例上,可能会引起 Storm 集群中某个 JVM 或者服务器出现性能瓶颈或崩溃；</li>
<li><strong>None grouping</strong>(不分组)：在功能上和随机分组相同,是为将来预留的；</li>
<li><strong>Direct gouping</strong>(直接分组/指向型分组)：数据源会调用 emitDirect() 方法来判断一个 tuple 应该由哪个 Storm 组件来接收。只能在声明了是指向型的数据流上使用；</li>
<li><strong>Local or shuffle grouping</strong>(本地或随即分组)：和随机分组类似,但是,会将 tuple 分发给同一个 worker 内的 bolt task(如果 worker 内有接收数据的 bolt task)。其他情况下,采用随机分组的方式。取决于 topology 的并发度,本地或随机分组可以减少网络传输,从而提高 topology 性能。</li>
</ul>
<p>除了预定义好的分组方式之外,还可以通过实现 CustomStreamGrouping(自定义分组)<br>接口来自定义分组方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> backtype.storm.generated.GlobalStreamId;</div><div class="line"><span class="keyword">import</span> backtype.storm.task.WorkerTopologyContext;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomStreamGrouping</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(WorkerTopologyContext context, GlobalStreamId stream, List&lt;Integer&gt; targetTasks)</span></span>;<span class="comment">//prepare()方法在调用时，用来初始化分组信息，分组的具体实现会使用这些信息决定如何向接收task分发tuple。WorkerTopologyContext 对象提供了topology的上下文信息，GlobalStreamId提供了待分组数据流的属性，targetTasks时分组所有待选task的标识符列表。</span></div><div class="line"></div><div class="line">     <span class="comment">//会将 targetTasks 的引用存在变量里作为 chooseTasks() 的参数</span></div><div class="line">    <span class="function">List&lt;Integer&gt; <span class="title">chooseTasks</span><span class="params">(<span class="keyword">int</span> taskId, List&lt;Object&gt; values)</span></span>; <span class="comment">//chooseTasks() 方法返回一个 tuple 发送目标 task 的标识符列表。它的两个参数是发送tuple 的组件的 id 和 tuple 的值。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可靠的消息处理机制"><a href="#可靠的消息处理机制" class="headerlink" title="可靠的消息处理机制"></a>可靠的消息处理机制</h2><p>Storm 提供了一种 API 能够保证 spout 发送出来的每个 tuple 都能够执行完整的处理过程。</p>
<p>在storm里一个tuple被完全处理的意思是：这个tuple以及由这个tuple所导致的所有的tuple都被成功处理。而一个tuple会被认为处理失败了如果这个tuple在timeout所指定的时间内没有成功处理。而这个<code>timeout</code>可以通过<code>Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS</code>来指定。</p>
<p>作为storm的使用者，有两件事情要做以更好的利用storm的可靠性特征。 首先，在你生成一个新的tuple的时候要通知storm; 其次，完成处理一个tuple之后要通知storm。 这样storm就可以检测整个tuple树有没有完成处理，并且通知源spout处理结果。storm提供了一些简洁的api来做这些事情。</p>
<h3 id="spout的可靠性"><a href="#spout的可靠性" class="headerlink" title="spout的可靠性"></a>spout的可靠性</h3><p>在有保障数据的处理过程中,bolt每收到一个 tuple,都需要向上游确认应答(ack)者报错。对主干 tuple 中的一个 tuple,如果 tuple 树上的每个 bolt 进行了确认应答,spout 会调用 ack 方法来标明这条消息已经完全处理了。如果树中任何一个 bolt 处理 tuple 报错,或者处理超时,spout 会调用 fail方法。<br>tuple树的结构如图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-tuple_tree.png" alt="tuple_tree"></p>
<p>Spout的nextuple()发送一个tuple，为了实现可靠的消息处理，首先要给每个发出的tuple带上唯一的ID，并且将ID作为参数传递给SpoutOutputCollector的emit()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collector.emit(<span class="keyword">new</span> Values(<span class="string">"value1"</span>,<span class="string">"value2"</span>),msgId);</div></pre></td></tr></table></figure>
<p>接下来，这个发射的tuple被传送到消息处理者bolt那里，storm会跟踪由此所产生的这课tuple树。如果storm检测到一个tuple被完全处理了，那么storm会以最开始的那个message-id作为参数来调用消息源的ack方法；反之storm会调用spout的fail方法。要注意的是，storm调用ack或者fail的task始终是产生这个tuple的那个task。所以如果一个spout被分成很多个task来执行，消息执行的成功失败与否始终会通知最开始发出tuple的那个task。</p>
<p>给tuple指定ID告诉Storm系统，无论执行成功还是失败，spout都要接收所有发出tuple返回的通知。如果处理成功，spout的ack()方法将会对编号是ID的消息应答确认，如果执行失败或者超时，会调用fail()方法。</p>
<h3 id="bolt的可靠性"><a href="#bolt的可靠性" class="headerlink" title="bolt的可靠性"></a>bolt的可靠性</h3><p>bolt要实现可靠的消息处理机制要包含两个步骤：</p>
<ol>
<li>当发射衍生的tuple时，需要锚定读入的tuple；</li>
<li>当处理消息成功或者失败时分别确认应答或者报错。</li>
</ol>
<p>由一个tuple产生一个新的tuple称为：anchoring(锚定)。你发射一个新tuple的同时也就完成了以西anchring。</p>
<p>锚定一个tuple的意思是，建立读入tuple和衍生出的tuple之间的对应关系，这样下游的bolt就可以通过应答确认，报错或超时来加入到tuple树结构中。<br>可以通过调用OutputCollect中emit()的一个重载函数锚定一个或者一组tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collector.emit(tuple, <span class="keyword">new</span> Values(word));<span class="comment">//anchoring</span></div></pre></td></tr></table></figure>
<p>这里，我们将读入的tuple和发射的新tuple锚定(anchoring)起来，下游的bolt就需要对输出的tuple进行确认应答或者报错。因为这个tuple被anchoring在上一个tuple， 这整个就构成了tuple树，如果这一级tuple处理出错了，那么这整个tuple处理过程都会被重新处理。</p>
<p>另外一个emit()方法会发射非锚定的tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collector.emit(<span class="keyword">new</span> Values(word));<span class="comment">// unanchoring</span></div></pre></td></tr></table></figure>
<p>用这种方法发射会导致新发射的这个tuple脱离原来的tuple树(unanchoring), unanchoring的tuple不会对数据流的可靠性起作用。如果一个unanchoring的tuple在下游处理过程中失败了，原始的根tuple是不会重新发送，到底要anchoring还是要 unanchoring则完全取决于你的业务需求。﻿</p>
<p>当处理完成或者发送了新tuple之后，可靠数据流中的bolt需要应答读入的tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.collector.ack(tuple);</div></pre></td></tr></table></figure>
<p>如果处理失败，这样的话spout必须发射tuple，bolt就要明确地对处理失败的tuple报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.collector.fail(tuple);</div></pre></td></tr></table></figure>
<p>如果因为超时的原因，或者显式调用OutputCollector.fail()方法，spout都会重新发送源是的tuple。</p>
<p>每个处理tuple，都必须进行ack或者fail。因为storm会追踪每个tuple要占用内存。所以如果你不ack/fail每一个tuple，那么最终年会看到<code>OutOfMemory</code>错误。</p>
<p>对于SplitSentence这一部分，如果用IRichBolt来做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</div><div class="line">        OutputCollector _collector;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,</span></span></div><div class="line">                            TopologyContext context,</div><div class="line">                            OutputCollector collector) &#123;</div><div class="line">            _collector = collector;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</div><div class="line">            String sentence = tuple.getString(<span class="number">0</span>);</div><div class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">                _collector.emit(tuple, <span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">            _collector.ack(tuple);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>大多数Bolt遵循这样的规律：读取一个tuple；发射一些新的tuple；在execute的结束的时候ack这个tuple。这些Bolt往往是一些过滤器或者简单函数。Storm为这类规律封装了一个BasicBolt类。如果用BasicBolt来做， 上面那个SplitSentence可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">implements</span> <span class="title">IBasicBolt</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,</span></span></div><div class="line">                            TopologyContext context) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple,</span></span></div><div class="line">                            BasicOutputCollector collector) &#123;</div><div class="line">            String sentence = tuple.getString(<span class="number">0</span>);</div><div class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</div><div class="line">                collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(</span></span></div><div class="line">                        OutputFieldsDeclarer declarer) &#123;</div><div class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个实现比之前的实现简单多了， 但是功能上是一样的。发送到BasicOutputCollector的tuple会自动和输入tuple相关联，而在execute方法结束的时候那个输入tuple会被自动ack的。</p>
<h3 id="acker"><a href="#acker" class="headerlink" title="acker"></a>acker</h3><p>storm里面有一类特殊的task称为：acker， 他们负责跟踪spout发出的每一个tuple的tuple树。当acker发现一个tuple树已经处理完成了。它会发送一个消息给产生这个tuple的那个task。你可以通过<code>Config.TOPOLOGY_ACKERS</code>来设置一个topology里面的acker的数量， 默认值是一。 如果你的topology里面的tuple比较多的话， 那么把acker的数量设置多一点，效率会高一点.</p>
<p>理解storm的可靠性的最好的方法是来看看tuple和tuple树的生命周期， 当一个tuple被创建， 不管是spout还是bolt创建的， 它会被赋予一个64位的id，而acker就是利用这个id去跟踪所有的tuple的。每个tuple知道它的祖宗的id(从spout发出来的那个tuple的id), 每当你新发射一个tuple， 它的祖宗id都会传给这个新的tuple。所以当一个tuple被ack的时候，它会发一个消息给acker，告诉它这个tuple树发生了怎么样的变化。具体来说就是：它告诉acker： 我呢已经完成了， 我有这些儿子tuple, 你跟踪一下他们吧。下面这个图演示了C被ack了之后，这个tuple树所发生的变化。<br>tuple ack示例:</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-acker.png" alt="acker"></p>
<p>关于storm怎么跟踪tuple还有一些细节， 前面已经提到过了， 你可以自己设定你的topology里面有多少个acker。而这又给我们带来一个问题， 当一个tuple需要ack的时候，它到底选择<code>哪个acker</code>来发送这个信息呢？</p>
<p>storm使用一致性哈希来把一个spout-tuple-id对应到acker， 因为每一个tuple知道它所有的祖宗的tuple-id， 所以它自然可以算出要通知哪个acker来ack。（这里所有的祖宗是指这个tuple所对应的所有的根tuple。这里注意因为一个tuple可能存在于多个tuple树，所以才有所有一说）。</p>
<p>storm的另一个细节是acker是怎么知道每一个spout tuple应该交给哪个task来处理。当一个spout发射一个新的tuple， 它会简单的发一个消息给一个合适的acker，并且告诉acker它自己的id(taskid)， 这样storm就有了taskid-tupleid的对应关系。 当acker发现一个树完成处理了， 它知道给哪个task发送成功的消息.</p>
<p>acker task并不现式的跟踪tuple树。对于那些有成千上万个节点的tuple树，把那么多的tuple信息都跟踪起来会消耗太多的内存。相反，acker永了一种不同的凡是，使得对于每一个spout tuple所需要的内存量都是恒定的(20bytes)。这个<strong>跟踪算法</strong>是storm如何工作的关键。</p>
<h1 id="Storm集群框架"><a href="#Storm集群框架" class="headerlink" title="Storm集群框架"></a>Storm集群框架</h1><h2 id="nimbus守护进程"><a href="#nimbus守护进程" class="headerlink" title="nimbus守护进程"></a>nimbus守护进程</h2><p>nimbus守护进程的主要职责是管理，协调和监控在集群上运行的topology。包括topology的发布，任务支派，事件处理失败时重新指派任务。</p>
<p>将topology发布到Storm集群，将预先打包的jar文件的topology和配置信息提交到nimbus服务器上，一旦nimbus接收到了topology的压缩包，会将jar包分发到足够数量的supervisor节点上。当supervisor节点接收到了topology压缩文件，nimbus就会指派task(bolt和spout实例)到每个supervisor并且发送信号指示supervisor生成足够的worker来执行指派的task。</p>
<p>nimbus记录所有supervisor节点的状态和分配给它们的task。如果nimbus发现某个supervisor没有上报心跳或者已经不可达了，它会将故障supervisor分配的task重新分配到集群中的其他supervisor节点。</p>
<p>严格意义上讲 nimbus 不会引起单点故障。这个特性是因为 nimubs 并不参与 topology 的数据处理过程,它仅仅是管理 topology 的初始化,任务分发和进行监控。实际上,如果 nimbus 守护进程在 topology 运行时停止了,只要分配的 supervisor 和worker 健康运行,topology 一直继续数据处理。要注意的是,在 nimbus 已经停止的情况下 supervisor 异常终止,因为没有 nimbus 守护进程来重新指派失败这个终止的 supervisor的任务,数据处理就会失败。</p>
<h2 id="supervisor守护进程"><a href="#supervisor守护进程" class="headerlink" title="supervisor守护进程"></a>supervisor守护进程</h2><p>supervisor守护进程等待nimbus分配任务后生成并监控workers(JVM进程)执行任务。supervisor和worker都是运行在不同的 JVM 进程上,如果由 supervisor 拉起的一个woker 进程因为错误(或者因为 Unix 终端的 kill-9 命令,Window 的 tskkill 命令强制结束)异常退出,supervisor 守护进程会尝试重新生成新的 worker 进程。</p>
<p>如果一个worker甚至整个supervisor节点都故障了，Storm怎么保障出错时正在处理的tuples的传输呢？答案就在Storm的tuple的锚定和应答确认机制中。当打开了可靠i传输的选项，传输到故障节点上的tuples将不会收到应答确认，spout会因为超时而重新发射原始的tuple。这样的过程会一直重复直到topology从故障中恢复开始正常处理数据。</p>
<h2 id="Zookeeper的作用"><a href="#Zookeeper的作用" class="headerlink" title="Zookeeper的作用"></a>Zookeeper的作用</h2><p>Storm 主要使用 ZooKeeper 来协调一个集群中的状态信息,比如任务的分配情况,worker 的状态,supervisor 之间的 nimbus 的拓扑度量。nimbus 和 supervisor 节点之间的通信主要是结合 ZooKeeper 的状态变更通知和监控通知来处理的。</p>
<h1 id="Storm程序框架"><a href="#Storm程序框架" class="headerlink" title="Storm程序框架"></a>Storm程序框架</h1><h2 id="topology提交"><a href="#topology提交" class="headerlink" title="topology提交"></a>topology提交</h2><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>使用LocalCluster类将topolog运行在本地模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalCluster cluster=<span class="keyword">new</span> LocalCluster();</div><div class="line">cluster.submitTopology(TOPOLOGY_NAME, config, builder.createTopology());</div></pre></td></tr></table></figure>
<p>一般得例子为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalRunningTopology</span> <span class="keyword">extends</span> <span class="title">ExclaimBasicTopo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        LocalRunningTopology topo = <span class="keyword">new</span> LocalRunningTopology();</div><div class="line">        Config conf = <span class="keyword">new</span> Config();</div><div class="line">        conf.setDebug(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">        cluster.submitTopology(<span class="string">"test"</span>, conf, topo.buildTopology());</div><div class="line">        Utils.sleep(<span class="number">100000</span>);</div><div class="line">        cluster.killTopology(<span class="string">"test"</span>);</div><div class="line">        cluster.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>提交一个topology到远程集群就非常简单了，只需要利用StormSubmitter类中同样的方法和名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StormSubmitter.submitTopology(TOPOLOGY_NAME, config, builder.createrTopology());</div></pre></td></tr></table></figure>
<p>一般的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterRunningTopology</span> <span class="keyword">extends</span> <span class="title">ExclaimBasicTopo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        String topoName = <span class="string">"test"</span>;</div><div class="line"></div><div class="line">        ClusterRunningTopology topo = <span class="keyword">new</span> ClusterRunningTopology();</div><div class="line">        Config conf = <span class="keyword">new</span> Config();</div><div class="line">        conf.setDebug(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        conf.setNumWorkers(<span class="number">3</span>);</div><div class="line"></div><div class="line">        StormSubmitter.submitTopology(topoName, conf, topo.buildTopology());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实际的例子"><a href="#实际的例子" class="headerlink" title="实际的例子"></a>实际的例子</h3><p>在实际的程序里，本地和集群是混绑在一起的，用传入参数以示区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        ExclaimBasicTopo topo = <span class="keyword">new</span> ExclaimBasicTopo();</div><div class="line">        Config conf = <span class="keyword">new</span> Config();</div><div class="line">        conf.setDebug(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            conf.setNumWorkers(<span class="number">3</span>);</div><div class="line"></div><div class="line">            StormSubmitter.submitTopology(args[<span class="number">0</span>], conf, topo.buildTopology());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">            cluster.submitTopology(<span class="string">"test"</span>, conf, topo.buildTopology());</div><div class="line">            Utils.sleep(<span class="number">100000</span>);</div><div class="line">            cluster.killTopology(<span class="string">"test"</span>);</div><div class="line">            cluster.shutdown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Spout"><a href="#Spout" class="headerlink" title="Spout"></a>Spout</h2><p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-spout.jpg" alt="spout"></p>
<p>Spout最顶层抽象的是<strong>ISPout</strong>接口：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-ISpout.jpg" alt="ISpout"></p>
<h2 id="Bolt"><a href="#Bolt" class="headerlink" title="Bolt"></a>Bolt</h2><p>自带的Blot类的关系见下图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-bolt.jpg" alt="bolt"></p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-IBolt.jpg" alt="IBolt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS7.0的常用配置]]></title>
      <url>http://wangzzu.github.io/2015/05/25/centos70/</url>
      <content type="html"><![CDATA[<h1 id="Windows开机引导"><a href="#Windows开机引导" class="headerlink" title="Windows开机引导"></a>Windows开机引导</h1><p>在<code>/etc/grub.d/40_custom</code>中加入以下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">menuentry <span class="string">"Windows"</span>&#123;</div><div class="line">    <span class="built_in">set</span> root=(hd0,1)</div><div class="line">    chainloader +1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后更新引导</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grub2-mkconfig -o /boot/grub2/grub.conf</div></pre></td></tr></table></figure>
<h1 id="挂载NTFS分区的硬盘"><a href="#挂载NTFS分区的硬盘" class="headerlink" title="挂载NTFS分区的硬盘"></a>挂载NTFS分区的硬盘</h1><p><a href="http://www.rpmfind.net/linux/rpm2html/search.php" target="_blank" rel="external">linux仓库</a><br>用yum安装ntfs-3g</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install fuse-ntfs-3g</div></pre></td></tr></table></figure>
<p>安装好ntfs-3g之后，系统就可以识别NTFS分区的硬盘了。</p>
<h1 id="开机自动挂载Windows下的ntfs磁盘"><a href="#开机自动挂载Windows下的ntfs磁盘" class="headerlink" title="开机自动挂载Windows下的ntfs磁盘"></a>开机自动挂载Windows下的ntfs磁盘</h1><p><code>fdisk -l</code>查看windows分区信息</p>
<p>用/mnt/winE挂载Windows下的E盘:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /mnt</div><div class="line">mkdir winE</div><div class="line">mount -t ntfs-3g /dev/sda3 /mnt/winE</div></pre></td></tr></table></figure>
<p>输入以下命令，查看信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -Th</div></pre></td></tr></table></figure>
<p>实现开机自动挂载，需要编辑<code>/etc/fstab</code>文件(编辑之前尽量先备份)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp /etc/fstab /etc/fstab_cp</div><div class="line">vim /etc/fstab</div></pre></td></tr></table></figure>
<p>保存后退出就可以实现开机自动挂载了。</p>
<h1 id="为软件建立桌面快捷方式"><a href="#为软件建立桌面快捷方式" class="headerlink" title="为软件建立桌面快捷方式"></a>为软件建立桌面快捷方式</h1><p>在<code>/usr/share/applications</code>下建立一个.desktop文件即可。<br>以eclipse为例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[Desktop Entry]</div><div class="line">Categories=Development;</div><div class="line">Comment[zh_CN]=</div><div class="line">Comment=</div><div class="line">Exec=/home/Matt/Software/eclipse/eclipse</div><div class="line">GenericName[zh_CN]=IDE</div><div class="line">GenericName=IDE</div><div class="line">Icon=/home/Matt/Software/eclipse/icon0.png</div><div class="line">MimeType=</div><div class="line">Name[zh_CN]=Eclipse</div><div class="line">Name=eclipse</div><div class="line">Path=</div><div class="line">StartupNotify=<span class="literal">true</span></div><div class="line">Terminal=<span class="literal">false</span></div><div class="line">Type=Application</div><div class="line">X-DBUS-ServiceName=</div><div class="line">X-DBUS-StartupType=</div><div class="line">X-KDE-SubstituteUID=<span class="literal">false</span></div><div class="line">X-KDE-Username=owen</div></pre></td></tr></table></figure>
<p>一般只有三个地方<code>Exec, Icon, Name</code>需要我们去修改。<br>建立好eclipse.desktop文件后，把这个文件移到<code>/home/WM/Desktop</code>下，并改变这个文件的所有者和所属用户组。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> chmod +x IntelliJIDE.desktop</div><div class="line">cp IntelliJIDE.desktop /home/Matt/Desktop/</div><div class="line"><span class="built_in">cd</span> /home/Matt/Desktop</div><div class="line">chown Matt IntelliJIDE.desktop</div><div class="line">chgrp Matt IntelliJIDE.desktop</div></pre></td></tr></table></figure>
<h1 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h1><p><a href="http://chrome.richardlloyd.org.uk/install_chrome.sh" target="_blank" rel="external">下载</a>自动安装脚本<br>然后使用gedit编辑install—chrome.sh，使用find功能查找并将</p>
<p>其中的<code>http://omahaproxy.appspot.com</code>改为<code>https://dl.google.com/linux/direct
/google-chrome-stable_current_x86_64.rpm</code></p>
<p>打开终端，进入chrome.sh文件所在目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod u+x install_chrome.sh</div><div class="line">./install_chrome.sh</div></pre></td></tr></table></figure>
<p><a href="http://www.google.cn/intl/zh-CN/chrome/browser/thankyou.html?brand=CHUN&amp;installdataindex=chinabookmarkcontrol&amp;platform=linux" target="_blank" rel="external">下载chrome最新版rpm包</a></p>
<h1 id="为Terminal设置快捷键"><a href="#为Terminal设置快捷键" class="headerlink" title="为Terminal设置快捷键"></a>为Terminal设置快捷键</h1><p>一般设置为：Ctrl+Alt+T</p>
<p> <a href="http://jingyan.baidu.com/album/cb5d61053598ed005d2fe05c.html?picindex=7" target="_blank" rel="external">Terminal</a></p>
<p>Setting》》点击Keyboard》》选择左边Shortcuts –&gt;Custom Shortcuts：</p>
<p>点击旁边的+号，然后输入（Name那儿随便写）,Command填写<code>/usr/bin/gnome-terminal</code>.</p>
<p>点Apply，然后将它的快捷键设置为Ctrl+Alt+T:</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p><a href="http://www.centoscn.com/CentOS/config/2014/1023/3993.html" target="_blank" rel="external">网络配置</a></p>
<h1 id="局域网内共享文件夹"><a href="#局域网内共享文件夹" class="headerlink" title="局域网内共享文件夹"></a>局域网内共享文件夹</h1><p>进入文件内，输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m SimpleHTTPServer 8080</div></pre></td></tr></table></figure>
<p>然后用在firewall中把端口8080打开即可，用tcp连接。</p>
<h1 id="软件库"><a href="#软件库" class="headerlink" title="软件库"></a>软件库</h1><p>安装软件库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm</div><div class="line">rpm -Uvh http://ftp6.sjtu.edu.cn/fedora/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</div></pre></td></tr></table></figure>
<p><a href="http://www.dedoimedo.com/computers/centos-7-perfect-desktop.html" target="_blank" rel="external">常用软件</a></p>
<h1 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h1><p><a href="http://dargonjack.blog.51cto.com/6294601/1334685" target="_blank" rel="external">乱码问题</a></p>
<h2 id="gedit中文乱码"><a href="#gedit中文乱码" class="headerlink" title="gedit中文乱码"></a>gedit中文乱码</h2><p>在终端输入一下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gsettings <span class="built_in">set</span> org.gnome.gedit.preferences.encodings auto-detected <span class="string">"['UTF-8', 'GB18030', 'GB2312', 'GBK', 'BIG5', 'CURRENT', 'UTF-16']"</span></div><div class="line">$ gsettings <span class="built_in">set</span> org.gnome.gedit.preferences.encodings shown-in-menu <span class="string">"['UTF-8', 'GB18030', 'GB2312', 'GBK', 'BIG5', 'CURRENT', 'UTF-16']"</span></div></pre></td></tr></table></figure>
<h2 id="Vim中文编码"><a href="#Vim中文编码" class="headerlink" title="Vim中文编码"></a>Vim中文编码</h2><p>编辑用户主目录下.vimrc(如果没有这创建touch  .vimrc)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$vim</span> .vimrc</div><div class="line"><span class="keyword">if</span> (has(<span class="string">"gui_running"</span>))</div><div class="line">    <span class="built_in">set</span> guifont=Bitstream\ Vera\ Sans\ Mono\ 10</div><div class="line">endif</div><div class="line"><span class="built_in">set</span> fencs=utf-8,ucs-bom,<span class="built_in">shift</span>-jis,gb18030,gbk,gb2312,cp936</div><div class="line"><span class="built_in">set</span> termencoding=utf-8</div><div class="line"><span class="built_in">set</span> encoding=utf-8</div><div class="line"><span class="built_in">set</span> fileencodings=ucs-bom,utf-8,cp936</div><div class="line"><span class="built_in">set</span> fileencoding=utf-8</div></pre></td></tr></table></figure>
<p>保存退出<br>此时不论是正文还是标题都不会有乱码出现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Strom之tuple]]></title>
      <url>http://wangzzu.github.io/2015/05/21/stromtuple/</url>
      <content type="html"><![CDATA[<p>这几天一直在看storm，其中注意到了storm中主要的数据结构类型tuple，刚开始对这种数据还是很不理解，看几个程序之后，才豁然开朗，下面就主要介绍一些storm中最简单的、最基础的东西——tuple。</p>
<p>storm中的数据首先是有spout收集，类似于一个消息源，spout的open()函数一般就是接收数据的地方，然后spout的 nextTuple()是发送(emit)tuple的地方。tuple到底是什么？感觉还是用英语来说比较容易理解吧，”A tuple is a named of values where each value can be any type.”  tuple是一个类似于列表的东西，存储的每个元素叫做field（字段）。我们用getString(i)可以获得tuple的第i个字段。而其中的每个字段都可以任意类型的，也可以一个很长的字符串。我们可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String A = tuple.getString(<span class="number">0</span>);</div><div class="line"><span class="keyword">long</span> a= tuple.getLong(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>来得到我想要的数据，不过前提你是要知道你的tuple的组成。具体tuple是什么类型，完全取决于自己的程序，取决于spout中nextTuple()方法中emit发送的类型。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka常用的一些命令]]></title>
      <url>http://wangzzu.github.io/2015/05/20/KafkaOrder/</url>
      <content type="html"><![CDATA[<h1 id="开启Kafka"><a href="#开启Kafka" class="headerlink" title="开启Kafka"></a>开启Kafka</h1><p>先进入kafka的安装目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-server-start.sh config/server.properties</div></pre></td></tr></table></figure>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>有以下两种方式来运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -Djava.ext.dirs=/opt/kafka_2.10-0.8.1.1/libs -jar <span class="built_in">test</span>Producer.jar  </div><div class="line">java -cp traffic-distribution.jar producer.producer /home/matt/<span class="built_in">test</span>/ topicName ...</div></pre></td></tr></table></figure>
<p>第一种是jar包中没有打入相关依赖包的情况；<br>第二种是jar宝中已经包含相关依赖包。</p>
<h1 id="列出所有的topic"><a href="#列出所有的topic" class="headerlink" title="列出所有的topic"></a>列出所有的topic</h1><p>列出当前集群上的所有topic：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --list --zookeeper serverIP:serverPort</div></pre></td></tr></table></figure>
<p>注：serverIP为zookeeper所在机器的IP，serverPort为对应的端口。</p>
<h1 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h1><p>删除topic的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-run-class.sh kafka.admin.DeleteTopicCommand -topic <span class="built_in">test</span> -zookeeper serverIP:serverPort</div></pre></td></tr></table></figure>
<p>这种删除方式只是删除了topic，但是该topic中Partition的数据依然存在，等数据过期之后就会自动删除。（也可以手动删除/tmp/kafka-logs/下的partition信息）</p>
<h1 id="kafka集群设置"><a href="#kafka集群设置" class="headerlink" title="kafka集群设置"></a>kafka集群设置</h1><p>主要是配置kafka的config的<code>server.properties</code>文件，后面我写一篇kafka安装配置的blog。</p>
<h1 id="查看topic的信息"><a href="#查看topic的信息" class="headerlink" title="查看topic的信息"></a>查看topic的信息</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --describe --zookeeper serverIP:serverPort --topic <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h1 id="删除group"><a href="#删除group" class="headerlink" title="删除group"></a>删除group</h1><p>进入zookeeper的安装目录，如<code>/opt/cloudera/parcels/CDH/bin/</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sh zookeeper-client</div><div class="line">ls /consumers</div><div class="line">rmr /consumers/groupName</div></pre></td></tr></table></figure>
<h1 id="开启topic"><a href="#开启topic" class="headerlink" title="开启topic"></a>开启topic</h1><p>建立topic的几种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --zookeeper serverIP:serverPort --create --topic <span class="built_in">test</span> --partitions 1 --replication-factor 1</div><div class="line">bin/kafka-topics.sh --zookeeper serverIP:serverPort --create --topic <span class="built_in">test</span> --replica-assignment 29,29</div></pre></td></tr></table></figure>
<p>第一种是一般的方式，建立的topic的partition为1，replication为1；<br>第二种是直接指定partition所在机器。</p>
<h1 id="KafkaOffsetMonitor"><a href="#KafkaOffsetMonitor" class="headerlink" title="KafkaOffsetMonitor"></a>KafkaOffsetMonitor</h1><p>使用KafkaOffsetMonitor对kafka集群进行监控。</p>
<p>KafkaOffsetMonitor的<a href="https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar" target="_blank" rel="external">jar包下载</a>,<a href="https://github.com/quantifind/KafkaOffsetMonitor" target="_blank" rel="external">源码地址</a>。</p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk serverIP1,serverIP2 --port 8080 --refresh 10.seconds --retain 2.days</div></pre></td></tr></table></figure>
<p>参数的意思是：</p>
<ul>
<li><strong>ZK</strong> the ZooKeeper hosts</li>
<li><strong>port</strong> on what port will the app be available</li>
<li><strong>refresh</strong> how often should the app refresh and store a point in the DB</li>
<li><strong>retain</strong> how long should points be kept in the DB</li>
<li><strong>dbName</strong> where to store the history (default ‘offsetapp’)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么你应该（从现在就开始）写博客【转】]]></title>
      <url>http://wangzzu.github.io/2014/10/24/hello-world/</url>
      <content type="html"><![CDATA[<p>向大家推荐一篇blog，刘未鹏大神的<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a>.下面的内容<strong>转载</strong>于这篇博文。</p>
<h3 id="1-为什么你应该（从现在开始就）写博客"><a href="#1-为什么你应该（从现在开始就）写博客" class="headerlink" title="1.为什么你应该（从现在开始就）写博客"></a>1.为什么你应该（从现在开始就）写博客</h3><p>用一句话来说就是，写一个博客有很多好处，却没有任何明显的坏处。（阿灵顿的情况属于例外，而非常态，就像不能拿抽烟活到一百岁的英国老太太的个例来反驳抽烟对健康的极大损伤一样）</p>
<p>让我说得更明确一点：用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。Note：碎碎念不算思考、心情琐记不算思考、唠唠叨叨也不算思考、没话找话也不算思考，请以此类推。</p>
<p>下面是我个人认为写一个长期的<strong>价值博客</strong>的最大的几点好处：</p>
<p>1). <strong>能够交到很多志同道合的朋友</strong>。我自己既写博客，也读别人的博客，在这个时代，对于生活中的绝大多数人来说，拓宽朋友圈子的途径几乎只有一个，通过网络，而如何在网络中寻找到气味相投的朋友，如何判断别人和自己是否有共同语言？显然，通过天天在SNS上碎碎念的那些日记是难以做到的。我佩服的一些朋友几乎全都是长期用博客记录想法的人，<strong>因此，和他们即便不打照面，也是心照不宣</strong>。即便素未谋面也能坐下来就聊得热火朝天。</p>
<p>为什么博客在结交志同道合的朋友方面的潜力要远胜于原始的交谈方式？很简单，<strong>第一，博客无地域限制，整个互联网上从A到B只有一个点击的距离</strong>，而传统的建立朋友圈子的方法则受到地域限制,<strong>第二</strong>，也是更重要的一点，即如果按照以前结交朋友的方式，需要互相聊天，交流观点，然后才逐渐熟悉起来，这需要一个较长的过程，而且更糟糕的是，当你遇到另一个陌生人，又要把整个过程重复一次，表达你已经对老友表达过的那番想法。可博客却做到了“<strong>一次表达，无数次阅读</strong>”，当我看到一个写了好几年的博客，看完了之后我仿佛和这个人交谈了很久，用程序员们喜欢听的话来说就是，“<strong>博客极大地增强了话语的复用性</strong>”。</p>
<p>我曾在CSDN上写了近六年的博客，在一年半前建立了一个Google Groups（TopLanguage），由于我的博客的长期阅读者都是互相有共同语言的，因此这个Group一开始就热火朝天，而高质量的技术讨论则进一步吸引了更多的牛人的参与，雪球滚起来之后，就很难停下来了，将近一年半下来，从这个Group的讨论中我获益良多[1]。而对于非程序员朋友，科学松鼠会则是一个很好的例子。</p>
<p>2). <strong>书写是为了更好的思考</strong>。我在<a href="http://delicious.com/pongba/toplanguage" target="_blank" rel="external">《书写是为了更好的思考》</a>里面详细总结了书写的好处，这里就不拷贝粘贴了。有些想法如果不写下来，也就忘掉了，有一个广为流传的《数学牛人们的轶事》（荣耀属于ukim）里面讲了希尔伯特的一个故事：一次在Hilbert的讨论班上，一个年轻人报告，其中用了一个很漂亮的定理，Hilbert说“这真是一个妙不可言（wunderbaschon）的定理呀,是谁发现的？”那个年轻人茫然的站了很久，对Hilbert说：“是你.……”。</p>
<p>3). <strong>“教”是最好的“学”。如果一件事情你不能讲清楚，十有八九你还没有完全理解</strong>。绝大多数人应该都知道在程序员行业面试官经常要求你讲解一个东西给他听，他会说他不懂这个东西（他如果真的不懂的话效果其实是最好的），而你的任务则是说到让他理解为止。</p>
<p>为了让一个不明白的人做到明白，你必须要知道从明白到不明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中整个的知识体系来个寻根究底，把藏在水面之下的那些东西统统挖出来，把大脑中的那些我们知道、但不知道自己知道的潜在概念或假设（assumptions）都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道、并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。</p>
<p>但是，你可能会怀疑，那除了能够讲清楚之外，弄清自己到底知道哪些东西还有其他什么好处吗？如果没有其他好处，那我又何必费这个劲呢？我又不当老师。</p>
<p>TopLanguage上的一位朋友sagasw曾经讲了这样一个小故事：<strong>据说在某个著名软件公司里，开发组的桌上会放着一只小熊，大家互相问问题之前，先对着小熊把问题说一遍，看能不能把问题描述的清晰，基本上说的比较有条理以后，答案也就随之而来了</strong>。当然，你不一定要对小熊说，你可以在大脑中虚构一个听众，一个不懂行的听众，然后你说给他听。这是可行的，我经常在路上用。不过如果你能坐下来，我建议你还是说给实际的听众听——即写下你的思考，因为书写是更好的思考。</p>
<p>我们的绝大多数知识在绝大多数时候都隐藏在潜意识中，其实我们意识的窗口很小，我们的工作记忆只能容纳寥寥数个条目（记得那个“看你能够记住屏幕上同时闪现的多少个数字”的flash小游戏吗？），我们平时所作的推理过程很大部分都是自动的，发生在潜意识中，而我们只能感知到一些中间结论。不信你回忆一下你在和别人讨论问题的时候有多少次觉得“<strong>反正就是这样，我感觉得到它是对的，但是你问我，我也说不清到底怎么回事”，对此你不觉得很奇怪吗？如果你都不能从逻辑上支持你的结论，你怎么就能确信它是对的呢？仅仅因为你的直觉强烈地告诉你它是对的？那如果旁边有另一个人，他和你持相反的观念，而他的直觉也强烈地告诉他他是对的。这时候你又怎么想？“他的直觉错了，我的直觉是对的”？难道你这么自信你的直觉是世界上最可靠的？</strong></p>
<p>我自己则是非常珍惜类似这样的机会，即当“我强烈地觉得它是对的，但我却说不出所以然来”，这时候<strong>往往是到大脑中翻箱倒柜的时候，弄清来龙去脉的时候，深入反思的时候，纠正一直以来错误的潜在前提假设的时候。另一方面，“我强烈地觉得这个说法有问题，但我却说不清它为什么有问题，到底哪有问题”</strong>，这也是一个极有意义的瞬间，它几乎总是意味着你对一个问题的认识有潜在的偏差，肯定是在你自己都没有觉知到的地方引入了一个潜在的假设、偷换了一个重要的概念，等等。而这种时候就是深入反思的时候，当你终于潜到问题的底层，触摸到问题的实质，把水面之下的冰山整体看清了的时候你会有一种通体舒泰的感觉。</p>
<p>为什么说以上这些？因为刚才说的是你必须等待这样的反思机会，<strong>但如果你选择经常总结自己的知识体系，并说出来给你的读者听，你就会发现你自己创造了这样的机会</strong>。如果我们平时不反思，我们觉得很多事情都是当然的，但结果如果要你一开口说给别人听，常常会发现事情就开始变得不那么明显了，你说着说着，就开始莫名其妙地发现自己需要用到“反正”这个词了。</p>
<p>于是，反思的机会就来了。</p>
<p><strong>一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能，而不是任它们在幕后阴险地左右你的思维</strong>。很多时候我们的思路出了问题并不是我们不会反思，而是不知道自己的思维中有那些隐含的假设（assumptions），如果你只感觉到答案，却不知道你大脑得到这个答案之前做了哪些推理，你又怎么知道哪一环可能出了问题呢？另一方面，一旦你弄清了自己到底是怎么想的，离意识到问题就不远了，很简单的道理——如果别人和你争辩的时候总是只摆立场，你就很难和他辩，但如果他把自己的推理过程原原本本暴露给你，批判起来总是容易得多的。（也正因为这个原因有很多人总是把逻辑藏在背后，不敢暴露出来）</p>
<p>绝大多数时候其实我们都会不假思索地得出一些结论，就像上了发条的自动机，但其实我们并不知道这些结论到底怎么来的，在思维的背后到底发生了哪些事情，故而当我们发现我们的结论错了的时候，一头雾水，没法着手寻找到底在哪错了。如果你注意一下很多人的发言（论坛、博客等等），如果你把他们的发言分为“前提”、“假设”、“逻辑”、“结论”这四个部分，你会发现一大堆人只会不停地下结论，摆立场，却见不到这些结论或离场的前提、假设和个中逻辑，倒也不是他们不愿意写出逻辑，而是因为反思自己的思维过程实在是一件困难非常的事情，我们的推理过程很大一部分发生在意识的水面之下，只有当有了重要结论的时候这条逻辑链才会浮出来冒一个泡，让我们的意识捕捉到。更何况绝大多数时候我们用的其实并不是完整严密的逻辑思维，而是思维捷径。</p>
<p><strong>去教一个完全不懂的人，则是一种最最强大和彻底的反思途径</strong>——因为他没有任何预备的知识，所以要让他弄懂你所知道的，你就必须彻底反思你的知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的，你不能自己站在11层上，然后假设你的读者站在第10层，指望着只要告诉他第11层有那些内容就让他明白。你的读者站在第一层，你必须知道你脚下踩着的另外10层到底是怎么构造的。<strong>这就迫使你对你所掌握的、或之前认为正确的那些东西作彻彻底底的、深刻的反思，你的受众越是不懂，你需要反思得就越深刻</strong>。</p>
<p>4). <strong>讨论是绝佳的反思</strong>。另一方面，<strong>很多时候我们并不是有机会说给完全不懂的人听，更大的可能性是说给同领域有一定基础的人听</strong>，这个时候并不代表就不能促使反思了，实际上，你会发现，如果你公开你的想法，<strong>几乎总能看到与你持不同意见的人</strong>，然后你通过比较你和他的观念之间的差别，会发现你们在一开始的思路上就存在差异，差异从哪里来的？在进一步讨论中你们就会不断地迫使对方拿出更深层次的理由，这同样也是一种非常有效地促使自己反思的方法，在讨论的过程中双方的理由自然会变得越来越深入，越来越接近问题的本质，<strong>一些平时难以注意到的深层面的差异性就会逐渐浮现出来，你也就多了一次难得的机会去审视自己的思维中到底存放了哪些错误的信息</strong>。</p>
<p>5). <strong>激励你去持续学习和思考</strong>。如果你没有持续学习和思考的习惯，你的博客很快就会没有内容可写，就只能整点碎碎念或者转载，然后你就会失去读者，然后你就会关掉博客，然后一旦关掉博客之后你也就死了写博客的心，然后就少了一条激励你去思考和总结的途径，然后你变得更不高兴总结和思考，然后…</p>
<p>为了打破这个死循环，不要永久停止更新你的博客，就算你两个月，三个月都不写，只要你每篇都是写自己思考的产物，写有价值的东西，在互联网上，金子的确总是会发光的，因为有无数的信息聚合平台在期待这些有价值的内容，有搜索引擎为你的内容提供海量的潜在读者，有海量的人肉在手动挖掘和转载那些有价值的东西。<strong>我们所能做的最差的一个决策莫过于停止做一件没有任何坏处，却有一大堆好处的事情</strong>。</p>
<p>为了让你的博客有价值，你必须不断总结自己学习的结果，你必须不断思考，给出比别人深刻、独到的见解。这看起来有点本末倒置，但很快本和末就会正过来。</p>
<p>6). <strong>学会持之以恒地做一件事情</strong>。很多人在生活中容易觉得迷失，不知道想要做什么，是因为没有一件能够持续地做的事情，用俗话来说就是没有主心骨。用积极心理学的话来说就是没有一件能够创造流体验的事情，而书写自己的思想则是一件容易产生流体验的事情，在书写的时候，特别是理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。不过前提是你得开始，并且坚持过一开始的困难期，以后的一切便成了习惯成自然。</p>
<p>7). <strong>一个长期的价值博客是一份很好的简历</strong>。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到<strong>价值博客的时代</strong>，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但<strong>至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环</strong>。</p>
<h3 id="2-怎么做到长期写一个价值博客"><a href="#2-怎么做到长期写一个价值博客" class="headerlink" title="2.怎么做到长期写一个价值博客"></a>2.怎么做到长期写一个价值博客</h3><p>注意到我并没有说“怎么做到长期<strong>坚持</strong>写一个价值博客”，因为当思考和总结成为习惯之后，诉诸文字以及借助书写来进一步思考就变成了一件自然而然的事情，就变成了一件“因为你在思考和总结从而必须书写下来”的事情，博客就变成了副产品。</p>
<p>一开始的时候你是因为要写博客而去使劲地思考和总结，指望给出令人眼睛一亮的东西，到了后来，就变成了因为你习惯了思考和总结，因为你意识到书写是更好的思考，你就必须使你的想法成为文字。至此本和末就会各归原位，不再颠倒。</p>
<p>怎样做到长期写一个价值博客？也许有人会给出很多有趣有用的小技巧来提供动机和激励，譬如如何做SEO，如何鼓励读者留言等等，但是这些我都不想说，我只想说最最重要的，那就是：</p>
<p><strong>让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来</strong>。</p>
<p>就像那句经常被人传阅的话：只做你最感兴趣的事情，钱会随之而来[2]。</p>
<p>这方面的具体例子大家可以留意一下，随处可见，就不一一举了。我想再重复一下的是，千万不要碎碎念，我能理解每个人都想偶尔发发牢骚的冲动，但是现在已经有了一个很好的窗口：twitter，所以立即停止在你的博客上碎碎念，阅读博客的人希望得到信息而非噪音。<strong>如果实在忍不住想碎碎念的话不妨换一下位置，这么来告诉自己：如果你看到别人博客来上这么一段，你会有兴趣看吗？</strong></p>
<h3 id="3-可能出现的问题以及怎样应付"><a href="#3-可能出现的问题以及怎样应付" class="headerlink" title="3.可能出现的问题以及怎样应付"></a>3.可能出现的问题以及怎样应付</h3><p>即便上文给出了N条写博客的理由，但有时候只要一条不写的理由就会让人停止做一件事情。所以我特别加上一节“可能出现的问题以及怎样应付”，《影响力2》[3]第五章雄辩地证明，“Much of Will is Skill”，<strong>意志力很大程度上来源于有正确的方法，而非天生</strong>。</p>
<p>1). <strong>担心别人认为没有价值</strong>。事实是，你面临过的问题总会有人面临过，你独立思考了，别人没有，你的文章对他们就会有价值。当然，肯定会对某些人没有价值，他们早就知道了，但就算你再厉害，也总是有人比你厉害的，不能说因为这些原因就不记录你自己的想法了，你自己思考了之后理解得最深刻，就算有别人想过了，总有人没有想到的。况且，思考成了习惯，你的思考能力也会越来越强，你的文章也会越来越有价值。重复，<strong>无论你面临什么困惑，总会有很多人同样面临过，于是你苦苦思索之后的结果，肯定会对很多人有意义</strong>。</p>
<p>或者，<strong>你想通了之后觉得其实也很简单于是不愿意或者不好意思写了，但要知道，问题在想通了之后总是简单的，问题的困难程度不在于想通了之后还觉得有多难，而在于从你觉得它难到你觉得它简单需要耗费多少思维体力</strong>，你耗费的时间越长，说明有越多的人最终还是没有想明白（路越长走到底的人越少）。</p>
<p>最后，虽然我现在看一年前的文章觉得挺不成熟，但是如果没有那些不成熟的思考，也不会有现在更成熟的思考，我几年后来看现在写的东西，还是会觉得不成熟。</p>
<p>2). <strong>担心想法太幼稚或有漏洞等等被别人笑话</strong>。人非圣贤。正是因为单个人的想法总是有漏洞，才值得拿出来交流（《书写是更好的思考》，讨论是绝佳的反思），被别人指出问题正是改进的空间，藏着掖着的想法永远不可能变得更成熟。</p>
<p>Much of intelligence is knowledge，有这么一个非常发人深省的经典心理学实验[4]：</p>
<p>将孩子们分成两组，通过给他们不同的阅读材料让一组相信智力是天生的，不可在后天改变的，另一组则让他们相信智力其实只是知识和技能的代名词，完全是后天习得的。接下来让他们做一组任务，那些被相信智力天生说的孩子，倾向于回避困难的任务，选择较容易的任务，这里的逻辑想必是这样的：如果做困难的任务，就增大了失败的几率，就在降低了自己在别人和自己心目中的智力的值。为了保护这个智力的值不被降低，应该避免那些有失败风险的项目。而另一组孩子则对于有挑战性的事情跃跃欲试，并且在失败的时候明显没有前者沮丧，因为失败也是学得新的东西，不管怎样都是“智力”的提高。</p>
<p>况且，只会批判乃至嘲笑别人的人是最不知道怎么建设的人，忽略他们。</p>
<p>3).  <strong>得不到激励</strong>。这其实是个最无聊的问题了，只有写碎碎念的博客才会面对“激励”的问题。如果写自己的总结，写自己独立的思考，那么书写下来、理解通透，本身就是一个极大的激励。就算放在自己的私密笔记本里面也一样有成就感。况且，如果你真做到了书写价值博客，那么绝对不用担心你的观点得不到传播，也许一开始会耗时长一点，但是这在任何事情上都是必要的初始阶段，Gmail小组的核心人物、FriendFeed创始人Paul Buchheit，和编程界名博Coding Horror的博主Jeff Atwood都曾经感叹过：Overnight success takes a long time （(1)，(2)），不过对于价值博客来说，现在网络上的聚合类服务这么多，机器的、人肉的、半人肉的都有，情况又要好得多了，而且我相信情况还会越来越好。</p>
<p>4). <strong>写不出来</strong>。这个问题也比较无聊，思考本不是一件急于求成的事情。长期订阅我的博客的朋友知道我一般发文频率在一个月三五篇，实际上有不少次我个把月也不发布文章，原因很简单，要么是有手头的事情要处理思考的时间被压缩了，要么是遇到比较大或者比较困难的问题需要长时间的思考和积淀，没有关系，如果没有想清楚就再想想，爱思考的人和不爱思考的人有一个本质的区别，前者在生活中总是挂着几个问题在大脑中，它们时常都会冒出来骚扰你一下，让你琢磨琢磨，不爱思考的则是没事不主动想问题，遇到问题还要先想想是否能找捷径（找人帮忙）解决。</p>
<p>无论如何，不用急于求成，在一个主题上深入下去思考，总能挖到别人挖不到的角落。你能让一个问题在大脑中停留的时间越长，就越是能够发现新的东西，一般来说，我认为有价值的问题我会让他在意识或潜意识中待短则一个星期，长则一个月（视问题大小而定），利用走路吃饭的时间琢磨（我发现很多我佩服的人也都有这个习惯），<strong>有时即便已经想通了写下来了发出去了，大脑仍然还是会在回味问题，还没有把它撤出潜意识，然后看到某篇文章或某本书的时候忽然又有所新的感悟</strong>。</p>
<p><strong>能够把问题长时间停靠在潜意识中是一种技能，能够带来很大的好处，停留得越长你越琢磨得透彻，比别人看到的就越多</strong>。我们必须要带着问题的眼镜看待事物才能发现新的视角，否则就会出现视而不见效应，别的不说，广为人知的例子是阿基米德的“尤里卡！”，如果不是长时间琢磨着一个问题，一直把它放在思维中，是不会从洗澡领悟到“排水测体积”的，否则他洗了那么多年澡怎么不早发现呢？[5]</p>
<p>所以，如果你习惯了思考问题，就总会有东西写，先有思考，然后有总结，然后在总结中进一步思考。</p>
<p>当然你也可以试试把不成熟的想法写下来，试图整理成条理清晰的文字，然后看看能否在整理的过程中走得更远。这往往是可行的。比如这篇文章在我的简记里面原本其实只有三行字（包含大约十来个备忘关键词），而最初在我的大脑里面其实只有一个走路时冒出来的问题——为什么要写博客？</p>
<p>–</p>
<p>[1] 你可以看一下我<a href="http://delicious.com/pongba/toplanguage" target="_blank" rel="external">收藏的一些精彩主题</a>。</p>
<p>[2] 尽管我并不完全同意这句话本身，但它这种解决问题链上更基本环节的问题的精神是我赞同的。</p>
<p>[3] 《影响力2》这个名字起得很聪明，其实它并不是《影响力》的作者写的。</p>
<p>[4] 我忘了这则实验的出处了，但实验的精神是记忆犹新的，哪位同学记得原始出处的麻烦提醒我一下。</p>
<p>[5] 对于阿基米德这个故事的真实性是有争议的，毕竟几千年久远的事情谁弄得清呢。但是故事的道理是很本质的，我们平时也经常有类似的体验，加上阿基米德的“尤里卡”实在太出名了，所以我相信用用无妨。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Matt 的中文简历]]></title>
      <url>http://wangzzu.github.io/2014/09/01/resume/</url>
      <content type="html"><![CDATA[<hr>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>王蒙/男/1992</li>
<li>硕士/北京邮电大学信息与通信工程（2014-2017） 本科/郑州大学电子信息工程专业（2010-2014）</li>
<li>技术博客：<a href="http://wangzzu.github.io">Matt’s Blog</a></li>
<li><p>Github：<a href="http://github.com/wangzzu" target="_blank" rel="external">wangzzu</a></p>
<hr>
</li>
</ul>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>Email：wangm92 # 163.com or mattbupt # gmail.com</li>
<li><p>微博：<a href="http://weibo.com/wangzzu" target="_blank" rel="external">柳年思水</a></p>
<hr>
</li>
</ul>
<h1 id="工作实习经历"><a href="#工作实习经历" class="headerlink" title="工作实习经历"></a>工作实习经历</h1><h2 id="美团网-（-2016年7月-至今-）"><a href="#美团网-（-2016年7月-至今-）" class="headerlink" title="美团网 （ 2016年7月 ~ 至今 ）"></a>美团网 （ 2016年7月 ~ 至今 ）</h2><p>技术工程部-数据平台组  系统开发实习生</p>
<h3 id="Kafka-身份认证与权限管理平台"><a href="#Kafka-身份认证与权限管理平台" class="headerlink" title="Kafka 身份认证与权限管理平台"></a>Kafka 身份认证与权限管理平台</h3><ul>
<li>项目简介：建立一个统一 Kafka 数据账户管理平台，并对账户设置相应的权限，加强数据的安全性。</li>
<li>工作内容<ol>
<li>阅读并修改 Kafka new Consumer 和 Security 部分的<strong>源码</strong>，熟悉 new Consumer 部分的设计思想;</li>
<li>设计和开发 Kafka 身份认证和权限管理平台。</li>
</ol>
</li>
</ul>
<h2 id="北邮网络体系构建与融合实验室-（2014年9月-2016年6月）"><a href="#北邮网络体系构建与融合实验室-（2014年9月-2016年6月）" class="headerlink" title="北邮网络体系构建与融合实验室 （2014年9月 ~ 2016年6月）"></a>北邮网络体系构建与融合实验室 （2014年9月 ~ 2016年6月）</h2><p>研究生期间主要在做实验室的项目。</p>
<h3 id="日志快速查询系统"><a href="#日志快速查询系统" class="headerlink" title="日志快速查询系统"></a>日志快速查询系统</h3><p>2015.08 - 2016.01</p>
<ul>
<li>项目描述：基于 HBase 开发常用字段的快速查询系统</li>
<li>工作内容<ol>
<li>改写 InputFormat，改进后 MR 作业读取 csv 文件的平均 Map 时间节省了<strong>60.6%</strong>，读取 lzo 压缩 文件的平均 Map 时间节省了<strong>69.1%</strong>；</li>
<li>开发 Kafka 客户端，代替运营商省网项目中 importer，将数据传入到 hdfs 和 HBase，该运营商每天的数据量大约是1.2TB；</li>
<li>利用 HBase 基于 RowKey 的快速查询为 hdfs 上的文件话单建立常用字段索引表。</li>
</ol>
</li>
</ul>
<h3 id="网络流量流向分析系统"><a href="#网络流量流向分析系统" class="headerlink" title="网络流量流向分析系统"></a>网络流量流向分析系统</h3><p>2015.02 - 2015.07</p>
<ul>
<li>项目描述：将实验室的实时网络访问信息以地图的形式进行展示。</li>
<li>工作内容<ol>
<li>设计和搭建实验室数据实时处理平台，使用 Flume 和 Kafka 实时监控实验室话单；</li>
<li>完成基于 Storm 的<strong>流处理模块开发</strong>；</li>
<li>在流处理模块中设计了数据聚合算法。</li>
</ol>
</li>
</ul>
<h3 id="Kafka-性能测试与优化"><a href="#Kafka-性能测试与优化" class="headerlink" title="Kafka 性能测试与优化"></a>Kafka 性能测试与优化</h3><p>2014.09 - 2015.05</p>
<ul>
<li>项目描述：测试和优化 Kafka 性能，设计并实现流处理系统。</li>
<li>工作内容<ol>
<li>测试和优化 producer、consumer 性能，优化后 producer 速度提高<strong>14%</strong>，consumer 速度提高<strong>21%</strong>；</li>
<li>研究 Kafka 与 Storm、Spark Streaming 的集成，分别实现一个流量实时统计系统;</li>
<li>在 <strong>IHMSC2016</strong> 会议上以第一作者的身份发表一篇关于 Kafka 性能优化的<strong>论文</strong>。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><h3 id="Apache-Kafka"><a href="#Apache-Kafka" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h3><p> 为开源社区做的贡献：</p>
<ul>
<li><a href="https://issues.apache.org/jira/browse/KAFKA-4328" target="_blank" rel="external">KAFKA-4328</a>：在阅读源码中，发现其中在创建 zk 实例时，参数调用有误；</li>
</ul>
<h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><ul>
<li><a href="http://wangzzu.github.io/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍【译】</a>：翻译自 Confluent 官网博客；</li>
<li><a href="http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka/">Kafka的简单介绍</a>：Kafka 基本入门文章；</li>
<li><a href="http://wangzzu.github.io/2016/03/02/hadoop-shuffle/">MapReduce之Shuffle过程详述</a>：介绍 MapReduce 中最核心部分—— Shuffle 的一篇文章。</li>
</ul>
<h2 id="游记"><a href="#游记" class="headerlink" title="游记"></a>游记</h2><p>个人非常喜欢户外跟旅行，经常会在<a href="http://www.jianshu.com/users/e50b355579a9/latest_articles" target="_blank" rel="external">简书</a>上分享一些个人的旅行攻略。</p>
<ul>
<li><a href="http://www.jianshu.com/p/778513f9ce4c" target="_blank" rel="external">Travel to Haituo | 2016河北海坨山露营</a>：第一次去海坨，人生第一次重装爬山露营；</li>
<li><a href="http://www.jianshu.com/p/afffa111edd0" target="_blank" rel="external">Travel to Kubuqi | 2016端午库布其穿越</a>：这一次穿越遇到了很多臭味相投的朋友；</li>
<li><a href="http://www.jianshu.com/p/183cb4b10ed5" target="_blank" rel="external">Travel to Qinghai Lake | 2015暑假环骑青海湖</a>：从最开始的在学校论坛上发帖征集队友，到最后带领着七人的校友小分队完成环骑旅行；</li>
</ul>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul>
<li>熟悉 <strong>Kafka</strong>，了解 Flume，对 Kafka 框架有较深入理解；</li>
<li>熟悉 <strong>MapReduce</strong> 框架，熟悉 <strong>Storm</strong>，了解 Spark 和 Flink；</li>
<li>熟悉 <strong>Java</strong> 和 <strong>Linux</strong>，了解 SQL、Shell、Scala 和 Python，有两年 Java 开发经验;</li>
<li>CET-6，良好的英语文档的阅读能力和写作能力。</li>
</ul>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>简历模板参考<a href="https://github.com/geekcompany/ResumeSample/blob/master/java.md" target="_blank" rel="external">jobdeer java</a></p>
]]></content>
    </entry>
    
  
  
</search>
