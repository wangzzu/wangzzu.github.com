<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Kafka 0.10.0 SASL/PLAIN身份认证及权限实现]]></title>
      <url>http://wangzzu.github.io/2016/07/29/sasl-plain-kafka/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下使用官方发布的 Kafka 0.10.0 版如何实现 SASL/PLAIN 认证机制以及权限控制。</p>
<h1 id="Kafka-安全机制"><a href="#Kafka-安全机制" class="headerlink" title="Kafka 安全机制"></a>Kafka 安全机制</h1><p> Kafka 的安全机制主要分为两部分：</p>
<ul>
<li>身份认证（Authentication）：对client 与服务器的连接进行身份认证。</li>
<li>权限控制（Authorization）：实现对于消息级别的权限控制</li>
</ul>
<blockquote>
<p>In release 0.9.0.0, the Kafka community added a number of features that, used either separately or together, increases security in a Kafka cluster.<br>These features are considered to be of beta quality. The following security measures are currently supported:</p>
<ol>
<li>Authentication of connections to brokers from clients (producers and consumers), other brokers and tools, using either SSL or SASL (Kerberos). SASL/PLAIN can also be used from release 0.10.0.0 onwards.</li>
<li>Authentication of connections from brokers to ZooKeeper</li>
<li>Encryption of data transferred between brokers and clients, between brokers, or between brokers and tools using SSL (Note that there is a performance degradation when SSL is enabled, the magnitude of which depends on the CPU type and the JVM implementation.)</li>
<li>Authorization of read / write operations by clients</li>
<li>Authorization is pluggable and integration with external authorization services is supported</li>
</ol>
</blockquote>
<p>这段话的中文意思也就是说</p>
<ol>
<li>可以使用 SSL 或者 SASL 进行客户端（producer 和 consumer）、其他 brokers、tools与 brokers 之间连接的认证，SASL/PLAIN将在0.10.0中得到支持；</li>
<li>对brokers和zookeeper之间的连接进行Authentication；</li>
<li>数据传输用SSL加密，性能会下降；</li>
<li>对clients的读写操作进行Authorization；</li>
<li>Authorization 是pluggable，与外部的authorization services结合进行支持。</li>
</ol>
<h1 id="Kafka身份认证"><a href="#Kafka身份认证" class="headerlink" title="Kafka身份认证"></a>Kafka身份认证</h1><p>Kafka 目前支持SSL、SASL/Kerberos、SASL/PLAIN三种认证机制，关于这些认证机制的介绍可以参考一下三篇文章。</p>
<ul>
<li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="external">数字证书原理</a>;</li>
<li><a href="http://www.cnblogs.com/mailingfeng/archive/2012/07/18/2597392.html" target="_blank" rel="external">数字证书, 数字签名, SSL(TLS) , SASL</a>;</li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="external">SSL的延迟</a></li>
</ul>
<h2 id="SASL-PLAIN-认证"><a href="#SASL-PLAIN-认证" class="headerlink" title="SASL/PLAIN 认证"></a>SASL/PLAIN 认证</h2><p>可以参考<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a>，这个官方文档的中文版。</p>
<h3 id="Kafka-Server-端配置"><a href="#Kafka-Server-端配置" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h3><p>需要在 Kafka 安装目录下的config/server.properties文件中配置以下信息</p>
<h2 id="Kafka-Server-端配置-1"><a href="#Kafka-Server-端配置-1" class="headerlink" title="Kafka Server 端配置"></a>Kafka Server 端配置</h2><p>在 kafka 安装目录下的<code>config/server.properties</code>配置一下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listeners=SASL_PLAINTEXT://ip:pot</span><br><span class="line">security.inter.broker.protocol=SASL_PLAINTEXT</span><br><span class="line">sasl.mechanism.inter.broker.protocol=PLAIN</span><br><span class="line">sasl.enabled.mechanisms=PLAIN</span><br><span class="line">authorizer.class.name = kafka.security.auth.SimpleAclAuthorizer</span><br><span class="line">super.users=User:admin</span><br></pre></td></tr></table></figure>
<p>还需要配置一个名 <code>kafka_server_jaas.conf</code> 的配置文件，将配置文件放置在<code>conf</code>目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;admin&quot;</span><br><span class="line">    password=&quot;admin&quot;</span><br><span class="line">    user_admin=&quot;admin&quot;</span><br><span class="line">    user_alice=&quot;alice&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，我们配置了两个用户：admin 和 alice，密码分别为 admin 和 alice。<br>最后需要为 Kafka 添加 <code>java.security.auth.login.config</code> 环境变量。在 <code>bin/kafka-run-class.sh</code> 中添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KAFKA_SASL_OPTS=<span class="string">'-Djava.security.auth.login.config=/opt/meituan/kafka_2.10-0.10.0.0/config/kafka_server_jaas.conf'</span></span><br><span class="line"><span class="comment"># Launch mode</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$DAEMON_MODE</span>"</span> = <span class="string">"xtrue"</span> ]; <span class="keyword">then</span></span><br><span class="line">  nohup <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span> &gt; <span class="string">"<span class="variable">$CONSOLE_OUTPUT_FILE</span>"</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> <span class="variable">$JAVA</span> <span class="variable">$KAFKA_HEAP_OPTS</span> <span class="variable">$KAFKA_JVM_PERFORMANCE_OPTS</span> <span class="variable">$KAFKA_GC_LOG_OPTS</span> <span class="variable">$KAFKA_SASL_OPTS</span> <span class="variable">$KAFKA_JMX_OPTS</span> <span class="variable">$KAFKA_LOG4J_OPTS</span> -cp <span class="variable">$CLASSPATH</span> <span class="variable">$KAFKA_OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：实际上，我们只是添加了第一行，并在第4和第6行中添加了 $KAFKA_SASL_OPTS 这个环境变量。</p>
</blockquote>
<h3 id="KafkaClient-配置"><a href="#KafkaClient-配置" class="headerlink" title="KafkaClient 配置"></a>KafkaClient 配置</h3><p>首先需要在客户端配置 <code>kafka_client_jaas.conf</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KafkaClient &#123;</span><br><span class="line">  org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">  username=&quot;alice&quot;</span><br><span class="line">  password=&quot;alice&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在（producer 和 consumer）程序中添加环境变量和配置，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.security.auth.login.config"</span>, <span class="string">".../kafka_client_jaas.conf"</span>); <span class="comment">// 环境变量添加，需要输入配置文件的路径</span></span><br><span class="line">props.put(<span class="string">"security.protocol"</span>, <span class="string">"SASL_PLAINTEXT"</span>);</span><br><span class="line">props.put(<span class="string">"sasl.mechanism"</span>, <span class="string">"PLAIN"</span>);</span><br></pre></td></tr></table></figure>
<p>配置完以上内容后，就可以正常运行 producer 和 consumer 程序，如果账户密码错误的话，程序就不能正常进行，但是不会有任何提示，这方面后面会进行一些改进。</p>
<h1 id="Kafka权限控制"><a href="#Kafka权限控制" class="headerlink" title="Kafka权限控制"></a>Kafka权限控制</h1><p>这个小节介绍一下 Kafka 的 ACL 。</p>
<h2 id="权限的内容"><a href="#权限的内容" class="headerlink" title="权限的内容"></a>权限的内容</h2><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ</td>
<td>读取topic</td>
</tr>
<tr>
<td>WRITE</td>
<td>写入topic</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除topic</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建topic</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改topic</td>
</tr>
<tr>
<td>DESCRIBE</td>
<td>获取topic的信息</td>
</tr>
<tr>
<td>ClusterAction</td>
<td></td>
</tr>
<tr>
<td>ALL</td>
<td>所有权限</td>
</tr>
</tbody>
</table>
<p>访问控制列表ACL存储在zk上，路径为<code>/kafka-acl</code>。</p>
<h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>Kafka 提供的命令如下表所示</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default</th>
<th>Option type</th>
</tr>
</thead>
<tbody>
<tr>
<td>–add</td>
<td>Indicates to the script that user is trying to add an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–remove</td>
<td>Indicates to the script that user is trying to remove an acl.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–list</td>
<td>Indicates to the script that user is trying to list acts.</td>
<td></td>
<td>Action</td>
</tr>
<tr>
<td>–authorizer</td>
<td>Fully qualified class name of the authorizer.</td>
<td>kafka.security.auth.SimpleAclAuthorizer</td>
<td>Configuration</td>
</tr>
<tr>
<td>–authorizer-properties</td>
<td>key=val pairs that will be passed to authorizer for initialization. For the default authorizer the example values are: zookeeper.connect=localhost:2181</td>
<td></td>
<td>Configuration</td>
</tr>
<tr>
<td>–cluster</td>
<td>Specifies cluster as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–topic [topic-name]</td>
<td>Specifies the topic as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–group [group-name]</td>
<td>Specifies the consumer-group as resource.</td>
<td></td>
<td>Resource</td>
</tr>
<tr>
<td>–allow-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Allow</strong> permission. You can specify multiple –allow-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–deny-principal</td>
<td>Principal is in PrincipalType:name format that will be added to ACL with <strong>Deny</strong> permission. You can specify multiple –deny-principal in a single command.</td>
<td></td>
<td>Principal</td>
</tr>
<tr>
<td>–allow-host</td>
<td>IP address from which principals listed in –allow-principal will have access.</td>
<td>if –allow-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–deny-host</td>
<td>IP address from which principals listed in –deny-principal will be denied access.</td>
<td>if –deny-principal is specified defaults to * which translates to “all hosts”</td>
<td>Host</td>
</tr>
<tr>
<td>–operation</td>
<td>Operation that will be allowed or denied. Valid values are : Read, Write, Create, Delete, Alter, Describe, ClusterAction, All</td>
<td>All</td>
<td>Operation</td>
</tr>
<tr>
<td>–producer</td>
<td>Convenience option to add/remove acls for producer role. This will generate acls that allows WRITE, DESCRIBE on topic and CREATE on cluster.</td>
<td></td>
<td>Convenience</td>
</tr>
<tr>
<td>–consumer</td>
<td>Convenience option to add/remove acls for consumer role. This will generate acls that allows READ, DESCRIBE on topic and READ on consumer-group.</td>
<td></td>
<td>Convenience</td>
</tr>
</tbody>
</table>
<h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>通过几个例子介绍一下如何进行权限设置。</p>
<h3 id="add-操作"><a href="#add-操作" class="headerlink" title="add 操作"></a>add 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为用户 alice 在 test（topic）上添加读写的权限</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --add --allow-principal User:alice --operation Read --operation Write --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 对于 topic 为 test 的消息队列，拒绝来自 ip 为198.51.100.3账户为 BadBob  进行 read 操作，其他用户都允许</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --add --allow-principal User:* --allow-host * --deny-principal User:BadBob --deny-host 198.51.100.3 --operation Read --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 为bob 和 alice 添加all，以允许来自 ip 为198.51.100.0或者198.51.100.1的读写请求</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --add --allow-principal User:bob --allow-principal User:alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出 topic 为 test 的所有权限账户</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --list --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>输出信息为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current ACLs <span class="keyword">for</span> resource `Topic:<span class="built_in">test</span>`:</span><br><span class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Describe from hosts: *</span><br><span class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Read from hosts: *</span><br><span class="line">    User:alice has Allow permission <span class="keyword">for</span> operations: Write from hosts: *</span><br></pre></td></tr></table></figure>
<h3 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove 操作"></a>remove 操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 移除 acl</span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_test10 --remove --allow-principal User:Bob --allow-principal User:Alice --allow-host 198.51.100.0 --allow-host 198.51.100.1 --operation Read --operation Write --topic test</span><br></pre></td></tr></table></figure>
<h3 id="producer-和-consumer-的操作"><a href="#producer-和-consumer-的操作" class="headerlink" title="producer 和 consumer 的操作"></a>producer 和 consumer 的操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># producer</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --add --allow-principal User:alice --producer --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#consumer</span></span><br><span class="line">bin/kafka-acls.sh --authorizer-properties zookeeper.connect=data-rt-dev02:2181/kafka_<span class="built_in">test</span>10 --add --allow-principal User:alice --consumer --topic <span class="built_in">test</span> —group <span class="built_in">test</span>-group</span><br></pre></td></tr></table></figure>
<h1 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h1><p>本小节记录了在使用 SASL/PLAIN 时遇到的一些坑。</p>
<h2 id="Controller连接broker失败"><a href="#Controller连接broker失败" class="headerlink" title="Controller连接broker失败"></a>Controller连接broker失败</h2><p>错误信息如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[2016-07-27 17:45:46,047] WARN [Controller-1-to-broker-1-send-thread], Controller 1<span class="string">'s connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</span><br><span class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:63)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$$anonfun$blockingReady$extension$2.apply(NetworkClientBlockingOps.scala:59)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll$1(NetworkClientBlockingOps.scala:112)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka$utils$NetworkClientBlockingOps$$pollUntil$extension(NetworkClientBlockingOps.scala:120)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady$extension(NetworkClientBlockingOps.scala:59)</span><br><span class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</span><br><span class="line">    at kafka.controller.RequestSendThread.liftedTree1$1(ControllerChannelManager.scala:181)</span><br><span class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</span><br><span class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</span><br><span class="line">[2016-07-27 17:45:46,056] INFO [delete-topics-thread-1], Starting  (kafka.controller.TopicDeletionManager$DeleteTopicsThread)</span><br><span class="line">[2016-07-27 17:45:46,057] DEBUG [Topic Deletion Manager 1], Waiting for signal to start or continue topic deletion (kafka.controller.TopicDeletionManager)</span><br><span class="line">[2016-07-27 17:45:46,351] WARN [Controller-1-to-broker-1-send-thread], Controller 1'</span>s connection to broker XXXX:9092 (id: 1 rack: null) was unsuccessful (kafka.controller.RequestSendThread)</span><br><span class="line">java.io.IOException: Connection to XXXX:9092 (id: 1 rack: null) failed</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:63)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$<span class="variable">$anonfun</span><span class="variable">$blockingReady</span><span class="variable">$extension</span><span class="variable">$2</span>.apply(NetworkClientBlockingOps.scala:59)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.recursivePoll<span class="variable">$1</span>(NetworkClientBlockingOps.scala:112)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.kafka<span class="variable">$utils</span><span class="variable">$NetworkClientBlockingOps</span>$<span class="variable">$pollUntil</span><span class="variable">$extension</span>(NetworkClientBlockingOps.scala:120)</span><br><span class="line">    at kafka.utils.NetworkClientBlockingOps$.blockingReady<span class="variable">$extension</span>(NetworkClientBlockingOps.scala:59)</span><br><span class="line">    at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:232)</span><br><span class="line">    at kafka.controller.RequestSendThread.liftedTree1<span class="variable">$1</span>(ControllerChannelManager.scala:181)</span><br><span class="line">    at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:180)</span><br><span class="line">    at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:63)</span><br></pre></td></tr></table></figure>
<p>查找原因查找了半天，之前以为是<code>kafka_server_jaas.conf</code>文件的格式有问题，改了之后发现 Kafka 有时启动正常，有时不能正常启动，修改之前 conf 文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;admin&quot;</span><br><span class="line">    password=&quot;admin&quot;</span><br><span class="line">    user_matt=“33&quot;</span><br><span class="line">    user_alice=&quot;alice&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后分析可能是因为没有在 user 中配置 admin 账户，因为 broker 之间也开启了身份认证，修改之后的配置文件如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;admin&quot;</span><br><span class="line">    password=&quot;admin&quot;</span><br><span class="line">    user_admin=&quot;admin&quot;</span><br><span class="line">    user_alice=&quot;alice&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改完之后，Kafka 就可以正常运行了。</p>
<hr>
<p>参考：</p>
<ul>
<li>confluent的官网博客：<a href="http://www.confluent.io/blog/apache-kafka-security-authorization-authentication-encryption" target="_blank" rel="external">Apache Kafka Security 101</a></li>
<li>Kafka 官网：<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">KIP-12 - Kafka Sasl/Kerberos and SSL implementation</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Security" target="_blank" rel="external">Kafka Security</a></li>
<li>Kafka 官网：<a href="http://kafka.apache.org/documentation.html#security" target="_blank" rel="external">Kafka security</a></li>
<li>Kafka 官网中文翻译<a href="http://orchome.com/270" target="_blank" rel="external">kafka使用SASL验证</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Apache Kafka 0.10.0 new Consumer使用]]></title>
      <url>http://wangzzu.github.io/2016/07/22/kafak-new-consumer-use/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下Kafka new Consumer的使用，关于new Consumer的基本概念可以参考上一篇博文<a href="http://wangzzu.github.io/2016/07/21/kafka-new-consumer/">Apache Kafka 0.9 Consumer Client 介绍【译】</a>，这篇对于Kafka的new Consumer介绍得比较清楚。本文的一部分内容也来自上一篇文章。</p>
<h1 id="Consumer-Client"><a href="#Consumer-Client" class="headerlink" title="Consumer Client"></a>Consumer Client</h1><p>本节主要介绍Kafka从一些topic消费数据的示例。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化与配置"><a href="#初始化与配置" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>Consumer的创建过程与之前旧的API创建方法一样，一个Consumer必备的最小配置项如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>); <span class="comment">// 通过其中的一台broker来找到group的coordinator，并不需要列出所有的broker</span></span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props); <span class="comment">// consumer实例</span></span><br></pre></td></tr></table></figure>
<p>Consumer的其他配置项可以参考<a href="http://kafka.apache.org/documentation.html#newconsumerconfigs" target="_blank" rel="external">New Consumer Configs</a>，除了上面的这几个配置之外，其他的几个比较常用的配置信息如下表所示</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>heartbeat.interval.ms</td>
<td>3000</td>
<td>当使用Kafka的group管理机制时，consumer向coordinator发送心跳的间隔，这个值要比session.timeout.ms小，最好不要超过session.timeout.ms的\frac{1}{3}</td>
</tr>
<tr>
<td>session.timeout.ms</td>
<td>30000</td>
<td>当使用Kafka的group管理机制时用于检测到consumer失败的时长，如果在这个时间内没有收到consumer的心跳信息，就认为Consumer失败了</td>
</tr>
<tr>
<td>auto.offset.reset</td>
<td>latest</td>
<td>group首次开始消费数据时的offset，有以下几个值可以选择：earliest、latest、none、anything else.</td>
</tr>
<tr>
<td>enable.auto.commit</td>
<td>true</td>
<td>设置为true时，Consumer的offset将会被周期性地自动commit</td>
</tr>
<tr>
<td>auto.commit.interval.ms</td>
<td>5000</td>
<td>Consumer的offset自动commit时的周期</td>
</tr>
</tbody>
</table>
<h2 id="Consumer-Auto-Offset-Commit"><a href="#Consumer-Auto-Offset-Commit" class="headerlink" title="Consumer Auto Offset Commit"></a>Consumer Auto Offset Commit</h2><p>本例使用Kafka的自动commit机制，每隔一段时间（可通过<code>auto.commit.interval.ms</code>来设置）就会自动进行commit offset。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</span><br><span class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>); <span class="comment">// 自动commit</span></span><br><span class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>); <span class="comment">// 自动commit的间隔</span></span><br><span class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>)); <span class="comment">// 可消费多个topic,组成一个list</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几点需要注意：</p>
<ol>
<li>在使用自动commit时，系统是保证at least once，因为offset是在这些messages被应用处理成功后才进行commit的；</li>
<li>subscribe方法需要传入所有topic的列表，一个group所消费的topic是不能动态增加的，但是可以在任何时间改变这个列表，它会把前面的设置覆盖掉；</li>
<li>poll中的参数就是设置一个时长，Consumer在进行拉取数据进行block的最大时间限制；</li>
</ol>
<h2 id="Consumer-Manual-Offset-Control"><a href="#Consumer-Manual-Offset-Control" class="headerlink" title="Consumer Manual Offset Control"></a>Consumer Manual Offset Control</h2><p>要进行手动commit，需要在配置文件中将enable.auto.commit设置为false，来禁止自动commit，本例以手动同步commit为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></span><br><span class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test1"</span>, <span class="string">"test2"</span>));</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</span><br><span class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工同步commit offset</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在本例中，我们调用了commitSync方法，这是同步commit的方式，同时Kafka还提供了commitAsync方法，它们的区别是：使用同步提交时，consumer会进行block知道commit的结果返回，这样的话如果commit失败就可以今早地发现错误，而当使用异步commit时，commit的结果还未返回，Consumer就会开始拉取下一批的数据，但是使用异步commit可以系统的吞吐量，具体使用哪种方式需要开发者自己权衡；</li>
<li>本例中的实现依然是保证at least once，但是如果每次拉取到数据之后，就进行commit，最后再处理数据，就可以保证at last once。</li>
</ol>
<h2 id="Consumer-Manual-Partition-Assign"><a href="#Consumer-Manual-Partition-Assign" class="headerlink" title="Consumer Manual Partition Assign"></a>Consumer Manual Partition Assign</h2><p>Kafka在进行消费数据时，可以指定消费某个topic的某个partition，这种使用情况比较特殊，并不需要coordinator进行rebalance，也就意味着这种模式虽然需要设置group id，但是它跟前面的group的机制并不一样，它与旧的Consumer中的Simple Consumer相似，这是Kafka在新的Consumer API中对这种情况的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"group"</span>);</span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">//关闭自动commit</span></span><br><span class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(props);</span><br><span class="line">TopicPartition partition0 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">0</span>);</span><br><span class="line">TopicPartition partition1 = <span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">2</span>);</span><br><span class="line">consumer.assign(Arrays.asList(partition0, partition1));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"offset = %d, key = %s, value = %s \n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= minBatchSize) &#123;</span><br><span class="line">        consumer.commitSync(); <span class="comment">//批量完成写入后，手工sync offset</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>与前面的subscribe方法一样，在调用assign方法时，需要传入这个Consumer要消费的所有TopicPartition的列表；</li>
<li>不管对于simple consumer还是consumer group，所有offset的commit都必须经过group coordinator；</li>
<li>在进行commit时，必须设置一个合适的group.id，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个CommitFailedException异常，但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</li>
</ol>
<h1 id="KafkaStream使用"><a href="#KafkaStream使用" class="headerlink" title="KafkaStream使用"></a>KafkaStream使用</h1><p>KafkaStream是在Kafka 0.10.0版中新提出的内容，Kafka官方也说了设计这个feature的原因——为了简单，之前在流处理方面，一般情况下都会使用Kafka作为消息队列，然后再搭建一个流处理环境做流处理，而现在我们可以直接在Kafka中进行流处理，不需要再搭建另外一个环境（加了这个feature之后会使得Kafka变得更加复杂，不过官网说，在使用时我们只需要在工程中添加一个外部依赖包即可使用这个功能）。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>需要在pom文件中添加如下依赖，KafkaStream在实际运行时也是依赖这个外部的jar包运行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化与配置-1"><a href="#初始化与配置-1" class="headerlink" title="初始化与配置"></a>初始化与配置</h2><p>KafkaStream使用的一个基本初始化部分如下所示（代码来自<a href="http://kafka.apache.org/0100/javadoc/index.html?org/apache/kafka/streams/KafkaStreams.html" target="_blank" rel="external">Javadoc</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"my-stream-processing-application"</span>);</span><br><span class="line">props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(StreamsConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">props.put(StreamsConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class="line">props.put(StreamsConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">props.put(StreamsConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);</span><br><span class="line">StreamsConfig config = <span class="keyword">new</span> StreamsConfig(props);</span><br><span class="line"></span><br><span class="line">KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</span><br><span class="line">builder.from(<span class="string">"my-input-topic"</span>).mapValue(value -&gt; value.length().toString()).to(<span class="string">"my-output-topic"</span>);</span><br><span class="line"></span><br><span class="line">KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, config);</span><br><span class="line">streams.start();</span><br></pre></td></tr></table></figure>
<p>完整的配置选项如下表所示，也可以参考<a href="http://kafka.apache.org/documentation.html#streamsconfigs" target="_blank" rel="external">Streams Configs</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>application.id</td>
<td>流处理应用的标识，对同一个应用需要一致，因为它是作为消费的group_id的</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>bootstrap.servers</td>
<td>host1:port1,host2:port2 这样的列表，是用来发现所有Kafka节点的种子，因此不需要配上所有的Kafka节点</td>
<td>list</td>
<td></td>
</tr>
<tr>
<td>client.id</td>
<td>应用的一个客户端的逻辑名称，设定后可以区分是哪个客户端在请求</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>zookeeper</td>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>key.serde</td>
<td>键的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>partition.grouper</td>
<td>用于分区组织的类，需要实现PartitionGrouper接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.DefaultPartitionGrouper</td>
</tr>
<tr>
<td>replication.factor</td>
<td>流处理应用会创建change log topic和repartition topic用于管理内部状态，这个参数设定这些topic的副本数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>state.dir</td>
<td>状态仓库的存储路径</td>
<td>string</td>
<td>/tmp/kafka-streams</td>
</tr>
<tr>
<td>timestamp.extractor</td>
<td>时间戳抽取类，需要实现TimestampExtractor接口</td>
<td>class</td>
<td>org.apache.kafka.streams.processor.ConsumerRecordTimestampExtractor</td>
</tr>
<tr>
<td>value.serde</td>
<td>值的序列化/反序列化类</td>
<td>class</td>
<td>org.apache.kafka.common.serialization.Serdes$ByteArraySerde</td>
</tr>
<tr>
<td>buffered.records.per.partition</td>
<td>每个分区缓存的最大记录数</td>
<td>int</td>
<td>1000</td>
</tr>
<tr>
<td>commit.interval.ms</td>
<td>存储处理器当前位置的间隔毫秒数</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>metric.reporters</td>
<td>用于性能报告的类列表。需要实现MetricReporter接口。JmxReporter会永远开启不需要指定</td>
<td>list</td>
<td>[]</td>
</tr>
<tr>
<td>metric.num.samples</td>
<td>计算性能需要的采样数</td>
<td>int</td>
<td>2</td>
</tr>
<tr>
<td>metric.sample.window.ms</td>
<td>性能采样的时间间隔</td>
<td>long</td>
<td>30000</td>
</tr>
<tr>
<td>num.standby.replicas</td>
<td>每个任务的后备副本数</td>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>num.stream.threads</td>
<td>执行流处理的线程数</td>
<td>int</td>
<td>1</td>
</tr>
<tr>
<td>poll.ms</td>
<td>等待输入的毫秒数</td>
<td>long</td>
<td>100</td>
</tr>
<tr>
<td>state.cleanup.delay.ms</td>
<td>一个分区迁移后，在删除状态前等待的毫秒数</td>
<td>long</td>
<td>60000</td>
</tr>
</tbody>
</table>
<h2 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h2><p>这是个将一个topic的事件进行过滤的示例，处理很简单，下面给出了这个例子的完整代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Serdes;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.KStreamBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.KafkaStreams;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.StreamsConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.kstream.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by matt on 16/7/22.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"test-filter"</span>);</span><br><span class="line">        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"10.4.232.70:9091,10.4.232.77:2181"</span>);</span><br><span class="line">        props.put(StreamsConfig.KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line">        props.put(StreamsConfig.VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setting offset reset to earliest so that we can re-run the demo code with the same pre-loaded data</span></span><br><span class="line">        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</span><br><span class="line"></span><br><span class="line">        KStreamBuilder builder = <span class="keyword">new</span> KStreamBuilder();</span><br><span class="line"></span><br><span class="line">        KStream&lt;String, String&gt; source = builder.stream(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        source.filter(<span class="keyword">new</span> Predicate&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (value.split(<span class="string">","</span>)[<span class="number">3</span>]).equals(<span class="string">"food"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).to(<span class="string">"food"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, props);</span><br><span class="line">        streams.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// usually the stream application would be running forever,</span></span><br><span class="line">        <span class="comment">// in this example we just let it run for some time and stop since the input data is finite.</span></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        streams.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>本文只是介绍这两个重要feature的使用方法，而KafkaStream并没有深入去讨论，后面会对本文再进行更新，并且还会增加Producer和Consumer使用安全机制的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Apache Kafka 0.9 Consumer Client 介绍【译】]]></title>
      <url>http://wangzzu.github.io/2016/07/21/kafka-new-consumer/</url>
      <content type="html"><![CDATA[<p>近段时间在公司实习，有一项任务就是负责对Kafka新版本的一些feature做一下调研，主要是调研的内容是Kafka在0.9.0版本中提供的两个新特性：New Consumer API和安全认证机制，本文是在研究Kafka的新consumer API时看过的一篇文章，对于理解新API的设计理念以及应用，有很多的帮助，因此就打算翻译一下，帮助自己更好理解的同时也为开源做一些贡献。本文译自<a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a>一文，是Confluent官方出的一篇关于Kafka新Consumer客户端介绍的文章。</p>
<blockquote>
<p>注：个人的英文及写作水平有限，虽然有些地方能够理解作者的意思，但是可能自己会表达不准确，读者遇到难以理解的地方，可以对照英文原文进行阅读。另外，有些在Kafka中经常出现专有英文名词，本文会尽量还用英文表示，本来直接看这些英文名词就非常简洁，翻译成中文反而难以理解。</p>
</blockquote>
<p>Kafka最初被设计时，它原生地提供了一个Scala版本的producer和Consumer客户端。但是随着Kafka的应用更加广泛，我们意识到这些API有很多的缺陷。比如，Kafka提供了一个<strong>high-level</strong>的Consumer API，它可以实现consumer group和自动容错，但是不能支持一些更复杂的使用场景，同时我们也提供了一套<strong>simple</strong>的Consumer API以提供更全面、更细粒度的控制，但是这种Consumer需要开发者自己设计容错机制。因此，我们重新设计和开发了客户端，以适应哪些旧的客户端很难或者无法适用的应用场景，并且建立了一套可以支持长久发展的API。</p>
<p>开始的第一阶段，在0.8.1的版本中，我们重写设计了Producer的API。最近的0.9.0版本完成了第二阶段，引入了新的Consumer API。在Kafka本身提供的一套新的<strong>group coordination protocol</strong>的基础上，新的Consumer有以下这些优势：</p>
<ul>
<li>Clean Consolidated API：新的Consumer结合了旧的”simple”和”high-level”Consumer客户端，同时提供了group协调机制和更细粒度的消费机制；</li>
<li>Reduced Dependencies：新的Consumer完全是用Java编写的，它在运行过程中没有依赖Scala或者Zookeeper，这使得我们的工程的依赖包更加轻量化；</li>
<li>Better Security：Kafka 0.9.0提供的<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=51809888" target="_blank" rel="external">security extensions</a>只被新的Consumer所支持；</li>
<li>新的Consumer同样也增加一系列用于管理消费过程中group容错的协议。之前这部分的设计是使用Java客户端实现的，它需要频繁地与Zookeeper进行交互，这个实现逻辑上的复杂性使得这些它很难推广到其他语言的客户端上。而随着新协议的提出，实现变得更加简单，实际上<a href="https://github.com/edenhill/librdkafka" target="_blank" rel="external">C Client</a>已经开始应用这个协议了。</li>
</ul>
<p>尽管新的Consumer使用了重新设计的API和一个新的coordination protocol，但是Kafka的那些基础的概念并没有任何变化。因此，对旧的Consumer非常熟悉的开发者在理解新Consumer客户端的设计时并不会遇到太大困难。然而，却有一些不易察觉细节需要额外的关注，特别是在理解<strong>group management</strong>和<strong>thread model</strong>上时。本文的目的就是讲述一下新Consumer的使用以及解释一下这些细节问题。</p>
<blockquote>
<p>有一点需要注意：在本文还在写的时候，新的Consumer在稳定性方面仍然被认为是”beta”。</p>
</blockquote>
<p>我们已经解决了几个在0.9.0版中遇到的重要bug，如果你在使用0.9.0版时遇到任何问题，我们建议你先对这个分支进行一下测试。如果依然遇到问题，可以通过<a href="https://kafka.apache.org/contact.html" target="_blank" rel="external">mail lists</a>或者<a href="https://issues.apache.org/jira/secure/Dashboard.jspa" target="_blank" rel="external">JIRA</a>提出。</p>
<h1 id="Getting-Started：开始"><a href="#Getting-Started：开始" class="headerlink" title="Getting Started：开始"></a>Getting Started：开始</h1><p>开始讲述代码之前，我们先回顾一下Kafka的基本概念。在Kafka中，每一个topic都被分为一系列消息的集合，这些集合被称为partition，Producer会在这些消息集合的尾部追加数据，Consumer从给定的位置读取数据。Kafka通过consumer group实现规模化地消费topic数据，group是一系列Consumers共享一个共同的标识符。下图展示了一个有3个partition的topic被一个有2个成员的group消费的情况，topic的每个partition被安排到group中的一个cosumer上。</p>
<p><img src="/images/kafka/consumer-figure1.png" alt="consumer group"></p>
<p>旧的Consumer依赖ZK进行group管理，而新的Consumer则使用了一个Kafka自身提供的group coordination protocol实现。对于每一个group，都会从所有的broker中选取一个作为<strong>group coordinator</strong>，这个coordinator是负责维护和管理这个group的状态，它的主要工作是当一个consumer加入、一个consumer离开（挂掉或者手动停止等）或者topic的partition改变时重新进行partition分配，这个过程就是group的<strong>rebalance</strong>。</p>
<blockquote>
<p>这里有一个问题需要思考，每个topic的元数据信息（具体的指的是，这个topic有多少个partition，每个partition的leader在哪台broker上）是不是也有coordinator保存的？还是这些元数据信息直接保存在broker上？</p>
</blockquote>
<p>当一个group刚开始被初始化时，group中consumer可以选择从每个partition的最小或者最大的offset开始消费数据，然后每个partition中的message会按顺序依次进行消费。随着Consumer的处理，它会对已经成功处理的msg进行commit（提交的是msg的offset）。例如，如下图所示，Consumer当前消费的msg的offset（<code>Current Position</code>）是6，上一次已经提交的msg的offset（<code>Last Committed Offset</code>）是1.</p>
<p><img src="/images/kafka/consumer-figure2.png" alt="consumer offset"></p>
<p>当一个partition被分配到group中的另外一个consumer时，初始化的位置是<code>Last Committed Offset</code>。如果本例中的consumer突然挂掉，这个group中的consumer将不得不从1（<code>Last Committed Offset</code>）开始消费数据，在这种情况下，offset为1~6的message将被重新处理。</p>
<p>图中也展示了在log中其他两个比较重要的位置信息，<code>Log End Offset</code>是写入log中的最新一条message的offset，而<code>High Watermark</code>是log中已经成功备份到其他replicas中的最新一条message的offset，也就是说<code>Log End Offset</code>与<code>High Watermark</code>之间的数据已经写入到log中，但是还未成功备份到其他的replicas中。从consuemr端来看，<code>High Watermark</code>是consumer可以消费的最后一条message的offset，这种机制会阻止Consumer读取那些未备份的message，因为这些message在后面可能会丢失。</p>
<h1 id="Configuration-and-Initialization：配置与初始化"><a href="#Configuration-and-Initialization：配置与初始化" class="headerlink" title="Configuration and Initialization：配置与初始化"></a>Configuration and Initialization：配置与初始化</h1><p>使用新版的Consumer，需要先在工程中添加kafka-clients依赖，添加的配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0-cp1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与其他的Kafka客户端一样，新版的Consumer也需要使用一个<code>Properties</code>文件来创建。下面例子中的配置，是对于一个Consumer group来说的几个必备的配置项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"consumer-tutorial"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br></pre></td></tr></table></figure>
<p>与旧的Consumer和Producer一样， 我们需要先配置一个brokers的初始列表，以便Consumer能够找到集群中其他的节点，这并不需要列出集群中的所有节点，客户端从列表中的broker中来找到全部的alive brokers，本例我们假设这台broker是运行在本地上的。Consumer也需要设置key和value反序列化的方式。最后，为了加入一个Consumer Group，也需要设置group id，它是group的一个标识符。在本文的下面，我们会介绍更多的配置选项。</p>
<blockquote>
<p>这里也有一个问题需要思考，Kafka是如何通过初始的broker列表来找到Kafka集群所有的节点信息？</p>
</blockquote>
<h1 id="Topic-Subscription：订阅Topic"><a href="#Topic-Subscription：订阅Topic" class="headerlink" title="Topic Subscription：订阅Topic"></a>Topic Subscription：订阅Topic</h1><p>开始消费前，必须首先配置出应用需要订阅的topic信息，下面的例子中，我们订阅了来自Topic为”foo”和”bar”的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>));</span><br></pre></td></tr></table></figure>
<p>开始订阅之后，Consumer可以与group的其他Consumer进行协调，来得到自己的partition分配，这个过程是在Consumer开始消费数据时自动进行的。下面，我们会展示如何使用<strong>assign</strong> API来手动进行partition分配，但是需要注意的是，Consumer中同时使用自动管理和手动管理是没有必要的。</p>
<p><code>subscribe</code>方法是不能增加的：程序中必须包含想要消费的所有topic列表，你可以在任何时间改变你订阅的topic的集合，但是之前订阅的这些topic会被你使用<code>subscribe</code>方法调用的新的列表所取代。</p>
<h1 id="Basic-Poll-Loop：基本的poll循环模型"><a href="#Basic-Poll-Loop：基本的poll循环模型" class="headerlink" title="Basic Poll Loop：基本的poll循环模型"></a>Basic Poll Loop：基本的poll循环模型</h1><p>Consumer需要支持并行地拉取数据，常见的情况就是从分布在不同broker上的多个topic的多个partition上拉取数据。为了实现这种情况，Kafka使用了一套类似于Unix中的<code>poll</code>或者<code>select</code>调用的API风格：一旦topic进行注册，未来所有的coordination、rebalance和数据拉取都是在一个event loop中通过一个单一的poll调用来触发的。这种实现方式是简单有效的，它可以处理来自单线程的所有IO。</p>
<blockquote>
<p>思考：Consumer在调用<code>poll</code>方法时处理逻辑是怎么样？</p>
</blockquote>
<p>在订阅了一个topic之后，你需要启动一个<code>event loop</code>来获得partition分配并开始开始拉取数据，这听起来很复杂，但是你需要做的就是在一个循环中调用<code>poll</code>方法，然后Consumer会自动处理其他的所有的事情。每一次对于<code>poll</code>方法的调用都会返回一个从其所分配的partition上拉取的message集合（集合可能会空）。下面的例子展示了在一个基本的poll循环模型中打印Consumer拉取的mmessage的offset和value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>poll</code>API返回了根据<code>Current Position</code>拉取到的record。当group第一次创建时，这个位置是根据配置来进行设置的，可以被设置每个partition的最早或者最新的offset。但是一旦这个Consumer开始commit offset，之后的每次rebalance都会把position重置到<code>Last Committed Offset</code>位置。<code>poll</code>的这个参数是用来控制当Consumer在<code>Current Position</code>等待数据时block的最大时间，只要有任何record是可用的，Consumer就会立马返回，但是如果没有任何record是可用，Consumer将会等待一定的时长（被设置的时间）。</p>
<blockquote>
<p>思考：新API中的record与旧API中的message有什么区别与联系？</p>
</blockquote>
<p>Consumer最初被设计时就是运行在它自己的线程上，在多线程情况下使用时如果没有额外的同步机制它并不是线程安全的，而且也不推荐去尝试。在这个例子中，我们使用了一个flag（<code>runnning</code>），当应用关掉时它用于从poll循环中中断。当这个flag被其他线程（例如：关闭进程的线程）设置为false时，当poll返回时循环就会结束，而且无论是否返回record应用都会结束进程。</p>
<p>当Consumer进程结束时，你应该显式地关闭Consumer进程，这样不仅可以清除使用的socket，而且可以确保Consumer会向Coordinator发送它离开group的信息。</p>
<p>在上面的例子中，我们使用了较小的定时来确保在关闭Consumer时没有太多的延迟，或者，你也可以设置一个较长的定时，通过使用<code>weakup</code>API来从循环中中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + “: ” + record.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">  <span class="comment">// ignore for shutdown</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们将时长设置为了<code>Long.MAX_VALUE</code>，它意味着Consumer将会一直bolck直到下一批records返回。相比于前面例子中使用的flag，本例中线程通过调用<code>consumer.wakeup()</code>来中断poll循环，同时进程抛出一个<code>WakeupException</code>异常。这个API被其他线程调用是安全的，但值得注意的是：如果进程当前没有调用poll，这个异常会在下次调用时被抛出。在这个例子中，我们可以捕捉这个异常来阻止它继续传播。</p>
<blockquote>
<p>思考：1.只要有数据，poll就立马返回吗？还是poll会等待一段时间或者一定消息量后返回？2.poll中设置的time参数在什么情况下起作用？如果拉取的消息为空，而时间又超出的话会出现什么情况？</p>
</blockquote>
<h1 id="Putting-in-all-Together：一个完整的例子"><a href="#Putting-in-all-Together：一个完整的例子" class="headerlink" title="Putting in all Together：一个完整的例子"></a>Putting in all Together：一个完整的例子</h1><p>在下面的例子中，我们创建一个简单的<code>Runnable</code>任务，它初始化这个Consumer、订阅一个topic的列表，并且一直执行poll循环除非遇到外部触发结束进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; topics;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConsumerLoop</span><span class="params">(<span class="keyword">int</span> id,</span><br><span class="line">                      String groupId, </span><br><span class="line">                      List&lt;String&gt; topics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.topics = topics;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    props.put(“group.id”, groupId);</span><br><span class="line">    props.put(“key.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    props.put(“value.deserializer”, StringDeserializer.class.getName());</span><br><span class="line">    <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      consumer.subscribe(topics);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          data.put(<span class="string">"partition"</span>, record.partition());</span><br><span class="line">          data.put(<span class="string">"offset"</span>, record.offset());</span><br><span class="line">          data.put(<span class="string">"value"</span>, record.value());</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.id + <span class="string">": "</span> + data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">      <span class="comment">// ignore for shutdown </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    consumer.wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试这个示例，需要有一个运行0.9.0版Kafka的broker，并且需要一个有一些待消费数据的topic，向一个topic写入数据的最简单的办法是使用<code>kafka-verifiable-producer.sh</code>脚本。为了确保实验更有趣，我们将topic设置为多个partition，这样的话就不用使一个parition去做所有的工作了。在本例中，Kafka的broker和Zookeeper都运行在本地，你可以在一个Kafka根目录下键入以下命令进行设置topic和partiion。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-topics.sh --create --topic consumer-tutorial --replication-factor 1 --partitions 3 --zookeeper localhost:2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bin/kafka-verifiable-producer.sh --topic consumer-tutorial --max-messages 200000 --broker-list localhost:9092</span></span><br></pre></td></tr></table></figure>
<p>然后我们创建了一个有三个成员的consumer group，这个group来订阅我们刚才创建的那个topic</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> numConsumers = <span class="number">3</span>;</span><br><span class="line">  String groupId = <span class="string">"consumer-tutorial-group"</span></span><br><span class="line">  List&lt;String&gt; topics = Arrays.asList(<span class="string">"consumer-tutorial"</span>);</span><br><span class="line">  ExecutorService executor = Executors.newFixedThreadPool(numConsumers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;ConsumerLoop&gt; consumers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numConsumers; i++) &#123;</span><br><span class="line">    ConsumerLoop consumer = <span class="keyword">new</span> ConsumerLoop(i, groupId, topics);</span><br><span class="line">    consumers.add(consumer);</span><br><span class="line">    executor.submit(consumer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (ConsumerLoop consumer : consumers) &#123;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">      &#125; </span><br><span class="line">      executor.shutdown();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.awaitTermination(<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子向一个executor提交三个consumer，每一个线程都分配了一个唯一的id，便于我们清楚是哪个线程在接收数据。当进程停止时，shutdown的Hook将被触发，它将使用<code>weakup</code>中断这三个线程，并且等待它们关闭。如果你运行这个程序，你将会看到所有这些线程接收到数据，下面是运行之后的输出例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2: &#123;partition=0, offset=928, value=2786&#125;</span><br><span class="line">2: &#123;partition=0, offset=929, value=2789&#125;</span><br><span class="line">1: &#123;partition=2, offset=297, value=891&#125;</span><br><span class="line">2: &#123;partition=0, offset=930, value=2792&#125;</span><br><span class="line">1: &#123;partition=2, offset=298, value=894&#125;</span><br><span class="line">2: &#123;partition=0, offset=931, value=2795&#125;</span><br><span class="line">0: &#123;partition=1, offset=278, value=835&#125;</span><br><span class="line">2: &#123;partition=0, offset=932, value=2798&#125;</span><br><span class="line">0: &#123;partition=1, offset=279, value=838&#125;</span><br><span class="line">1: &#123;partition=2, offset=299, value=897&#125;</span><br><span class="line">1: &#123;partition=2, offset=300, value=900&#125;</span><br><span class="line">1: &#123;partition=2, offset=301, value=903&#125;</span><br><span class="line">1: &#123;partition=2, offset=302, value=906&#125;</span><br><span class="line">1: &#123;partition=2, offset=303, value=909&#125;</span><br><span class="line">1: &#123;partition=2, offset=304, value=912&#125;</span><br><span class="line">0: &#123;partition=1, offset=280, value=841&#125;</span><br><span class="line">2: &#123;partition=0, offset=933, value=2801&#125;</span><br></pre></td></tr></table></figure>
<p>这个输出展示三个partition的消费情况，每一个partition都被安排到其中的一个线程上。在每个partition中，你都会看到offset如期望中的一样在不断增加，你可以使用命令行或者IDE中的<code>Ctrl+C</code>关闭这个进程。</p>
<h1 id="Consumer-Liveness：Consumer存活"><a href="#Consumer-Liveness：Consumer存活" class="headerlink" title="Consumer Liveness：Consumer存活"></a>Consumer Liveness：Consumer存活</h1><p>Group中每一个Consumer都被安排它订阅topic的partitions的一个子集，group会使用一个group锁在这些partition上。只要这些锁还被持有，其他的Consumer成员就不能从这些partition上读取数据。如果这些Consumer运行正常，这种情况就是我们想要的结果，这也是避免重复读消费数据的唯一办法。但是如果由于节点或者程序故障造成Consumer异常退出时，你需要能够释放这些锁，以便这些partition可以被安排到其他健康的Consumer上。</p>
<p>Kafka的group coordination protocol通过心跳机制来解决这个问题（Consumer通过心跳机制来实现持有锁和释放锁），在每一次rebalance之后，当前group中的所有Consumer都会定期向group的coordinator发送心跳信息，如果可以收到这个Consumer的心跳信息，就证明这个Consumer是正常的。一旦收到心跳信息，这个coordinator会重新开始计时。如果定时到了而还没有收到心跳信息，coordinator将会把这个consumer标记为dead，并且会向group的其他成员发送信号，这样就会进行rebalance操作，从而重新对这些partition进行分配。定时的时长就是session 时长，它可以通过客户端的<code>session.timeout.ms</code>这个参数来设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"60000"</span>);</span><br></pre></td></tr></table></figure>
<p>session时长机制可以确保如果遇到节点或者应用崩亏、或者网络把consumer从group中隔离的情况，锁会被释放。但是，通常应用失败的情况处理起来有点麻烦，因为即使Consumer仍然向coordinator发送心跳信息也不能证明应用是正常运行的。</p>
<p>Consumer的poll循环是被设置为解决这个问题，当你调用<code>poll</code>方法或者其他的阻塞的API时所有的网络IO就已经完成。而且Consumer并不会在后台调用任何其他线程，这就意味着心跳信息只是在调用<code>poll</code>方法时发送给coordinator的。如果因为处理代码的逻辑部分抛出异常或者下游系统崩溃而造成应用停止<code>poll</code>方法调用，那么也会造成没有任何心跳被发送，然后session定时就会超时，这个group就会进行rebalance操作。</p>
<p>如果一个consumer在给定的时间内没有发送心跳信息，这种机制就会被触发一个虚假的rebalance操作。当然可以通过将定时设置足够大来避免这种情况的发生，它默认的时长是30s，但是它没有必要的将时长设置高达几分钟。设置为更长时长的一个问题就是它需要花费更多的时间来发现失败的Consumer。</p>
<h1 id="Delivery-Semantics：可靠的消息传递"><a href="#Delivery-Semantics：可靠的消息传递" class="headerlink" title="Delivery Semantics：可靠的消息传递"></a>Delivery Semantics：可靠的消息传递</h1><p>当一个consumer group刚开始被创建的时候，最初的offset是通过<code>auto.offset.reset</code>配置项来进行设置的。一旦Consumer开始处理数据，它根据应用的需要来定期地对offset进行commit。在每一次的rebalance之后，group会将这个offset将被设置为<code>Last Committed Offset</code>。但如果consumer在对已经处理过的message进行commit之前挂掉了，另外一个Consumer最终会重复处理这些已经处理但未commit的数据。应用中对offset进行commit越频繁，在一次崩溃后你重复消费的数据就会越少。</p>
<p>在前面的例子中，我们都已经设置了自动提交机制，当把<code>enable.auto.commit</code>设置为<code>true</code>（default）时，Consumer会周期性地自动触发的offset commit机制，这个时长可以通过<code>auto.commit.interval.ms</code>来进行配置。通过减少这个间隔，我们可以限制当崩溃发生时Consumer重新处理的数据量。</p>
<p>如果要使用consumer的commit API，首先需要在配置文件中将<code>enable.auto.commit</code>设置为false，来禁止自动commit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>);</span><br></pre></td></tr></table></figure>
<p>这个commit API使用起来非常简单，难点在于如何与poll循环配合使用。下面的例子，主体中包含了commit细节实现的完整的poll循环。调用同步commit的API是处理手动提交的最简单的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">      <span class="comment">// application specific failure handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无参的<code>commitSync</code>API进行commit的offset是在调用<code>poll</code>后返回的，因为是同步commit，所以这个调用将会被一直block直到commit成功或者因为不可恢复的错误而失败。处理过程中，需要特别注意的是message处理的时间大于session时长的这种情况，如果这种情况发生，coordinator就会把这个consumer踢出这个group，它会导致抛出<code>CommitFailedException</code>异常。应用程序应该能够处理这种错误，并对由于消费自从上一次成功提交后的message造成的变化进行回滚操作。</p>
<p>一般情况下，你应该确保message被成功处理后，这个offset被commit了。但是如果在commit被发送之前consumer挂掉了，然后这些messages就会被重复处理。如果这个commit机制保证<code>Last Committed Offset</code>不会超过<code>Current Position</code>（如图2所示，上图，非下图），然后系统就会保证<strong>at last once</strong>消息传递机制。</p>
<p><img src="/images/kafka/consumer-figure3.png" alt="consumer commit offset"></p>
<p>通过改变commit机制来保证<code>Current Position</code>不会超过<code>Last Committed Offset</code>，如上图所示，你将会得到<strong>at most once</strong>消息传递保证。如果在<code>Current Position</code>赶上<code>Last Committed Offset</code>之前consumer挂掉了，这段时间内的所有messages都会丢失，但是可以确定是没有消息会处理超过一次。为了实现这个机制，我们只需要改变commit和消息处理的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">      <span class="comment">// application specific failure handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，如果使用<strong>默认的自动commit机制，系统是保证<code>at least once</code>消息处理</strong>，因为offset是在这些messages被应用处理后才进行commit的。在最糟糕的情况下，系统不得不重新处理的消息数量是由自动commit的间隔决定的（可以通过<code>auto.commit.interval.ms</code>设置）。</p>
<blockquote>
<p>思考：为什么kafka不能保证exactly once？</p>
</blockquote>
<p>通过应用commit API，你可以对重复处理的消息量进行更细的控制，在更极端的情况下，你甚至可以在每一条消息被处理后都进行commit，如下面的例子所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(record.partition(), <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">      <span class="comment">// application specific failure handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们调用<code>commitSync</code>方法通过对明确的offset进行commit，要注意的是，要进行commit的offset应该是应用将要读取的下一条消息的offset。当<code>commitSync</code>方法被无参调用时，这个consumer对应用返回的<code>Last Offset（+1）</code>进行commit，但是在这里并不能使用，因为我们不允许<code>The Committed Position</code>超过我们实际的处理位置（<code>Current Position</code>）。</p>
<p>由于处理线程在每次进行commit请求并等待服务器返回这个过程中需要进行加锁，很明显对于大多数的应用场景，这种设计并不适用，这种设计会严重影响到consumer的吞吐量。更合理的设计是每接收N条消息后再进行commit，为了更高的吞吐量N的值可以进行调整。</p>
<p>本例中<code>commitSync</code>方法的参数是一个map的数据结构，key为topic partition，value为<code>OffsetAndMetadata</code>的实例。Commit API允许在每次commit时包含一些额外的元数据信息，这些数据信息可以是record进行commit的时间、要发送的host、或者应用程序中需要的任何其他信息，在本例中，我们并没有添加这个额外信息。</p>
<p>相比于对每接收一条message就进行commit，一个更加合理的机制是当你处理完每个partition的数据后进行commit offset。<code>ConsumerRecords</code>集合类提供了获取它内部每个partition集合以及每个partition内数据的方法。下面的例子详细描述这种机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Long.MAX_VALUE);</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">      List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords)</span><br><span class="line">        System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> lastoffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">      consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastoffset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截止到目前为止，我们主要研究的是同步commit的API，但是consumer也提供了异步提交的API——<code>commitAsync</code>。使用异步commit一般情况下会提高系统的吞吐量，因为应用可以在commit结果还未返回时就能开始处理下一批的message。但是你可能在之后才会发现commit失败了，这是需要开发者进行权衡。下面的例子是异步commit的基本用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">      System.out.println(record.offset() + <span class="string">": "</span> + record.value());</span><br><span class="line"></span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// application specific failure handling</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本例中，在<code>commitAsync</code>中我们提供了回调方法，这个方法只会在commit完成后（不管成功还是失败）才会被consumer触发。如果你不需要这个设置，你也可以使用无参的<code>commitAsync</code>API。</p>
<blockquote>
<p>思考：在进行commit时，如果commit失败，consumer会怎么处理，同步与异步的处理过程是一样的吗？</p>
</blockquote>
<h1 id="Consumer-Group-Inspection：consumer-group查看"><a href="#Consumer-Group-Inspection：consumer-group查看" class="headerlink" title="Consumer Group Inspection：consumer group查看"></a>Consumer Group Inspection：consumer group查看</h1><p>当一个consuemr group是active，你可以通过在命令行运行<code>consumer-groups.sh</code>脚本来查看partition assignment和group消费情况，这个脚本存放在Kafka的<code>bin</code>目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/kafka-consumer-groups.sh --new-consumer --describe --group consumer-tutorial-group --bootstrap-server localhost:9092</span></span><br></pre></td></tr></table></figure>
<p>输出的结果如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GROUP, TOPIC, PARTITION, CURRENT OFFSET, LOG END OFFSET, LAG, OWNER</span><br><span class="line">consumer-tutorial-group, consumer-tutorial, 0, 6667, 6667, 0, consumer-1_/127.0.0.1</span><br><span class="line">consumer-tutorial-group, consumer-tutorial, 1, 6667, 6667, 0, consumer-2_/127.0.0.1</span><br><span class="line">consumer-tutorial-group, consumer-tutorial, 2, 6666, 6666, 0, consumer-3_/127.0.0.1</span><br></pre></td></tr></table></figure>
<p>上面的结果展示了这个consumer group的partition分配以及哪个consumer实例消费这个partition，还有<code>Last Committed Offset</code>（这里也可以认为是<code>Current Offset</code>）。每个partition的lag就是这个partition的最后offset与<code>Last Committed Offset</code>的差值。Administrators会一直进行监控以确保consuemr group能跟得上producers。</p>
<h1 id="Using-Manual-Assignment：使用手动的assign"><a href="#Using-Manual-Assignment：使用手动的assign" class="headerlink" title="Using Manual Assignment：使用手动的assign"></a>Using Manual Assignment：使用手动的assign</h1><p>正如本文开始所述的一样，新的Consumer实现了对那些不需要group的场景进行更细粒度的控制，对这种场景的支持是建议使用新Consumer API的重要原因之一。旧的<code>simple consumer</code>虽然也提供这样的设计，但是却需要你自己做很多的容错处理。而新的Consumer API，你只需要提供了你需要读取的topic的partition，然后就可以开始读取数据，其他的东西Consumer会帮你处理。</p>
<p>下面的例子展示了如何使用<code>partitionsFor</code> API来分配安排一个topic的所有partition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (PartitionInfo partition : consumer.partitionsFor(topic))</span><br><span class="line">  partitions.add(<span class="keyword">new</span> TopicPartition(topic, partition.partition()));</span><br><span class="line">consumer.assign(partitions);</span><br></pre></td></tr></table></figure>
<p>和<code>subscribe</code>方法相似，调用<code>assign</code>方法时必须传入consuemr要读取的所有parition的集合，一旦partition被分配了，poll循环部分就与前面的过程基本一样。</p>
<p>有一点需要的注意的是，不管是一个simple consumer还是一个consumer group，所有offset的commit都必须经过<strong>group coordinator</strong>。因此，如果你需要进行commit，你必须设置一个合适的<code>group.id</code>，避免与其他的group产生冲突。如果一个simple consumer试图使用一个与一个active group相同的id进行commit offset，coordinator将会拒绝这个commit请求，会返回一个<code>CommitFailedException</code>异常。但是，如果一个simple consumer与另一个simple consumer使用同一个id，系统就不会报任何错误。</p>
<h1 id="Conclusion：结论"><a href="#Conclusion：结论" class="headerlink" title="Conclusion：结论"></a>Conclusion：结论</h1><p>新的Consumer给Kafka社区带了很多的好处，比如，简洁的API、更好的安全性和对ZK更少的依赖。本文介绍了new consumer的基本用法，并注重于poll循环模型以及使用commit API来控制传递机制。虽然还有很多需要讨论的地方，但是本文对于基本的使用是足够了。尽管新的comsumer还在开发中，但是我们仍然鼓励你去尝试使用。使用中如果遇到什么问题，欢迎通过邮件告诉我们.</p>
<hr>
<p>参考</p>
<ul>
<li><a href="http://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client" target="_blank" rel="external">Introducing the Kafka Consumer: Getting Started with the New Apache Kafka 0.9 Consumer Client</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac常用软件配置]]></title>
      <url>http://wangzzu.github.io/2016/07/09/mac-software/</url>
      <content type="html"><![CDATA[<p>近段时间因为在公司实习，公司提供的电脑都是Mac，还给发了一台全新的Mac pro，刚开始用的时候有很多不习惯的地方，但是用了几天之后就感觉Mac真的爽到爆啊，本篇文章就记录一下自己感觉在Mac上用到的一些不错的软件，以及Mac下一些常用编程工具的配置安装方法，这样也方便自己以后查看，本篇文章会一直保持更新。</p>
<h1 id="Mac基本配置"><a href="#Mac基本配置" class="headerlink" title="Mac基本配置"></a>Mac基本配置</h1><p>推荐一些Mac下常用的软件</p>
<ul>
<li>笔记：<a href="https://www.yinxiang.com/download/?offer=www_menu" target="_blank" rel="external">Evernote</a>；</li>
<li>MarkDown：<a href="http://zh.mweb.im/" target="_blank" rel="external">MWeb</a>、<a href="http://25.io/mou/" target="_blank" rel="external">Mou</a>、Ulysses、<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">MacDown</a>；</li>
<li>编辑器：<a href="https://atom.io/" target="_blank" rel="external">Atom</a>；</li>
<li>思维导图：<a href="http://www.xmindchina.net/" target="_blank" rel="external">XMid</a>、SimpleMind；</li>
<li>NTFS挂载：<a href="http://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="external">Tuxera NTFS</a>（<a href="http://www.orsoon.com/Mac/129966.html" target="_blank" rel="external">序列号</a>，建议买正版）；</li>
<li>播放器：MPV（mpv安装及快捷键操作参考<a href="https://intxt.net/meet-mpv/" target="_blank" rel="external">mpv安装</a>一文）；</li>
<li>浏览器：chrome，必须是chrome；</li>
<li>上网：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases/" target="_blank" rel="external">shadowsocks</a>；</li>
</ul>
<p>博文推荐</p>
<ul>
<li><a href="http://www.jianshu.com/p/19e8ffd91576" target="_blank" rel="external">Mac下开发常用的必备软件</a>，这里有office、ps等工具的安装；</li>
</ul>
<h2 id="chrome常用配置"><a href="#chrome常用配置" class="headerlink" title="chrome常用配置"></a>chrome常用配置</h2><p>chrome既方便又强大，于是乎，不得不单独弄出一小章来介绍。</p>
<h3 id="常用小插件"><a href="#常用小插件" class="headerlink" title="常用小插件"></a>常用小插件</h3><ul>
<li>代理：<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">switchyomega</a>；</li>
<li>流程图：<a href="https://chrome.google.com/webstore/detail/gliffy-diagrams/bhmicilclplefnflapjmnngmkkkkpfad" target="_blank" rel="external">gliffy</a>;</li>
<li>MarkDown：<a href="chrome-extension://elifhakcjgalahccnjkneoccemfahfoa/common/options.html" target="_blank" rel="external">MarkDown Here</a>;</li>
<li>词典：<a href="https://chrome.google.com/webstore/detail/%E7%BF%B0%E6%9E%97%E8%8B%B1%E6%B1%89%E5%8F%8C%E8%A7%A3%E8%AF%8D%E5%85%B8/fidicgekecdkdmkjghdgadgdmcfodfid" target="_blank" rel="external">翰林英汉双解词典</a>;</li>
</ul>
<h1 id="Mac下常用快捷键"><a href="#Mac下常用快捷键" class="headerlink" title="Mac下常用快捷键"></a>Mac下常用快捷键</h1><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页刷新</td>
<td>command+r</td>
</tr>
<tr>
<td>自定义截图</td>
<td>command+shfit+4</td>
</tr>
<tr>
<td>显示器</td>
<td>control+shift+电源键</td>
</tr>
<tr>
<td>将文本编辑器由带格式变为存文本</td>
<td>command+shfit+t</td>
</tr>
<tr>
<td>EverNote无格式粘贴</td>
<td>command+shift+option+v</td>
</tr>
<tr>
<td>文件/文件夹重命名</td>
<td>选中该文件/文件夹，点击回车键</td>
</tr>
</tbody>
</table>
<p>快捷键可以参考<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">Mac键盘快捷键</a>一文.</p>
<p>这里有一篇Bash下的快捷键的wiki，<a href="https://github.com/hokein/Wiki/wiki/Bash-Shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" target="_blank" rel="external">Bash Shell常用快捷键</a>，可以方便查找bash下的常用快捷键。</p>
<p>其他博文推荐：</p>
<ol>
<li><a href="http://wuchong.me/blog/2014/06/29/the-first-experience-of-mac/" target="_blank" rel="external">Mac上手体验</a></li>
<li><a href="http://www.macx.cn/thread-2133104-1-1.html" target="_blank" rel="external">Mac快速锁屏</a></li>
<li><a href="https://support.apple.com/kb/PH18669?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="external">Mac锁屏后设置需要输密码</a></li>
<li><a href="http://www.hangge.com/blog/cache/detail_540.html" target="_blank" rel="external">Mac下文本编辑器</a></li>
<li><a href="http://popozhu.github.io/2013/09/24/mac%E5%85%89%E6%A0%87%E9%80%9F%E5%BA%A6%E8%B0%83%E6%95%B4/" target="_blank" rel="external">Mac光标速度调整</a></li>
</ol>
<h1 id="Mac终端iTerm2配置"><a href="#Mac终端iTerm2配置" class="headerlink" title="Mac终端iTerm2配置"></a>Mac终端iTerm2配置</h1><p>Mac下的iTerm2用着真的超爽</p>
<h2 id="iTerm2下载安装"><a href="#iTerm2下载安装" class="headerlink" title="iTerm2下载安装"></a>iTerm2下载安装</h2><p><a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2下载</a></p>
<p>下载完直接安装即可。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>安装成功后的效果如下图所示</p>
<p><img src="/images/mac/iterm-1.png" alt="zsh"></p>
<h2 id="安装powerline"><a href="#安装powerline" class="headerlink" title="安装powerline"></a>安装powerline</h2><p>关于powerline的介绍可以参考<a href="http://cenalulu.github.io/linux/mac-powerline/" target="_blank" rel="external">为Bash和VIM配置一个美观奢华的状态提示栏</a>这篇文章，powerline就是一个全局的状态提示栏，安装方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装pip指令</span></span><br><span class="line">sudo easy_install pip</span><br><span class="line"><span class="comment"># 安装管道</span></span><br><span class="line">pip install powerline-status</span><br></pre></td></tr></table></figure>
<p>在第二步安装时，出现了这个错误，<code>error: [Errno 1] Operation not permitted: u&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/powerline&#39;</code>，如下图所示</p>
<p><img src="/images/mac/iterm-2.png" alt="error"></p>
<p>这个问题出现的原因，因为没有安装python，解决办法如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装Homebrew</span></span><br><span class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br><span class="line"><span class="comment"># 2.配置python</span></span><br><span class="line">brew install python</span><br><span class="line"><span class="comment"># 3.安装管道</span></span><br><span class="line">pip install --user powerline-status</span><br></pre></td></tr></table></figure>
<p>powerline的安装可以参考：</p>
<ol>
<li>brew安装参考<a href="http://brew.sh/" target="_blank" rel="external">官网</a></li>
<li>PowerLine安装参考<a href="http://powerline.readthedocs.io/en/latest/installation/osx.html" target="_blank" rel="external">官网</a></li>
</ol>
<h2 id="安装字体库"><a href="#安装字体库" class="headerlink" title="安装字体库"></a>安装字体库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载字体库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git</span><br><span class="line"><span class="comment"># 安装所有字体</span></span><br><span class="line"><span class="built_in">cd</span> fonts</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>安装成功后，如下图所示</p>
<p><img src="/images/mac/iterm-3.png" alt="font"></p>
<p>安装完成后会提示所有的字体均已下载到<code>/Users/superdanny/Library/Fonts</code>路径。</p>
<h2 id="字体设置、配色方案设置及主题设置"><a href="#字体设置、配色方案设置及主题设置" class="headerlink" title="字体设置、配色方案设置及主题设置"></a>字体设置、配色方案设置及主题设置</h2><h3 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h3><p>安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的<code>Regular Font</code>和<code>Non-ASCII Font</code>的字体都设置成powerline的字体，我这里设置的字体是<code>14pt Meslo LG S DZ Regular for Powerline</code>.</p>
<p><img src="/images/mac/iterm-4.png" alt="font-setting"></p>
<h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><h4 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h4><p>需要先在github下下载solarized工程，<a href="https://github.com/altercation/solarized" target="_blank" rel="external">solarized github地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/altercation/solarized</span><br></pre></td></tr></table></figure>
<p>然后进入刚刚下载的工程的<code>solarized/iterm2-colors-solarized</code> 下双击 <code>Solarized Dark.itermcolors</code> 和 <code>Solarized Light.itermcolors</code> 两个文件就可以把配置文件导入到 iTerm2 里.</p>
<h4 id="配置配色方案"><a href="#配置配色方案" class="headerlink" title="配置配色方案"></a>配置配色方案</h4><p>通过load presets选择刚刚安装的配色主题即可</p>
<p><img src="/images/mac/iterm-5.png" alt="color"></p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>这里使用的是agnoster主题，<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="external">oh-my-zsh-agnoster-fcamblor Github地址</a></p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载主题</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor</span><br><span class="line"><span class="comment"># 2.安装主题</span></span><br><span class="line"><span class="built_in">cd</span> oh-my-zsh-agnoster-fcamblor</span><br><span class="line">./install</span><br></pre></td></tr></table></figure>
<h4 id="设置该主题"><a href="#设置该主题" class="headerlink" title="设置该主题"></a>设置该主题</h4><p>编辑<code>~/.zshrc</code>文件，然后将<code>ZSH_THEME</code>后面的字段改为<code>agnoster</code>。<code>ZSH_THEME=&quot;agnoster&quot;</code>（agnoster即为要设置的主题）.</p>
<h4 id="增加指令高亮效果"><a href="#增加指令高亮效果" class="headerlink" title="增加指令高亮效果"></a>增加指令高亮效果</h4><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮，这里需要先下载<code>zsh-syntax-highlighting</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.下载工程项目</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"><span class="comment"># 2.打开.zshrc文件，在最后添加下面内容</span></span><br><span class="line"><span class="built_in">source</span> /Users/matt/git//zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"><span class="comment"># 3.打开.zshrc文件，在最后面添加下面内容</span></span><br><span class="line">plugins=(zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>配置完之后效果如下图所示</p>
<p><img src="/images/mac/iterm-6.png" alt="end"></p>
<h2 id="iTerm2快捷键"><a href="#iTerm2快捷键" class="headerlink" title="iTerm2快捷键"></a>iTerm2快捷键</h2><p>iTerm2快捷键的使用可以参考<a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a>这篇文章，这里给出一些常用的命令</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建标签</td>
<td>command + t</td>
</tr>
<tr>
<td>关闭标签</td>
<td>command + w</td>
</tr>
<tr>
<td>切换标签</td>
<td>command + 数字 command + 左右方向键</td>
</tr>
<tr>
<td>切换全屏</td>
<td>command + enter</td>
</tr>
<tr>
<td>查找</td>
<td>command +f</td>
</tr>
<tr>
<td>垂直分屏</td>
<td>command + d</td>
</tr>
<tr>
<td>水平分屏</td>
<td>command + shift + d</td>
</tr>
<tr>
<td>切换屏幕</td>
<td>command + option + 方向键 command + [ 或 command + ]</td>
</tr>
<tr>
<td>查看历史命令</td>
<td>command + ;</td>
</tr>
<tr>
<td>查看剪贴板历史</td>
<td>command + shift + h</td>
</tr>
<tr>
<td>清除当前行</td>
<td>ctrl + u</td>
</tr>
<tr>
<td>到行首</td>
<td>ctrl + a</td>
</tr>
<tr>
<td>到行尾</td>
<td>ctrl + e</td>
</tr>
<tr>
<td>前进后退</td>
<td>ctrl + f/b (相当于左右方向键)</td>
</tr>
<tr>
<td>上一条命令</td>
<td>ctrl + p</td>
</tr>
<tr>
<td>搜索命令历史</td>
<td>ctrl + r</td>
</tr>
<tr>
<td>删除当前光标的字符</td>
<td>ctrl + d</td>
</tr>
<tr>
<td>删除光标之前的字符</td>
<td>ctrl + h</td>
</tr>
<tr>
<td>删除光标之前的单词</td>
<td>ctrl + w</td>
</tr>
<tr>
<td>删除到文本末尾</td>
<td>ctrl + k</td>
</tr>
<tr>
<td>交换光标处文本</td>
<td>ctrl + t</td>
</tr>
<tr>
<td>清屏1</td>
<td>command + r</td>
</tr>
<tr>
<td>清屏2</td>
<td>ctrl + l</td>
</tr>
</tbody>
</table>
<h1 id="编程环境配置"><a href="#编程环境配置" class="headerlink" title="编程环境配置"></a>编程环境配置</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一般情况下，可能需要安装多个版本的JDK，具体各个版本的下载，JDK7和JDK8可以在官网上直接下载，而JDK6的下载资源就比较难找了，可以参考<a href="http://www.codecate.com/code/archives/16" target="_blank" rel="external">Mac安装jdk1.6 1.7 1.8</a>这篇文章</p>
<p>下载安装完这三个版本的JDK之后，需要进行以下配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash下是~/.bashrc文件</span></span><br><span class="line"><span class="built_in">export</span> JAVA_6_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/</span><br><span class="line"><span class="built_in">export</span> JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_76.jdk/Contents/Home/</span><br><span class="line"><span class="built_in">export</span> JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_7_HOME</span></span><br><span class="line"><span class="built_in">alias</span> jdk8=<span class="string">'export JAVA_HOME=$JAVA_8_HOME'</span></span><br><span class="line"><span class="built_in">alias</span> jdk7=<span class="string">'export JAVA_HOME=$JAVA_7_HOME'</span></span><br><span class="line"><span class="built_in">alias</span> jdk6=<span class="string">'export JAVA_HOME=$JAVA_6_HOME'</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><h3 id="idea安装"><a href="#idea安装" class="headerlink" title="idea安装"></a>idea安装</h3><p><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">idea下载地址</a></p>
<p>如果下载的版本是2016.1版，这里有一个<a href="http://aiyougege.com/articles/022711.html" target="_blank" rel="external">激活码</a>，不过推荐购买正版，免费版推荐社区版，一般的开发也就够用了。</p>
<h3 id="Google-Java编程规范配置"><a href="#Google-Java编程规范配置" class="headerlink" title="Google Java编程规范配置"></a>Google Java编程规范配置</h3><p>参考<a href="http://zacard.net/2016/04/11/idea-google-code-style/" target="_blank" rel="external">Idea直接导入xml文件</a>一文。</p>
<p>idea可以支持自定义的code style，并且google code style也提供了对idea的xml配置，直接导入就可以在idea中使用google提倡的code style了。</p>
<p>使用方法：</p>
<ol>
<li>从github上clone <a href="https://github.com/google/styleguide" target="_blank" rel="external">Google Style GitHub</a>；</li>
<li>复制对应的xml配置（如intellij-java-google-style.xml）到“~/Library/Preferences/IDEA/codestyles/”下</li>
<li>重启idea在Prefrence-&gt;Editor—&gt;Code Stytle-&gt;Java,选择GoogleStyle即可</li>
</ol>
<p>mac下格式化代码的快捷键： <code>command+alt+L</code></p>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><p>需要配置的内容主要有以下几项：</p>
<ol>
<li>自动行号显示</li>
<li>字体</li>
<li>SDK设置（就是jdk，scala等设置）</li>
<li>maven设置</li>
<li>快捷键</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>常用的快捷键如下表所示</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看所选代码的源码</td>
<td>cmd + ↓</td>
</tr>
<tr>
<td>查看maven依赖</td>
<td>opt+shift+cmd+U</td>
</tr>
<tr>
<td>智能补齐代码</td>
<td>opt + enter</td>
</tr>
<tr>
<td>生成一些常用方法，如：toString、get 等</td>
<td>control + enter</td>
</tr>
</tbody>
</table>
<p>关于快捷键可以参考<a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html" target="_blank" rel="external">Mac下idea快捷键</a>一文。</p>
<ul>
<li><a href="http://baowp.iteye.com/blog/1989575" target="_blank" rel="external">Mac下Idea打开Maven的jar包依赖图</a></li>
</ul>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="external">PyCharm下载地址</a></p>
<p>2016版的可以使用<a href="http://blog.csdn.net/jiang314/article/details/51680072" target="_blank" rel="external">注册码</a>进行破解，不过推荐购买正版。</p>
<h1 id="其他常用命令安装"><a href="#其他常用命令安装" class="headerlink" title="其他常用命令安装"></a>其他常用命令安装</h1><h2 id="tree命令安装"><a href="#tree命令安装" class="headerlink" title="tree命令安装"></a>tree命令安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先安装HomeBrew</span></span><br><span class="line">brew install tree</span><br></pre></td></tr></table></figure>
<h1 id="Mac下遇到的其他问题"><a href="#Mac下遇到的其他问题" class="headerlink" title="Mac下遇到的其他问题"></a>Mac下遇到的其他问题</h1><h2 id="bashrc每次打开iterm都要重新加载"><a href="#bashrc每次打开iterm都要重新加载" class="headerlink" title="~/.bashrc每次打开iterm都要重新加载"></a>~/.bashrc每次打开iterm都要重新加载</h2><p>参考<a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">文章</a></p>
<p>原因：使用的zsh，而不是bash，所以zsh没有义务去加载<code>~/.bashrc</code>文件，zsh下别名一般放置到<code>~/.zshrc</code>文件中。</p>
<p>解决办法：在<code>~/.zshrc</code>文件的最后添加<code>source ~/.bashrc</code>.</p>
<h2 id="修改电脑名的方法"><a href="#修改电脑名的方法" class="headerlink" title="修改电脑名的方法"></a>修改电脑名的方法</h2><p>有人可能感觉跟我一样有强迫症，看到电脑名太长影响终端的显示，就想着怎么修改一下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令“Tmp”是你想要改的电脑名称</span></span><br><span class="line">sudo scutil --set HostName Tmp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：关闭终端之后，重新打开终端就会生效。</p>
</blockquote>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="external">iTerm 2 &amp;&amp; Oh My Zsh</a></li>
<li><a href="http://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="external">Iterm2快捷键</a></li>
<li><a href="http://www.zhihu.com/question/29653438" target="_blank" rel="external">为什么我的Mac不加载/etc/bashrc文件呢？</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis简单介绍]]></title>
      <url>http://wangzzu.github.io/2016/06/06/redis-introduce/</url>
      <content type="html"><![CDATA[<p>本文是根据我在<a href="https://www.shiyanlou.com/courses/106" target="_blank" rel="external">实验楼-Redis基础教程</a>中学习的总结，简单讲述了一下Redis的安装和使用。</p>
<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括 <code>lists</code>, <code>sets</code>, <code>ordered sets</code> 以及 <code>hashes</code> ，当然还有和<code>Memcached</code>一样的 strings结构。Redis当然还包括了对这些数据结构的丰富操作。</p>
<p>Redis常被称作是一款数据结构服务器（<code>data structure server</code>）。Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（<code>append</code>）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p>
<h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><ul>
<li>性能极高：Redis能支持超过 100K+ 每秒的读写频率。</li>
<li>丰富的数据类型：Redis支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li>
<li>原子：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性：Redis还支持 <code>publish/subscribe</code>, 通知, key 过期等等特性。</li>
</ul>
<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>在<a href="http://redis.io/" target="_blank" rel="external">Redis官网</a>中下载最新的稳定版，这里我选用的是<code>3.2.0</code>稳定版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 解压按照包</span><br><span class="line">$ tar xvfz redis-3.2.0.tar.gz</span><br><span class="line"></span><br><span class="line"># 编译</span><br><span class="line">$ cd redis-3.2.0</span><br><span class="line">$ sudo make </span><br><span class="line">$ sudo make install</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">$ make test</span><br></pre></td></tr></table></figure>
<p>测试成功的结果如下图所示：</p>
<p><img src="/images/redis/test.png" alt="test"></p>
<h1 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h1><h2 id="启动与配置"><a href="#启动与配置" class="headerlink" title="启动与配置"></a>启动与配置</h2><p>在 Redis 安装完成后，注意一些重要的文件，可用 ls 命令查看。</p>
<ul>
<li>服务端的启动脚本：<code>src/redis-server</code>；</li>
<li>客户端的启动脚本：<code>src/redis-cls</code>；</li>
<li>默认配置文件：<code>redis.conf</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis服务器</span></span><br><span class="line">$ ./src/redis-server</span><br></pre></td></tr></table></figure>
<p>启动成功结果如下图：</p>
<p><img src="/images/redis/start.png" alt="start"></p>
<blockquote>
<p>说明： 从上图中，可以发现启动的端口为缺省的<strong>6379</strong>. 用户可以在启动的时候，指定具体的配置文件，并在其中指定启动的端口。</p>
</blockquote>
<h2 id="配置-PATH"><a href="#配置-PATH" class="headerlink" title="配置$PATH"></a>配置$PATH</h2><p>然后将可执行文件放置在$PATH环境目录下，便于以后使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo　cp src/redis-server /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">$　sudo cp src/redis-cli /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>
<h2 id="查看Redis"><a href="#查看Redis" class="headerlink" title="查看Redis"></a>查看Redis</h2><p>再启动玩Redis服务器之后，可以通过以下命令来查看Redis运行情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep redis</span><br><span class="line"><span class="comment"># 通过启动命令检查Redis服务器状态</span></span><br><span class="line">$ netstat -nlt|grep 6379</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/state.png" alt="state"></p>
<h2 id="启动Redis-client"><a href="#启动Redis-client" class="headerlink" title="启动Redis-client"></a>启动Redis-client</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的<code>key-value</code> 存储器，正如本文开头所述Redis同时也是一种<code>data structures server</code>。传统的<code>key-value</code>是指支持使用一个<code>key</code>字符串来索引<code>value</code>字符串的存储，而Redis中，<code>value</code>不仅仅支持字符串，还支持更多的复杂结构，包括列表，集合，哈希表等。</p>
<p>在本小节中，我们一一讲解：Redis keys是采用<strong>二进制安全</strong>（这里的二进制安全可以理解为：只关心二进制化的字符串，不关心具体格式，只会严格的按照二进制的数据存取，并不会按照某种具体格式去解析，杜绝了出乱码的问题），这就意味着你可以使用任何二进制序列作为重点，从像”foo”可以联系一个 JPEG 文件。空字符串也是一个有效的密钥。</p>
<h2 id="Redis-strings"><a href="#Redis-strings" class="headerlink" title="Redis strings"></a>Redis strings</h2><p>字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。</p>
<p>这里启动<code>redis-cli</code>来看看Redis strings数据类型。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器与客户端</span></span><br><span class="line">$ sudo service redis-server start</span><br><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis客户端下</span></span><br><span class="line">&gt; <span class="built_in">set</span> mykey somevalue</span><br><span class="line">&gt; get mykey</span><br></pre></td></tr></table></figure>
<p>如上例所示，可以<code>SET</code>和<code>GET</code>命令来创建和检索strings。注意,<code>set</code>命令将取代现有的任何已经存在的key。</p>
<p><code>SET</code>命令还有一个提供附加参数的选项,我们能够让<code>SET</code>命令只有在没有相同key的情况下成功，反之亦然，可以让<code>SET</code>命令在有相同key值得情况下成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> mykey newval nx</span><br><span class="line">&gt; <span class="built_in">set</span> mykey newval xx</span><br></pre></td></tr></table></figure>
<p>即使string是Redis的基本类型，也可以对其进行一些有趣的操作，例如加法器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> counter 100</span><br><span class="line">&gt; incr counter</span><br><span class="line">&gt; incr counter</span><br><span class="line">&gt; incrby counter 50</span><br></pre></td></tr></table></figure>
<p><code>INCR</code>命令让the value 成为一个整数，运行一次<code>INCR</code>便+1。<code>INCRBY</code>命令便是一个加法运算。类似的命令如减法运算为： <code>DECR and DECRBY</code>。</p>
<p>Redis可以运用<code>MSET and MGET</code> 命令完成一次性的完成多个key-value的对应关系，使用<code>MGET</code>命令，Redis返回一个value数组。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mset a 10 b 20 c 30</span><br><span class="line">&gt; mget a b c</span><br></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/strings.png" alt="string"></p>
<h2 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p>
<ul>
<li><code>LPUSH</code> 命令插入一个新的元素导头部；</li>
<li><code>RPUSH</code>插入一个新元素导尾部.</li>
</ul>
<p>当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间中删除。</p>
<p><code>PUSH</code>一类的命令的返回值为list的长度。一些类表操作和结果的例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist A</span><br><span class="line">&gt; rpush mylist B</span><br><span class="line">&gt; lpush mylist first</span><br><span class="line">&gt; lrange mylist 0 -1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>LRANGE</code> 利用了两个检索值，0表示list的开头第一个，-1表示list的倒数第一个，即最后一个。-2则便是list的倒数第二个，以此类推。</p>
</blockquote>
<p>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入list。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist 1 2 3 4 5 <span class="string">"foo bar"</span></span><br><span class="line">&gt; lrange mylist 0 -1</span><br></pre></td></tr></table></figure>
<p>在Redis的命令操作中，还有一类重要的操作：<code>POP</code>，取出list元素。和<code>PUSH</code>操作类似，<code>POP</code>命令可以选择不同的方向取出元素.<code>POP</code>命令返回值为取出的元素。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; del mylist</span><br><span class="line">&gt; rpush mylist a b c</span><br><span class="line">&gt; rpop mylist</span><br><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">&gt; lpop mylist</span><br><span class="line">&gt; lrange mylist 0 -1</span><br></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/list.png" alt="list"></p>
<h2 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h2><p>Redis Hashes是字符串字段和字符串值之间的映射，因此他们是展现对象的完美数据类型。 (例如:一个有名，姓，年龄等等属性的用户)：一个带有一些字段的<code>hash</code>仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的Redis实例中。 哈希主要用来表现对象，他们有能力存储很多对象，因此你可以将哈希用于许多其他的任务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset user:1000 username antirez birthyear 1977 verified 1</span><br><span class="line">&gt; hget user:1000 username</span><br><span class="line">&gt; hget user:1000 birthyear</span><br><span class="line">&gt; hgetall user:1000</span><br></pre></td></tr></table></figure>
<ul>
<li><code>HMSET</code>命令设置一个多域的hash表；</li>
<li><code>HGET</code>命令获取指定的单域；</li>
<li><code>HGETALL</code>命令获取指定key的所有信息；</li>
<li><code>HMGET</code>类似于<code>HGET</code>，只是返回一个value数组。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmget user:1000 username birthyear no-such-field</span><br></pre></td></tr></table></figure>
<p>同样可以根据需要对hash表的表项进行单独的操作，例如 <code>HINCRBY</code>， （原本birthyear 为1977，见上一图）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hincrby user:1000 birthyear 10</span><br><span class="line">&gt; hincrby user:1000 birthyear 10</span><br></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/hash.png" alt="hash"></p>
<h2 id="Redis-无序集合"><a href="#Redis-无序集合" class="headerlink" title="Redis 无序集合"></a>Redis 无序集合</h2><p>Redis 集合（Set）是一个<strong>无序的字符串集合</strong>. 你可以以$O(1)$的时间复杂度 (无论集合中有多少元素时间复杂度都是常量）完成添加、删除，以及测试元素是否存在。 Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（<code>unions</code>）, 求交集（<code>intersections</code>），找出不同的元素（<code>differences of sets</code>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd myset 1 2 3</span><br><span class="line">&gt; smembers myset</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SADD</code>命令产生一个无序集合，并返回集合的元素个数；</li>
<li><code>SMEMBER</code>用于查看集合；</li>
<li><code>SISMEMBER</code>用于查看集合是否存在，匹配项包括集合名和元素个数，匹配成功返回1，匹配失败返回0。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; sismember myset 3</span><br><span class="line">&gt; sismember myset 30</span><br><span class="line">&gt; sismember mys 3</span><br></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set1.png" alt="set1"></p>
<h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>Redis有序集合与普通集合非常相似，是一个<strong>没有重复元素的字符串集合</strong>。不同之处是有序集合的没有成员都关联了一个<strong>评分</strong>，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。 使用有序集合你可以以非常快的速度（$O\log{N}$）添加，删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（<code>score</code>）或者次序（<code>position</code>）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。</p>
<p><code>ZADD</code>与<code>SADD</code>类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd hackers 1940 <span class="string">"Alan Kay"</span></span><br><span class="line">&gt; zadd hackers 1957 <span class="string">"Sophie Wilson"</span></span><br><span class="line">&gt; zadd hackers 1953 <span class="string">"Richard Stallman"</span></span><br><span class="line">&gt; zadd hackers 1949 <span class="string">"Anita Borg"</span></span><br><span class="line">&gt; zadd hackers 1965 <span class="string">"Yukihiro Matsumoto"</span></span><br><span class="line">&gt; zadd hackers 1914 <span class="string">"Hedy Lamarr"</span></span><br><span class="line">&gt; zadd hackers 1916 <span class="string">"Claude Shannon"</span></span><br><span class="line">&gt; zadd hackers 1969 <span class="string">"Linus Torvalds"</span></span><br><span class="line">&gt; zadd hackers 1912 <span class="string">"Alan Turing"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ZRANGE</code>是查看正序的集合;</li>
<li><code>ZREVRANGE</code>是查看反序的集合。0表示集合第一个元素，-1表示集合的倒数第一个元素。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrange hackers 0 -1</span><br><span class="line">&gt; zrevrange hackers 0 -1</span><br></pre></td></tr></table></figure>
<p>使用<code>WITHSCORES</code> 参数返回记录值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrange hackers 0 -1 withscores</span><br></pre></td></tr></table></figure>
<p>以上操作的结果如下图所示：</p>
<p><img src="/images/redis/set2.png" alt="set2"></p>
<h1 id="Redis系统管理"><a href="#Redis系统管理" class="headerlink" title="Redis系统管理"></a>Redis系统管理</h1><p>在Redis中，命令大小写不敏感。</p>
<h2 id="适合全体类型的常用命令"><a href="#适合全体类型的常用命令" class="headerlink" title="适合全体类型的常用命令"></a>适合全体类型的常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器与客户端</span></span><br><span class="line">$ redis-server</span><br><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>
<h3 id="EXISTS-and-DEL"><a href="#EXISTS-and-DEL" class="headerlink" title="EXISTS and DEL"></a>EXISTS and DEL</h3><ul>
<li><code>EXISTS key</code> 判断一个key是否存在，存在返回 1;否则返回0; </li>
<li><code>DEL key</code> 删除某个key，或是一系列key，<code>DEL key1 key2 key3 key4</code>。成功返回1，失败返回0（key值不存在）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> mykey hello</span><br><span class="line">&gt; exists mykey</span><br><span class="line"></span><br><span class="line">&gt; del mykey</span><br><span class="line">&gt; exists mykey</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/exist.png" alt="exist"></p>
<h3 id="TYPE-and-KEYS"><a href="#TYPE-and-KEYS" class="headerlink" title="TYPE and KEYS"></a>TYPE and KEYS</h3><ul>
<li><code>TYPE key</code>：返回某个key元素的数据类型 ( none:不存在,string:字符,list,set,zset,hash)，key不存在返回空。 </li>
<li><code>KEYS key—pattern</code> ：返回匹配的key列表 (<code>KEYS foo*</code>:查找foo开头的keys)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> mykey x</span><br><span class="line">&gt; <span class="built_in">type</span> mykey</span><br><span class="line">&gt; keys my*</span><br><span class="line">&gt; del mykey</span><br><span class="line">&gt; keys my*</span><br><span class="line">&gt; <span class="built_in">type</span> mykey</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/type.png" alt="type"></p>
<h3 id="RANDOMKEY-and-CLEAR"><a href="#RANDOMKEY-and-CLEAR" class="headerlink" title="RANDOMKEY and CLEAR"></a>RANDOMKEY and CLEAR</h3><ul>
<li><code>RANDOMKEY</code> ： 随机获得一个已经存在的key，如果当前数据库为空，则返回空字符串</li>
<li><code>CLEAR</code> ：清除界面。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; randomkey</span><br><span class="line">&gt; clear</span><br></pre></td></tr></table></figure>
<h3 id="RENAME-and-RENAMENX"><a href="#RENAME-and-RENAMENX" class="headerlink" title="RENAME and RENAMENX"></a>RENAME and RENAMENX</h3><ul>
<li><code>RENAME oldname newname</code>：改key的名字，新键如果存在将被覆盖;</li>
<li><code>RENAMENX oldname newname</code>：更改key的名字，如果名字存在则更改失败.</li>
</ul>
<p>笔者randomkey结果为mylist，将此key值更名为newlist。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; randomkey</span><br><span class="line">&gt; rename mylist newlist</span><br><span class="line">&gt; exists mylist</span><br><span class="line">&gt; exists newlist</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/rename.png" alt="rename"></p>
<h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><p><code>DBSIZE</code> ：返回当前数据库的key的总数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; dbsize</span><br></pre></td></tr></table></figure>
<h2 id="Redis-时间相关命令"><a href="#Redis-时间相关命令" class="headerlink" title="Redis 时间相关命令"></a>Redis 时间相关命令</h2><h3 id="限定key生存时间"><a href="#限定key生存时间" class="headerlink" title="限定key生存时间"></a>限定key生存时间</h3><p>这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的DEL操作。</p>
<ul>
<li><code>EXPIRE</code>：设置某个key的过期时间（秒）,(<code>EXPIRE bruce 1000</code>：设置<code>bruce</code>这个key1000秒后系统自动删除)</li>
</ul>
<blockquote>
<p>注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> key some-value</span><br><span class="line">&gt; expire key 10</span><br><span class="line"><span class="comment"># 马上执行此命令</span></span><br><span class="line">&gt; get key     </span><br><span class="line"><span class="comment"># 10s后执行此命令</span></span><br><span class="line">&gt; get key</span><br></pre></td></tr></table></figure>
<p>结果显示，执行EXPIRE命令后，马上GET，显示key存在。10秒后再GET时，key 已经被自动删除。</p>
<p><img src="/images/redis/ttl.png" alt="ttl"></p>
<h3 id="查询key剩余生存时间"><a href="#查询key剩余生存时间" class="headerlink" title="查询key剩余生存时间"></a>查询key剩余生存时间</h3><p>限时操作可以再<code>SET</code>命令中实现，并且可用<code>TTL</code>命令查询key剩余生存时间。 </p>
<p><code>TTL</code>：查找某个key还有多长时间过期,返回时间秒</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> key 100 ex 30</span><br><span class="line">&gt; ttl key</span><br><span class="line">&gt; ttl key</span><br></pre></td></tr></table></figure>
<h3 id="清除key"><a href="#清除key" class="headerlink" title="清除key"></a>清除key</h3><ul>
<li><code>FLUSHDB</code>：清空当前数据库中的所有键;</li>
<li><code>FLUSHALL</code>：清空所有数据库中的所有键.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">&gt; flushall</span><br></pre></td></tr></table></figure>
<h2 id="Redis设置相关命令"><a href="#Redis设置相关命令" class="headerlink" title="Redis设置相关命令"></a>Redis设置相关命令</h2><p>Redis有其配置文件，可以通过client-command窗口查看或者更改相关配置。相关命令介绍如下：</p>
<h3 id="CONFIG-GET-and-CONFIG-SET"><a href="#CONFIG-GET-and-CONFIG-SET" class="headerlink" title="CONFIG GET and CONFIG SET"></a>CONFIG GET and CONFIG SET</h3><ul>
<li><code>CONFIG GET</code>：用来读取运行Redis服务器的配置参数。 </li>
<li><code>CONFIG SET</code>：用于更改运行Redis服务器的配置参数。 </li>
<li><code>AUTH</code> : 认证密码，下面针对Redis密码的示例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get requirepass （查看密码）</span><br><span class="line">&gt; config <span class="built_in">set</span> requirepass <span class="built_in">test</span>123 （设置密码为<span class="built_in">test</span>123 ）</span><br><span class="line">&gt; config get requirepass  （报错，没有认证）</span><br><span class="line">&gt; auth <span class="built_in">test</span>123</span><br><span class="line">&gt; config get requirepass</span><br></pre></td></tr></table></figure>
<p>由结果可知，刚开始时Reids并未设置密码，密码查询结果为空。然后设置密码为test123，再次查询报错。经过auth命令认证后，可正常查询。</p>
<p>可以经过修改Redis的配置文件redis.conf修改密码。</p>
<p><code>CONFIG GET</code>命令是以list的key-value对显示的，如查询数据类型的最大条目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get *max-*-entries*</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/pass.png" alt="pass"></p>
<h3 id="重置报告"><a href="#重置报告" class="headerlink" title="重置报告"></a>重置报告</h3><p><code>CONFIG RESETSTAT</code>：重置数据统计报告，通常返回值为’OK”。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; CONFIG RESETSTAT</span><br></pre></td></tr></table></figure>
<h2 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h2><p><code>INFO [section]</code> ：查询Redis相关信息。 INFO命令可以查询Redis几乎所有的信息，其命令选项有如下：</p>
<ul>
<li><code>server</code> : Redis server的常规信息</li>
<li><code>clients</code> : Client的连接选项</li>
<li><code>memory</code> : 存储占用相关信息</li>
<li><code>persistence</code> : RDB and AOF 相关信息</li>
<li><code>stats</code> : 常规统计</li>
<li><code>replication</code> : Master/slave请求信息</li>
<li><code>cpu</code> : CPU 占用信息统计</li>
<li><code>cluster</code> : Redis 集群信息</li>
<li><code>keyspace</code> : 数据库信息统计</li>
<li><code>all</code> : 返回所有信息</li>
<li><code>default</code> : 返回常规设置信息</li>
</ul>
<p>若命令参数为空，info命令返回所有信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; info keyspace</span><br><span class="line">&gt; info server</span><br></pre></td></tr></table></figure>
<h1 id="Redis的高级应用"><a href="#Redis的高级应用" class="headerlink" title="Redis的高级应用"></a>Redis的高级应用</h1><p>本节来讲述Redis的高级应用，包括：安全性设置，主从复制，事务处理， 持久化机制， 虚拟内存的使用。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>设置在客户端连接是需要指定的密码（由于redis速度相当的快，一秒钟可以150K次的密码尝试，所以需要设置一个密码强度很大的密码）。</p>
<p>设置密码的方式有两种：</p>
<ol>
<li>使用<code>config set</code> 命令的<code>requirepass</code> 参数，具体格式为<code>config set requirepass “password”</code>;</li>
<li>配置<code>redis.conf</code> 中设置<code>requirepass</code>属性，后面为密码。</li>
</ol>
<p>输入认证的方式也有两种：</p>
<ol>
<li>登录时可以 <code>redis-cli -a password</code>;</li>
<li>登录后使用 <code>auth password</code>.</li>
</ol>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>第一种密码设置方式在上面已经提到，（在<code>CONFIG SET</code>命令讲解的实例），此处我们来看看第二种方式设置密码。</p>
<p>首先需要进入Redis的安装目录，然后修改配置文件<code>redis.conf</code>。根据<code>grep</code>命令的结果，使用vi编辑器修改<code># requirepass foobared</code> 为<code>requirepass test123</code>，然后保存退出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n requirepass /etc/redis/redis.conf</span><br><span class="line">$ sudo vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<h3 id="重启redis-server-与redis-cli"><a href="#重启redis-server-与redis-cli" class="headerlink" title="重启redis-server 与redis-cli"></a>重启redis-server 与redis-cli</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启redis server。</span></span><br><span class="line">$ sudo service redis-server restart</span><br></pre></td></tr></table></figure>
<p>进入到redis-cli交互界面进行验证</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">&gt; info</span><br><span class="line">&gt; auth <span class="built_in">test</span>123</span><br><span class="line">&gt; info</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>结果表明第一次<code>info</code>命令失败，在<code>auth</code>认证之后<code>info</code>命令正常返回。最后退出<code>redis-cli</code>。</p>
<p>另外一种密码认证方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli <span class="_">-a</span> <span class="built_in">test</span>123</span><br><span class="line">&gt; info</span><br></pre></td></tr></table></figure>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制配置和使用都比较简单，通过主从复制可以允许多个slave server拥有和master server相同的数据库副本。从服务器只能读，不能写。</p>
<p>Redis主从复制特点：</p>
<ol>
<li>master可以拥有多个slave;</li>
<li>多个slave可以连接同一个master外，还可以连接到其他的slave。（当master宕机后，相连的slave转变为master）;</li>
<li>主从复制不会阻塞master，再同步数据时，master可以继续处理client请求;</li>
<li>提高了系统的可伸缩性。</li>
</ol>
<p>Redis主从复制的过程：</p>
<ol>
<li>Slave与master建立连接，发送sync同步命令;</li>
<li>Master会启动一个后台进程，将数据库快照保存到文件中，同时Master主进程会开始收集新的写命令并缓存;</li>
<li>后台完成保存后，就将此文件发送给Slave;</li>
<li>Slave将此文件保存到磁盘上。</li>
</ol>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令，当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">&gt; <span class="built_in">set</span> name a</span><br><span class="line">&gt; <span class="built_in">set</span> name b</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">&gt; get name</span><br></pre></td></tr></table></figure>
<p><img src="/images/redis/multi.png" alt="multi"></p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p>
<p>Redis支持两种持久化方式：</p>
<ol>
<li><code>snapshotting</code>（快照），将数据存放到文件里，默认方式。<br>是将内存中的数据已快照的方式写入到二进制文件中，默认文件<code>dump.rdb</code>，可以通过配置设置自动做快照持久化的方式。可配置Redis在n秒内如果超过m个key被修改就自动保存快照。<ul>
<li><code>save 900 1</code>: 900秒内如果超过1个key被修改，则发起快照保存;</li>
<li><code>save 300 10</code>: 300秒内如果超过10个key被修改，则快照保存.</li>
</ul>
</li>
<li><code>Append-only file</code>（缩写为<code>aof</code>），将读写操作存放到文件中。</li>
</ol>
<blockquote>
<p>Note: 由于快照方式在一定间隔时间做一次，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
</blockquote>
<p><code>aof</code>比快照方式有更好的持久化性，是由于使用<code>aof</code>时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p>
<p>由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉redis我们想要通过<code>fsync</code>函数强制os写入到磁盘的时机。</p>
<p>配置文件中的可配置参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly   yes     //启用aof持久化方式</span><br><span class="line">#appendfsync  always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化</span><br><span class="line">appendfsync   everysec  //每秒中写入磁盘一次，在性能和持久化方面做了很好的折中</span><br><span class="line">#appendfsync  no     //完全依赖os，性能最好，持久化没有保证</span><br></pre></td></tr></table></figure>
<p>在redis-cli的命令中，SAVE命令是将数据写入磁盘中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">help</span> save</span><br><span class="line">&gt; save</span><br></pre></td></tr></table></figure>
<h2 id="虚拟内存的使用"><a href="#虚拟内存的使用" class="headerlink" title="虚拟内存的使用"></a>虚拟内存的使用</h2><p>虚拟内存管理在2.6及之上版本取消了，本文安装的的是3.2.0版本的redis ，所以配置文件中并没有虚拟内存管理功能的配置选项。此处仅仅是大概介绍一下。</p>
<p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其他的访问数据，尤其对于redis这样的内存数据库，内存总是不够用的。除了分隔到多个redis server外，提高数据库的容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。</p>
<p>通过配置vm相关的<code>redis.config</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm-enable  yes                   #开启vm功能</span><br><span class="line">vm-swap-file    /tmp/redis.swap  #交换出来的value保存的文件路径</span><br><span class="line">vm-max-memory    10000000        #redis使用的最大内存上线</span><br><span class="line">vm-page-size   32       #每个页面的大小32字节</span><br><span class="line">vm-pages     123217729    #最多使用多小个页面</span><br><span class="line">vm-max-threads     4        #用于执行value对象换入的工作线程数量</span><br></pre></td></tr></table></figure>
<hr>
<p>参考</p>
<ul>
<li><a href="http://redis.io/" target="_blank" rel="external">Redis官网</a></li>
<li><a href="http://www.redis.cn/" target="_blank" rel="external">Redis中文网站</a></li>
<li><a href="http://redisdoc.com/" target="_blank" rel="external">Redis命令参考</a></li>
<li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">Redis | 菜鸟教程</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java序列化学习]]></title>
      <url>http://wangzzu.github.io/2016/05/21/java-serializable/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文主要是对Java序列化学习的一些总结，一来是方便自己以后查阅，二来是希望通过本文能给他人带来一些帮助。</p>
<h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>Java提供了一种对象序列化的机制，在该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以再从文件中读取出来，并且对它进行反序列化，也就是说，可以根据对象的类型信息、对象的数据、还有对象中的数据类型可以在内存中新建该对象。</p>
<p>在实际的应用中，我们为什么需要对象序列化机制呢？因为在一般情况下，只有当JVM进程处于运行时，JVM建立的对象才可能存在，也就是说，这些对象的生命周期不会比JVM进程的生命周期更长。但是在现实的应用中，有时需要在JVM进程停止运行之后能够保存(持久化)指定的对象，并且在将来某个时刻重新读取被保存的对象，或者我们希望将一个进程创建的对象传送到另一个JVM进程中。Java的对象序列化机制就能够帮助我们实现这些功能（这就意味着序列化机制是可以自动弥补不同操作系统之间的差异）。</p>
<p>一般来说，对象的序列化主要有两种用途：</p>
<ul>
<li>把对象的字节序列持久化到硬盘，通常保存在一个文件中；</li>
<li>在网络上传输对象的字节序列；</li>
</ul>
<p>我们在使用Java对象序列化时，会把对象的状态保存为一组字节序列，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的<strong>状态</strong>，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量，因为静态变量是类的状态。</p>
<p>这个整个过程都是Java虚拟机（JVM）独立完成的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>但是一个类的对象如果要想序列化成功，必须满足两个条件：</p>
<ul>
<li>该类必须实现 <code>java.io.Serializable</code> 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性<strong>必须注明是短暂</strong>的。</li>
</ul>
<p>如果你想知道一个Java标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现<code>java.io.Serializable</code>接口即可。</p>
<h1 id="序列化实现的示例"><a href="#序列化实现的示例" class="headerlink" title="序列化实现的示例"></a>序列化实现的示例</h1><ul>
<li>对象序列化时，首先要创建某个<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，只需要调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>（对象化序列是基于字节的，因要使用<code>InputStream</code>和<code>OutputStream</code>继承层次结构）；</li>
<li>对象反序列化时，需要将一个<code>InputStream</code>对象封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>方法；</li>
</ul>
<p>对象序列化时，不仅保存了对象的“全景图”，而且能追踪对象内所包含的所有引用，并保存那些对象，接着又能对对象内包含的每个这样的引用进行追踪，并保存那些对象，这种情况有时被称为“对象网”。</p>
<p>这里我们先建立一个对象<code>Person</code>，如下（<a href="https://github.com/wangzzu/java_learn/tree/master/java_thinking/src/javabasic/serialize" target="_blank" rel="external">示例参考</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Gender gender;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Gender gender)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">		<span class="keyword">this</span>.id = (<span class="keyword">new</span> Random()).nextInt(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Gender <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Gender gender)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">", "</span> + age + <span class="string">", "</span> + gender + <span class="string">", "</span> + id + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们在一个进程里对其进行序列化，然后再反序列化出该对象（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Serialize.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serialize.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person(<span class="string">"wm0"</span>, <span class="number">10</span>, Gender.MALE);</span><br><span class="line">		Person p2 = <span class="keyword">new</span> Person(<span class="string">"wm1"</span>, <span class="number">18</span>, Gender.MALE);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"p1 = "</span> + p1);</span><br><span class="line">		ObjectOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 写入本地文件</span></span><br><span class="line">			out.writeObject(<span class="string">"Person1 storage\n"</span>);</span><br><span class="line">			out.writeObject(p1);</span><br><span class="line">			out.close(); <span class="comment">// Also flushes output</span></span><br><span class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/person.out"</span>)); <span class="comment">// 从本地文件读取</span></span><br><span class="line">			String s = <span class="keyword">null</span>;</span><br><span class="line">			Person p11 = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s = (String) in.readObject();</span><br><span class="line">				p11 = (Person) in.readObject();</span><br><span class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p11);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"\n"</span>+ <span class="string">"p2 = "</span> + p2);</span><br><span class="line">			ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream(); <span class="comment">// 将数据写入缓冲区</span></span><br><span class="line">			ObjectOutputStream out2 = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">			out2.writeObject(<span class="string">"Person2 storage\n"</span>);</span><br><span class="line">			out2.writeObject(p2);</span><br><span class="line">			out2.flush();</span><br><span class="line">			ObjectInputStream in2 = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray())); <span class="comment">// 通过toByteArray()获取数据</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				s = (String) in2.readObject();</span><br><span class="line">				Person p22 = (Person) in2.readObject();</span><br><span class="line">				System.out.println(<span class="string">"after Serialize: "</span> + p22);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一点要注意的是：反序列化Person对象时，需要要能找到<code>Person.class</code>，否者就会抛出<code>ClassNotFoundException</code>的异常。</p>
<h1 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h1><p>通过上面的例子，我们可以看出序列化的使用，其实还是很简单的，但是，如果我们有特殊的需要那又该怎么办呢？下面我们介绍几种序列化的控制机制。</p>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p>如果我们希望对象的一部分被序列化，而另一部分不被序列化；或者一个对象被还原之后，某子对象需要重新创建，从而不必将该子对象序列化。在这种情况下，我们可以通过实现<code>Externalization</code>接口——该接口实现<code>Serializable</code>接口，同时增加两个方法：<code>writeExternal()</code>和<code>readExternal()</code>，这两个方法会在序列化和反序列化还原的过程中被自动调用以便执行一些特殊操作。</p>
<p>这与恢复<code>Serializable</code>对象不同，对于<code>Serializable</code>对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。但是对于一个<code>Externalization</code>对象，所有普通的默认构造器都会被调用（包括字段定义时的初始化），然后调用<code>readExternal()</code>。</p>
<blockquote>
<p>必须要注意这一点：所有默认的构造器都会被调用，才能使<code>Externalization</code>对象产生正确的行为。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blip3.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip3</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">private</span> String s; <span class="comment">// No initialization</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Blip3 Constructor"</span>);</span><br><span class="line">		<span class="comment">// s, i not initialized</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Blip3</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Blip3(String x, int a)"</span>);</span><br><span class="line">		s = x;</span><br><span class="line">		i = a;</span><br><span class="line">		<span class="comment">// s &amp; i initialized only in non-default constructor.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s + i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Blip3.writeExternal"</span>);</span><br><span class="line">		<span class="comment">// You must do this:</span></span><br><span class="line">		out.writeObject(s);</span><br><span class="line">		out.writeInt(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Blip3.readExternal"</span>);</span><br><span class="line">		<span class="comment">// You must do this:</span></span><br><span class="line">		s = (String) in.readObject();</span><br><span class="line">		i = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</span><br><span class="line">		Blip3 b3 = <span class="keyword">new</span> Blip3(<span class="string">"A String "</span>, <span class="number">47</span>);</span><br><span class="line">		System.out.println(b3);</span><br><span class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Blip3.out"</span>));</span><br><span class="line">		System.out.println(<span class="string">"Saving object:"</span>);</span><br><span class="line">		o.writeObject(b3);</span><br><span class="line">		o.close();</span><br><span class="line">		<span class="comment">// Now get it back:</span></span><br><span class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Blip3.out"</span>));</span><br><span class="line">		System.out.println(<span class="string">"Recovering b3:"</span>);</span><br><span class="line">		b3 = (Blip3) in.readObject();</span><br><span class="line">		System.out.println(b3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">* Constructing objects:</span><br><span class="line">* Blip3(String x, int a)</span><br><span class="line">* A String 47</span><br><span class="line">* Saving object:</span><br><span class="line">* Blip3.writeExternal</span><br><span class="line">* Recovering b3:</span><br><span class="line">* Blip3 Constructor</span><br><span class="line">* Blip3.readExternal</span><br><span class="line">* A String 47</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，字段<code>s</code>和<code>i</code>只会在第二个构造器中初始化，而不是在默认的构造器中初始化。这意味着假如不在<code>readExternal()</code>中初始化<code>s</code>和<code>i</code>，<code>s</code>就会为<code>null</code>，而<code>i</code>就会为零（因为在创建对象的第一步中将对象的存储空间清理为0）。如果我们把<code>writeExternal()</code>方法中两行注释掉，对象还原后，<code>s</code>是<code>null</code>，而<code>i</code>是零。</p>
<p>我们如果从一个<code>Externalization</code>对象继承，通常需要调用基类版本的<code>writeExternal()</code>和<code>readExternal()</code>来为基类组件提供恰当的存储和恢复功能。</p>
<p>因此，为了正常运行，我们不仅需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalization</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据。</p>
<h2 id="Transient关键字"><a href="#Transient关键字" class="headerlink" title="Transient关键字"></a>Transient关键字</h2><p>在进行序列化控制时，可能某个特定子对象不想让Java的序列化机制自动保存和恢复。如果子对象表示的是我们不希望将其序列化的敏感信息（如密码），那么我们就会面临这种情况。即使对象中的这些信息是<code>private</code>属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问到它。</p>
<p>有两种方法可以实现上述要求：</p>
<ol>
<li>将类实现<code>Externalizable</code>接口，这样的话，没有任何东西是可以自动序列化，并且可以在<code>writeExternal()</code>内部只对所需部门进行显式的序列化；</li>
<li>如果在操作的是一个<code>Serializable</code>对象，那么所有序列化操作都会自动进行，为了能够进行控制，可以用<code>transient</code>关键字逐个字段地关闭序列化，这个关键字的意思就是<strong>不用麻烦你保存或者回复数据——我自己会处理的</strong>。</li>
</ol>
<p><a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/Login.java" target="_blank" rel="external">示例</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Login.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">//: io/Logon.java</span></span><br><span class="line"><span class="comment">//Demonstrates the "transient" keyword.</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Login</span><span class="params">(String name, String pwd)</span> </span>&#123;</span><br><span class="line">		username = name;</span><br><span class="line">		password = pwd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"logon info: \n   username: "</span> + username + <span class="string">"\n   date: "</span> + date + <span class="string">"\n   password: "</span> + password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Login a = <span class="keyword">new</span> Login(<span class="string">"Hulk"</span>, <span class="string">"myLittlePony"</span>);</span><br><span class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</span><br><span class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/Logon.out"</span>));</span><br><span class="line">		o.writeObject(a);</span><br><span class="line">		o.close();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// Delay</span></span><br><span class="line">		<span class="comment">// Now get them back:</span></span><br><span class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/Logon.out"</span>));</span><br><span class="line">		System.out.println(<span class="string">"Recovering object at "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">		a = (Login) in.readObject();</span><br><span class="line">		System.out.println(<span class="string">"logon a = "</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">/*</span><br><span class="line">* logon a = logon info:</span><br><span class="line">*   username: Hulk</span><br><span class="line">*    date: Tue May 17 11:11:28 CST 2016</span><br><span class="line">*    password: myLittlePony</span><br><span class="line">* Recovering object at Tue May 17 11:11:29 CST 2016</span><br><span class="line">* logon a = logon info:</span><br><span class="line">*    username: Hulk</span><br><span class="line">*    date: Tue May 17 11:11:28 CST 2016</span><br><span class="line">*    password: null</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，其中的<code>date</code>和<code>username</code>域是一般的（不是<code>transient</code>的），所以它们会被自动序列化。而<code>password</code>是<code>transient</code>的，所以不会被自动保存到磁盘；另外，自动序列化机制也不会尝试去恢复它。当对象被恢复时，<code>password</code>域就会变成<code>null</code>。我们还可以发现，<code>date</code>字段也是从存储到了磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
<blockquote>
<p>由于实现<code>Externalizable</code>接口的对象在默认情况下不保存它们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用。</p>
</blockquote>
<h2 id="重写writeObject-和readObject-方法"><a href="#重写writeObject-和readObject-方法" class="headerlink" title="重写writeObject()和readObject()方法"></a>重写writeObject()和readObject()方法</h2><p>如果不是特别坚持使用<code>Externalizable</code>接口，那么还有一种方法。我们可以实现<code>Serializable</code>接口，并添加<code>writeObject()</code>和<code>readObject()</code>方法。这样一旦对象被序列化或者被反序列化还原，就会自动地分别调用这两个方法，而不是使用默认的序列化机制。（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/SerialCtl.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SerialCtl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCtl</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String b;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SerialCtl</span><span class="params">(String aa, String bb)</span> </span>&#123;</span><br><span class="line">		a = <span class="string">"Not Transient: "</span> + aa;</span><br><span class="line">		b = <span class="string">"Transient: "</span> + bb;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + <span class="string">" "</span> + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 自定义该方法，这里要注意方法时private</span><br><span class="line">	 * 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了它自己的writeObject()。</span><br><span class="line">	 * 如果是这样，就跳过正常的序列化过程并调用它的writeObject()</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@param</span> stream</span><br><span class="line">	 * <span class="doctag">@throws</span> IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		stream.defaultWriteObject(); <span class="comment">// 执行默认的writeObject()</span></span><br><span class="line">		stream.writeObject(b); <span class="comment">// transient字段需要明确保存和</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		stream.defaultReadObject(); <span class="comment">// 执行默认的readObject()</span></span><br><span class="line">		b = (String) stream.readObject(); <span class="comment">// transient字段需要明确恢复</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		SerialCtl sc = <span class="keyword">new</span> SerialCtl(<span class="string">"Test1"</span>, <span class="string">"Test2"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before:\n"</span> + sc);</span><br><span class="line">		ByteArrayOutputStream buf = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(buf);</span><br><span class="line">		o.writeObject(sc);</span><br><span class="line">		<span class="comment">// Now get it back:</span></span><br><span class="line">		ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(buf.toByteArray()));</span><br><span class="line">		SerialCtl sc2 = (SerialCtl) in.readObject();</span><br><span class="line">		System.out.println(<span class="string">"After:\n"</span> + sc2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">* Before:</span><br><span class="line">* Not Transient: Test1 Transient: Test2</span><br><span class="line">* After:</span><br><span class="line">* Not Transient: Test1 Transient: Test2</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>上述的例子中，非transient字段由<code>defaultReadObject</code>保存，而transient字段必须在程序中明确保存和恢复。</p>
<h2 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h2><p>前面我们也已经提到过，静态变量是不会被序列化的，这里我们通过一个例子来看一下（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StaticTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Constructing objects:"</span>);</span><br><span class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/static.out"</span>));</span><br><span class="line">			o.writeObject(<span class="keyword">new</span> StaticTest());</span><br><span class="line">			o.close();</span><br><span class="line">			StaticTest.id=<span class="number">0</span>;</span><br><span class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/static.out"</span>));</span><br><span class="line">			StaticTest staticTest = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				staticTest = (StaticTest) in.readObject();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(staticTest.id);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* output:</span><br><span class="line">* 0</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>程序输出的结果为修改之后的结果，正如我们前面所述一样，对象序列化时并不会序列化静态变量，这一点可以这样理解：对象序列化是序列化对象的状态，而静态变量是类变量，也就是类的状态。因此，<strong>对象序列化并不保存静态变量</strong>。</p>
<h2 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h2><p>这里我们通过一个例子来看一下Java序列化机制的存储规则，主要是多次写入同一个对象的情况（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/serialize/StoreTest.java" target="_blank" rel="external">示例</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ObjectOutputStream o = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"/home/matt/store.out"</span>));</span><br><span class="line">			Person person=<span class="keyword">new</span> Person(<span class="string">"matt1"</span>,<span class="number">20</span>,Gender.MALE);</span><br><span class="line">			o.writeObject(person);</span><br><span class="line">			person.setAge(<span class="number">22</span>);</span><br><span class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</span><br><span class="line">			o.writeObject(person);</span><br><span class="line">			System.out.println(<span class="keyword">new</span> File(<span class="string">"/home/matt/store.out"</span>).length());</span><br><span class="line">			o.close();</span><br><span class="line">			ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/matt/store.out"</span>));</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Person person1= (Person) in.readObject();</span><br><span class="line">				System.out.println(person1.getAge());</span><br><span class="line">				Person person2= (Person) in.readObject();</span><br><span class="line">				System.out.println(person2.getAge());</span><br><span class="line">				System.out.println(person1==person2);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Output:</span><br><span class="line">* 232</span><br><span class="line">* 237</span><br><span class="line">* 20</span><br><span class="line">* 20</span><br><span class="line">* true</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，对于同一个对象，在修改完年龄值后又重新将该实例对象序列化到文件。通过运行的结果我们可以发现：</p>
<ul>
<li>第二次将对象序列化到文件之后，文件的大小只增加了5个字节的大小；</li>
<li>第二次序列化的对象年龄值已经修改为22，但是从反序列化的结果来看，该实例对象的年龄值并未改变。</li>
</ul>
<p>大家是不是感觉到非常的奇怪，通过下面的两点解释之后，大家可能就会明白这其中的原因了：</p>
<ol>
<li>因为写入的是同一个对象，Java序列化机制为了节省磁盘空间，当写入文件的为同一个对象时，并不会将对象的内容再次进行存储，而只是再次存储一份引用，上面增加的5个字节的存储空间就是新增的引用和一些控制信息的空间，从反序列化的结果也可以看出，两个引用指向的是同一个对象；</li>
<li>虽然第二次存储时将年龄修改为22，但是因为Java序列化机制在第二次序列化同一个对象时，并保存具体的数据，只是保存了第一次的引用，所以反序列化时，得到的对象都是第一次序列化的对象。</li>
</ol>
<h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>这里可以可以参考<a href="http://ych0108.iteye.com/blog/2256640" target="_blank" rel="external">Java中序列化的serialVersionUID作用</a>一文。</p>
<p>这里我们就简单说一下序列化ID的作用：</p>
<p><code>serialVersionUID</code>用来表明类的不同版本间的兼容性。它有两种生成方式： 一个是默认的1L；另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的<code>serialVersionUID</code>；而在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的<code>serialVersionUID</code>。 </li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置<code>serialVersionUID</code>，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了<code>serialVersionUID</code>，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10058164.html" target="_blank" rel="external">Java编程思想 第4版</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="external">Java序列化的高级认识</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java容器学习]]></title>
      <url>http://wangzzu.github.io/2016/05/13/java-collection/</url>
      <content type="html"><![CDATA[<p>Java的容器类，在程序中经常被用，而且也是在面试中经常被问到的部分，笔者近段就被问到过n次了，所以这里就根据网上的一些资料，并结合着openJDK的源码对这些容器类好好总结一下。</p>
<h1 id="Java中的容器"><a href="#Java中的容器" class="headerlink" title="Java中的容器"></a>Java中的容器</h1><p>在Java（以JDK1.7为例）中，如果一个程序包含固定数量的且生命周期已知的对象，那么我们可以使用数组来保存这些对象。但是一般情况下，我们在写程序时不知道需要保存多少个对象，对于这种情况，Java的实用类库中提供了一套相当完整的容器类来解决这个问题，其中基本的类型是：</p>
<ol>
<li>List</li>
<li>Set</li>
<li>Map</li>
</ol>
<p>这些容器类也称为集合类。</p>
<p>对于它们之间的联系：我是这样理解的，首先Map是一个K-V对的集合（关联数组）：</p>
<ol>
<li>key的集合组成了一个Set，因为key是不允许重复的，且Map不会保存key的插入顺序，所以key可组成一个set；</li>
<li>value的集合组成了一个List，因为value是完全可以重复的，Map会根据key的值来获取value，这些value（如果当key是int型时）就组成了一个List（当然List并不是根据Map实现的）。</li>
</ol>
<p>上面的三种集合类只是提供了三个基本的接口，实际使用的集合类主要还是在它们的子类，下面这个图比较清楚地介绍了这三种容器类的常用子类（图片来自<a href="http://stackoverflow.com/questions/3317381/what-is-the-difference-between-collection-and-list-in-java" target="_blank" rel="external">StackOverFlow</a>）</p>
<p><img src="/images/java/collection.png" alt="collection"></p>
<blockquote>
<p>注：图片并没有把所有的继承与接口实现全部表示出来，只是列出了主要的部分，比如：<code>class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code>，而<code>class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set</code>，而<code>AbstractCollection&lt;E&gt; implements Collection</code>，全部的继承与接口实现机制比较复杂，这里只画出了它们的主要部分，这样方便我们看到这些集合类之间的联系与区别。</p>
</blockquote>
<p>对于集合类的分析，这里我们主要从以下几个部分去分析：</p>
<ol>
<li>原理：底层如何实现；</li>
<li>性能：分析这个集合类在具体操作上的复杂度<ul>
<li>插入：插入是如何实现的，性能如何；</li>
<li>删除：删除是如何实现的，性能如何；</li>
<li>读取：读取是如何实现的，性能如何；</li>
</ul>
</li>
<li>其他：比如集合类存储对象时，HashMap里需要重写<code>hash()</code>和<code>equals()</code>等性质。</li>
</ol>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>首先这里先介绍一下List集合类，List集合存储的是对象的引用或者基本数据类型，而且存储都是<strong>有序</strong>的，并且<strong>可以重复</strong>。下面分别介绍三种常见的List类。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/ArrayList.java" target="_blank" rel="external">ArrayList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认的数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData; <span class="comment">// transient关键字主要是用于定制序列化方面</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 知道数组长度的情况下初始化数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// 动态增加数组的长度，每次动态增加(oldCapacity &gt;&gt; 1)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取元素，先检查index是否在范围，然后直接以数组的方式取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改给定位置的一个元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 在list的最后添加一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在给定位置添加一个元素（随机插入），这时候需要将该位置后面的所有元素移位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移出给定位置的一个元素（随机删除），这时候也需要将该位置后面的所有元素移位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移出第一个符合要求的元素（需要从最前面开始遍历list）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对代码的分析，下面总结一下ArrayList（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/ArrayListTest.java" target="_blank" rel="external">测试代码</a>）：</p>
<ul>
<li>原理：基于<strong>数组</strong>来实现（顺序存储的线性表）</li>
<li>特点：<ol>
<li>动态数组，每次插入时都会检查数组长度是否够用，不够用时需要进行扩大，每次会将数组的长度增加$\frac{N}{2}$，也就是新建一个数组，然后将原来数组的元素拷贝进去；</li>
<li>ArrayList是List接口的可变数组的实现； </li>
<li>非同步；</li>
<li>添加、删除操作时，每次都需要把该索引右边的数组整体移动，性能较差，所以ArrayList更擅长随机访问数组，但是在数组中间进行插入或删除元素时较慢；</li>
<li>内部实现时，使用了<code>transient</code>修饰数组，这保证系统序列化ArrayList对象时不会直接序列化<code>elementData</code>数组，而是通过ArrayList提供的<code>writeObject</code>、<code>readObject</code>方法定制序列化。</li>
</ol>
</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Vector.java" target="_blank" rel="external">Vector</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement; <span class="comment">// 数组动态增加时的步长</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化list，可以设置步长</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在list最后添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在给定位置添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        insertElementAt(element, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机插入元素的实际操作方法，这里也需要移动整个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">        elementCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除给定位置的元素，也需要整体移动数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取给定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Vector与ArrayLis很相似，ArrayList与Vector的大部分方法都是相同，只是Vector添加了<code>synchronized</code>，也就是说，Vector是ArrayList的线程安全版本，但是在序列化方面，ArrayList比Vector更安全。</p>
<ul>
<li>原理：基于<strong>数组</strong>实现</li>
<li>特点：<ol>
<li>同步的（方法大都是<code>synchronized</code>的）；</li>
<li>每次扩大时可以通过参数设置扩大的步长;</li>
<li>对于Vector，没有使用<code>transient</code>修饰数组，而且Vector只提供了一个<code>writeObject</code>方法，并未完全实现定制序列化。</li>
</ol>
</li>
</ul>
<p>它有一个子类为Stack（线程安全），对于栈，不要求线程安全时，可以使用<code>ArrayDeque</code>实现。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>源码可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，我们这里主要摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 指向第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 指向最后一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素e添加到list的头部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用上一个私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;&#125; <span class="comment">// 将元素添加到list的尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在节点succ前添加一个元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在list尾部添加元素的实际操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 在list最后面添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定位置添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index)); <span class="comment">//调用这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除给定的节点</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据索引返回该位置的Node（这个方法会经常调用，通过遍历的方法找到该位置）</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：基于<strong>双向链表</strong>实现的（链式存储的线性表）</li>
<li>特点：<ol>
<li>在获取元素的索引时，需要去<strong>遍历</strong>链表来获取索引（也就是<code>node()</code>方法）。</li>
<li>它的插入和删除操作比ArrayList更加高效（主要是对于List中间的删除或添加，因为ArrayList需要整体移动右边数组），也正是由于它是基于链表实现的，所以随机访问的效率要比ArrayList差。</li>
<li>非同步；</li>
<li>实现了List和Deque接口，既可以做双向链表使用，又可以做队列使用，还可以做栈使用;</li>
<li>也可以进行定制序列化。</li>
</ol>
</li>
</ul>
<blockquote>
<p>Deque接口是双端队列，既可以作为栈也可以作为队列。</p>
</blockquote>
<p>关于LinkedList，笔者做一个test，使用LinkedList分别做链表、队列和栈，参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/list/LinkedListTest.java" target="_blank" rel="external">测试代码</a>。</p>
<blockquote>
<p>Notice: <strong>fail-fast 机制</strong>是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件（<code>ConcurrentModificationException</code>）。fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用 fail-fast机制的集合，建议使用<code>java.util.concurrent</code>包下的类去取代<code>java.util</code>包下的类。</p>
</blockquote>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map一种经常用的容器类型，它存储的是K-V键值对。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>先讲一下最常用的HashMap吧，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashMap.java" target="_blank" rel="external">HashMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认的长度，这里是16，要求必须是2的次方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认的负载因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// map中的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定大小和负载因子初始化map</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 添加KV对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; <span class="comment">// key相等（hash值还有实际值相等）时，替换value</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i); <span class="comment">// 将&lt;key, value&gt;添加到i索引处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将KV对添加到给定位置的Entry链上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key获取相应的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key找到给KV对象</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key删除该元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际删除该Entry链元素的实际操作</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Google上找到了一张关于关于HashMap数据存储图，如下所示</p>
<p><img src="/images/java/hashmap.png" alt="hashmap"></p>
<ul>
<li>原理： 基于<strong>拉链法的散列表</strong>（数组和链表的结合），数组的每个元素都是一个链表的引用，对象的存储位置跟key的hash值有关。</li>
<li>特点：<ol>
<li>允许存放null键和null值；</li>
<li>HashMap数组的长度总是2的n次方（这样才能高效地利用数组空间的存储）；</li>
<li>当key的hash值相同，而值不同时，会添加到链表里，key值相同时，就会覆盖原kv对的value值； </li>
<li><code>java.util.HashMap</code>不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出<code>ConcurrentModificationException</code>，这就是所谓fail-fast策略；</li>
<li>HashMap在底层吧K-V当成一个整体进行处理，这个整体就是一个Entry对象。</li>
</ol>
</li>
<li>缺点： Hashmap数据有可能出现分布不均匀的情况这样就会影响查询效率，这跟HashCode算法和具体数据有关系，一般需要重写HashCode算法。</li>
<li>性能<ol>
<li>负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的总容量(initialCapacity)，当loadFactor达到指定值或者0.75时候，HashMap的总容量自动扩展一倍，以此类推。</li>
<li>负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</li>
<li>负载因子是对时间和空间成本上的一种折衷。增大负载因袭可以减少Hash表所占用的内存空间，但会增加查询时间，而查询是HashMap中对频繁的操作；减少负载因子会提高数据查询的性能，但会增加Hash表所占用的内存空间。</li>
</ol>
</li>
</ul>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/Hashtable.java" target="_blank" rel="external">Hashtable</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Hashtable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是11，与有所HashMap不同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看是否包含某个KV对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key查找KV对的value值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能分配的最大数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加数组的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">        Entry&lt;K,V&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt;[] newMap = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);</span><br><span class="line"></span><br><span class="line">        table = newMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素，与HashMap类似</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                V old = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = hash(key);</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素，如果该key不存在，则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：数组+链表（与HashMap一样）</li>
<li>特点：<ol>
<li>和HashMap一样，Hashtable也是一个基于拉链法实现的散列表，它存储的内容是键值对；</li>
<li>Hashtable继承于Dictionary类，实现了Map, Cloneable, java.io.Serializable接口；</li>
<li>线程安全；</li>
<li>比较老的类，命名也没有遵循现在Java的驼峰法；</li>
<li>Hashtable的key和value都不允许为null；</li>
</ol>
</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedList.java" target="_blank" rel="external">LinkedList</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123; <span class="comment">// 继承HashMap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header; <span class="comment">// 头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder; <span class="comment">// 设置迭代顺序，可以设置插入顺序（false）或者访问顺序（true）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(m);</span><br><span class="line">        accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        header.before = header.after = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上调用HashMap的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap的数据的存储方式如下图所示（图片来自<a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="external">LinkedHashMap</a>）：</p>
<p><img src="/images/java/linkedhashmap.png" alt="LinkedHashMap"></p>
<blockquote>
<p>Note：途中蓝色箭头的指针是<code>Entry</code>对象的<code>next</code>指针，而黑色箭头的指针是双向链表的<code>before</code>和<code>after</code>指针。</p>
</blockquote>
<ul>
<li>原理：数组+双向链表（有before、after两个指针，所以可以保留插入或访问顺序）</li>
<li>特点：<ol>
<li>LinkedHashMap是HashMap的一个子类，它<strong>保留插入的顺序</strong>， 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap；</li>
<li>LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的<strong>双向链接列表</strong>。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序；</li>
<li>非同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步；</li>
<li>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序；</li>
<li>如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表；</li>
<li>底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性；</li>
<li>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序；</li>
<li>LinkedHashMap通过继承hashMap中的Entry,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序；</li>
<li>允许使用null值和null键；</li>
</ol>
</li>
</ul>
<p>关于迭代顺序可以参考<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/LinkedHashMapTest.java" target="_blank" rel="external">测试代码</a></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>对于线程安全的情况，在不考虑性能问题的时候，我们的解决方案有Hashtable或者Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个hash表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。 但是Java为我们提供了封装好的线程安全的集合类，这些类在<code>java.util.concurrent</code>包内，这里我们介绍一个常用的map子类——ConcurrentHashMap。</p>
<p>源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/concurrent/ConcurrentHashMap.java" target="_blank" rel="external">ConcurrentHashMap</a>，这里就不再介绍 ConcurrentHashMap的源码了。</p>
<p>先看一下ConcurrentHashMap的结构，如下图所示</p>
<p><img src="/images/java/concurrenthashmap.png" alt="concurrenthashmap"></p>
<p>在ConcurrentHashMap内有几个重要的内部类分别是：</p>
<ol>
<li><code>HashEntry</code>类：用来封装散列映射表中的键值对，HashEntry的学习可以类比着 HashMap中的Entry。我们的存储键值对的过程中，散列的时候如果发生“碰撞”，将采用<strong>拉链法</strong>来处理碰撞：把碰撞的 HashEntry 对象链接成一个链表；</li>
<li><code>Segment</code>类：Segment 的类定义为<code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</code>，其继承于 ReentrantLock类，从而使得 Segment对象可以充当锁的角色。Segment中包含HashEntry的数组，其可以守护其包含的若干个桶（HashEntry的数组）。Segment 在某些意义上有点类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</li>
</ol>
<ul>
<li>原理：数组+链表，每个数组元素是一个类似于HashMap结构的segment，每个segment又是一个数组和链表的形式，这样在对某个segment操作时，就可以锁住该segment，不影响对其他segment的操作。</li>
<li>特点：<ol>
<li>ConcurrentHashMap的实现是依赖于Java内存模型；</li>
<li>本质也是数组和链表，ConcurrentHashMap数据结构为一个Segment数组，Segment的数据结构为HashEntry的数组，而HashEntry存的是我们的键值对，可以构成链表，默认的Segment是16个，通过key的hash值与16取余确定在哪个桶。</li>
<li>ConcurrentHashMap的结构中包含的Segment的数组，在默认的并发级别会创建包含16个Segment对象的数组。</li>
<li>执行put方法的时候，会需要<strong>加锁</strong>来完成，在put操作时锁定的是一个Segment而不是整个ConcurrentHashMap。</li>
<li>ConcurrentHashMap不允许空值。该方法首先有一个Segment的引用s，然后会通过hash()方法对key进行计算，得到哈希值；继而通过调用Segment的put(K key, int hash, V value, boolean onlyIfAbsent)方法进行存储操作。</li>
<li>在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</li>
</ol>
</li>
</ul>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ol>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeMap.java" target="_blank" rel="external">TreeMap</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator; <span class="comment">// 比较器，不设置时使用key的自然顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以设置比较器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = <span class="keyword">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入方法，这个是红黑树中非常重要的方法，根据定制的比较器将插入的元素放在合适的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">            root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除KV对</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        V oldValue = p.value;</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key找到对应的Entry对象，熟悉二叉树的人应该很熟悉这里的结构</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 很多话方法都会调用这个比较方法（这个方法设置为了final，是不允许修改的）</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>特点：<ol>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的；</li>
<li>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合；</li>
<li>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合；</li>
<li>TreeMap 实现了Cloneable接口，意味着它能被克隆；</li>
<li>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化；</li>
<li>TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的；</li>
<li>可以重写<code>comparable</code>。</li>
</ol>
</li>
<li>性能：<ol>
<li>因为底层是使用红黑树保存集合中的Entry对象，这也就意味着TreeMap对于添加元素、取出元素的性能要比HashMap低。当TreeMap添加元素时，需要通过循环找到新增Entry的插入位置，因此比较耗性能；当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，也比较耗性能；</li>
<li>TreeMap的优势在于：TreeMap中的所有Entry都是按key根据指定排序规则（可以根据重写的<code>comparable</code>定制排序规则）操持有序状态。</li>
</ol>
</li>
</ul>
<p>这里我做了一个测试，使用TreeMapTest（及其自定义排序形式）与HashMap做一下对比（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/map/TreeMapTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by matt on 5/13/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">		HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		treeMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</span><br><span class="line">		treeMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</span><br><span class="line">		treeMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</span><br><span class="line">		treeMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</span><br><span class="line">		Iterator tree = treeMap.keySet().iterator();</span><br><span class="line">		System.out.println(<span class="string">"TreeMap:"</span>);</span><br><span class="line">		<span class="keyword">while</span> (tree.hasNext()) &#123;</span><br><span class="line">			Object key = tree.next();</span><br><span class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap.get(key));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		TreeMap&lt;String,String&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;String,String&gt;(<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				String a = (String)o1;</span><br><span class="line">				String b = (String)o2;</span><br><span class="line">				<span class="keyword">return</span> -a.compareTo(b);</span><br><span class="line">			&#125;&#125;);</span><br><span class="line">		treeMap1.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</span><br><span class="line">		treeMap1.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</span><br><span class="line">		treeMap1.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</span><br><span class="line">		treeMap1.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</span><br><span class="line">		Iterator tree1 = treeMap1.keySet().iterator();</span><br><span class="line">		System.out.println(<span class="string">"\nTreeMap（根据value排序）:"</span>);</span><br><span class="line">		<span class="keyword">while</span> (tree1.hasNext()) &#123;</span><br><span class="line">			Object key = tree1.next();</span><br><span class="line">			System.out.println(key.toString() + <span class="string">" "</span> + treeMap1.get(key));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hashMap.put(<span class="string">"a"</span>, <span class="string">"wm0"</span>);</span><br><span class="line">		hashMap.put(<span class="string">"b"</span>, <span class="string">"wm1"</span>);</span><br><span class="line">		hashMap.put(<span class="string">"c"</span>, <span class="string">"wm2"</span>);</span><br><span class="line">		hashMap.put(<span class="string">"d"</span>, <span class="string">"wm3"</span>);</span><br><span class="line">		Iterator hash = hashMap.keySet().iterator();</span><br><span class="line">		System.out.println(<span class="string">"\nHashMap:"</span>);</span><br><span class="line">		<span class="keyword">while</span> (hash.hasNext()) &#123;</span><br><span class="line">			Object key = hash.next();</span><br><span class="line">			System.out.println(key.toString() + <span class="string">" "</span> + hashMap.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Output:</span><br><span class="line">* TreeMap:</span><br><span class="line">* a wm0</span><br><span class="line">* b wm1</span><br><span class="line">* c wm2</span><br><span class="line">* d wm3</span><br><span class="line">* </span><br><span class="line">* TreeMap（根据value排序）:</span><br><span class="line">* d wm3</span><br><span class="line">* c wm2</span><br><span class="line">* b wm1</span><br><span class="line">* a wm0</span><br><span class="line">*</span><br><span class="line">* HashMap:</span><br><span class="line">* d wm3</span><br><span class="line">* b wm1</span><br><span class="line">* c wm2</span><br><span class="line">* a wm0</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>下面开始介绍Set了，Set是不保存重复元素的集合。当保存对象引用，一般情况下，对象需要重写<code>equals()</code>和<code>hashCode()</code>方法，不重写的话，就会使用对应Map（HashMap，TreeMap）的判断方法。</p>
<p>因为Set集合类的底层实现大都与前面的类似，所以下面会介绍稍微简洁一些。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>先介绍一下HashSet，还是看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/HashSet.java" target="_blank" rel="external">HashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// 使用HashMap实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object(); <span class="comment">// map中默认的value值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法都是借助与HashMap实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感觉这个应该是老方法，构造对象时是无法使用这个方法的</span></span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素，这个方法本质上还是调用了HashMap的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中，我们可以看到，HashSet的实现其实非常简单，他只是封装了一个HashMap对象来存储所有的集合元素。所有放入HashSet中的集合元素实际上由HashMap的key来保存，而HashMap的value则存储了一个<code>PRESENT</code>，它是一个静态的Object对象。</p>
<ul>
<li>原理：HashSet底层使用HashMap来保存所有元素（value出存储了一个静态的Object对象）。</li>
<li>特点：<ol>
<li>HashSet实现了Set接口，它不允许集合中有重复的值;</li>
<li>HashSet的随机读取和写入还是很快的，同样也会出现与HashMap一样的问题，即有可能出现数据不均匀的情况；</li>
<li>重写<code>equals()</code>和<code>hashCode()</code>方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象;</li>
<li>当向Set添加元素时，如果与Set中的某一个元素比较时，当<code>equals()</code>比较返回true和<code>hashCode()</code>的返回值相等时，此时，元素就会添加失败（并不会覆盖Set中的元素，因为在HashMap中，遇到这种情况，只是覆盖value，不会覆盖key，而HashSet是基于HashMap实现的，所以元素也并不会被覆盖，只是会添加失败）；</li>
</ol>
</li>
</ul>
<p>下面我们看一个三个测试用例，来说明使用HashSet存储对象引用时，重写<code>equals()</code>和<code>hashCode()</code>方法的重要性。</p>
<p>Test1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</span><br><span class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Output: false</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>Test2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</span><br><span class="line">			Person per = (Person) o;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age == per.age &amp;&amp; <span class="keyword">this</span>.name.equals(per.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</span><br><span class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 因为两个对象的hash值不同，这样就会当作两个对象来处理。</span><br><span class="line">* Output: false</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>Test3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o.getClass() == Person.class) &#123;</span><br><span class="line">			Person per = (Person) o;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(per.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">12</span>));</span><br><span class="line">		System.out.println(set.contains(<span class="keyword">new</span> Person(<span class="string">"wm"</span>,<span class="number">123</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 重写的equals和hashCode方法的返回值必须保持一致，当两个类的hashCode()返回值相同时，</span><br><span class="line">* 它们通过equals()方法的比较也应该相同。</span><br><span class="line">* Output: true</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>还是先看一下主要的源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/LinkedHashSet.java" target="_blank" rel="external">LinkedHashSet</a>，这里摘取几块重要的部分（并非全部代码）</p>
<p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上是调用了HashSet中的default方法（该方法只能在包内或同一个文件内部调用），实际使用LinkedHashMap实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理：继承于HashSet、又基于LinkedHashMap来实现。</li>
<li>特点：<ol>
<li>是一个Set的实现，所以它其中存的肯定不是键值对，而是值；</li>
<li>与HashSet的不同之处在于，LinkedHashSet维护着一个运行于所有条目的双向链接列表。 此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序；</li>
<li>非同步。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步；</li>
<li>继承于HashSet、又基于LinkedHashMap（父类HashSet实现时专门为其提供了一个LinkedHashMap的构造方法）来实现的。</li>
</ol>
</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet源码，可以参考<a href="https://github.com/fanhongtao/JDK/blob/master/src/java/util/TreeSet.java" target="_blank" rel="external">TreeSet</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的源码可知，TreeSet底层采用一个<code>NavigableMap</code>来保存TreeSet集合的元素。但实际上，由于<code>NavigableMap</code>只是一个接口，因此底层依然是使用了TreeMap来包含Set集合中的所有元素。TreeSet里绝大多数方法都是直接使用TreeMap的方法来实现的，因此在上面的源码只列出简单的TreeSet的构造方法。</p>
<ul>
<li>原理：基于TreeMap实现的。</li>
<li>特点：TreeSet中的所有元素总是根据指定排序规则保存有序状态（可以自定义TreeSet的排序规则）。</li>
</ul>
<p>下面给一个例子（<a href="https://github.com/wangzzu/java_learn/blob/master/java_thinking/src/javabasic/collection/set/TreeSetTest.java" target="_blank" rel="external">测试代码</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by matt on 5/13/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeSet&lt;String&gt; treeSet=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">		treeSet.add(<span class="string">"wm0"</span>);</span><br><span class="line">		treeSet.add(<span class="string">"wm1"</span>);</span><br><span class="line">		treeSet.add(<span class="string">"matt0"</span>);</span><br><span class="line">		treeSet.add(<span class="string">"matt1"</span>);</span><br><span class="line">		Iterator tree=treeSet.iterator();</span><br><span class="line">		System.out.println(<span class="string">"HashSet(默认排序规则):"</span>);</span><br><span class="line">		<span class="keyword">while</span> (tree.hasNext())&#123;</span><br><span class="line">			System.out.println(tree.next());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TreeSet&lt;String&gt; treeSet1 = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				String a = (String)o1;</span><br><span class="line">				String b = (String)o2;</span><br><span class="line">				<span class="keyword">return</span> -a.compareTo(b);</span><br><span class="line">			&#125;&#125;);</span><br><span class="line">		treeSet1.add(<span class="string">"wm0"</span>);</span><br><span class="line">		treeSet1.add(<span class="string">"wm1"</span>);</span><br><span class="line">		treeSet1.add(<span class="string">"matt0"</span>);</span><br><span class="line">		treeSet1.add(<span class="string">"matt1"</span>);</span><br><span class="line">		System.out.println(<span class="string">"\nHashSet(向反的默认排序规则):"</span>);</span><br><span class="line">		Iterator tree1=treeSet1.iterator();</span><br><span class="line">		<span class="keyword">while</span> (tree1.hasNext())&#123;</span><br><span class="line">			System.out.println(tree1.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* HashSet(默认排序规则):</span><br><span class="line">* matt0</span><br><span class="line">* matt1</span><br><span class="line">* wm0</span><br><span class="line">* wm1</span><br><span class="line">*</span><br><span class="line">* HashSet(向反的默认排序规则):</span><br><span class="line">* wm1</span><br><span class="line">* wm0</span><br><span class="line">* matt1</span><br><span class="line">* matt0</span><br><span class="line">* /</span></span><br></pre></td></tr></table></figure>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><p>这里理出一些常见的面试题，大部分题并未给出准确的回答，大家可以根据前面的分析自行总结。</p>
<ol>
<li>ArrayList VS Vector</li>
<li>ArrayList VS LinkedList<ul>
<li>ArrayList和LinkedList是两个集合 类，用于存储一系列的对象引用(references)。一般大家都知道ArrayList和LinkedList的大致区别： </li>
</ul>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 </li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要进行遍历。 </li>
<li>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动部分数据。 </li>
</ol>
</li>
<li>说你知道的几个Java集合类：list、set、queue、map实现类。<ul>
<li>Map接口<br>映射。主要存储一组组具有映射关系的数据，映射关系主要用key/value的键值对形式表示，一组键值对构成了Map的内部类Entry，所以可以把Map当做由Entry构成的集合。</li>
<li>List接口<br>表。这个表可以是数组实现的ArrayList，也可以是链表实现的LinkedList。比较古老的实现是Vector，现在不推荐使用，包括它的子类Stack，尽管它是线程安全的。List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。</li>
<li>Queue接口<br>模拟”队列”这种数据结构</li>
<li>Set 接口<br>Set是只有Key值，value值为NULL的一个特殊的Map。 只能通过iterator访问元素。</li>
</ul>
</li>
<li>Java中的队列都有哪些，有什么区别。</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高？</li>
<li>HashMap与HashTable的区别？<ol>
<li>继承的父类不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap，它们都实现了Map接口。Dictionary是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的实现；</li>
<li>key和value是否允许出现null值。HashMap的key和value都允许为null，而Hashtable的key和value都不允许为null。HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理；Hashtable遇到null，直接返回NullPointerException；</li>
<li>线程安全不同，Hashtable中的几乎所有的public的方法都是synchronized的，而有些方法也是在内部通过synchronized代码块来实现。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理；</li>
<li>是否提供contains方法，HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同；</li>
<li>内部实现使用的数组初始化和扩容方式不同，HashTable中hash数组默认大小是11，增加的方式是 $old*2+1$，HashMap中hash数组的默认大小是16，而且一定是2的指数；</li>
<li>两个遍历方式的内部实现上不同，Hashtable、HashMap都使用了 Iterator，Hashtable还保留了Enumeration的方式 ；</li>
<li>hash值不同，哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值。</li>
</ol>
</li>
<li>HashMap冲突很厉害，最差性能，你会怎么解决?从$O(n)$提升到$\log{n}$。</li>
<li>HashMap和Concurrent HashMap区别， Concurrent HashMap 线程安全吗， Concurrent HashMap如何保证 线程安全？</li>
<li>Hash冲突怎么办？哪些解决散列冲突的方法？<ol>
<li>基于<strong>拉链法</strong>的散列表</li>
</ol>
<ul>
<li>原理：数组+链表（HashMap的实现方式）</li>
<li>特点：</li>
</ul>
<ol>
<li>方法：一，根据散列值查找相应的链表；二，沿着链表查找相应的键；</li>
<li>性能：对于一张含有M条链表和N个键的散列表中，未命中查找和插入操所需的比较次数都为$~\frac{N}{M}$。</li>
<li>基于<strong>线性探测法</strong>的散列表</li>
</ol>
<ul>
<li>原理：用大小为M的<strong>数组</strong>保存N个键值对（$M&gt;N$）。利用空位，也称为开放地址散列表。</li>
<li>特点：当发生碰撞时，直接检查散列表的下一个位置（索引值加1），会有三种结果：</li>
</ul>
<ol>
<li>命中，该位置的键和被查找的键相同；</li>
<li>未命中，键为空；</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ol>
<ul>
<li>缺点：进行删除操作时，删除键右边的所有键（连在一起）需要重新插入散列表。</li>
</ul>
</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写。</li>
<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现。</li>
<li>常用的hash算法有哪些？<ul>
<li>除法hash：求余；</li>
<li>乘法hash；</li>
</ul>
</li>
<li>什么是一致性哈希？（参考<a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="external">五分钟理解一致性Hash算法</a>）<br>为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题。<br>判定哈希算法好坏的四个定义：<ol>
<li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用；</li>
<li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。；</li>
<li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性；</li>
<li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷；<br>在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点：<strong>虚拟节点</strong>（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列.</li>
</ol>
</li>
<li>ReHash<br>ReHash的过程其实是空间和时间的双重重大损失，ReHash的过程其实就是一个动态扩容的过程，而哈希表的扩容是个空间和时间消耗都非常惊人的内部操作。<ol>
<li>原来当我们对哈希结构的容器进行扩容时，散列表内部要重新new一个更大的数组，然后把原来数组的内容拷贝到新数组，并进行重新散列；</li>
<li>new出来的这个更大的新数组容量有多大也是一门学问，一般来说，新数组的大小会设置成原数组双倍大小的相近的一个素数</li>
</ol>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/" target="_blank" rel="external">Java集合学习指南</a></li>
<li><a href="http://www.cnblogs.com/leesf456/tag/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">Java集合框架学习</a></li>
<li><a href="http://item.jd.com/10064252.html" target="_blank" rel="external">突破Java程序员基本功的16课</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中对象的内存使用学习]]></title>
      <url>http://wangzzu.github.io/2016/05/07/java-object-memory/</url>
      <content type="html"><![CDATA[<p>本文的内容来自《算法 第四版》，上次看这一部分的时候应该是一年前了，不过因为昨天在面试中，被问到String对象在内存是如何存储，虽然之前看过这方面的内容，对这还有一点模糊印象，但终究没想起来，所以就想再看一下，顺便写成博客，方便以后查看。</p>
<p>本文主要介绍在Java中，对象、数组、字符串在内存是如何存储的，它们需要占用多少内存。</p>
<h1 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h1><p>要想知道一个对象使用的内存量，需要将所有实例变量使用的内存与对象本身的开销（一般是16个字节）相加。这些开销包括一个指向对象的类的引用、垃圾收集信息以及同步信息。另外，一般内存的使用都会被填充为8个字节（64位计算机中的机器字）的倍数。如下图所示，对于一个<code>Integer</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/integer.png" alt="int"></p>
<p>一个<code>Integer</code>对象会使用24字节（16个字节的对象开销，4个字节用于保存它的int值以及4个填充字节）。</p>
<p>一个<code>Date</code>对象（如下图）需要使用32字节：16个字节的对象开销，3个int实例变量各需4个字节，以及4个填充字节。</p>
<p><img src="/images/2016-05-07-java-object-mem/date.png" alt="date"></p>
<p>对象的引用一般都是一个内存地址，因此会使用8个字节。</p>
<p>例如对于一个<code>Counter</code>对象</p>
<p><img src="/images/2016-05-07-java-object-mem/counter.png" alt="counter"></p>
<p>它需要32字节：16个字节的对象开销，8个字节用于它的String型实例变量（<strong>一个引用</strong>），4字节用于int实例变量，以及4个填充字节。</p>
<p>当我们说明一个引用所占的内存时，我们会单独说它所指向的对象所占用的内存，因此，这个内存使用总量并没有包含String对象所使用的内存。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在java中，数组一般被实现为对象，它们一般都会因为记录长度而需要额外的内存。</p>
<p>一个原始数据类型的数组一般需要24字节的头信息（如下）和保存值所需的引用。</p>
<ol>
<li>16个字节的对象开销；</li>
<li>4个字节用于保存长度；</li>
<li>4个填充字节。</li>
</ol>
<p>下面分别介绍一下<code>int[]</code>、<code>double[]</code>、对象数组和二维数组的内存占用情况。</p>
<p><img src="/images/2016-05-07-java-object-mem/array.png" alt="array"></p>
<h2 id="int值的数组"><a href="#int值的数组" class="headerlink" title="int值的数组"></a>int值的数组</h2><p>一个含有N个int值的数组需要使用$24+4N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="double值的数组"><a href="#double值的数组" class="headerlink" title="double值的数组"></a>double值的数组</h2><p>一个含有N个double值的数组需要使用$24+8N$字节（<em>notice：最后会被填充为8的倍数</em>）。</p>
<h2 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h2><p>一个对象的数组就是一个对象的引用的数组，所以我们应该在对象所需的内存之外再加上引用所需的内存。例如，对于一个含有N个<code>Date</code>对象的数组需要使用24字节（头信息）加上$8N$字节（所有的引用）加上每个对象的32字节，总共$24+40N$。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>对于二维数组而言，它就是一个数组的数组（每个数组都是一个对象）。例如：一个$M*N$的double类型的二维数组需要使用24字节（头信息）加上$8M$字节（所有元素数组的引用）加上$24M$字节（所有元素的开销）加上$8MN$字节（$M$个长度为$N$的double类型的数组），总和共$8MN+32M+24$字节。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>一个String对象</p>
<p><img src="/images/2016-05-07-java-object-mem/string.png" alt="string"></p>
<p>String的标准实现含有4个<strong>实例变量</strong>：</p>
<ul>
<li>一个指向字符数组的引用（8字节）；</li>
<li>三个int值（4个字节）<ol>
<li>第一个int值：字符数组中的偏移量；</li>
<li>第二个int值：一个计数器，也就是字符串的长度，以上图为例，对象所表示的字符串由<code>value[offset]</code>到<code>value[offset+count-1]</code>中的字符组成；</li>
<li>第三个int值：散列值。</li>
</ol>
</li>
</ul>
<p>因此，每个String对象都会使用40字节（16字节表示对象，三个int实例变量各需4个字节，加上数组引用的8个字节和4个填充字节）。这是除字符数组之外字符所需的内存空间，所有字符所需的内存需要另记，因为String的char数组常常是在多个字符串之间共享的。因为String对象是不可变的，这种设计使String的实现能够在多个对象都含有相同的<code>value[]</code>数组时节省内存。</p>
<h1 id="字符串的值和子字符串"><a href="#字符串的值和子字符串" class="headerlink" title="字符串的值和子字符串"></a>字符串的值和子字符串</h1><p>字符串和子字符串的例子如下所示：</p>
<p><img src="/images/2016-05-07-java-object-mem/substring.png" alt="substring"></p>
<p>一个长度为N的String对象一般需要使用40字节（String对象本身）加上$24+2N$字节（字符数组），总共$64+2N$字节。但在处理字符串时经常会和子字符串打交道，所以Java对字符串的表示希望能够避免复制字符串中的字符。</p>
<p>当调用<code>substring()</code>方法时，就创建了一个新的String对象（40字节），但它仍然重用了相同的<code>value[]</code>数组，因此该字符串的子字符串只会使用40字节的内存。含有原始字符串的字符数组的别名存在于子字符串中，字符串对象的偏移量和长度域标记了子字符串的位置。</p>
<p>这些基础机制能够有效地帮助我们估计大量程序对内存的使用情况，但是很多复杂的因素仍然会使这个任务变得困难，这就得看一下JVM方面的书籍了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/11098789.html" target="_blank" rel="external">算法 第四版</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google Java Style]]></title>
      <url>http://wangzzu.github.io/2016/04/22/google-java-style/</url>
      <content type="html"><![CDATA[<p>这份文档是Google Java编程风格规范的定义。在平时编写代码时应该养成一个良好的习惯，按照这个标准去编写容易维护的代码。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。</p>
<h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>源文件编码格式为：<strong>UTF-8</strong>。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(<code>0x20</code>，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h3 id="特殊转义序列"><a href="#特殊转义序列" class="headerlink" title="特殊转义序列"></a>特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(<code>\b</code>,<code>\t</code>,<code>\n</code>, <code>\f</code>, <code>\r</code>,<code>&quot;</code>,<code>&#39;</code>及<code>\</code>)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p>
<h3 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如<code>∞</code>)，还是使用等价的Unicode转义符(比如<code>\u221e</code>)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含（按顺序地）：</p>
<ol>
<li>许可证版权信息（如果需要的情况下）；</li>
<li>package语句；</li>
<li>import语句；</li>
<li>一个顶级类（只有一个）；</li>
</ol>
<p><em>以上每个部分用一个空行隔开。</em></p>
<h2 id="许可证或版权信息"><a href="#许可证或版权信息" class="headerlink" title="许可证或版权信息"></a>许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h2><p><strong>package语句不换行</strong>，列限制并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><ul>
<li>import<strong>不要使用通配符</strong>，不要出现类似这样的import语句：<code>import java.util.*</code>；</li>
<li>import语句<strong>不要换行</strong>，每个import语句独立成行；</li>
<li>顺序与间距：import语句分为以下几组，按照这个顺序，每组由一个空行分隔。<ol>
<li>所有的静态类导入独立成组；</li>
<li><code>com.google</code> imports；</li>
<li>第三的包。每个包为一组，字典序，如<code>andriod</code>，<code>com</code>，<code>junit</code>，<code>org</code>，<code>sun</code>.</li>
<li><code>java</code> imports;</li>
<li><code>javax</code> imports.</li>
</ol>
</li>
</ul>
<p>组内不空行，按字典序排序。</p>
<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><h3 id="只有一个顶级类声明"><a href="#只有一个顶级类声明" class="headerlink" title="只有一个顶级类声明"></a>只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>
<p>例如：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>
<h3 id="类成员顺序"><a href="#类成员顺序" class="headerlink" title="类成员顺序"></a>类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以<strong>某种逻辑</strong>去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h3 id="重载：永不分离"><a href="#重载：永不分离" class="headerlink" title="重载：永不分离"></a>重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><h3 id="使用大括号"><a href="#使用大括号" class="headerlink" title="使用大括号"></a>使用大括号</h3><p>当大括号与<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>语句一起使用，即使只有一条语句（或者是空），也应该把大括号写上。</p>
<h3 id="非空块"><a href="#非空块" class="headerlink" title="非空块"></a>非空块</h3><p>对于非空块和块状结构，主要有以下几个原则：</p>
<ul>
<li>在左大括号前不换行；</li>
<li>左大括号后换行；</li>
<li>右大括号前换行；</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                something();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">                recover();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="空块"><a href="#空块" class="headerlink" title="空块"></a>空块</h3><p>这里主要有两种情况：</p>
<ul>
<li>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行；</li>
</ul>
<ul>
<li>但是也有例外的情况：如果它是一个多块语句的一部分(<code>if/else</code>或 <code>try/catch/finally</code>) ，即使大括号内没内容，右大括号也要换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不换行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="块缩进：2个空格"><a href="#块缩进：2个空格" class="headerlink" title="块缩进：2个空格"></a>块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加<strong>2个空格</strong>，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。（不过一般情况大家用的都是4个，这个的话看个人喜好，感觉只要统一就可以了）</p>
<h2 id="一行一个语句"><a href="#一行一个语句" class="headerlink" title="一行一个语句"></a>一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="列限制：80或100"><a href="#列限制：80或100" class="headerlink" title="列限制：80或100"></a>列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ul>
<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考);</li>
<li><code>package</code>和<code>import</code>语句;</li>
<li>注释中那些可能被剪切并粘贴到shell中的命令行.</li>
</ul>
<h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(<strong>80或100</strong>个字符)而被分为多行，我们称之为<strong>自动换行</strong>(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h3 id="从哪里断开"><a href="#从哪里断开" class="headerlink" title="从哪里断开"></a>从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ul>
<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
<li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ul>
<h3 id="自动换行时缩进至少-4个空格"><a href="#自动换行时缩进至少-4个空格" class="headerlink" title="自动换行时缩进至少+4个空格"></a>自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><h3 id="垂直空白"><a href="#垂直空白" class="headerlink" title="垂直空白"></a>垂直空白</h3><p>以下情况需要使用<strong>一个空行</strong>：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<br>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>
<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>
<h3 id="水平空白"><a href="#水平空白" class="headerlink" title="水平空白"></a>水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和<code>Javadoc</code>用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
<li>在任何左大括号前(<code>{</code>)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
<li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
<li><code>catch</code>块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
<li><code>foreach</code>语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则<strong>双斜杠(//)两边都要空格</strong>。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li><p>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</p>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
</li>
</ol>
<h3 id="水平对齐：不做要求"><a href="#水平对齐：不做要求" class="headerlink" title="水平对齐：不做要求"></a>水平对齐：不做要求</h3><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未对齐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"><span class="comment">// 对齐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h2 id="用小括号来限定组：推荐"><a href="#用小括号来限定组：推荐" class="headerlink" title="用小括号来限定组：推荐"></a>用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。（把所有优先级表全部记下来是比较困难的）</p>
<h2 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="每次只声明一个变量"><a href="#每次只声明一个变量" class="headerlink" title="每次只声明一个变量"></a>每次只声明一个变量</h4><p><strong>不要使用组合声明</strong>，比如<code>int a, b</code>;。</p>
<h4 id="局部变量需要时才声明，并尽快进行初始化"><a href="#局部变量需要时才声明，并尽快进行初始化" class="headerlink" title="局部变量需要时才声明，并尽快进行初始化"></a>局部变量需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组初始化：可写成块状结构"><a href="#数组初始化：可写成块状结构" class="headerlink" title="数组初始化：可写成块状结构"></a>数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">     <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     <span class="number">1</span>,</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">     <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">     <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>与其它块状结构一致，<code>switch</code>块中的内容缩进为2个空格。</p>
<p>每个<code>switch</code>标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h4 id="Fall-through：注释"><a href="#Fall-through：注释" class="headerlink" title="Fall-through：注释"></a>Fall-through：注释</h4><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">         prepareOneOrTwo();</span><br><span class="line">         <span class="comment">// fall through</span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">         handleOneTwoOrThree();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="default的情况要写出来"><a href="#default的情况要写出来" class="headerlink" title="default的情况要写出来"></a>default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>
<h3 id="注解-Annotations"><a href="#注解-Annotations" class="headerlink" title="注解(Annotations)"></a>注解(<code>Annotations</code>)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解<strong>独占一行</strong>。这些换行不属于自动换行，因此缩进级别不变。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="块注释风格"><a href="#块注释风格" class="headerlink" title="块注释风格"></a>块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">* This is // And so /* Or you can</span><br><span class="line">* okay. // is this. * even do this. */</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
<h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>类和成员的<code>modifiers</code>如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="对所有标识符都通用的规则"><a href="#对所有标识符都通用的规则" class="headerlink" title="对所有标识符都通用的规则"></a>对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>,<code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>
<h2 id="标识符类型的规则"><a href="#标识符类型的规则" class="headerlink" title="标识符类型的规则"></a>标识符类型的规则</h2><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>包名<strong>全部小写</strong>，连续的单词只是<strong>简单地连接</strong>起来，不使用下划线。</p>
<h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，<strong>全部字母大写，用下划线分隔单词</strong>。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态<code>final</code>字段，但不是所有静态<code>final</code>字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>); <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="非常量字段名"><a href="#非常量字段名" class="headerlink" title="非常量字段名"></a>非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="局部变量名"><a href="#局部变量名" class="headerlink" title="局部变量名"></a>局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是<code>final</code>和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="类型变量名"><a href="#类型变量名" class="headerlink" title="类型变量名"></a>类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h2 id="驼峰式命名法-CamelCase"><a href="#驼峰式命名法-CamelCase" class="headerlink" title="驼峰式命名法(CamelCase)"></a>驼峰式命名法(<code>CamelCase</code>)</h2><p>驼峰式命名法：</p>
<ol>
<li>大驼峰式命名法(<code>UpperCamelCase</code>);</li>
<li>小驼峰式命名法(<code>lowerCamelCase</code>)。</li>
</ol>
<p>有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ol>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ol>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form Correct Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="string">"XML HTTP request"</span> XmlHttpRequest XMLHTTPRequest</span><br><span class="line"><span class="string">"new customer ID"</span> newCustomerId newCustomerID</span><br><span class="line"><span class="string">"inner stopwatch"</span> innerStopwatch innerStopWatch</span><br><span class="line"><span class="string">"supports IPv6 on iOS?"</span> supportsIpv6OnIos supportsIPv6OnIOS</span><br><span class="line"><span class="string">"YouTube importer"</span> YouTubeImporter</span><br><span class="line">YoutubeImporter*</span><br></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>
</blockquote>
<h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="Override：能用则用"><a href="#Override：能用则用" class="headerlink" title="@Override：能用则用"></a><code>@Override</code>：能用则用</h2><p>只要是合法的，就把<code>@Override</code>注解给用上。</p>
<h2 id="捕获的异常：不能忽视"><a href="#捕获的异常：不能忽视" class="headerlink" title="捕获的异常：不能忽视"></a>捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>
<p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">     <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">     <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     emptyStack.pop();</span><br><span class="line">     fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员：使用类进行调用"><a href="#静态成员：使用类进行调用" class="headerlink" title="静态成员：使用类进行调用"></a>静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure>
<h2 id="Finalizers-禁用"><a href="#Finalizers-禁用" class="headerlink" title="Finalizers: 禁用"></a><code>Finalizers</code>: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* Multiple lines of Javadoc text are written here,</span><br><span class="line">* wrapped normally...</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h3 id="Javadoc标记"><a href="#Javadoc标记" class="headerlink" title="Javadoc标记"></a>Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="摘要片段"><a href="#摘要片段" class="headerlink" title="摘要片段"></a>摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="哪里需要使用Javadoc"><a href="#哪里需要使用Javadoc" class="headerlink" title="哪里需要使用Javadoc"></a>哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个<code>public</code>和<code>protected</code>成员处使用Javadoc，以下是一些例外：</p>
<h3 id="例外：不言自明的方法"><a href="#例外：不言自明的方法" class="headerlink" title="例外：不言自明的方法"></a>例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
</blockquote>
<h3 id="例外：重写"><a href="#例外：重写" class="headerlink" title="例外：重写"></a>例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p>
<h3 id="可选的Javadoc"><a href="#可选的Javadoc" class="headerlink" title="可选的Javadoc"></a>可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Java Style</a></li>
<li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Style编程指南</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[postgres安装]]></title>
      <url>http://wangzzu.github.io/2016/04/14/postgres-install/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下在linux（CentOS7.1）下postgres的安装，后续的一篇博文会着重的介绍一下SQL操作。</p>
<p>注：</p>
<ul>
<li>#：超级用户提示符 </li>
<li>$：普通用户提示符</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install postgresql</span><br><span class="line">$ sudo yum install pgadmin3</span><br><span class="line"></span><br><span class="line">$ su postgres <span class="comment">#切换psql用户下</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></span><br></pre></td></tr></table></figure>
<p>修改用户postgres密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd postgres <span class="comment">#重置新密码</span></span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /var/lib/pgsql/data      #创建pgsql的数据库目录 </span><br><span class="line"># cd /var/lib/pgsql  </span><br><span class="line"># chown postgres.postgres data     #改变目录的所属用户用组 </span><br><span class="line"># su postgres                     #切换到postgres，不然初始化不了</span><br><span class="line"></span><br><span class="line">initdb -E UTF-8 -D /var/lib/pgsql/data --locale=en_US.UTF-8 -U postgres -W  #在postgres下，初始化数据库(初始化过程中，需要输入root密码)</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件，修改postgresql.conf的目的是修改连接权限；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /var/lib/pgsql/data/postgresql.conf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = <span class="string">'*'</span>     <span class="comment">#监听所有ip的连接，默认是本机 ip，当然也可以设置局域网ip</span></span><br><span class="line">port = 5432             <span class="comment">#这个不开也行，默认就是5432端口</span></span><br></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/pg_hba.conf</code>文件，修改pg_hba.conf的目的是设置谁才可以操作数据服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /var/lib/pgsql/data/pg_hba.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD</span></span><br><span class="line"><span class="comment"># "local" is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all         all                               trust </span><br><span class="line"><span class="comment"># IPv4 local connections:  </span></span><br><span class="line">host    all         all         127.0.0.1/32          <span class="literal">true</span></span><br><span class="line">host    all         all         0.0.0.0/0             <span class="literal">true</span>   <span class="comment">#这一行我加的，所有IP和用户，密码对都可以连接 </span></span><br><span class="line"><span class="comment"># IPv6 local connections:  </span></span><br><span class="line">host    all         all         ::1/128               <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="psql使用"><a href="#psql使用" class="headerlink" title="psql使用"></a>psql使用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start postgresql.service</span><br><span class="line"># or</span><br><span class="line"># service postgresql start</span><br></pre></td></tr></table></figure>
<p>但是出现了一个问题：</p>
<p><img src="/images/2016-04-14-postgresql/1.png" alt="startFailed"></p>
<p>使用<code>systemctl status postgresql.service</code>查看日志信息：</p>
<p><img src="/images/2016-04-14-postgresql/fail.png" alt="fail"></p>
<p>检查：</p>
<ul>
<li><p>配置防火墙，在<code>/etc/sysconfig/iptables</code>中添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT //postgresql的端口是5432</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后设置<code>systemctl enable postgresql.service</code> 来设置<code>/usr/lib/systemd/system/postgresql.service</code>文件。</p>
</li>
</ul>
<p>成功启动的psql如下所示：</p>
<p><img src="/images/2016-04-14-postgresql/status.png" alt="status"></p>
<p>通过<code>netstat -tpnl | grep 5432</code>来查看5432端口的情况。</p>
<p><img src="/images/2016-04-14-postgresql/port.png" alt="port"></p>
<h2 id="添加用户和数据库"><a href="#添加用户和数据库" class="headerlink" title="添加用户和数据库"></a>添加用户和数据库</h2><p>推荐两个学习的网站：</p>
<ul>
<li><a href="http://developer.51cto.com/art/201401/426437.htm" target="_blank" rel="external">psql学习网站</a></li>
<li><a href="http://www.yiibai.com/html/postgresql/" target="_blank" rel="external">psql教程</a></li>
</ul>
<p>首先，在linux下进入到<code>postgres</code>用户名下，然后进入到postgres的控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># su postgres</span><br><span class="line">psql</span><br></pre></td></tr></table></figure>
<p>这样就进入了<strong>数据库的控制台</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不要忘记每句话后的";"，建立数据库用户时，首先linux系统下要有user用户(adduser user )，然后才可以再把user用户指定为数据库的用户。</span></span><br><span class="line"></span><br><span class="line">CREATE USER matt WITH PASSWORD <span class="string">'123456'</span>;<span class="comment">#创建数据库用户matt，并设置密码</span></span><br><span class="line"></span><br><span class="line">CREATE DATABASE bank OWNER matt;<span class="comment">#创建数据库bank，并指定该数据库的所有者为matt</span></span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE bank to matt;<span class="comment">#将test数据库的所有权限都赋给用户matt，否则用户matt只能登陆控制台，没有任何数据库操作权限</span></span><br><span class="line"></span><br><span class="line">\q <span class="comment">#退出控制台（ctrl+D）</span></span><br></pre></td></tr></table></figure>
<p>控制台命令：</p>
<ul>
<li><strong>\h</strong>：查看SQL命令的解释，比如\h select。</li>
<li><strong>\?</strong>：查看psql命令列表。</li>
<li><strong>\l</strong>：列出所有数据库。</li>
<li><strong>\c [database_name]</strong>：连接其他数据库。</li>
<li><strong>\d</strong>：列出当前数据库的所有表格。</li>
<li><strong>\d [table_name]</strong>：列出某一张表格的结构。</li>
<li><strong>\du</strong>：列出所有用户。</li>
<li><strong>\e</strong>：打开文本编辑器。</li>
<li><strong>\conninfo</strong>：列出当前数据库和连接的信息</li>
</ul>
<h2 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">psql -U matt <span class="_">-d</span> bank -h 127.0.0.1 -p 5432<span class="comment">#上面命令的参数含义如下：-U指定用户，-d指定数据库，-h指定服务器，-p指定端口。</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">psql -U matt <span class="_">-d</span> bank</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建立四张表，不要忘记最后面的“；”号</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(customer_name <span class="built_in">char</span>(<span class="number">20</span>), customer_street <span class="built_in">char</span>(<span class="number">30</span>), customer_city <span class="built_in">char</span>(<span class="number">30</span>), primary <span class="keyword">key</span>(customer_name));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> branch(branch_name <span class="built_in">char</span>(<span class="number">15</span>), branch_city <span class="built_in">char</span>(<span class="number">30</span>), assets <span class="built_in">numeric</span>(<span class="number">16</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(branch_name));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(account_number <span class="built_in">char</span>(<span class="number">10</span>), branch_name <span class="built_in">char</span>(<span class="number">15</span>), balance <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>), primary <span class="keyword">key</span>(account_number));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> depositor(customer_name <span class="built_in">char</span>(<span class="number">20</span>), account_number <span class="built_in">char</span>(<span class="number">10</span>), primary <span class="keyword">key</span>(customer_name, account_number));</span><br></pre></td></tr></table></figure>
<p>其他的SQL命令会后续的博客中详细介绍。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="连接数据库失败"><a href="#连接数据库失败" class="headerlink" title="连接数据库失败"></a>连接数据库失败</h2><p>错误为<code>org.postgresql.util.PSQLException: FATAL: password authentication failed for user &quot;postgres&quot;</code>。<br>打开Postgresql安装目录下的data文件夹，找到pg_hba.conf文件并打开。修改认证方式，将md5改为trust，然后保存。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TYPE DATABASE USER CIDR-ADDRESS METHOD</span></span><br><span class="line"><span class="comment"># IPv4 local connections:</span></span><br><span class="line">host all all 127.0.0.1/32 trust<span class="comment">#md5改为trust</span></span><br><span class="line">host all all 0.0.0.0/0 trust</span><br></pre></td></tr></table></figure>
<p>参考<a href="http://blog.chinaunix.net/uid-26149100-id-3189230.html" target="_blank" rel="external">Postgresql常见问题</a>。</p>
<h2 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h2><p>有可能是电脑的端口5432的TCP/IP允许没有开启。</p>
<h2 id="JAVA接口"><a href="#JAVA接口" class="headerlink" title="JAVA接口"></a>JAVA接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">table_insert</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">         Connection c = <span class="keyword">null</span>;</span><br><span class="line">         Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">long</span> time= <span class="number">201503292255L</span>;</span><br><span class="line">         <span class="keyword">int</span> client_id=<span class="number">4</span>;</span><br><span class="line">         <span class="keyword">int</span> server_id=<span class="number">3</span>;</span><br><span class="line">         <span class="keyword">int</span> server_location=<span class="number">110000</span>;</span><br><span class="line">         String WebName=<span class="string">"other"</span>;</span><br><span class="line">         <span class="keyword">int</span> count=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Class.forName(<span class="string">"org.postgresql.Driver"</span>);</span><br><span class="line">             c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://192.168.81.136:5432/postgres"</span>,<span class="string">"postgres"</span>,<span class="string">"psql"</span>);</span><br><span class="line">             c.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">             System.out.println(<span class="string">"Opened database successfully"</span>);</span><br><span class="line"></span><br><span class="line">             stmt = c.createStatement();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//String sql = "INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( 201503292255, 1, 3, 110000,'others', 2);";</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//String sql="INSERT INTO traffic (time, client_id, server_id, server_location, web_name, count) VALUES( "+time+", "+client_id+", "+server_id+", "+server_location+", '"+WebName+"'"+", "+count+");";</span></span><br><span class="line"></span><br><span class="line">             String sql=<span class="string">"UPDATE traffic SET count="</span>+count+<span class="string">" WHERE time="</span>+time+<span class="string">" AND client_id="</span>+client_id+<span class="string">" AND server_id="</span>+server_id+<span class="string">" AND server_location="</span>+server_location+<span class="string">" AND web_name= '"</span>+WebName+<span class="string">"';"</span>;</span><br><span class="line">             stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">             stmt.close();<span class="comment">//必须从要有对应关闭数据库的操作，否则会出现问题</span></span><br><span class="line">             c.commit();</span><br><span class="line">             <span class="comment">//c.close();</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             System.err.println( e.getClass().getName()+<span class="string">": "</span>+ e.getMessage() );</span><br><span class="line">             System.exit(<span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"Records created successfully"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里必须要有数据库关闭的操作。</p>
<h2 id="连接数过多"><a href="#连接数过多" class="headerlink" title="连接数过多"></a>连接数过多</h2><p><code>So many clients alreay！</code>.<br>查看的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--控制台下输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--当前总共正在使用的连接数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> pg_stat_activity;</span><br><span class="line"><span class="comment">--显示系统允许的最大连接数</span></span><br><span class="line"><span class="keyword">show</span> max_connections;</span><br><span class="line"><span class="comment">--显示系统保留的用户数</span></span><br><span class="line"><span class="keyword">show</span> superuser_reserved_connections ;</span><br></pre></td></tr></table></figure>
<p>修改<code>/var/lib/pgsql/data/postgresql.conf</code>文件的<code>max_connections</code>，默认为100.但是更多的时候需要考虑的是为什么数据库的连接会那么多，一般情况下是自己的程序出错了。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://blog.51yip.com/pgsql/1520.html" target="_blank" rel="external">Postgres安装介绍</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper之学习笔记]]></title>
      <url>http://wangzzu.github.io/2016/04/13/zookeeper-learn/</url>
      <content type="html"><![CDATA[<p>Zookeeper的重要性及应用的广泛性，这里就不再叙述了，本文是学习<a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南</a>的基础上进行的总结，当然本文大部分内容来自此书，中间会穿插一些个人的理解。本文主要分以下几块进行详述。</p>
<blockquote>
<ul>
<li>ZooKeeper介绍</li>
<li>Zookeeper安装与运行</li>
<li>ZooKeeper组成员关系</li>
<li>ZooKeeper服务</li>
<li>ZooKeeper应用</li>
</ul>
</blockquote>
<h1 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h1><p><a href="https://zookeeper.apache.org/" target="_blank" rel="external">官网</a>对其介绍的原话如下：</p>
<blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them ,which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.</p>
</blockquote>
<p>总结一下就是，Zookeeper分布式服务框架是一个用来解决分布式应用中经常遇到的一些数据管理问题（如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等）的中央服务。</p>
<p>对于一个分布式系统最困难的事情之一就是如何处理<strong>部分失败</strong>（partial failure）。当一条message在网络中的两个节点之间传送时，如果出现了网络错误，发送者无法知道接收者是否已经接收到了这条message。接收者有可能在发生错误之前收到这个message，也有可能没有收到，还有可能接收者已经挂掉。发送者获得真实情况的一般解决方案就是：重新连接接收者，然后发起询问。这就是部分失败：即我们甚至不知道一个操作是否已经完成。</p>
<p>Zookeeper正是为了解决这个问题而应运而生的，当然Zookeeper并不能完全根除部分失败，当然它也不会隐藏这部分的失败。ZooKeeper具有以下几个特点：</p>
<ul>
<li>简单：它的核心是一个精简的文件系统，它提供一些简单的操作和一些额外的抽象操作；</li>
<li>富有表现力：ZooKeeper可以用于实现多种协议和数据结构；</li>
<li>高可用性：可避免单点故障；</li>
<li>采用耦合交互方式：在交互过程中，参与者不需要彼此了解，进程在不了解其他进程的情况下就能够彼此发现并进行交互；</li>
<li>是一个资源库：它是一个开源共享存储库，能使程序员免于编写这类通用的协议。</li>
<li>高性能：对于写操作而言，Zookeeper的基准测试吞吐量已经超过每秒10000个操作，对于常规的读操作，吞吐量更高。</li>
</ul>
<h1 id="Zookeeper的安装与运行"><a href="#Zookeeper的安装与运行" class="headerlink" title="Zookeeper的安装与运行"></a>Zookeeper的安装与运行</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="external">Zookeeper镜像上</a>下载Zookeeper安装包（这里以<code>zookeeper-3.4.6.tar.gz</code>为例）。这里给出一般Zookeeper的安装与运行的方法，很多实际生成环境中，我们都是使用CDH集成的Zookeeper，这样的话安装与运行就完全可以通过图形化界面操作了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf zookeeper-3.4.6.tar.gz -C /opt</span><br><span class="line"><span class="comment"># 复制配置文件</span></span><br><span class="line">cp /opt/zookeeper/zoo_sample.cfg /opt/zookeeper/zoo.cfg</span><br></pre></td></tr></table></figure>
<p>修改配置文件<code>zoo.cfg</code>.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/opt/zookeeper/data</span><br><span class="line">dataLogDir=/opt/zookeeper/logs</span><br><span class="line">clientPort=2181</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=zookeeper1:2888:3888</span><br><span class="line">server.2=zookeeper2:2888:3888</span><br><span class="line">server.3=zookeeper3:2888:3888</span><br></pre></td></tr></table></figure>
<p>首先需要在<code>dataDir</code>目录下，新建一个名为<code>myid</code>的文件，这个文件的作用是指定这个服务器的ID，服务器ID在集合体中是唯一的，并且取值范围在1到255之间。下面再分别介绍一下其他几个参数的意义：</p>
<ul>
<li>dataDir：数据目录；</li>
<li>dataLogDir：日志目录；</li>
<li>clientPort：客户端连接端口；</li>
<li>tickTime：Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳（它也是Zookeeper中的基本时间单位）；</li>
<li>initLimit：设定了允许所有follower（下面会介绍）与leader进行连接并同步的时间，它是tickTime的整数倍；</li>
<li>syncLimit：设定了一个follower与leader进行同步的时间，也是tickTime的整数倍；</li>
<li>server.n=hostname:port1:port2：n的值就是服务器的ID，port1是follower用来连接leader的端口，port2是用于leader选举。总结起来就是，2181用于客户端连接，对于leader来说，2888端口用于follower连接，3888端口用于leader选举阶段的其他服务器连接。</li>
</ul>
<h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2><p>启动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>停止：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zookeeper-3.4.6/bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>
<h1 id="ZooKeeper组成员关系"><a href="#ZooKeeper组成员关系" class="headerlink" title="ZooKeeper组成员关系"></a>ZooKeeper组成员关系</h1><p>Zookeeper是一个具有高可用性的高性能协调服务。</p>
<h2 id="组成员关系"><a href="#组成员关系" class="headerlink" title="组成员关系"></a>组成员关系</h2><p>Zookeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，但是这个文件系统中没有文件和目录，而是统一使用节点（node）的概念，成为<strong>znode</strong>。znode既可以作为保存数据的容器（如：文件），也可以作为保存其他znode的容器（如：目录）。所有的znode构成一个层次化的命名空间。一种自然的建立组成员列表的方式就是利用这个层次结构，如下图所示，首先创建一个以组名（<code>/zk</code>）为节点的znode作为父节点，然后以组成员（<code>/zk/node1</code>、<code>/zk/node2</code>、<code>/zk/node3</code>）为节点名来创建作为子节点的znode。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/group.png" alt="group"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>本例通过一个小项目来介绍Zookeeper的API使用。工程项目参见<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/groupexample" target="_blank" rel="external">ZooKeeperGroupExample</a>.</p>
<p>这里是使用maven建立的工程，pom文件中jar包的依赖内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5-cdh5.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h3><p>本程序是在Zookeeper中新建表示组的znode，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateGroup</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		zk = <span class="keyword">new</span> ZooKeeper(hosts, SESSION_TIMEOUT, <span class="keyword">this</span>);</span><br><span class="line">		connectedSignal.await();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">			connectedSignal.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">		String path = <span class="string">"/"</span> + groupName;</span><br><span class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">		System.out.println(<span class="string">"CreateGroup: Created"</span> + createdPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		zk.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		CreateGroup createGroup = <span class="keyword">new</span> CreateGroup();</span><br><span class="line">		createGroup.connect(args[<span class="number">0</span>]);</span><br><span class="line">		createGroup.create(args[<span class="number">1</span>]);</span><br><span class="line">		createGroup.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的主要接口有：</p>
<ul>
<li><code>new ZooKeeper()</code>:实例化一个新的Zookeeper类的对象，这个类负责维护客户端和Zookeeper服务之间的联系。它有三个参数<ol>
<li>Zookeeper服务的主机地址（可指定端口，默认是2181）；</li>
<li>以毫秒为单位的会话超时参数；</li>
<li>一个<code>Watcher</code>对象的实例，<code>Watcher</code>对象接收来自Zookeeper的回调，以获得各种事件的通知。</li>
</ol>
</li>
<li><code>zk.create()</code>:创建一个新的Zookeeper的znode。它有四个参数：<ol>
<li>路径（字符串表示）；</li>
<li>znode的内容（字节数组，本例中都使用null值）；</li>
<li>ACL（访问控制列表）；</li>
<li>创建znode的类型，有短暂和持久两种。</li>
</ol>
</li>
</ul>
<p>当一个Zookeeper实例新建时，会启动一个线程连接到Zookeeper服务，它对构造函数是立即返回的，因此在新建的Zookeeper对象之前一定要等待其与Zookeeper服务之间连接成功。这里使用<code>CountDownLatch</code>来阻止使用的Zookeeper对象。当客户端与Zookeeper建立连接之后，<code>Watcher</code>的<code>process()</code>方法会被调用，参数表示一个连接的事件。在接收到一个连接事件（以<code>Watcher.Event.KeeperState</code>的枚举类型值<code>SyncConnected</code>来表示）时，我们通过调用<code>CountDownLatch</code>的<code>countDown()</code>方法来递减它的计数器。锁存器（latch）被创建时带有一个值为1的计数器，用于表示它在释放所有线程之前需要发生的事件数。在调用一次<code>countDown()</code>方法之后，计数器的值变为0，则<code>await()</code>方法返回。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp zookeeperexample.jar groupexample.CreateGroup zkIP matt</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateGroup: Created/matt</span><br></pre></td></tr></table></figure>
<h3 id="创建组成员"><a href="#创建组成员" class="headerlink" title="创建组成员"></a>创建组成员</h3><p>下面我们编写一个用于注册组成员的程序，每个组成员将作为一个程序运行，并且加入到组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于等待建立与Zookeeper连接的辅助类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT=<span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">protected</span> ZooKeeper zk;</span><br><span class="line">	<span class="keyword">private</span> CountDownLatch connectedSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">		zk=<span class="keyword">new</span> ZooKeeper(hosts,SESSION_TIMEOUT,<span class="keyword">this</span>);</span><br><span class="line">		connectedSignal.await();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(event.getState()== Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">			connectedSignal.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span>  InterruptedException</span>&#123;</span><br><span class="line">		zk.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码与<code>CreateGroup</code>的很类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于将组成员加入到组中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(String groupName, String memberName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">		String path = <span class="string">"/"</span> + groupName + <span class="string">"/"</span> + memberName;</span><br><span class="line">		String createdPath = zk.create(path, <span class="keyword">null</span><span class="comment">/*data*/</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">		System.out.println(<span class="string">"Created "</span> + createdPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		JoinGroup joinGroup = <span class="keyword">new</span> JoinGroup();</span><br><span class="line">		joinGroup.connect(args[<span class="number">0</span>]);</span><br><span class="line">		joinGroup.join(args[<span class="number">1</span>], args[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>CreateMode.PERSISTENT</code>也可以设置为<code>CreateMode.EPHEMERAL</code>，当设置为<code>EPHEMERAL</code>时，也就意味着这个znode是一个短暂的znode，一旦关闭客户端，子节点的znode就会从父节点的znode中删除。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm1</span><br><span class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm2</span><br><span class="line">java -cp zookeeperexample.jar groupexample.JoinGroup 192.168.80.23 matt wm3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Created /matt/wm1</span><br><span class="line">Created /matt/wm2</span><br><span class="line">Created /matt/wm3</span><br></pre></td></tr></table></figure>
<h3 id="列出组成员"><a href="#列出组成员" class="headerlink" title="列出组成员"></a>列出组成员</h3><p>这段程序的目标是，在给出Zookeeper地址和父节点znode的情况下，列出该父节点znode的子节点znode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">		String path = <span class="string">"/"</span> + groupName;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			List&lt;String&gt; children = zk.getChildren(path, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (children.isEmpty()) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"No members in group %s\n"</span>, groupName);</span><br><span class="line">				System.exit(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">				System.out.println(child);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ListGroup listGroup = <span class="keyword">new</span> ListGroup();</span><br><span class="line">		listGroup.connect(args[<span class="number">0</span>]);</span><br><span class="line">		listGroup.list(args[<span class="number">1</span>]);</span><br><span class="line">		listGroup.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是调用了<code>zk.getChildren()</code>来打印出一个znode的子节点列表，调用参数为该znode的路径和设为false的观察标志。如果在一个znode上设置了观察标志，那么一旦该znode的状态改变，关联的观察（<code>Watcher</code>）会被触发。在这里我们没有使用观察，但是在查看一个znode的子节点时，也可以设置观察，让应用程序接收到组成员加入、退出和组被删除的有关通知。</p>
<p><code>KeeperException.NoNodeException</code>代表了组znode不存在的异常。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp zookeeperexample.jar groupexample.ListGroup 192.168.80.23 matt</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wm1</span><br><span class="line">wm2</span><br><span class="line">wm3</span><br></pre></td></tr></table></figure>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p>这里给出一个删除znode的程序，它需要支持一级目录的递归删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteGroup</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String groupName)</span> <span class="keyword">throws</span> KeeperException,InterruptedException</span>&#123;</span><br><span class="line">		String path=<span class="string">"/"</span>+groupName;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			List&lt;String&gt; children=zk.getChildren(path,<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span>(String child: children)&#123;</span><br><span class="line">				zk.delete(path+<span class="string">"/"</span>+child,-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			zk.delete(path,-<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (KeeperException.NoNodeException e)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Group %s does not exist\n"</span>, groupName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		DeleteGroup deleteGroup=<span class="keyword">new</span> DeleteGroup();</span><br><span class="line">		deleteGroup.connect(args[<span class="number">0</span>]);</span><br><span class="line">		deleteGroup.delete(args[<span class="number">1</span>]);</span><br><span class="line">		deleteGroup.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zookeeper对象提供了<code>delete()</code>的方法，该方法有两个参数：</p>
<ol>
<li>路径；</li>
<li>版本号：如果所提供的版本号与znode的版本号一致，则Zookeeper会删除这个znode，这是一种乐观枷锁方式，使客户端能够检测出对znode的修改冲突，这里将版本号设置为-1，可以绕过这个版本检测机制，不管znode的版本号是什么而直接将其删除。</li>
</ol>
<p>Zookeeper不支持递归的删除操作，所以在删除父节点之前必须删除其子节点。</p>
<p>输入以下命令运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp zookeeperexample.jar groupexample.DeleteGroup 192.168.80.23 matt</span><br></pre></td></tr></table></figure>
<p>通过Zookeeper客户端看到的变化如下图（处理过之后的图）所示：</p>
<p><img src="/images/2016-04-13-zookeeper-learn/zk.png" alt="zk"></p>
<h1 id="ZooKeeper服务"><a href="#ZooKeeper服务" class="headerlink" title="ZooKeeper服务"></a>ZooKeeper服务</h1><p>这里主要通过数据模型、操作、实现、一致性、会话和状态来介绍。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Zookeeper维护着一个树形层次结构，树中的节点被称为znode。znode可以用与存储数据，并且有一个与之关联的ACL。</p>
<ol>
<li>Zookeeper被设计用来协调服务（通常是小数据文件），而不是用于大容量数据存储，因此一个znode能存储的数据被限制在1MB以内；</li>
<li>znode的数据访问具有<strong>原子性</strong>：客户端在读取一个znode数据时，要么读取到所有的数据，要么读操作失败，不会只读到部分数据。同样，写操作将替换znode存储的所有数据（Zookeeper不支持添加操作）；</li>
<li>znode通过路径被引用：Zookeeper中使用的路径必须是绝对路径，而且所有的路径必须是规范的，即每条路径只有唯一的一种表示方式，不支持路径解析；</li>
<li>Zookeeper的路径与URI不同，前者在Java API中通过（<code>java.lang.String</code>）来使用，而后者通过Hadoop <code>Path</code>类（或<code>java.net.URI</code>）来使用。</li>
</ol>
<h3 id="短暂znode"><a href="#短暂znode" class="headerlink" title="短暂znode"></a>短暂znode</h3><p>znode有两种类型，znode的类型在创建时确定并且之后不能再修改。</p>
<ol>
<li>短暂的：在创建短暂znode的客户端会话结束时，Zookeeper会将该短暂znode删除（短暂的znode不能有子节点）；<br>应用：对于那些需要知道特定时刻有哪些分布式资源可用的应用来说，使用短暂znode是一种理想的选择。</li>
<li>持久的：持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除。</li>
</ol>
<h3 id="顺序号"><a href="#顺序号" class="headerlink" title="顺序号"></a>顺序号</h3><ul>
<li>概念<ul>
<li>顺序（sequential）znode是指名称中包含ZooKeeper指定顺序号的znode。</li>
</ul>
</li>
<li>设置<ul>
<li>如果在创建znode时设置了顺序标识，那么该znode名称之后便会附加一个值，这个值由一个单调递增的<strong>计数器</strong>（由父节点维护）所添加的。</li>
</ul>
</li>
<li>举例<ul>
<li>如果一个客户端请求创建一个名为<code>/a/b-</code>的顺序znode，则所创建znode的名字可能是<code>/a/b-3</code>。如果稍后，另外一个名为<code>/a/b-</code>的顺序znode被创建，计数器会给出一个更大的值来保证znode名称的唯一性，例如：<code>/a/b-5</code>。在 Java 的 API 中，顺序 znode 的实际路径会作为 create() 调用的返回值被传回到客户端。</li>
</ul>
</li>
<li>应用<ul>
<li>在一个分布式系统中，顺序号可以被用于为所有的时间进行全局排序，这样客户端就可以通过顺序号来推断事件的顺序。今后的共享锁就是利用该原理。</li>
</ul>
</li>
</ul>
<h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p>znode以某种方式发生变化时，<strong>观察</strong>（Watch）机制可以让客户端得到通知。可以针对Zookeeper服务的操作来设置观察，该服务的其他操作可以触发观察。</p>
<p>注意：</p>
<ul>
<li>观察只触发一次，为了得到多次收到通知，客户端需要重新注册所需的观察。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>如下表，Zookeeper中有9种基本操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>创建一个 znode （必须要有父节点）</td>
</tr>
<tr>
<td>delete</td>
<td>删除一个 znode （该 znode不能有任何子节点）</td>
</tr>
<tr>
<td>exists</td>
<td>测试一个 znode 是否存在并且查询它的元数据</td>
</tr>
<tr>
<td>getACL,setACL</td>
<td>获取/设置一个 znode 的 ACL</td>
</tr>
<tr>
<td>getChildren</td>
<td>获取一个 znode 的子节点列表</td>
</tr>
<tr>
<td>getData，setData</td>
<td>获取/设置一个 znode 所保存的数据</td>
</tr>
<tr>
<td>sync</td>
<td>将客户端的 znode 视图与 Zookeeper 同步</td>
</tr>
</tbody>
</table>
<p>Zookeeper 中的更新操作时有条件的，在使用<code>delete</code>或<code>setData</code>操作时必须提供被更新 znode 的版本号（可以通过 exists 操作获得）。如果版本号不匹配，则更新操作会失败。更新操作时非阻塞操作，因此一个更新失败的客户端（由于其他进程同时在更新同一个 znode）可以决定是否重试，或执行其他操作，并不会因此而阻塞其他进程的执行。</p>
<p>虽然 Zookeeper 可以被看作是一个文件系统，但出于简单性的需求，有一些文件系统的基本操作被它摒弃了。由于 Zookeeper 中的文件较小并且总是被整体读写，因此没有必要提供打开、关闭或查找操作。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>对于 Zookeeper 客户端来说，主要由两种语言绑定 (binging) 可以使用：Java 和 C；当然也可以使用 Perl、Python 和 REST 的 contrib 绑定。对于每一种绑定语言来说，在执行操作时都可以选择同步执行或异步执行（提供两种不同的API）。</p>
<p>同步API与异步API的区别：</p>
<ul>
<li>同步API：使用同步API每个线程都会阻塞进程，知道该操作返回；</li>
<li>异步API：允许以流水线方式处理请求，这在某些情况下可以提供更好的吞吐量。</li>
</ul>
<h3 id="观察触发器"><a href="#观察触发器" class="headerlink" title="观察触发器"></a>观察触发器</h3><p>在<code>exists</code>、<code>getChildren</code>和<code>getData</code>这些读操作上可以设置观察，这些观察可以被写操作<code>create</code>、<code>delete</code>和<code>setData</code> 触发。ACL 相关的操作不参与触发任何观察。当一个观察被触发时会产生一个观察事件，这个观察和触发它的操作共同决定着观察事件的类型。</p>
<ul>
<li>当所观察的znode被创建子节点、删除或其他数据更新时，设置在<code>exists</code>操作上的观察将会被触发。</li>
<li>当所观察的znode被删除或其更新时，设置在<code>getData</code>上的观察将会被触发，创建znode不会触发<code>getData</code>上的观察，因为getData操作成功执行的前提是znode必须已经在。</li>
<li>当所观察的znode的一个子节点被创建或删除时，或观察的znode自己被删时，设置在<code>getChildren</code>操作上的观察将会被触发。</li>
</ul>
<p>设置监视器的操作及对应的触发器</p>
<p><img src="/images/2016-04-13-zookeeper-learn/watch.png" alt="watch"></p>
<ul>
<li>NodeCreated:节点创建事件；</li>
<li>NodeDeleted：代表znode被删除事件；</li>
<li>NodeDataChanged：节点数据改变事件；</li>
<li>NodeChildrenChanged：节点的子节点改变事件；</li>
</ul>
<p>注意：</p>
<ul>
<li>对于NodeCreated和NodeDeleted事件，可以通过路径来判断哪一个节点被创建或删除；</li>
<li>对于NodeChildrenChanged事件，需要重新调用<code>getChildren</code>来获取新的子节点列表来判断哪一个子节点被修改；</li>
<li>对于NodeDataChanged事件，需要调用<code>getData</code>来获取最新的数据；</li>
<li>对于上述第二、三种情况，从收到观察事件到执行操作期间，znode的状态可能会发生变化。</li>
</ul>
<h3 id="ACL-列表"><a href="#ACL-列表" class="headerlink" title="ACL 列表"></a>ACL 列表</h3><p>每个 znode 被创建时都会有一个 ACL 列表，用于决定谁可以对它执行何种操作。ACL 依赖于 Zookeeper 的客户端身份验证机制。Zookeeper 提供了一下几种身份验证方式：</p>
<ul>
<li>digest ：通过用户名和密码来识别客户端；</li>
<li>host：通过客户端的主机名（hostname）来识别客户端；</li>
<li>ip : 通过客户端的 IP 地址来识别客户端。</li>
</ul>
<p>在建议一个 Zookeeper 会话之后，客户端可以对自己进行身份验证。虽然 znode 的 ACL 列表会要求所有的客户端是经过验证的，但 Zookeeper 的身份验证过程却是可选的，客户端必须自己进行身份验证来支持对 znode 的访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用digest模式（用户和密码）进行身份验证</span></span><br><span class="line">zk.addAuthInfo(<span class="string">"digest"</span>,<span class="string">"tom:secret"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//给域example.com下的客户端对某个znode的读权限，可以使用host模式、example.com的ID和READ权限在该znode上设置一个ACL</span></span><br><span class="line"><span class="keyword">new</span> ACL(Perms.READ,<span class="keyword">new</span> Id(<span class="string">"host"</span>,<span class="string">"example.com"</span>));</span><br></pre></td></tr></table></figure>
<p>ACL权限如下表：</p>
<table>
<thead>
<tr>
<th>ACL权限</th>
<th>允许的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>create（子节点）</td>
</tr>
<tr>
<td>READ</td>
<td>getChildren/getData</td>
</tr>
<tr>
<td>WRITE</td>
<td>setData</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（子节点）</td>
</tr>
<tr>
<td>ADMIN</td>
<td>setACL</td>
</tr>
</tbody>
</table>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里先介绍一下Zookeeper在实际环境中使用时两种不同的运行模式：</p>
<ol>
<li>独立模式（standalone mode）<ul>
<li>只有一个ZooKeeper服务器，这种模式比较简单，适用于测试环境，但是不能保证高可用性和恢复性；</li>
</ul>
</li>
<li>复制模式（replicated mode）<ul>
<li>运行于一个计算机集群上，这个计算机集群被称为一个”集合体“（ensemble）,ZooKeeper通过复制模式来实现高可用性，只要集合体中有半数以上的机器处于可用状态，他就可以提供服务；</li>
<li>对于一个有5个节点的集合体中，最多可以容忍两台机器出现故障，这里要注意的是对于6个节点的集合体也是只能够容忍2台机器出现故障。</li>
</ul>
</li>
</ol>
<p>ZooKeeper要做的事情就是：确保对znode树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p>
<p>Zookeeper使用了<strong>Zab协议</strong>，该协议包括两个可以无限重复的阶段：</p>
<ol>
<li>阶段1：leader选举<ul>
<li>集合体中的所有机器通过一个选择过程来选出一台被称为“领导者”（leader）的机器，其他的机器被称为”跟随者“（follower）。一旦半数以上（或指定数量）的follower已经将其状态与leader同步，则标明这个阶段已经完成。</li>
</ul>
</li>
<li>阶段2: 原子广播<ol>
<li>所有的写请求都会被转发给leader，再由leader将更新广播给follwer；</li>
<li>当半数以上的follower已经将修改持久化之后，leader才会提交这个更新，然后客户端才会收到一个更新成功的响应。</li>
<li>这个用来打成共识的协议被设计成具有原子性，因此每个修改要么成功要么失败。</li>
</ol>
</li>
</ol>
<p>注意：</p>
<ul>
<li>如果leader出现故障，其余的机器会选出另外一个leader，并和新的leader继续提供服务。之后，如果之前的leader恢复正常，它就变成了一个follower（leader选举工程很快，根据<a href="http://zookeeper.apache.org/doc/current/zookeeperOver" target="_blank" rel="external">目前的结果</a>，大概只需要200ms）；</li>
<li>在更新内存中的znode树之前，集合体中的所有机器都会被先将更新写入磁盘。</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>理解 Zookeeper 的实现基础有助于理解其服务所提供的一致性保证。在集合体中所使用的术语leader和follower是恰当的，它们表名了一点，即一个follower可能滞后于leader几个更新。这也表名了一个现实情况，在一个修改被提交之前，只需要集合体中半数以上机器已经将该修改持久化即可。对 Zookeeper 来说，理想的情况就是将客户端都连接到与leader状态一致的服务器上，每个客户端都有连接到leader，但客户端对此无法控制，甚至它自己都无法知道是否连接到leader。参见下图</p>
<p><img src="/images/2016-04-13-zookeeper-learn/service.png" alt="service"></p>
<p>每一个对 znode 树的更新都被赋予一个全局唯一的 ID，称为<strong>zxid</strong> （代表 “Zookeeper Transaction ID”）。Zookeeper决定了分布式系统中的顺序，它对所有的更新进行排序，如果 zxid z1 小于 z2，则 z1 一定发生在 z2 之前。</p>
<p>在 Zookeeper 的设计中，以下几点考虑保证了数据的一致性。</p>
<ol>
<li>顺序一致性 <ul>
<li>来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将 znode z 的值更新为 a，在之后的操作中，它又将 z 的值更新为 b ，则没有客户端能够在看到 z 的值是 b 之后再看到值 a（如果没有其他对于 z 的更新）。</li>
</ul>
</li>
<li>原子性 <ul>
<li>更新要么成功，要么失败，不会存在部分成功或失败的结果。如果失败了，则不会有客户端看到这个更新的结果。</li>
</ul>
</li>
<li>单一系统映像 <ul>
<li>一个客户端无论连接到具体哪一台服务器上，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。当一台服务器出故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有状态滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器将状态赶上故障服务器。</li>
</ul>
</li>
<li>持久性（可靠性） <ul>
<li>一个更改一旦成功，其结果就会被持久化并且不会被撤。这表明更新不会受到服务器故障的影响。</li>
</ul>
</li>
<li>及时性 <ul>
<li>任何客户端所看到的系统视图的滞后都是有限的，不会超过几十秒，这意味着与其允许一个客户端看到非常陈旧的数据，还不如将服务器关闭，强迫该客户端连接到到一个状态较新的服务器。</li>
</ul>
</li>
</ol>
<p>由于性能的原因，所有的读操作都是从 Zookeeper 服务器的内存获得数据，它们不参与写操作的全局排序。如果客户端之间通过 Zookeeper 之外的机制进行通信，则客户端可能会发现它们所看到的 Zookeeper 状态是不一致的。</p>
<p>可以使用<code>sync</code>操作，保证任何后续的操作都在服务器的<code>sync</code>操作完成之后才执行。客户端使用<code>sync</code>操作来使自己保持最新的状态。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>每个 Zookeeper 客户端的配置中都包括集合体中服务器的列表。在启动时，客户端会尝试连接到列表中的一台服务器。如果连接失败，它会尝试连接另一台服务器，以此类推，直到成功与一台服务器建立连接或因为所有 Zookeeper 服务器都不可用而失败。</p>
<p>一旦客户端与一台 Zookeeper 服务器建立连接，这台服务器就会为该客户端创建一个新的会话。每个会话都会有一个超时的时间设置，这个设置由创建会话的应用来设定。如果服务器在超过时间段内没有收到任何请求，则相应的会话会过期。一旦一个会话已经过期，就无法重新被打开，并且任何与该会话相关联的短暂 znode 都会丢失。会话通常会长期存在，而会话过期则是一种比较罕见的事件，但对于应用来说，如何处理会话过期仍是非常重要的。</p>
<p>只要一个会话空闲超过一定时间，都可以通过客户端发送 ping 请求（也称为心跳）来保持会话不过期。（ping 请求是由 Zookeeper 的客户端库自动发送，因此在你的代码中不需要考虑如何维护会话）。这个时间长度的设置应当足够低，以便能够检测出服务器故障（由读超时体现），并且能够在会话超时的时间段内重新连接到另外一台服务器。</p>
<p>Zookeeper 客户端可以自动地进行故障切换，切换至另一台 Zookeeper 服务器，并且关键的是，在另一台服务器接替故障服务器之后，所有的会话（和相关的短暂 znode）仍然是有效的。</p>
<p>在故障切换过程中，应用程序将收到断开连接和连接至服务的通知。当客户端断开连接时，观察通知将无法发送；但是当客户端成功恢复连接后，这些延迟的通知还会被发送。当然，在客户端重新连接至另一台服务器的过程中，如果应用程序试图执行一个操作，这个操作将会失败。这充分说明在真实的 Zookeeper 应用中处理连接丢失异常的重要性。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在 Zookeeper 中有几个时间参数。<strong>滴答 (tickTime)</strong> 参数定义了 ZooKeeper 中的基本时间周期。</p>
<p>其他设置都是根据 滴答 (tickTime) 参数来定义的，或至少受它的限制。例如，会话超时 (session timeout) 参数的值不可以小于 2 个 滴答 (tickTime) 并且不可以大于 20 个 滴答 (tickTime)。如果你试图将会话超时参数设置在这个范围之外，它将会被自动修改到这个范围之内。</p>
<p>通常将 滴答 (tickTime) 参数设置为 2 秒 (2000毫秒)，对应于允许的会话超时范围是 4 到 40 秒。在选择会话超时设置时有几点需要考虑。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>ZooKeeper 对象在其生命周期中会经历几种不同的状态，如下图。你可以在任何时刻通过 <code>getState()</code> 方法来查询对象的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">getState</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>Status被定义为代表Zookeeper对象在不同状态的枚举类型值（一个Zookeeper的实例在一个时刻只能处于一种状态）。</p>
<p><img src="/images/2016-04-13-zookeeper-learn/status.png" alt="status"></p>
<ul>
<li>一个新建的Zookeeper实例处于<code>CONNECTING</code>状态。</li>
<li>一旦建立连接，他就会进入<code>CONNECTED</code>状态。</li>
<li>一个对象在进入<code>CONNECTED</code>状态时，观察对象会收到一个<code>WatchedEvent</code>通知，其中<code>KeeperState</code>的值是<code>SyncConnected</code>。</li>
<li>Zookeeper实例可以断开，然后重新连接到Zookeeper服务，此时它的状态就在<code>CONNECTED</code>和<code>CONNECTING</code>之间转换。</li>
<li>如果<code>close()</code>方法被调用或出现会话超时，Zookeeper实例就会转换到第三个状态<code>CLOSED</code>。一旦处于<code>CLOSED</code>状态，Zookeeper对象就不再被认为是活跃的，并且不能再用。</li>
</ul>
<p>Zookeeper的观察对象有两个作用：</p>
<ul>
<li>它可以用来获得Zookeeper状态变化的相关通知；</li>
<li>它还可以用来获得znode变化的相关通知。</li>
</ul>
<h1 id="ZooKeeper应用"><a href="#ZooKeeper应用" class="headerlink" title="ZooKeeper应用"></a>ZooKeeper应用</h1><h2 id="配置服务示例"><a href="#配置服务示例" class="headerlink" title="配置服务示例"></a>配置服务示例</h2><p>配置服务是分布式系统应用所需要的基本服务之一，它可以使集群中的机器共享配置信息中的那些公共部分。也就是说，Zookeeper可以作为一个具有高可用性的配置服务存储器，允许分布式应用的参与者检索和更新配置文件。</p>
<p>这里我们编写这样一个应用示例（完整代码参考<a href="https://github.com/wangzzu/bigdata-examples/tree/master/zookeeperexample/src/main/java/updateexample" target="_blank" rel="external">Zookeeper Update Example</a>），这里有两个假设来简化我们的示例：</p>
<ol>
<li>所需存储的配置数据是字符串，关键字是znode的路径，因此我们在znode上存储了一个键值对；</li>
<li>在任何时候只有一个客户端会执行更新操作。</li>
</ol>
<p>首先我们在<code>ActiveKeyValueStore</code>的类中编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groupexample.ConnectionWatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveKeyValueStore</span> <span class="keyword">extends</span> <span class="title">ConnectionWatcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String path, String value)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">		Stat stat = zk.exists(path, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">			zk.create(path, value.getBytes(CHARSET), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			zk.setData(path, value.getBytes(CHARSET), -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">(String path, Watcher watcher)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] data = zk.getData(path, watcher, <span class="keyword">null</span><span class="comment">/*stat*/</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(data, CHARSET);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有两个关键方法：</p>
<ul>
<li><code>write()</code>：将一个关键字及其值写入Zookeeper；</li>
<li><code>read()</code>：读取Zookeeper中的配置属性。</li>
</ul>
<p>Zookeeper的<code>getData()</code>方法有三个参数：</p>
<ol>
<li>路径；</li>
<li>一个观察对象；</li>
<li>一个Stat对象.</li>
</ol>
<p>其中，Stat对象由<code>getData()</code>方法返回的值填充，用来将信息传回给调用者，通过这个方法，调用者可以获得一个znode的数据和元数据，但在本例中，由于我们对元数据不感兴趣，因此将Stat参数设为null。</p>
<p>下面我们编写一个用于更新配置属性值的类<code>ConfigUpdater</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigUpdater</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/matt"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</span><br><span class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigUpdater</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</span><br><span class="line">		store.connect(hosts);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			String value = random.nextInt(<span class="number">100</span>) + <span class="string">" "</span>;</span><br><span class="line">			store.write(PATH, value);</span><br><span class="line">			System.out.printf(<span class="string">"Set %s to %s \n"</span>, PATH, value);</span><br><span class="line">			TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ConfigUpdater configUpdater=<span class="keyword">new</span> ConfigUpdater(args[<span class="number">0</span>]);</span><br><span class="line">		configUpdater.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run()</code>方法在随机时间将随机值更新到<code>/matt</code>znode中。</p>
<p>下面我们通过一个<code>ConfigWatcher</code>类初始化一个实例，然后在<code>dirplayConfig()</code>方法中调用<code>read()</code>显示它所读取到的配置信息的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ActiveKeyValueStore store;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConfigWatcher</span><span class="params">(String hosts)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		store = <span class="keyword">new</span> ActiveKeyValueStore();</span><br><span class="line">		store.connect(hosts);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayConfig</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">		String value = store.read(ConfigUpdater.PATH, <span class="keyword">this</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Read %s as %s.\n"</span>, ConfigUpdater.PATH, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				displayConfig();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Interrupted. exiting."</span>);</span><br><span class="line">				Thread.currentThread().interrupt();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"KeeperException: %s. Exiting.\n"</span>, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ConfigWatcher configWatcher = <span class="keyword">new</span> ConfigWatcher(args[<span class="number">0</span>]);</span><br><span class="line">		configWatcher.displayConfig();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个控制台分别运行以下命令</span></span><br><span class="line">java -cp zookeeperexample.jar updateexample.ConfigUpdater zkIP</span><br><span class="line">java -cp zookeeperexample.jar updateexample.ConfigWatcher zkIp</span><br></pre></td></tr></table></figure>
<p>这里要注意<code>ConfigWatcher</code>只能收到最近的一个更新，而不是收到所有的更新，每当<code>ConfigWatcher</code>调用时，就会收到最近的一个更新。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在前面的两个例子，我们经常会看到<code>InterruptedException</code>和<code>KeeperException</code>这两种类型的异常，下面，我们就详细讲述一下。</p>
<h3 id="InterruptedException异常"><a href="#InterruptedException异常" class="headerlink" title="InterruptedException异常"></a>InterruptedException异常</h3><p>如果操作被中断，则会有一个<code>InterruptedException</code>异常。在Java中，有一个取消阻塞方法的标准机制，即针对存在阻塞方法的线程调用<code>interrupt()</code>。一个成功的取消操作将产生一个<code>InterruptedException</code>异常。Zookeeper也遵循这一机制，因此你可以使用这种方法来取消一个Zookeeper操作。使用了Zookeeper的类或者库时，通常就会传播<code>InterruptedException</code>异常，使客户端取消它们的操作。</p>
<p><code>InterruptedException</code>异常并不意味着故障，只是表明相应的操作被取消了而已。</p>
<h3 id="KeeperException异常"><a href="#KeeperException异常" class="headerlink" title="KeeperException异常"></a>KeeperException异常</h3><p>如果ZooKeeper服务器发出一个错误信号或与服务器存在通信问题，抛出的则是<code>KeeperException</code>异常。</p>
<ul>
<li>针对不同的错误情况，<code>KeeperException</code>异常存在不同的子类。<br>例如:　<code>KeeperException.NoNodeException</code>是<code>KeeperException</code>的一个子类，如果你试图针对一个不存在的znode执行操作，抛出的则是该异常。</li>
<li>每一个<code>KeeperException</code>异常的子类都对应一个关于错误类型信息的代码。<br>例如:　<code>KeeperException.NoNodeException</code>异常的代码是<code>KeeperException.Code.NONODE</code>.</li>
</ul>
<p>有两种方法被用来处理<code>KeeperException</code>异常：</p>
<ol>
<li>捕捉<code>KeeperException</code>异常，并且通过检测它的代码来决定采取何种补救措施；</li>
<li>另一种是捕捉等价的<code>KeeperException</code>子类，并且在每段捕捉代码中执行相应的操作。</li>
</ol>
<p>KeeperException异常分为三大类</p>
<h4 id="1-状态异常"><a href="#1-状态异常" class="headerlink" title="1.状态异常"></a>1.状态异常</h4><p>当一个操作因不能被应用于znode树而导致失败时，就会出现状态异常。状态异常产生的原因通常是在同一时间有另外一个进程正在修改znode。例如，如果一个znode先被另外一个进程更新了，根据版本号执行<code>setData()</code>操作的进程就会失败，并收到一个<code>KeeperException.BadVersionException</code>异常，这是因为版本号不匹配。程序员通常都知道这种冲突总是存在的，也都会编写代码来进行处理。</p>
<p>一些状态异常会指出程序中的错误，例如<code>KeeperException.NoChildrenForEphemeralsException</code>异常，试图在短暂znode下创建子节点时就会抛出该异常。</p>
<h4 id="2-可恢复异常"><a href="#2-可恢复异常" class="headerlink" title="2.可恢复异常"></a>2.可恢复异常</h4><p>可恢复的异常是指那些应用程序能够在同一个ZooKeeper会话中恢复的异常。一个可恢复的异常是通过<code>KeeperException.ConnectionLossException</code>来表示的，它意味着已经丢失了与ZooKeeper的连接。ZooKeeper会尝试重新连接，并且在大多数情况下重新连接会成功，并确保会话是完整的。</p>
<p>但是ZooKeeper不能判断与<code>KeeperException.ConnectionLossException</code>异常相关的操作是否成功执行。这种情况就是部分失败的一个例子。这时程序员有责任来解决这种不确定性，并且根据应用的情况来采取适当的操作。在这一点上，就需要对<strong>幂等(idempotent)操作</strong>和<strong>非幂等(Nonidempotent)操作</strong>进行区分。</p>
<ul>
<li>幂等操作:指那些一次或多次执行都会产生相同结果的操作，例如读请求或无条件执行的<code>setData</code>操作。对于幂等操作，只需要简单地进行重试即可。</li>
<li>非幂等操作:就不能盲目地进行重试，因为它们多次执行的结果与一次执行是完全不同的。程序可以通过在znode的路径和它的数据中编码信息来检测是否非幂等操怍的更新已经完成。</li>
</ul>
<h4 id="3-不可恢复的异常"><a href="#3-不可恢复的异常" class="headerlink" title="3.不可恢复的异常"></a>3.不可恢复的异常</h4><p>在某些情况下，ZooKeeper会话会失效——也许因为超时或因为会话被关闭，两种情况下都会收到<code>KeeperException.SessionExpiredException</code>异常，或因为身份验证失败，<code>KeeperException.AuthFailedException</code>异常。无论上述哪种情况，所有与会话相关联的短暂znode都将丢失，因此应用程序需要在重新连接到ZooKeeper之前重建它的状态。</p>
<p>到这里，对Zookeeper的主要内容已经讲述差不多了，希望对大家能有所帮助。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B0055QFIA6/ref=sr_1_3?ie=UTF8&amp;qid=1460778185&amp;sr=8-3&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97" target="_blank" rel="external">Hadoop权威指南第二版</a></li>
<li><a href="https://zookeeper.apache.org/" target="_blank" rel="external">Apache Zookeeper</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Index" target="_blank" rel="external">ZooKeeper WIKI</a></li>
<li><a href="http://zookeeper.apache.org/doc/current/index.html" target="_blank" rel="external">ZooKeeper 3.4Documentation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Thrift之学习笔记]]></title>
      <url>http://wangzzu.github.io/2016/04/07/thrift-learn/</url>
      <content type="html"><![CDATA[<p>本文主要是对Thrift学习的一些总结，主要讲述了Thrift的开发、基本数据类型服务类型的介绍，然后会通过两个例子来学习如何使用Thrift进行开发，同时会介绍Thrift在大数据框架方面的应用。</p>
<h2 id="thrift-介绍"><a href="#thrift-介绍" class="headerlink" title="thrift 介绍"></a>thrift 介绍</h2><p>Apache Thrift 是由 Facebook 开发的一种远程服务调用（RPC Remote Procedure Call）的框架。下面应用官网的一句话对其进行介绍：</p>
<blockquote class="blockquote-center">IThe Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.</blockquote>

<p>简而言之，Thrift是一种支持多语言的软件框架，在各个服务之间的RPC通信领域应用非常广泛。<strong>RPC</strong>（远程过程调用）是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。（参考<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">远程过程调用</a>）。</p>
<p>Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk和OCaml）,并由生成的代码负责RPC协议层和传输层的实现。</p>
<h3 id="Thrift安装"><a href="#Thrift安装" class="headerlink" title="Thrift安装"></a>Thrift安装</h3><p>安装可以参考<a href="https://thrift.apache.org/docs/install/" target="_blank" rel="external">Apache Thrift Install</a>，我使用的是CentOS7.1，直接使用yum安装即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">$ sudo yum install thrift</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">$ thrift -version</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output： Thrift version 0.9.1</span></span><br></pre></td></tr></table></figure>
<h2 id="Thrift-Type"><a href="#Thrift-Type" class="headerlink" title="Thrift Type"></a>Thrift Type</h2><p>使用Thrift时，涉及到了<code>.thrift</code>文件（也就是服务）的编写，因此，需要了解一下Thrift Types，它包含了基本类型，自定义的结构体，容器，异常等。关于这部分，<a href="http://wuchong.me/blog/2015/10/07/thrift-induction/" target="_blank" rel="external">Thrift 入门</a>这篇文章，总结很不错，我这里也就直接使用了拿来主义，首稍微有些修改。</p>
<h3 id="基本类型（Base-Types）"><a href="#基本类型（Base-Types）" class="headerlink" title="基本类型（Base Types）"></a>基本类型（Base Types）</h3><ul>
<li>bool: 布尔变量（A boolean value, one byte）；</li>
<li>byte: 8位有符号整数（A signed byte）；</li>
<li>i16: 16位有符号整数（A 16-bit signed integer）；</li>
<li>i32: 32位有符号整数（A 32-bit signed integer）；</li>
<li>i64: 64位有符号整数（A 64-bit signed integer）；</li>
<li>double: 64位浮点数（A 64-bit floating point number）；</li>
<li>binary: byte数组（A byte array）；</li>
<li>string: 字符串（Encoding agnostic text or binary string）；</li>
</ul>
<p><em>Note：Thrift 不支持无符号整数，因为有些语言也不支持无符号整数，比如Java</em></p>
<h3 id="容器类型（Containers）"><a href="#容器类型（Containers）" class="headerlink" title="容器类型（Containers）"></a>容器类型（Containers）</h3><ul>
<li>list<t>: 一系列由T类型的数据组成的有序列表，元素可以重复；</t></li>
<li>set<t>: 一系列由T类型的数据组成的无序集合，元素不可重复</t></li>
<li>map<t1,t2>: 一个字典结构，key为T1类型，value为T2类型；</t1,t2></li>
</ul>
<p><em>Note：这些集合中的元素可以是除了服务的任何Thrift类型（包括结构体和异常）。</em></p>
<h3 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h3><p>结构体中包含一系列的强类型域，等同于无继承的class。可以看出struct写法很类似C语言的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Example &#123;</span><br><span class="line">  1:i32 number=10,</span><br><span class="line">  2:i64 bigNumber,</span><br><span class="line">  3:list&lt;double&gt; decimals,</span><br><span class="line">  4:string name=&quot;thrifty&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可选与必选"><a href="#可选与必选" class="headerlink" title="可选与必选"></a>可选与必选</h3><p>Thrift提供两个关键字<code>required</code>，<code>optional</code>，分别用于表示对应的字段时必填的还是可选的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct People &#123;</span><br><span class="line">    1: required string name;</span><br><span class="line">    2: optional i32 age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示name是必填的，age是可选的。</p>
<h3 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h3><p>在一个结构体中，如果field之间的关系是互斥的，即<strong>只能有一个field</strong>被使用被赋值。在这种情况下，我们可以使用<code>union</code>来声明这个结构体，而不是一堆堆optional的field，语意上也更明确了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union JavaObjectArg &#123;</span><br><span class="line">  1: i32 int_arg;</span><br><span class="line">  2: i64 long_arg;</span><br><span class="line">  3: string string_arg;</span><br><span class="line">  4: bool bool_arg;</span><br><span class="line">  5: binary binary_arg;</span><br><span class="line">  6: double double_arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常-Exceptions"><a href="#异常-Exceptions" class="headerlink" title="异常(Exceptions)"></a>异常(Exceptions)</h3><p>可以自定义异常类型，所定义的异常会继承对应语言的异常基类，例如java，就会继承 <code>java.lang.Exception</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exception InvalidOperation &#123;</span><br><span class="line">  1: i32 what,</span><br><span class="line">  2: string why</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务-service"><a href="#服务-service" class="headerlink" title="服务(service)"></a>服务(service)</h3><p>Thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service Hello&#123;</span><br><span class="line">  string helloString(1:string para)</span><br><span class="line">  i32 helloInt(1:i32 para)</span><br><span class="line">  bool helloBoolean(1:bool para)</span><br><span class="line">  void helloVoid()</span><br><span class="line">  string helloNull()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间(namespace)"></a>命名空间(namespace)</h3><p>Thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键字namespace定义命名空间，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace java service.demo</span><br></pre></td></tr></table></figure>
<p>注意末尾不能有分号，由此生成的代码，其包路径结构为<code>service.demo</code>.</p>
<h2 id="Thrift支持的数据传输格式、数据传输方式和服务模型"><a href="#Thrift支持的数据传输格式、数据传输方式和服务模型" class="headerlink" title="Thrift支持的数据传输格式、数据传输方式和服务模型"></a>Thrift支持的数据传输格式、数据传输方式和服务模型</h2><h3 id="协议（传输格式）"><a href="#协议（传输格式）" class="headerlink" title="协议（传输格式）"></a>协议（传输格式）</h3><ul>
<li>TBinaryProtocol： 二进制格式；</li>
<li>TCompactProtocol：高效率的、密集的二进制编码格式进行数据传输；</li>
<li>TJSONProtocol：JSON格式；</li>
<li>TSimpleJSONProtocol：提供JSON只写协议, 生成的文件很容易通过脚本语言解析；</li>
<li>TDebugProtocol：使用易懂的可读的文本格式，以便于debug。</li>
</ul>
<h3 id="传输层（数据传输方式）"><a href="#传输层（数据传输方式）" class="headerlink" title="传输层（数据传输方式）"></a>传输层（数据传输方式）</h3><ul>
<li>TSocket：阻塞式socker；</li>
<li>TFramedTransport：使用非阻塞方式，以frame为单位进行传输。</li>
<li>TFileTransport：以文件形式进行传输。</li>
<li>TMemoryTransport：将内存用于I/O. java实现时内部实际使用了简单的ByteArrayOutputStream。</li>
<li>TZlibTransport：使用zlib进行压缩， 与其他传输方式联合使用。当前无java实现。</li>
<li>TNonblockingTransport —— 使用非阻塞方式，用于构建异步客户端</li>
</ul>
<h3 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h3><ul>
<li>TSimpleServer：单线程服务器端使用标准的阻塞式 I/O，简单的单线程服务模型，常用于测试；</li>
<li>TThreadPoolServer：多线程服务模型，使用标准的阻塞式IO；</li>
<li>TNonblockingServer：多线程服务模型，使用非阻塞式IO（需使用TFramedTransport数据传输方式）。</li>
</ul>
<h2 id="Thrift-简单使用"><a href="#Thrift-简单使用" class="headerlink" title="Thrift 简单使用"></a>Thrift 简单使用</h2><p>这里我们使用两个Thrift的示例来讲述Thrift的使用，第一例子比较简单，类似于Hello World这种。第二例子，我们会使用阻塞单线程多线程、非阻塞、半同步半阻塞等方式。</p>
<p>这里Maven工程的<code>pom.xml</code>文件的配置为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Thrift之Hello-World"><a href="#Thrift之Hello-World" class="headerlink" title="Thrift之Hello World"></a>Thrift之Hello World</h3><p>本例是一个简单Thrift示例，具体代码参见<a href="https://github.com/wangzzu/java_learn/tree/master/thrift/src/main/java/matt/thrifthello" target="_blank" rel="external">thrifthello</a></p>
<h4 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h4><p>我们来编写一个thrift文件，定义服务端的接口定义个服务接口（<code>hello.thrift</code>）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace java hello.thrift</span><br><span class="line">service Hello&#123;</span><br><span class="line"> string helloString(1:string para)</span><br><span class="line"> i32 helloInt(1:i32 para)</span><br><span class="line"> bool helloBoolean(1:bool para)</span><br><span class="line"> void helloVoid()</span><br><span class="line"> string helloNull()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了5个不同的接口，接着使用Thrift对文件进行编译，产生对应的程序文件，以Java为例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift —gen java hello.thrift</span><br></pre></td></tr></table></figure>
<p>命令执行完成后，就会在<code>gen-java/hello/thrift</code>生成一个Hello.java的文件，将这个java文件放到<code>hello/thrift</code>中。</p>
<h4 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2.接口实现"></a>2.接口实现</h4><p>前面只是定义了接口的签名，现在我们来对接口进行实现，实现类需要实现<code>Hello.Iface</code>接口，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> matt.thrifthello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helloBoolean</span><span class="params">(<span class="keyword">boolean</span> para)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"hello true/false"</span>);</span><br><span class="line">        <span class="keyword">return</span> para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helloInt</span><span class="params">(<span class="keyword">int</span> para)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello times: "</span> + para);</span><br><span class="line">        <span class="keyword">return</span> para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloNull</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloString</span><span class="params">(String para)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + para);</span><br><span class="line">        <span class="keyword">return</span> para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloVoid</span><span class="params">()</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-服务端代码的实现"><a href="#3-服务端代码的实现" class="headerlink" title="3.服务端代码的实现"></a>3.服务端代码的实现</h4><p>下面来编写服务器端的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> matt.thrifthello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TProcessor;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TThreadPoolServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TServerSocket;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置服务端口为 9527</span></span><br><span class="line">            TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(<span class="number">9527</span>);</span><br><span class="line">            <span class="comment">// 关联处理器与 Hello 服务的实现</span></span><br><span class="line">            TProcessor processor = <span class="keyword">new</span> Hello.Processor(<span class="keyword">new</span> HelloServiceImpl());</span><br><span class="line">            TServer server = <span class="keyword">new</span> TThreadPoolServer(<span class="keyword">new</span> TThreadPoolServer.Args(serverTransport).processor(processor));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Start server on port 9527..."</span>);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-客户端的实现"><a href="#4-客户端的实现" class="headerlink" title="4.客户端的实现"></a>4.客户端的实现</h4><p>下面来编写客户端的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> matt.thrifthello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TException;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TSocket;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransport;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置调用的服务地址为本地，端口为 9527</span></span><br><span class="line">            TTransport transport = <span class="keyword">new</span> TSocket(<span class="string">"localhost"</span>, <span class="number">9527</span>);</span><br><span class="line">            transport.open();</span><br><span class="line">            <span class="comment">// 设置传输协议为 TBinaryProtocol</span></span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            Hello.Client client = <span class="keyword">new</span> Hello.Client(protocol);</span><br><span class="line">            <span class="comment">// 调用服务的 helloVoid 方法，向server发送数据</span></span><br><span class="line">            client.helloVoid();</span><br><span class="line"></span><br><span class="line">            transport.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>代码完成后，可以先运行<code>HelloServiceServer</code>（会一直运行，需要手动关闭），然后再运行<code>HelloServiceClient</code>（调用一次<code>helloVoid()</code>方法之后，就会退出，不过可以重复运行，这样就可以在server端看到多次输出了），就可以在<code>HelloServiceServer</code>的输出结果中看到客户端打印的<code>Hello World</code>字符串。</p>
<h3 id="Thrift之Account"><a href="#Thrift之Account" class="headerlink" title="Thrift之Account"></a>Thrift之Account</h3><p>本例是关于用户帐号的示例，会涉及到用户帐号的添加登陆注册以及查询等，详细的代码参考<a href="https://github.com/wangzzu/java_learn/tree/master/thrift/src/main/java/matt/thrift/account" target="_blank" rel="external">Thrift_Account</a>.</p>
<h4 id="1-接口定义-1"><a href="#1-接口定义-1" class="headerlink" title="1.接口定义"></a>1.接口定义</h4><p>这里我们编写一个thrift文件，定义服务接口，先定义一个操作状态有两种选项登陆或者注册；然后定一个结构体User，它有四个属性；再声明一个自定义的异常类，最后定义服务接口的一些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">namespace java matt.thrift.account</span><br><span class="line"></span><br><span class="line">enum Operation&#123;</span><br><span class="line">	LOGIN=1,</span><br><span class="line">	REGISTER=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User&#123;</span><br><span class="line">	1: required i32 userId,</span><br><span class="line">	2: required string username,</span><br><span class="line">	3: required string password,</span><br><span class="line">	4: Operation op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exception InvalidOperation&#123;</span><br><span class="line">	1: i32 code,</span><br><span class="line">	2: string reason</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Account&#123;</span><br><span class="line">	void addUser(1:User user) throws (1: InvalidOperation e)</span><br><span class="line">	User queryUser(1:i32 id)</span><br><span class="line">	list&lt;User&gt; queryUserList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着对Thrift对文件进行编译，产生对应的程序文件，以Java为例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">thrift —gen java Account.thrift</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">命令执行完成后，就会在`gen-java/matt/thrift/account`生成多个java的文件，将这些java文件放到`matt/thrift/account`中。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2.接口实现</span></span><br><span class="line"></span><br><span class="line">这里定义`AccountService`类来实现`Account.Iface`接口，主要实现了三个方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package matt.thrift.account;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.apache.thrift.TException;</span><br><span class="line"></span><br><span class="line">public class AccountService implements Account.Iface &#123;</span><br><span class="line">	private static Map&lt;String, String&gt; namePw = new HashMap&lt;&gt;();</span><br><span class="line">	private static Map&lt;String, Integer&gt; nameId = new HashMap&lt;&gt;();</span><br><span class="line">	private static Map&lt;String, Operation&gt; nameOp = new HashMap&lt;&gt;();</span><br><span class="line">	private static Map&lt;Integer, String&gt; idname = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void addUser(User user) throws TException &#123;</span><br><span class="line">		int id = user.getUserId();</span><br><span class="line">		String name = user.getUsername();</span><br><span class="line">		String pass = user.getPassword();</span><br><span class="line">		Operation op = user.getOp();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (name == null || name.length() == 0) &#123;</span><br><span class="line">			throw new InvalidOperation(100, <span class="string">"The name should not be empty!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (namePw.containsKey(name)) &#123;</span><br><span class="line">			throw new InvalidOperation(101, <span class="string">"The name has been used, please change the name!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nameId.containsValue(id) || id &lt;= 0) &#123;</span><br><span class="line">			throw new InvalidOperation(102, <span class="string">"The id has been used or the id is invalid, please change the id!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (op == Operation.LOGIN) &#123;</span><br><span class="line">			String password = namePw.get(name);</span><br><span class="line">			<span class="keyword">if</span> (password != null &amp;&amp; password.equals(pass)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Login success!! Hello "</span> + name);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Login failed!! please check your username and password"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == Operation.REGISTER) &#123;</span><br><span class="line">			<span class="keyword">if</span> (namePw.containsKey(name)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"The username "</span> + name + <span class="string">" has been registered, please change one."</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				namePw.put(name, pass);</span><br><span class="line">				nameId.put(name, id);</span><br><span class="line">				nameOp.put(name, op);</span><br><span class="line">				idname.put(id, name);</span><br><span class="line">				System.out.println(<span class="string">"Register success!! Hello "</span> + name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			throw new InvalidOperation(103, <span class="string">"unknown operation: "</span> + op.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public User queryUser(int id) throws TException &#123;</span><br><span class="line">		System.out.println(id);</span><br><span class="line">		<span class="keyword">if</span> (idname.containsKey(id)) &#123;</span><br><span class="line">			User user = new User();</span><br><span class="line">			user.userId = id;</span><br><span class="line">			String name = idname.get(id);</span><br><span class="line">			user.username = name;</span><br><span class="line">			user.password = namePw.get(name);</span><br><span class="line">			user.op = nameOp.get(name);</span><br><span class="line">			<span class="built_in">return</span> user;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"The id: "</span> + id + <span class="string">" does not exist!"</span>);</span><br><span class="line">			User user = new User();</span><br><span class="line">			user.userId = 0;</span><br><span class="line">			user.username = <span class="string">""</span>;</span><br><span class="line">			user.password = <span class="string">"123456"</span>;</span><br><span class="line">			user.op = Operation.LOGIN;</span><br><span class="line">			<span class="built_in">return</span> user;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;User&gt; queryUserList() throws TException &#123;</span><br><span class="line">		List&lt;User&gt; list = new ArrayList&lt;User&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : namePw.keySet()) &#123;</span><br><span class="line">			User user = new User();</span><br><span class="line">			user.userId = nameId.get(name);</span><br><span class="line">			user.username = name;</span><br><span class="line">			user.password = namePw.get(name);</span><br><span class="line">			user.op = nameOp.get(name);</span><br><span class="line">			list.add(user);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-服务端代码的实现-1"><a href="#3-服务端代码的实现-1" class="headerlink" title="3.服务端代码的实现"></a>3.服务端代码的实现</h4><p>这里是服务器端的实现，主要使用多种方式来实现，这几种方式实现的差别是使用API的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> matt.thrift.account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.TProcessor;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TCompactProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.THsHaServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TNonblockingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TSimpleServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.server.TThreadPoolServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TFramedTransport;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TNonblockingServerSocket;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TNonblockingServerTransport;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TServerSocket;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransportException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8090</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 简单服务器类型 阻塞单线程</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> matt</span><br><span class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</span><br><span class="line">	 * <span class="doctag">@throws</span> 无</span><br><span class="line">	 *             void</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSimpleServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建trsnaport 阻塞通信</span></span><br><span class="line">			TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port);</span><br><span class="line">			<span class="comment">// 创建protocol</span></span><br><span class="line">			TBinaryProtocol.Factory protocol = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">			<span class="comment">// 将processor transport protocol设入到服务器server中</span></span><br><span class="line">			TServer.Args args = <span class="keyword">new</span> TServer.Args(serverTransport);</span><br><span class="line">			args.processor(tprocessor);</span><br><span class="line">			args.protocolFactory(protocol);</span><br><span class="line">			<span class="comment">// 定义服务器类型 设定参数</span></span><br><span class="line">			TServer server = <span class="keyword">new</span> TSimpleServer(args);</span><br><span class="line">			<span class="comment">// 开启服务</span></span><br><span class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</span><br><span class="line">			server.serve();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (TTransportException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 多线程服务器 阻塞多线程</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> matt</span><br><span class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</span><br><span class="line">	 * <span class="doctag">@throws</span> 无</span><br><span class="line">	 *             void</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThreadPoolServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建processor</span></span><br><span class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建transport 阻塞通信</span></span><br><span class="line">			TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port);</span><br><span class="line">			<span class="comment">// 创建protocol 数据传输协议</span></span><br><span class="line">			TBinaryProtocol.Factory protocol = <span class="keyword">new</span> TBinaryProtocol.Factory();</span><br><span class="line">			TThreadPoolServer.Args args = <span class="keyword">new</span> TThreadPoolServer.Args(serverTransport);</span><br><span class="line">			args.processor(tprocessor);</span><br><span class="line">			args.protocolFactory(protocol);</span><br><span class="line">			<span class="comment">// 创建服务器类型 多线程</span></span><br><span class="line">			TServer server = <span class="keyword">new</span> TThreadPoolServer(args);</span><br><span class="line">			<span class="comment">// 开启服务</span></span><br><span class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</span><br><span class="line">			server.serve();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 非阻塞I/O</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> matt</span><br><span class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</span><br><span class="line">	 * <span class="doctag">@throws</span> 无</span><br><span class="line">	 *             void</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTNonblockingServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建processor</span></span><br><span class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建transport 非阻塞 nonblocking</span></span><br><span class="line">			TNonblockingServerTransport serverTransport = <span class="keyword">new</span> TNonblockingServerSocket(port);</span><br><span class="line">			<span class="comment">// 创建protocol 数据传输协议</span></span><br><span class="line">			TCompactProtocol.Factory protocol = <span class="keyword">new</span> TCompactProtocol.Factory();</span><br><span class="line">			<span class="comment">// 创建transport 数据传输方式 非阻塞需要用这种方式传输</span></span><br><span class="line">			TFramedTransport.Factory transport = <span class="keyword">new</span> TFramedTransport.Factory();</span><br><span class="line">			TNonblockingServer.Args args = <span class="keyword">new</span> TNonblockingServer.Args(serverTransport);</span><br><span class="line">			args.processor(tprocessor);</span><br><span class="line">			args.transportFactory(transport);</span><br><span class="line">			args.protocolFactory(protocol);</span><br><span class="line">			<span class="comment">// 创建服务器 类型是非阻塞</span></span><br><span class="line">			TServer server = <span class="keyword">new</span> TNonblockingServer(args);</span><br><span class="line">			<span class="comment">// 开启服务</span></span><br><span class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</span><br><span class="line">			server.serve();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 半同步半异步的非阻塞I/O</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTHsHaServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建processor</span></span><br><span class="line">		TProcessor tprocessor = <span class="keyword">new</span> Account.Processor(<span class="keyword">new</span> AccountService());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建transport 非阻塞</span></span><br><span class="line">			TNonblockingServerTransport serverTransport = <span class="keyword">new</span> TNonblockingServerSocket(port);</span><br><span class="line">			<span class="comment">// 非阻塞需要的传输方式</span></span><br><span class="line">			TFramedTransport.Factory transport = <span class="keyword">new</span> TFramedTransport.Factory();</span><br><span class="line">			<span class="comment">// 数据传输协议</span></span><br><span class="line">			TCompactProtocol.Factory protocol = <span class="keyword">new</span> TCompactProtocol.Factory();</span><br><span class="line">			<span class="comment">// 创建半同步半异步服务</span></span><br><span class="line">			THsHaServer.Args args = <span class="keyword">new</span> THsHaServer.Args(serverTransport);</span><br><span class="line">			args.processor(tprocessor);</span><br><span class="line">			args.transportFactory(transport);</span><br><span class="line">			args.protocolFactory(protocol);</span><br><span class="line">			<span class="comment">// 创建 服务类型</span></span><br><span class="line">			TServer server = <span class="keyword">new</span> THsHaServer(args);</span><br><span class="line">			<span class="comment">// 开启服务</span></span><br><span class="line">			System.out.println(<span class="string">"Starting the Account server..."</span>);</span><br><span class="line">			server.serve();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启简单服务器</span></span><br><span class="line">		<span class="comment">// AccountServer.startSimpleServer();</span></span><br><span class="line">		<span class="comment">// 开启多线程服务器</span></span><br><span class="line">		<span class="comment">// AccountServer.startThreadPoolServer();</span></span><br><span class="line">		<span class="comment">// 非阻塞I/O</span></span><br><span class="line">		AccountServer.startTNonblockingServer();</span><br><span class="line">		<span class="comment">// 半同步半异步的非阻塞I/O</span></span><br><span class="line">		<span class="comment">// AccountServer.startTHsHaServer();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-客户端的实现-1"><a href="#4-客户端的实现-1" class="headerlink" title="4.客户端的实现"></a>4.客户端的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> matt.thrift.account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TBinaryProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TCompactProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.protocol.TProtocol;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TFramedTransport;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TSocket;</span><br><span class="line"><span class="keyword">import</span> org.apache.thrift.transport.TTransport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String ip = <span class="string">"localhost"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8090</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> time_out = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 使用阻塞式socket</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> matt</span><br><span class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</span><br><span class="line">	 * <span class="doctag">@throws</span> 无</span><br><span class="line">	 *             void</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSimpleClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建Transport</span></span><br><span class="line">			transport = <span class="keyword">new</span> TSocket(ip, port, time_out);</span><br><span class="line">			<span class="comment">// 创建TProtocol</span></span><br><span class="line">			TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">			<span class="comment">// 基于TTransport和TProtocol创建Client</span></span><br><span class="line">			Account.Client client = <span class="keyword">new</span> Account.Client(protocol);</span><br><span class="line">			transport.open();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 正常添加用户</span></span><br><span class="line">			User user1 = <span class="keyword">new</span> User(<span class="number">001</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user1);</span><br><span class="line">			User user2 = <span class="keyword">new</span> User(<span class="number">002</span>, <span class="string">"matt2"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user2);</span><br><span class="line">			User user3 = <span class="keyword">new</span> User(<span class="number">003</span>, <span class="string">"matt3"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user3);</span><br><span class="line">			User user4 = <span class="keyword">new</span> User(<span class="number">004</span>, <span class="string">"matt4"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user4);</span><br><span class="line">			User user5 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user5);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 查看全部用户</span></span><br><span class="line">			List&lt;User&gt; list = client.queryUserList();</span><br><span class="line">			System.out.println(<span class="string">"There are "</span> + list.size() + <span class="string">" users in total."</span>);</span><br><span class="line">			<span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">				System.out.println(user.userId + <span class="string">" "</span> + user.username + <span class="string">" "</span> + user.password);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 查询用户</span></span><br><span class="line">			User userq1 = client.queryUser(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (userq1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Query: "</span> + userq1.userId + <span class="string">" "</span> + userq1.username + <span class="string">" "</span> + userq1.password);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"The id: 1 does not exist!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			User userq2 = client.queryUser(<span class="number">8</span>);</span><br><span class="line">			<span class="keyword">if</span> (userq2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Query: "</span> + userq2.userId + <span class="string">" "</span> + userq2.username + <span class="string">" "</span> + userq2.password);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"The id: 8 does not exist!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 登陆用户</span></span><br><span class="line">			User users = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.LOGIN);</span><br><span class="line">			client.addUser(users);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 添加异常用户</span></span><br><span class="line">			User user6 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">""</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name=null</span></span><br><span class="line">			client.addUser(user6);</span><br><span class="line">			User user7 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name存在</span></span><br><span class="line">			client.addUser(user7);</span><br><span class="line">			User user8 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt6"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// id异常</span></span><br><span class="line">			client.addUser(user8);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 非阻塞</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> matt</span><br><span class="line">	 * <span class="doctag">@since</span> Apr 7, 2016</span><br><span class="line">	 * <span class="doctag">@throws</span> 无</span><br><span class="line">	 *             void</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startNonblockingClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			transport = <span class="keyword">new</span> TFramedTransport(<span class="keyword">new</span> TSocket(ip, port));</span><br><span class="line">			TCompactProtocol protocol = <span class="keyword">new</span> TCompactProtocol(transport);</span><br><span class="line">			Account.Client client = <span class="keyword">new</span> Account.Client(protocol);</span><br><span class="line">			transport.open();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 正常添加用户</span></span><br><span class="line">			User user1 = <span class="keyword">new</span> User(<span class="number">001</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user1);</span><br><span class="line">			User user2 = <span class="keyword">new</span> User(<span class="number">002</span>, <span class="string">"matt2"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user2);</span><br><span class="line">			User user3 = <span class="keyword">new</span> User(<span class="number">003</span>, <span class="string">"matt3"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user3);</span><br><span class="line">			User user4 = <span class="keyword">new</span> User(<span class="number">004</span>, <span class="string">"matt4"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user4);</span><br><span class="line">			User user5 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.REGISTER);</span><br><span class="line">			client.addUser(user5);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 查看全部用户</span></span><br><span class="line">			List&lt;User&gt; list = client.queryUserList();</span><br><span class="line">			System.out.println(<span class="string">"There are "</span> + list.size() + <span class="string">" users in total."</span>);</span><br><span class="line">			<span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">				System.out.println(user.userId + <span class="string">" "</span> + user.username + <span class="string">" "</span> + user.password);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 查询用户</span></span><br><span class="line">			User userq1 = client.queryUser(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (!userq1.username.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Query: "</span> + userq1.userId + <span class="string">" "</span> + userq1.username + <span class="string">" "</span> + userq1.password);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"The id: 1 does not exist!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			User userq2 = client.queryUser(<span class="number">8</span>);</span><br><span class="line">			<span class="keyword">if</span> (!userq2.username.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Query: "</span> + userq2.userId + <span class="string">" "</span> + userq2.username + <span class="string">" "</span> + userq2.password);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"The id: 8 does not exist!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 登陆用户</span></span><br><span class="line">			User users = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt5"</span>, <span class="string">"123456"</span>, Operation.LOGIN);</span><br><span class="line">			client.addUser(users);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 添加异常用户</span></span><br><span class="line">			User user6 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">""</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name=null</span></span><br><span class="line">			client.addUser(user6);</span><br><span class="line">			User user7 = <span class="keyword">new</span> User(<span class="number">006</span>, <span class="string">"matt1"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// name存在</span></span><br><span class="line">			client.addUser(user7);</span><br><span class="line">			User user8 = <span class="keyword">new</span> User(<span class="number">005</span>, <span class="string">"matt6"</span>, <span class="string">"123456"</span>, Operation.REGISTER);<span class="comment">// id异常</span></span><br><span class="line">			client.addUser(user8);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// AccountClient.startSimpleClient();</span></span><br><span class="line">		AccountClient.startNonblockingClient();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>代码完成后，可以先运行<code>AccountServer</code>（会一直运行，需要手动关闭），然后再运行<code>AccountClient</code>。</p>
<p>上面程序服务器端的运行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Starting the Account server...</span><br><span class="line">Register success!! Hello matt1</span><br><span class="line">Register success!! Hello matt2</span><br><span class="line">Register success!! Hello matt3</span><br><span class="line">Register success!! Hello matt4</span><br><span class="line">Register success!! Hello matt5</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">The id: 8 does not exist!</span><br></pre></td></tr></table></figure>
<p>客户端运行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">There are 5 users in total.</span><br><span class="line">1 matt1 123456</span><br><span class="line">3 matt3 123456</span><br><span class="line">2 matt2 123456</span><br><span class="line">5 matt5 123456</span><br><span class="line">4 matt4 123456</span><br><span class="line">Query: 1 matt1 123456</span><br><span class="line">The id: 8 does not exist!</span><br><span class="line">InvalidOperation(code:101, reason:The name has been used, please change the name!)</span><br><span class="line">	at matt.thrift.account.Account$addUser_result$addUser_resultStandardScheme.read(Account.java:1165)</span><br><span class="line">	at matt.thrift.account.Account$addUser_result$addUser_resultStandardScheme.read(Account.java:1)</span><br><span class="line">	at matt.thrift.account.Account$addUser_result.read(Account.java:1101)</span><br><span class="line">	at org.apache.thrift.TServiceClient.receiveBase(TServiceClient.java:86)</span><br><span class="line">	at matt.thrift.account.Account$Client.recv_addUser(Account.java:93)</span><br><span class="line">	at matt.thrift.account.Account$Client.addUser(Account.java:80)</span><br><span class="line">	at matt.thrift.account.AccountClient.startNonblockingClient(AccountClient.java:135)</span><br><span class="line">	at matt.thrift.account.AccountClient.main(AccountClient.java:151)</span><br></pre></td></tr></table></figure>
<h2 id="Thrift结构"><a href="#Thrift结构" class="headerlink" title="Thrift结构"></a>Thrift结构</h2><p>Thrift包含了一个完整的堆栈结构用于构建客户端和服务器端，下面描述了Thrift的整体的架构。</p>
<p><img src="/images/2016-04-07-thrift/thrift.png" alt="selection_sort"></p>
<ul>
<li>黄色部分：是用户实现的业务逻辑；</li>
<li>褐色部分：是根据 Thrift 定义的服务接口描述文件生成的客户端和服务器端代码框架；</li>
<li>红色部分：是根据 Thrift 文件生成代码实现数据的读写操作；</li>
<li>TProtocol：是协议层, 定义数据传输格式，可以为二进制或者XML等；</li>
<li>TTransport：是传输层，定义数据传输方式，可以为TCP/IP传输，内存共享或者文件共享等。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://thrift.apache.org/" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="http://thrift-tutorial.readthedocs.org/en/latest/index.html" target="_blank" rel="external">Thrift Tutorial</a></li>
<li><a href="http://dongxicheng.org/recommend/" target="_blank" rel="external">董的博客 五.Apache Thrift</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li>
<li><a href="https://diwakergupta.github.io/thrift-missing-guide/" target="_blank" rel="external">Thrift: The Missing Guide</a></li>
<li><a href="http://zhaozhiming.github.io/blog/2015/01/25/hello-thrift/" target="_blank" rel="external">Apache Thrift的简单代码示例</a></li>
<li><a href="http://wuchong.me/blog/2015/10/07/thrift-induction/" target="_blank" rel="external">Thrift 入门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从Jekyll转向Hexo]]></title>
      <url>http://wangzzu.github.io/2016/03/30/hexo-set/</url>
      <content type="html"><![CDATA[<p>之前的博客，是使用Jekyll搭建的，因为学过一些ruby，也会一些ruby on rails，所以对Jekyll有天生的好感，看不上wordpress、hexo之类的。不过后来当我看到了hexo的next主题时，被它的简洁所吸引，因此决定转向hexo，本文记录使用hexo构建博客的方法（PS；我只是一个搬运工，针对Linux用户而言）。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装Hexo需要三步，需要安装以下三个部分：</p>
<ul>
<li>Git</li>
<li>Node.js</li>
<li>Hexo</li>
</ul>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p><a href="https://git-scm.com/downloads" target="_blank" rel="external">下载地址</a></p>
<ul>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git</code>;</li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git</code>;</li>
</ul>
<h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>安装Node.js的最佳方式是使用<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></p>
<p>nvm安装的两种方式：</p>
<ul>
<li>cURL: <code>$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</code>;</li>
<li>Wget: <code>$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code>;</li>
</ul>
<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。（<code>$</code>代表在当前普通用户下执行命令）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 4</span><br></pre></td></tr></table></figure>
<p>当然也可以通过<a href="https://nodejs.org/en/download/" target="_blank" rel="external">下载</a>安装。</p>
<h4 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>到这里Hexo已经安装完毕了，下面讲一下如何使用。</p>
<h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>通过下列命令，Hexo会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init /home/matt/wangzzuB<span class="built_in">log</span></span><br><span class="line">$ <span class="built_in">cd</span> /home/matt/wangzzuB<span class="built_in">log</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹<code>/home/matt/wangzzuBlog</code>的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p><strong><code>_config.yml</code></strong></p>
<p>它与Jekyll中的<code>_config.yml</code>功能类似，对博客网站进行一下配置。</p>
<p><strong><code>package.json</code></strong></p>
<p>这里面是安装的应用程序的信息，EJS, Stylus 和 Markdown renderer 已默认安装，我们可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>source</code></strong></p>
<p>资源文件夹是存放用户资源的地方。除 <code>_posts</code>文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<p><strong><code>themes</code></strong></p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>文件夹，Hexo会根据主题来生成静态页面。</p>
<h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><p>这里可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo中文文档</a>，这里讲述的非常详细。</p>
<h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h3><p>参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo 指令</a>。</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<p>草稿的使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"new draft"</span> <span class="comment">#新建草稿</span></span><br><span class="line">$ hexo publish [layout] &lt;title&gt; <span class="comment">#变成正式文章</span></span><br></pre></td></tr></table></figure>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d, –deploy</td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w, –watch</td>
<td>监视文件变动</td>
</tr>
</tbody>
</table>
<h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo server -p 4040</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="external">http://localhost:4000/。</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g, –generate</td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o, –output</td>
<td>设置输出路径</td>
</tr>
</tbody>
</table>
<h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从其他博客系统 迁移内容。</p>
<h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列出网站资料。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>
<p>显示 Hexo 版本。</p>
<h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h2><p>Hexo博客的主题有很多种，可以参考<a href="https://hexo.io/themes/" target="_blank" rel="external">Themes</a>，个人比较喜欢Next主题，下面给出一些Next主题配置的一些资料，本文就不再详述了。</p>
<ul>
<li>Next主题的基本配置可以参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next WIKI</a>，这个网站基本上讲述已经非常清晰了。</li>
<li>这个博文——<a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="external">动动手指，NexT主题与Hexo更搭哦（基础篇）</a>配着图片进行讲述如何配置使用。</li>
<li>这篇介绍如何统计阅读量<a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a>。</li>
<li>这位博主由一系列关于Hexo配置的博文，非常推荐——<a href="http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/" target="_blank" rel="external">动动手指，给你的Hexo站点添加最近访客（多说篇）</a>。</li>
</ul>
<h2 id="Jekyll迁移到Hexo"><a href="#Jekyll迁移到Hexo" class="headerlink" title="Jekyll迁移到Hexo"></a>Jekyll迁移到Hexo</h2><p>把 <code>_posts</code> 文件夹内的所有文件复制到 <code>source/_posts</code> 文件夹，并在 <code>_config.yml</code> 中修改 <code>new_post_name</code> 参数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>
<p>然后进行生成静态文件，部署网站即可。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">Next WIKI</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">文档 | Hexo</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="external">动动手指，NexT主题与Hexo更搭哦（基础篇）</a></li>
<li><a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="external">Hexo搭建GitHub博客（三）- NexT主题配置使用</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/" target="_blank" rel="external">动动手指，给你的Hexo站点添加最近访客（多说篇）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法总结]]></title>
      <url>http://wangzzu.github.io/2016/03/26/algorithm-sort/</url>
      <content type="html"><![CDATA[<p>排序算法是算法中基础的部分，也是面试中经常被问到的地方。因此，根据对《算法》和《算法导论》关于这部分的学习，做一下总结，以后再遇到排序方面的问题就可以直接看一下博文就行了（文中算法用java实现）。</p>
<blockquote>
<ul>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
<li>冒泡排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>基数排序</li>
<li>桶排序</li>
</ul>
</blockquote>
<h2 id="性能评估指标"><a href="#性能评估指标" class="headerlink" title="性能评估指标"></a>性能评估指标</h2><ol>
<li>运行时间：<strong>排序的成本模型</strong>：在研究排序算法时，需要计算比较和交换的数量，对于不交换元素的算法，我们会计算访问数组的次数。</li>
<li>额外的内存使用：排序算法分为两种：除了函数调用的栈和固定数目的实例变量之外无需额外内存的<code>原地排序算法</code>，以及需要额外内存空间存储另一份数组副本的其他排序算法。</li>
</ol>
<p>代码中使用基本方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable tmp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        System.out.print(a[i] + <span class="string">" "</span>)</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认按升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>先找到数组中最小的那个元素；</li>
<li>将它和数组中第一个元素交换位置（如果第一个元素是自己，和自己交换）；</li>
<li>在剩下的数组中找到最小的元素，将它和第二个元素交换位置，以此类推。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]))</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Selection.java" target="_blank" rel="external">Selection.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之选择排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Selection_sort_animation.gif" alt="selection_sort"></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>对于长度为$N$的数组，选择排序需要大约$\frac{N^2}{2}$次比较和$N$次交换；</li>
<li>最好的情况：已经有序，交换$0$次；</li>
<li>最坏的情况：逆序，交换$N-1$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>运行时间与输入无关，即使对于一个有序数组，依然需要扫描全部元素而且运行时间与随机数组一样；</li>
<li>数据移动是最少的。交换次数与数组大小成线性关系。</li>
</ol>
</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(less(a[j], a[j - <span class="number">1</span>]))</span><br><span class="line">                exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Insertion.java" target="_blank" rel="external">Insertion.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Insertion_sort_animation.gif" alt="Insertion_sort"></p>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>平均来说，插入排序的复杂度为$O(n^2)$;</li>
<li>最好的情况：已经有序，只需要比较操作$N-1$次即可；</li>
<li>最坏的情况：逆序，需要比较$\frac{N*(N-1)}{2}$次。</li>
</ol>
</li>
<li>特点：<ol>
<li>插入排序很适合部分有序的数组和规模较小的数组；</li>
<li>插入排序不适合对于数据量比较大的排序应用.</li>
</ol>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>也称为递减增量排序算法，它是对插入排序的一种快速算法，插入排序相当于$h=1$的情况。（希尔排序的思想是使数组中任意间隔为h的元素都是有序的）</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位。</li>
</ol>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>算法最重要的部分是<strong>步长</strong>，当步长为1时就是插入排序。</p>
<ol>
<li>最开始以一定的步长进行排序；</li>
<li>然后会继续以一定步长进行排序；</li>
<li>最终算法以步长为1进行排序。</li>
</ol>
<p>当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>步长的设置，影响着希尔排序算法的复杂度，具体可参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>，这里给出一个步长序列与复杂度的关系表：</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/shell.png" alt="shell"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Shell.java" target="_blank" rel="external">Shell.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之希尔排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_shellsort_anim.gif" alt="shellsort"></p>
<h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：参见上表</li>
<li>特点：<ol>
<li>排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。</li>
</ol>
</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>冒泡排序是一种简单的排序算法。它每次去从开始去比较两个元素，如果顺序错误就交换过来，当比较到最后一个元素时，就会把最小（最大）的元素找出来；然后在重复比较，前面已经找到的就不再参与比较。元素越小（大）的元素会经过交换慢慢“浮”到数列顶端。</p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=a.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(a[i],a[i-<span class="number">1</span>]))</span><br><span class="line">                exch(a,i,i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Bubble.java" target="_blank" rel="external">Bubble.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之插入排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Bubble_sort_animation.gif" alt="Bubble_sort"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原地归并排序"><a href="#原地归并排序" class="headerlink" title="原地归并排序"></a>原地归并排序</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>对两个有序数组进行归并。</p>
<h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><p>原地归并排序主要是对于有序数组而言，这里只需要额外申请一段数据空间，来进行合并数组即可（迭代法）。</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法(第一个有序数组为lo~mid，第二个有序数组为mid+1~hi)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid)</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>首先要知道原地归并排序算法，这个是将两个有序的数组归并到一个数组中，然后使用递归算法，每次都对对并一半的数据（直到把数据间隔减少到1为止，从上往下切分）进行归并排序，这样就是递归地调用归并排序。</p>
<h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>将序列分成两部分，然后对部分分别进行归并；</li>
<li>再将这部分分成两部分进行归并；</li>
<li>重复步骤2，直到把每部分分成为大小为1的数组。</li>
</ol>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(a, lo, mid);</span><br><span class="line">    sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);<span class="comment">// 归并两个有序数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h4><ol>
<li>对于长度为N的任意数组，自顶向下的归并排序需要$\frac{N\lg{N}}{2} $至$N\lg{N}$次比较；</li>
<li>对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组$6NlgN$次。</li>
</ol>
<ul>
<li>缺点：其辅助数组所使用的额外空间和N的大小成正比。</li>
</ul>
<h3 id="自低向上"><a href="#自低向上" class="headerlink" title="自低向上"></a>自低向上</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>从最下面的长度为1数组开始往上进行合并，直到最后数组变成两个有序数组，再进行最后依次合并。</p>
<h4 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>将序列每相邻两个数字进行归并操作，形成$ \lfloor\frac{n}{2}\rfloor$个序列，排序后每个序列包含两个元素；</li>
<li>将上述序列再次归并，形成$\lfloor\frac{n}{4}\rfloor$个序列，每个序列包含四个元素；</li>
<li>重复步骤2，直到所有元素排序完毕。</li>
</ol>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz)</span><br><span class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h4><ol>
<li>对于长度为N的任意数组，自低向上的归并排序需要$\frac{N\lg{N}}{2}$至$N\lg{N}$次比较，最多需要访问数组$6N\lg{N}$次。</li>
<li>与自顶向下是相同的，只是顺序不同而已。</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>分治思想，将数组分成两个子数组，独自进行排序。最简单的递归切分：指针i从数组的最左端开始扫描直到找到一个大于等于它的元素，指针j从数组的最右端开始扫描直到找到一个小于等于它的元素，然后交换它们的位置，直到指针相遇。</p>
<p>注意：</p>
<ol>
<li>终止循环：一个常见的错误就是没有考虑到数组中可能包含和切分元素的值相同的其他元素。</li>
</ol>
<h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素;</li>
<li>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大;</li>
<li>此时基准元素在其排好序后的正确位置;</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ol>
<h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = low;</span><br><span class="line">    <span class="keyword">int</span> h = high;</span><br><span class="line">    Comparable key = a[l];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(key, a[h]))</span><br><span class="line">            h--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">            exch(a, l, h);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; h &amp;&amp; less(a[l], key))</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">            exch(a, l, h);</span><br><span class="line">            h--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; low)</span><br><span class="line">        sort(a, low, l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (h &lt; high)</span><br><span class="line">        sort(a, l + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Quick.java" target="_blank" rel="external">Quick.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F#.E9.81.B8.E6.93.87.E7.9A.84.E9.97.9C.E9.80.A3.E6.80.A7" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_quicksort_anim.gif" alt="quick_sort"></p>
<h3 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h3><ol>
<li>快速排序的内循环会用一个递增的索引将数组元素和一个定值进行比较，其他的几种排序还需要再内循环中移动元素；</li>
<li>它的比较次数较少；</li>
<li>排序的效率取决于切分的效果，而不是切分元素的值，最好的效果是每次都能将数组对半分，在切分不平衡时，程序就会变得比较低效；</li>
<li>对于长度为N的无重复数组排序，快速排序平均需要～$2N\ln{N}$次比较（以及$\frac{1}{6}$次交换）；</li>
<li>快速排序最多需要约$\frac{n^2}{2}$次比较，随机打乱数组可以预防这种情况（当切分时，每次两个子数组之一为空才会出现这种情况）；</li>
<li>三向切分：主要对于有大量元素相等的情况。</li>
</ol>
<h3 id="快排算法改进"><a href="#快排算法改进" class="headerlink" title="快排算法改进"></a>快排算法改进</h3><ol>
<li>小数组时（$h_i&lt;lo+M$），切换到插入排序。对于小数组，快排比插入排序要慢；</li>
<li>三取样切分。使用子数组的一小部分的中位数来切分数组，这样做得到切分效果更好，但是代价是需要计算中位数；</li>
<li>三向切分，主要是对于有重复元素的情况下，将数组切分为三部分，分别是小于，等于和大于切分元素的数组元素。</li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>先构造一个最大堆（最小堆），然后将根节点的最大值（最小值）与最后一位交换，再对第一位进行下沉（上浮）操作，依次类推（下次与倒数第二位进行交换），最后得到的数组即为有序数组。</p>
<p>最大堆的特点：</p>
<ol>
<li>一棵大小为$N$的完全二叉树的高度为不小于的$\lg{N}$最小整数；</li>
<li>当一棵二叉树的每个节点都大于等于它的两个子节点时，被称为<strong>堆有序</strong>；</li>
<li>根节点是最大的节点；</li>
<li>对于节点$i$，左移一位算出$2i$节点（即为左子节点），左移一位并在低位加1得到$2i+1$节点（右子节点），右移一位得到$\lfloor\frac{i}{2}\rfloor$（父节点）。</li>
</ol>
<h3 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] pq)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> N = pq.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">			sink(pq, k, N);</span><br><span class="line">		<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			exch(pq, <span class="number">1</span>, N);</span><br><span class="line">			N--;</span><br><span class="line">			sink(pq, <span class="number">1</span>, N);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; N &amp;&amp; less(pq, j, j + <span class="number">1</span>))</span><br><span class="line">					j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!less(pq, k, j))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			exch(pq, k, j);</span><br><span class="line">			k = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		Comparable swap = pq[i - <span class="number">1</span>];</span><br><span class="line">		pq[i - <span class="number">1</span>] = pq[j - <span class="number">1</span>];</span><br><span class="line">		pq[j - <span class="number">1</span>] = swap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] pq, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pq[i - <span class="number">1</span>].compareTo(pq[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/Heap.java" target="_blank" rel="external">Quick.java</a></p>
<p>排序效果如下图所示（原图来自<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科之快速排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/Sorting_heapsort_anim.gif" alt="heap_sort"></p>
<h3 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>构造堆的时间复杂度为$O(n)$；</li>
<li>堆排序的时间复杂度为$O(n\lg{n})$;</li>
</ol>
</li>
<li>特点：<ol>
<li>排序算法使用的是最大堆，最小堆通常用于优先队列（当然也可以反过来）；</li>
<li>将一个数组构造为一个最大堆时，使用递归循环通过下沉（<code>sink</code>方法）将所有有子节点的父节点下沉到给定位置，它的时间复杂度为<code>O(n)</code>；</li>
<li>最大优先队列的一个典型应用就是共享计算机系统中的作业调度。</li>
</ol>
</li>
</ul>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>对于每个输入元素x，确定小于x的元素个数，利用这个信息可以直接把x放在输出数组中的位置上了。</p>
<h4 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤"></a>步骤</h4><p>参考<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">CountingSort</a>，其步骤为：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从$C$中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第$C(i)$项，每放一个元素就将$C(i)$减去1。</li>
</ol>
<h3 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">	<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">	<span class="keyword">int</span> min = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; max)</span><br><span class="line">			max = i;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; min)</span><br><span class="line">			min = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = max - min + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		c[a[i] - min]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">		c[i] = c[i] + c[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		b[--c[a[i] - min]] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/CountingSort.java" target="_blank" rel="external">CountingSort.java</a></p>
<h3 id="性能分析-7"><a href="#性能分析-7" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>时间复杂度为O(k+n).</li>
</ol>
</li>
<li>特点：<ol>
<li>用运算确定次序，而非比较来确定；</li>
<li><strong>稳定</strong>：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。</li>
</ol>
</li>
</ul>
<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序直到最高位排序完成以后，数列就变成了一个有序序列。</p>
<h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤"></a>步骤</h3><p>对于$n$个$d$位数，每个数位有k个可能的取值（比如十进制数每位有10个可能的取值）。</p>
<ol>
<li>先按最低位对数进行排序（可以是计数排序）；</li>
<li>再次低位进行排序</li>
<li>重复第2步，直到最后一步按照最高位进行排序。</li>
</ol>
<p>从最低位开始排序，保证排序算法的稳定性（如果遇到该位数值相同的话，就按输入顺序）。可以参考<a href="http://baike.baidu.com/view/1170573.htm#1" target="_blank" rel="external">百度百科之基数排序</a>中例子。</p>
<h3 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">// d最大值多少位</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>[][] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length];</span><br><span class="line">	<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">while</span> (m &lt;= d) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">			<span class="keyword">int</span> lsd = (i / n) % <span class="number">10</span>;</span><br><span class="line">			tmp[lsd][num[lsd]] = i;</span><br><span class="line">			num[lsd]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num[i] != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; j++) &#123;</span><br><span class="line">					a[index] = tmp[i][j];</span><br><span class="line">					index++;</span><br><span class="line">				&#125;</span><br><span class="line">				num[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n *= <span class="number">10</span>;</span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">		m++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/RadixSort.java" target="_blank" rel="external">RadixSort.java</a></p>
<h3 id="性能分析-8"><a href="#性能分析-8" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>使用稳定排序方法耗时$O(k+n)$，那么就可以在$O(d*(k+n))$时间内将这些数排好序。</li>
</ol>
</li>
<li>特点：<ol>
<li>基数排序利用的计数排序不是原址排序，而快排是原址排序。</li>
</ol>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>也即是箱排序。</p>
<h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h3><p>将数组分到有限数量的桶子里。每个桶子再个别排序。</p>
<h3 id="步骤-10"><a href="#步骤-10" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>设置一个合适数量的数组作为空桶子；</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子里；</li>
<li>对每个不是空桶子进行排序；</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>排序效果如下图所示（原图来自<a href="http://baike.baidu.com/link?url=0bNJEspxIkXRmUyeUSZPfOG5N2YcfhFT00DXysI-k0IVGq7IkaGxs1ronj3iQasuVTLrEvIY3A_POP3V8eTWma" target="_blank" rel="external">百度百科之桶排序</a>）</p>
<p><img src="http://wangzzu.github.io/images/2016-03-26-sort/bucketSort.jpg" alt="bucket_sort"></p>
<h3 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">	<span class="keyword">int</span> bask[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];</span><br><span class="line">	<span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		max = max &gt; (Integer.toString(a[i]).length()) ? max : (Integer.toString(a[i]).length());</span><br><span class="line">	&#125;</span><br><span class="line">	String str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			str = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">if</span> (Integer.toString(a[j]).length() &lt; max) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max - Integer.toString(a[j]).length(); k++)</span><br><span class="line">					str += <span class="string">"0"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			str += Integer.toString(a[j]);</span><br><span class="line">			bask[str.charAt(i) - <span class="string">'0'</span>][index[str.charAt(i) - <span class="string">'0'</span>]++] = a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index[j]; k++) &#123;</span><br><span class="line">				a[pos++] = bask[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">			index[x] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考<a href="https://github.com/wangzzu/algorithms/blob/master/Algorithms-4th/src/main/java/sort_two/BucketSort.java" target="_blank" rel="external">BucketSort.java</a></p>
<h3 id="性能分析-9"><a href="#性能分析-9" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>复杂度分析：<ol>
<li>平均时间复杂度为 $O(k+n)$；</li>
<li>最差时间复杂度：$O(n^2)$;</li>
<li>最差空间复杂度：$O(k*n)$；</li>
</ol>
</li>
<li>特点：<ol>
<li>感觉相当于先进行hash，然后再进行排序，这种思想在海量数据排序中经常会使用到。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="算法性能总结"><a href="#算法性能总结" class="headerlink" title="算法性能总结"></a>算法性能总结</h2><table>
<thead>
<tr>
<th>算法名称</th>
<th>平均时间复杂度</th>
<th>最坏情况时间复杂度</th>
<th>最好情况时间复杂度</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n\lg{n})$ ~ $O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^{1.3})$</td>
<td>$ O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$ O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自底向上归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$O(n\lg{n}) $</td>
<td>$ O(n) $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>自顶向下归并排序</td>
<td>$O(n\lg{n})$</td>
<td>$ O(n\lg{n}) $</td>
<td>$O(n)  $</td>
<td>$ O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n^2)$</td>
<td>$O(nlgn)$</td>
<td>$O(\lg{n})$ ~ $O(n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}) $</td>
<td>$O(n\lg{n}$)</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$ O(n+k) $</td>
<td></td>
<td></td>
<td>$O(n + k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(k*n)$</td>
<td></td>
<td></td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n^2)$</td>
<td></td>
<td></td>
<td>$ O(k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?ie=UTF8&amp;qid=1458988861&amp;sr=8-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法 第四版》</a></li>
<li><a href="http://www.amazon.cn/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-Thomas-H-Cormen/dp/B00AK7BYJY/ref=sr_1_3?ie=UTF8&amp;qid=1458988861&amp;sr=8-3&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">《算法导论 第三版》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科之排序</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java工程师成神之路【转】]]></title>
      <url>http://wangzzu.github.io/2016/03/22/java-learn/</url>
      <content type="html"><![CDATA[<p>原文转自<a href="http://www.hollischuang.com/archives/489" target="_blank" rel="external">Java工程师成神之路</a>，并对原文根据自己的学习及经验做了一些修改。</p>
<h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><p>先推荐一个网址<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Code Style for Java</a>，这是Google出的一个关于Java代码规范化的文章，代码规范化的好处及重要性这里就不再叙述了，希望大家都能按照这个要求去写代码，这样才能写出真正易读的优秀代码。</p>
<h3 id="1-1-JVM"><a href="#1-1-JVM" class="headerlink" title="1.1 JVM"></a>1.1 JVM</h3><h4 id="1-1-1-Java内存模型"><a href="#1-1-1-Java内存模型" class="headerlink" title="1.1.1. Java内存模型"></a>1.1.1. Java内存模型</h4><ul>
<li>Java内存管理;</li>
<li>Java堆和栈;</li>
<li>垃圾回收</li>
</ul>
<p>学习资料：</p>
<ul>
<li><a href="http://www.jcp.org/en/jsr/detail?id=133" target="_blank" rel="external">Java Community Process</a></li>
<li><a href="http://ifeve.com/jmm-faq/" target="_blank" rel="external">并发编程网之Java内存模型</a></li>
</ul>
<h4 id="1-1-2-了解JVM各种参数及调优"><a href="#1-1-2-了解JVM各种参数及调优" class="headerlink" title="1.1.2. 了解JVM各种参数及调优"></a>1.1.2. 了解JVM各种参数及调优</h4><h4 id="1-1-3-学习使用Java工具"><a href="#1-1-3-学习使用Java工具" class="headerlink" title="1.1.3. 学习使用Java工具"></a>1.1.3. 学习使用Java工具</h4><ul>
<li>jps；</li>
<li>jstack；</li>
<li>jmap；</li>
<li>jconsole；</li>
<li>jinfo；</li>
<li>jhat；</li>
<li>javap …</li>
</ul>
<p>学习资料：</p>
<p><a href="http://kenai.com/projects/btrace" target="_blank" rel="external">http://kenai.com/projects/btrace</a><br><a href="http://www.crashub.org/" target="_blank" rel="external">http://www.crashub.org/</a><br><a href="https://github.com/taobao/TProfiler" target="_blank" rel="external">https://github.com/taobao/TProfiler</a><br><a href="https://github.com/CSUG/HouseMD" target="_blank" rel="external">https://github.com/CSUG/HouseMD</a><br><a href="http://wiki.cyclopsgroup.org/jmxterm" target="_blank" rel="external">http://wiki.cyclopsgroup.org/jmxterm</a><br><a href="https://github.com/jlusdy/TBJMap" target="_blank" rel="external">https://github.com/jlusdy/TBJMap</a></p>
<h4 id="1-1-4-学习Java诊断工具"><a href="#1-1-4-学习Java诊断工具" class="headerlink" title="1.1.4. 学习Java诊断工具"></a>1.1.4. 学习Java诊断工具</h4><p><a href="http://www.eclipse.org/mat/" target="_blank" rel="external">http://www.eclipse.org/mat/</a><br><a href="http://visualvm.java.net/oqlhelp.html" target="_blank" rel="external">http://visualvm.java.net/oqlhelp.html</a></p>
<h4 id="1-1-5-自己编写各种outofmemory，stackoverflow程序"><a href="#1-1-5-自己编写各种outofmemory，stackoverflow程序" class="headerlink" title="1.1.5. 自己编写各种outofmemory，stackoverflow程序"></a>1.1.5. 自己编写各种outofmemory，stackoverflow程序</h4><ul>
<li>HeapOutOfMemory</li>
<li>Young OutOfMemory</li>
<li>MethodArea OutOfMemory</li>
<li>ConstantPool OutOfMemory</li>
<li>DirectMemory OutOfMemory</li>
<li>Stack OutOfMemory</li>
<li>Stack OverFlow</li>
</ul>
<h4 id="1-1-6-使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题"><a href="#1-1-6-使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题" class="headerlink" title="1.1.6. 使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题"></a>1.1.6. 使用工具尝试解决以下问题，并写下总结当一个Java程序响应很慢时如何查找问题</h4><ul>
<li>当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志</li>
<li>当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同</li>
</ul>
<h4 id="1-1-7-参考资料"><a href="#1-1-7-参考资料" class="headerlink" title="1.1.7. 参考资料"></a>1.1.7. 参考资料</h4><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="external">http://docs.oracle.com/javase/specs/jvms/se7/html/</a><br><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="external">http://www.cs.umd.edu/~pugh/java/memoryModel/</a><br><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p>
<h3 id="1-2-Java基础知识"><a href="#1-2-Java基础知识" class="headerlink" title="1.2. Java基础知识"></a>1.2. Java基础知识</h3><h4 id="1-2-1-阅读源代码"><a href="#1-2-1-阅读源代码" class="headerlink" title="1.2.1. 阅读源代码"></a>1.2.1. 阅读源代码</h4><ul>
<li>java.lang.String</li>
<li>java.lang.Integer</li>
<li>java.lang.Long</li>
<li>java.lang.Enum</li>
<li>java.math.BigDecimal</li>
<li>java.lang.ThreadLocal</li>
<li>java.lang.ClassLoader &amp; java.net.URLClassLoader</li>
<li>java.util.ArrayList &amp; java.util.LinkedList</li>
<li>java.util.HashMap &amp; java.util.LinkedHashMap &amp; java.util.TreeMap</li>
<li>java.util.HashSet &amp; java.util.LinkedHashSet &amp; java.util.TreeSet</li>
</ul>
<h4 id="1-2-2-熟悉Java中各种变量类型"><a href="#1-2-2-熟悉Java中各种变量类型" class="headerlink" title="1.2.2. 熟悉Java中各种变量类型"></a>1.2.2. 熟悉Java中各种变量类型</h4><h4 id="1-2-3-熟悉Java-String的使用，熟悉String的各种函数"><a href="#1-2-3-熟悉Java-String的使用，熟悉String的各种函数" class="headerlink" title="1.2.3. 熟悉Java String的使用，熟悉String的各种函数"></a>1.2.3. 熟悉Java String的使用，熟悉String的各种函数</h4><h4 id="1-2-4-熟悉Java中各种关键字"><a href="#1-2-4-熟悉Java中各种关键字" class="headerlink" title="1.2.4. 熟悉Java中各种关键字"></a>1.2.4. 熟悉Java中各种关键字</h4><h4 id="1-2-5-学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景"><a href="#1-2-5-学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景" class="headerlink" title="1.2.5. 学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景"></a>1.2.5. 学会使用List，Map，Stack，Queue，Set上述数据结构的遍历、上述数据结构的使用场景</h4><ul>
<li>Java实现对Array/List排序</li>
<li>java.uti.Arrays.sort()</li>
<li>java.util.Collections.sort()</li>
<li>Java实现对List去重</li>
<li>Java实现对List去重，并且需要保留数据原始的出现顺序</li>
<li>Java实现最近最少使用cache，用LinkedHashMap</li>
</ul>
<h4 id="1-2-6-Java-IO"><a href="#1-2-6-Java-IO" class="headerlink" title="1.2.6. Java IO"></a>1.2.6. Java IO</h4><ul>
<li>Java NIO，并学会使用java.io.*</li>
<li>java.nio.*</li>
<li>nio和reactor设计模式</li>
<li>文件编码，字符集</li>
<li>几种不同I/O类型（与UNIX网络编程模式做对比）</li>
</ul>
<h4 id="1-2-7-Java反射与javassist反射与工厂模式"><a href="#1-2-7-Java反射与javassist反射与工厂模式" class="headerlink" title="1.2.7. Java反射与javassist反射与工厂模式"></a>1.2.7. Java反射与javassist反射与工厂模式</h4><ul>
<li>java.lang.reflect.*</li>
</ul>
<h4 id="1-2-8-Java序列化java-io-Serializable"><a href="#1-2-8-Java序列化java-io-Serializable" class="headerlink" title="1.2.8. Java序列化java.io. Serializable"></a>1.2.8. Java序列化<code>java.io. Serializable</code></h4><ul>
<li>什么是序列化，为什么序列化</li>
<li>序列化与单例模式</li>
<li>google序列化protobuf</li>
</ul>
<h4 id="1-2-9-虚引用，弱引用，软引用java-lang-ref"><a href="#1-2-9-虚引用，弱引用，软引用java-lang-ref" class="headerlink" title="1.2.9. 虚引用，弱引用，软引用java.lang.ref.*"></a>1.2.9. 虚引用，弱引用，软引用java.lang.ref.*</h4><ul>
<li>这些引用概念、区别使用；</li>
<li>实验这些引用的回收</li>
</ul>
<h4 id="1-2-10-熟悉Java系统属性java-util-Properties"><a href="#1-2-10-熟悉Java系统属性java-util-Properties" class="headerlink" title="1.2.10. 熟悉Java系统属性java.util.Properties"></a>1.2.10. 熟悉Java系统属性java.util.Properties</h4><h4 id="1-2-11-熟悉Annotation用法java-lang-annotation"><a href="#1-2-11-熟悉Annotation用法java-lang-annotation" class="headerlink" title="1.2.11. 熟悉Annotation用法java.lang.annotation.*"></a>1.2.11. 熟悉Annotation用法java.lang.annotation.*</h4><h4 id="1-2-12-JMSjavax-jms"><a href="#1-2-12-JMSjavax-jms" class="headerlink" title="1.2.12. JMSjavax.jms.*"></a>1.2.12. JMSjavax.jms.*</h4><h4 id="1-2-13-JMXjava-lang-management-、javax-management"><a href="#1-2-13-JMXjava-lang-management-、javax-management" class="headerlink" title="1.2.13. JMXjava.lang.management.、javax.management."></a>1.2.13. JMXjava.lang.management.<em>、javax.management.</em></h4><h4 id="1-2-14-泛型和继承，泛型和擦除"><a href="#1-2-14-泛型和继承，泛型和擦除" class="headerlink" title="1.2.14. 泛型和继承，泛型和擦除"></a>1.2.14. 泛型和继承，泛型和擦除</h4><h4 id="1-2-15-自动拆箱装箱与字节码"><a href="#1-2-15-自动拆箱装箱与字节码" class="headerlink" title="1.2.15. 自动拆箱装箱与字节码"></a>1.2.15. 自动拆箱装箱与字节码</h4><h4 id="1-2-16-实现Callback"><a href="#1-2-16-实现Callback" class="headerlink" title="1.2.16. 实现Callback"></a>1.2.16. 实现Callback</h4><h4 id="1-2-17-java-lang-Void类使用"><a href="#1-2-17-java-lang-Void类使用" class="headerlink" title="1.2.17. java.lang.Void类使用"></a>1.2.17. java.lang.Void类使用</h4><h4 id="1-2-18-Java-Agent，premain函数java-lang-instrument"><a href="#1-2-18-Java-Agent，premain函数java-lang-instrument" class="headerlink" title="1.2.18. Java Agent，premain函数java.lang.instrument"></a>1.2.18. Java Agent，premain函数java.lang.instrument</h4><h4 id="1-2-19-单元测试"><a href="#1-2-19-单元测试" class="headerlink" title="1.2.19. 单元测试"></a>1.2.19. 单元测试</h4><ul>
<li>Junit，<a href="http://junit.org/" target="_blank" rel="external">http://junit.org/</a></li>
<li>Jmockit，<a href="https://code.google.com/p/jmockit/" target="_blank" rel="external">https://code.google.com/p/jmockit/</a></li>
<li>djUnit，<a href="http://works.dgic.co.jp/djunit/" target="_blank" rel="external">http://works.dgic.co.jp/djunit/</a></li>
</ul>
<h4 id="1-2-20-Java实现通过正则表达式提取一段文本中的电子邮件，并将-替换为-输出java-lang-util-regex"><a href="#1-2-20-Java实现通过正则表达式提取一段文本中的电子邮件，并将-替换为-输出java-lang-util-regex" class="headerlink" title="1.2.20. Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出java.lang.util.regex.*"></a>1.2.20. Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出java.lang.util.regex.*</h4><h4 id="1-2-21-学习使用常用的Java工具库commons-lang-commons-…"><a href="#1-2-21-学习使用常用的Java工具库commons-lang-commons-…" class="headerlink" title="1.2.21. 学习使用常用的Java工具库commons.lang, commons.*…"></a>1.2.21. 学习使用常用的Java工具库commons.lang, commons.*…</h4><ul>
<li>guava-libraries</li>
<li>netty、jetty（storm、hadoop、spark也用到了）</li>
</ul>
<h4 id="1-2-22-什么是API-amp-SPI"><a href="#1-2-22-什么是API-amp-SPI" class="headerlink" title="1.2.22. 什么是API&amp;SPI"></a>1.2.22. 什么是API&amp;SPI</h4><p><a href="http://en.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="external">http://en.wikipedia.org/wiki/Application_programming_interface</a><br><a href="http://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="external">http://en.wikipedia.org/wiki/Service_provider_interface</a></p>
<h4 id="1-2-23-参考资料JDK-src-zip-源代码"><a href="#1-2-23-参考资料JDK-src-zip-源代码" class="headerlink" title="1.2.23. 参考资料JDK src.zip 源代码"></a>1.2.23. 参考资料JDK src.zip 源代码</h4><p><a href="http://openjdk.java.net/" target="_blank" rel="external">http://openjdk.java.net/</a><br><a href="http://commons.apache.org/" target="_blank" rel="external">http://commons.apache.org/</a><br><a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="external">https://code.google.com/p/guava-libraries/</a><br><a href="http://netty.io/" target="_blank" rel="external">http://netty.io/</a><br><a href="http://stackoverflow.com/questions/2954372/difference-between-spi-and-api" target="_blank" rel="external">http://stackoverflow.com/questions/2954372/difference-between-spi-and-api</a><br><a href="http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java" target="_blank" rel="external">http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java</a></p>
<h3 id="1-3-Java并发编程"><a href="#1-3-Java并发编程" class="headerlink" title="1.3. Java并发编程"></a>1.3. Java并发编程</h3><h4 id="1-3-1-阅读源代码"><a href="#1-3-1-阅读源代码" class="headerlink" title="1.3.1. 阅读源代码"></a>1.3.1. 阅读源代码</h4><p>阅读源代码，并学会使用</p>
<ul>
<li>java.lang.Thread</li>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.util.concurrent.locks.ReentrantLock</li>
<li>java.util.concurrent.locks.ReentrantReadWriteLock</li>
<li>java.util.concurrent.atomic.Atomic*</li>
<li>java.util.concurrent.Semaphore</li>
<li>java.util.concurrent.CountDownLatch</li>
<li>java.util.concurrent.CyclicBarrier</li>
<li>java.util.concurrent.ConcurrentHashMap</li>
<li>java.util.concurrent.Executors</li>
</ul>
<h4 id="1-3-2-学习使用线程池，自己设计线程池需要注意什么"><a href="#1-3-2-学习使用线程池，自己设计线程池需要注意什么" class="headerlink" title="1.3.2. 学习使用线程池，自己设计线程池需要注意什么"></a>1.3.2. 学习使用线程池，自己设计线程池需要注意什么</h4><h4 id="1-3-3-锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么"><a href="#1-3-3-锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么" class="headerlink" title="1.3.3. 锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么"></a>1.3.3. 锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么，在并发编程中锁的意义是什么</h4><h4 id="1-3-4-synchronized的作用是什么，synchronized和lock"><a href="#1-3-4-synchronized的作用是什么，synchronized和lock" class="headerlink" title="1.3.4. synchronized的作用是什么，synchronized和lock"></a>1.3.4. synchronized的作用是什么，synchronized和lock</h4><h4 id="1-3-5-sleep和wait"><a href="#1-3-5-sleep和wait" class="headerlink" title="1.3.5. sleep和wait"></a>1.3.5. sleep和wait</h4><h4 id="1-3-6-wait和notify"><a href="#1-3-6-wait和notify" class="headerlink" title="1.3.6. wait和notify"></a>1.3.6. wait和notify</h4><h4 id="1-3-7-写一个死锁的程序"><a href="#1-3-7-写一个死锁的程序" class="headerlink" title="1.3.7. 写一个死锁的程序"></a>1.3.7. 写一个死锁的程序</h4><h4 id="1-3-8-什么是守护线程，守护线程和非守护线程的区别以及用法"><a href="#1-3-8-什么是守护线程，守护线程和非守护线程的区别以及用法" class="headerlink" title="1.3.8. 什么是守护线程，守护线程和非守护线程的区别以及用法"></a>1.3.8. 什么是守护线程，守护线程和非守护线程的区别以及用法</h4><h4 id="1-3-9-volatile关键字的理解C-volatile关键字和Java-volatile关键字"><a href="#1-3-9-volatile关键字的理解C-volatile关键字和Java-volatile关键字" class="headerlink" title="1.3.9. volatile关键字的理解C++ volatile关键字和Java volatile关键字"></a>1.3.9. volatile关键字的理解C++ volatile关键字和Java volatile关键字</h4><p>happens-before语义<br>编译器指令重排和CPU指令重排<br><a href="http://en.wikipedia.org/wiki/Memory_ordering" target="_blank" rel="external">http://en.wikipedia.org/wiki/Memory_ordering</a><br><a href="http://en.wikipedia.org/wiki/Volatile_variable" target="_blank" rel="external">http://en.wikipedia.org/wiki/Volatile_variable</a><br><a href="http://preshing.com/20130702/the-happens-before-relation/" target="_blank" rel="external">http://preshing.com/20130702/the-happens-before-relation/</a></p>
<h4 id="1-3-10-以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？"><a href="#1-3-10-以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？" class="headerlink" title="1.3.10. 以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？"></a>1.3.10. 以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-11-解释一下下面两段代码的差别-代码1"><a href="#1-3-11-解释一下下面两段代码的差别-代码1" class="headerlink" title="1.3.11. 解释一下下面两段代码的差别// 代码1"></a>1.3.11. 解释一下下面两段代码的差别// 代码1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-12-参考资料http-book-douban-com-subject-10484692"><a href="#1-3-12-参考资料http-book-douban-com-subject-10484692" class="headerlink" title="1.3.12. 参考资料http://book.douban.com/subject/10484692/"></a>1.3.12. 参考资料<a href="http://book.douban.com/subject/10484692/" target="_blank" rel="external">http://book.douban.com/subject/10484692/</a></h4><p><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></p>
<h2 id="二、-进阶篇"><a href="#二、-进阶篇" class="headerlink" title="二、 进阶篇"></a>二、 进阶篇</h2><h3 id="2-1-Java底层知识"><a href="#2-1-Java底层知识" class="headerlink" title="2.1. Java底层知识"></a>2.1. Java底层知识</h3><h4 id="2-1-1-学习了解字节码、class文件格式"><a href="#2-1-1-学习了解字节码、class文件格式" class="headerlink" title="2.1.1. 学习了解字节码、class文件格式"></a>2.1.1. 学习了解字节码、class文件格式</h4><p><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a><br><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="external">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br><a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></p>
<h4 id="2-1-2-写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码："><a href="#2-1-2-写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：" class="headerlink" title="2.1.2. 写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码："></a>2.1.2. 写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  i += <span class="number">1</span>;</span><br><span class="line">  i *= <span class="number">1</span>;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  编译后读取class文件输出以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">Code:</span><br><span class="line"> Stack=2, Locals=2, Args_size=1</span><br><span class="line"> 0:   iconst_0</span><br><span class="line"> 1:   istore_1</span><br><span class="line"> 2:   iinc    1, 1</span><br><span class="line"> 5:   iload_1</span><br><span class="line"> 6:   iconst_1</span><br><span class="line"> 7:   imul</span><br><span class="line"> 8:   istore_1</span><br><span class="line"> 9:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"> 12:  iload_1</span><br><span class="line"> 13:  invokevirtual   #3; //Method java/io/PrintStream.println:(I)V</span><br><span class="line"> 16:  return</span><br><span class="line">LineNumberTable: </span><br><span class="line"> line 4: 0</span><br><span class="line"> line 5: 2</span><br><span class="line"> line 6: 5</span><br><span class="line"> line 7: 9</span><br><span class="line"> line 8: 16</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-CPU缓存，L1，L2，L3和伪共享"><a href="#2-1-3-CPU缓存，L1，L2，L3和伪共享" class="headerlink" title="2.1.3. CPU缓存，L1，L2，L3和伪共享"></a>2.1.3. CPU缓存，L1，L2，L3和伪共享</h4><p><a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches/" target="_blank" rel="external">http://duartes.org/gustavo/blog/post/intel-cpu-caches/</a><br><a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" target="_blank" rel="external">http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html</a></p>
<h4 id="2-1-4-什么是尾递归"><a href="#2-1-4-什么是尾递归" class="headerlink" title="2.1.4. 什么是尾递归"></a>2.1.4. 什么是尾递归</h4><h4 id="2-1-5-熟悉位运算用位运算实现加、减、乘、除、取余"><a href="#2-1-5-熟悉位运算用位运算实现加、减、乘、除、取余" class="headerlink" title="2.1.5. 熟悉位运算用位运算实现加、减、乘、除、取余"></a>2.1.5. 熟悉位运算用位运算实现加、减、乘、除、取余</h4><h4 id="2-1-6-参考资料"><a href="#2-1-6-参考资料" class="headerlink" title="2.1.6. 参考资料"></a>2.1.6. 参考资料</h4><p><a href="http://book.douban.com/subject/1138768/" target="_blank" rel="external">http://book.douban.com/subject/1138768/</a><br><a href="http://book.douban.com/subject/6522893/" target="_blank" rel="external">http://book.douban.com/subject/6522893/</a><br><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a></p>
<h3 id="2-2-设计模式"><a href="#2-2-设计模式" class="headerlink" title="2.2. 设计模式"></a>2.2. 设计模式</h3><h4 id="2-2-1-实现AOPCGLIB和InvocationHandler的区别"><a href="#2-2-1-实现AOPCGLIB和InvocationHandler的区别" class="headerlink" title="2.2.1. 实现AOPCGLIB和InvocationHandler的区别"></a>2.2.1. 实现AOPCGLIB和InvocationHandler的区别</h4><p><a href="http://cglib.sourceforge.net/" target="_blank" rel="external">http://cglib.sourceforge.net/</a><br>动态代理模式<br>Javassist实现AOP<br><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="external">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br>ASM实现AOP<br><a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></p>
<h4 id="2-2-2-使用模板方法设计模式和策略设计模式实现IOC"><a href="#2-2-2-使用模板方法设计模式和策略设计模式实现IOC" class="headerlink" title="2.2.2. 使用模板方法设计模式和策略设计模式实现IOC"></a>2.2.2. 使用模板方法设计模式和策略设计模式实现IOC</h4><h4 id="2-2-3-不用synchronized和lock，实现线程安全的单例模式"><a href="#2-2-3-不用synchronized和lock，实现线程安全的单例模式" class="headerlink" title="2.2.3. 不用synchronized和lock，实现线程安全的单例模式"></a>2.2.3. 不用synchronized和lock，实现线程安全的单例模式</h4><h4 id="2-2-4-nio和reactor设计模式"><a href="#2-2-4-nio和reactor设计模式" class="headerlink" title="2.2.4. nio和reactor设计模式"></a>2.2.4. nio和reactor设计模式</h4><h4 id="2-2-5-参考资料http-asm-ow2-org"><a href="#2-2-5-参考资料http-asm-ow2-org" class="headerlink" title="2.2.5. 参考资料http://asm.ow2.org/"></a>2.2.5. 参考资料<a href="http://asm.ow2.org/" target="_blank" rel="external">http://asm.ow2.org/</a></h4><p><a href="http://cglib.sourceforge.net/" target="_blank" rel="external">http://cglib.sourceforge.net/</a><br><a href="http://www.javassist.org/" target="_blank" rel="external">http://www.javassist.org/</a></p>
<h3 id="2-3-网络编程知识"><a href="#2-3-网络编程知识" class="headerlink" title="2.3. 网络编程知识"></a>2.3. 网络编程知识</h3><h4 id="2-3-1-Java-RMI，Socket，HttpClient"><a href="#2-3-1-Java-RMI，Socket，HttpClient" class="headerlink" title="2.3.1. Java RMI，Socket，HttpClient"></a>2.3.1. Java RMI，Socket，HttpClient</h4><h4 id="2-3-2-用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304"><a href="#2-3-2-用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304" class="headerlink" title="2.3.2. 用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304"></a>2.3.2. 用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304</h4><ul>
<li>实现可并发下载一个文件</li>
<li>使用线程池处理客户端请求</li>
<li>使用nio处理客户端请求</li>
<li>支持简单的rewrite规则</li>
<li>上述功能在实现的时候需要满足“开闭原则”</li>
</ul>
<h4 id="2-3-3-了解nginx和apache服务器的特性并搭建一个对应的服务器"><a href="#2-3-3-了解nginx和apache服务器的特性并搭建一个对应的服务器" class="headerlink" title="2.3.3. 了解nginx和apache服务器的特性并搭建一个对应的服务器"></a>2.3.3. 了解nginx和apache服务器的特性并搭建一个对应的服务器</h4><p><a href="http://nginx.org/" target="_blank" rel="external">http://nginx.org/</a><br><a href="http://httpd.apache.org/" target="_blank" rel="external">http://httpd.apache.org/</a></p>
<h4 id="2-3-4-用Java实现FTP、SMTP协议"><a href="#2-3-4-用Java实现FTP、SMTP协议" class="headerlink" title="2.3.4. 用Java实现FTP、SMTP协议"></a>2.3.4. 用Java实现FTP、SMTP协议</h4><h4 id="2-3-5-什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器"><a href="#2-3-5-什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器" class="headerlink" title="2.3.5. 什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器"></a>2.3.5. 什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器</h4><p>搭建一个 Squid 或 Apache Traffic Server 服务器<br><a href="http://www.squid-cache.org/" target="_blank" rel="external">http://www.squid-cache.org/</a><br><a href="http://trafficserver.apache.org/" target="_blank" rel="external">http://trafficserver.apache.org/</a><br><a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="external">http://en.wikipedia.org/wiki/Domain_Name_System</a></p>
<h4 id="2-3-6-参考资料"><a href="#2-3-6-参考资料" class="headerlink" title="2.3.6. 参考资料"></a>2.3.6. 参考资料</h4><p><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2616.txt</a><br><a href="http://tools.ietf.org/rfc/rfc5321.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc5321.txt</a><br><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Open/closed_principle</a></p>
<h3 id="2-4-框架知识spring，spring-mvc，阅读主要源码"><a href="#2-4-框架知识spring，spring-mvc，阅读主要源码" class="headerlink" title="2.4. 框架知识spring，spring mvc，阅读主要源码"></a>2.4. 框架知识spring，spring mvc，阅读主要源码</h3><p>ibatis，阅读主要源码<br>用spring和ibatis搭建java server</p>
<h3 id="2-5-应用服务器知识熟悉使用jboss，https-www-jboss-org-overview"><a href="#2-5-应用服务器知识熟悉使用jboss，https-www-jboss-org-overview" class="headerlink" title="2.5. 应用服务器知识熟悉使用jboss，https://www.jboss.org/overview/"></a>2.5. 应用服务器知识熟悉使用jboss，<a href="https://www.jboss.org/overview/" target="_blank" rel="external">https://www.jboss.org/overview/</a></h3><ul>
<li>熟悉使用tomcat，<a href="http://tomcat.apache.org/" target="_blank" rel="external">http://tomcat.apache.org/</a></li>
<li>熟悉使用jetty，<a href="http://www.eclipse.org/jetty/" target="_blank" rel="external">http://www.eclipse.org/jetty/</a></li>
</ul>
<h2 id="三、-高级篇"><a href="#三、-高级篇" class="headerlink" title="三、 高级篇"></a>三、 高级篇</h2><h3 id="3-1-编译原理知识"><a href="#3-1-编译原理知识" class="headerlink" title="3.1. 编译原理知识"></a>3.1. 编译原理知识</h3><h4 id="3-1-1-用Java实现以下表达式解析并返回结果（语法和Oracle中的select-sysdate-1-from-dual类似）-sysdate"><a href="#3-1-1-用Java实现以下表达式解析并返回结果（语法和Oracle中的select-sysdate-1-from-dual类似）-sysdate" class="headerlink" title="3.1.1. 用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似） sysdate"></a>3.1.1. 用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似） sysdate</h4><p> sysdate - 1<br> sysdate - 1/24<br> sysdate - 1/(12*2)</p>
<h4 id="3-1-2-实现对一个List通过DSL筛选-QList"><a href="#3-1-2-实现对一个List通过DSL筛选-QList" class="headerlink" title="3.1.2. 实现对一个List通过DSL筛选  QList"></a>3.1.2. 实现对一个List通过DSL筛选  QList<map<string, object="">&gt; mapList = new QList<map<string, object="">&gt;;</map<string,></map<string,></h4><p>  mapList.add({“name”: “hatter test”});<br>  mapList.add({“id”: -1,”name”: “hatter test”});<br>  mapList.add({“id”: 0, “name”: “hatter test”});<br>  mapList.add({“id”: 1, “name”: “test test”});<br>  mapList.add({“id”: 2, “name”: “hatter test”});<br>  mapList.add({“id”: 3, “name”: “test hatter”});<br>  mapList.query(“id is not null and id &gt; 0 and name like ‘%hatter%’”);<br>要求返回列表中匹配的对象，即最后两个对象；</p>
<h4 id="3-1-3-用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）："><a href="#3-1-3-用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：" class="headerlink" title="3.1.3. 用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）："></a>3.1.3. 用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：</h4><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="number">1</span>;</span><br><span class="line">var b = <span class="number">2</span>;</span><br><span class="line">var c = function() &#123;</span><br><span class="line">  var a = <span class="number">3</span>;</span><br><span class="line">  println(a);</span><br><span class="line">  println(b);</span><br><span class="line">&#125;;</span><br><span class="line">c();</span><br><span class="line">println(a);</span><br><span class="line">println(b);</span><br></pre></td></tr></table></figure>
<p>输出：<br>3<br>2<br>1<br>2</p>
<h4 id="3-1-4-参考资料"><a href="#3-1-4-参考资料" class="headerlink" title="3.1.4. 参考资料"></a>3.1.4. 参考资料</h4><p><a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">http://en.wikipedia.org/wiki/Abstract_syntax_tree</a><br><a href="https://javacc.java.net/" target="_blank" rel="external">https://javacc.java.net/</a><br><a href="http://www.antlr.org/" target="_blank" rel="external">http://www.antlr.org/</a></p>
<h3 id="3-2-操作系统知识Ubuntu"><a href="#3-2-操作系统知识Ubuntu" class="headerlink" title="3.2. 操作系统知识Ubuntu"></a>3.2. 操作系统知识Ubuntu</h3><p>Centos<br>使用linux，熟悉shell脚本</p>
<h3 id="3-3-数据存储知识"><a href="#3-3-数据存储知识" class="headerlink" title="3.3. 数据存储知识"></a>3.3. 数据存储知识</h3><h4 id="3-3-1-关系型数据库MySQL"><a href="#3-3-1-关系型数据库MySQL" class="headerlink" title="3.3.1. 关系型数据库MySQL"></a>3.3.1. 关系型数据库MySQL</h4><ul>
<li>如何看执行计划</li>
<li>如何搭建MySQL主备</li>
<li>binlog是什么</li>
<li>Derby，H2，PostgreSQL</li>
<li>SQLite</li>
</ul>
<h4 id="3-3-2-NoSQLCache"><a href="#3-3-2-NoSQLCache" class="headerlink" title="3.3.2. NoSQLCache"></a>3.3.2. NoSQLCache</h4><ul>
<li>Redis</li>
<li>Memcached</li>
<li>Leveldb</li>
<li>Bigtable</li>
<li>HBase</li>
<li>Cassandra</li>
<li>Mongodb</li>
<li>图数据库</li>
<li>neo4j</li>
</ul>
<h4 id="3-3-3-参考资料"><a href="#3-3-3-参考资料" class="headerlink" title="3.3.3. 参考资料"></a>3.3.3. 参考资料</h4><p><a href="http://db-engines.com/en/ranking" target="_blank" rel="external">http://db-engines.com/en/ranking</a><br><a href="http://redis.io/" target="_blank" rel="external">http://redis.io/</a><br><a href="https://code.google.com/p/leveldb/" target="_blank" rel="external">https://code.google.com/p/leveldb/</a><br><a href="http://hbase.apache.org/" target="_blank" rel="external">http://hbase.apache.org/</a><br><a href="http://cassandra.apache.org/" target="_blank" rel="external">http://cassandra.apache.org/</a><br><a href="http://www.mongodb.org/" target="_blank" rel="external">http://www.mongodb.org/</a><br><a href="http://www.neo4j.org/" target="_blank" rel="external">http://www.neo4j.org/</a></p>
<h3 id="3-4-大数据知识"><a href="#3-4-大数据知识" class="headerlink" title="3.4. 大数据知识"></a>3.4. 大数据知识</h3><h4 id="3-4-1-Zookeeper，在linux上部署zk"><a href="#3-4-1-Zookeeper，在linux上部署zk" class="headerlink" title="3.4.1. Zookeeper，在linux上部署zk"></a>3.4.1. Zookeeper，在linux上部署zk</h4><h4 id="3-4-2-Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引"><a href="#3-4-2-Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引" class="headerlink" title="3.4.2. Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引"></a>3.4.2. Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引</h4><h4 id="3-4-3-Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm-hello-world，local和remote模式运行调试storm-topology。"><a href="#3-4-3-Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm-hello-world，local和remote模式运行调试storm-topology。" class="headerlink" title="3.4.3. Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。"></a>3.4.3. Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。</h4><h4 id="3-4-4-Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件"><a href="#3-4-4-Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件" class="headerlink" title="3.4.4. Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件"></a>3.4.4. Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件</h4><p>MapReduce：部署JobTracker，TaskTracker，编写mr job<br>Hive：部署hive，书写hive sql，得到结果<br>Presto：类hive，不过比hive快，非常值得学习</p>
<h4 id="3-4-5-分布式日志收集flume，kafka，logstash"><a href="#3-4-5-分布式日志收集flume，kafka，logstash" class="headerlink" title="3.4.5. 分布式日志收集flume，kafka，logstash"></a>3.4.5. 分布式日志收集flume，kafka，logstash</h4><h4 id="3-4-6-数据挖掘，mahout"><a href="#3-4-6-数据挖掘，mahout" class="headerlink" title="3.4.6. 数据挖掘，mahout"></a>3.4.6. 数据挖掘，mahout</h4><h4 id="3-4-7-参考资料"><a href="#3-4-7-参考资料" class="headerlink" title="3.4.7. 参考资料"></a>3.4.7. 参考资料</h4><p><a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a><br><a href="https://lucene.apache.org/solr/" target="_blank" rel="external">https://lucene.apache.org/solr/</a><br><a href="https://github.com/nathanmarz/storm/wiki" target="_blank" rel="external">https://github.com/nathanmarz/storm/wiki</a><br><a href="http://hadoop.apache.org/" target="_blank" rel="external">http://hadoop.apache.org/</a><br><a href="http://prestodb.io/" target="_blank" rel="external">http://prestodb.io/</a><br><a href="http://flume.apache.org/，http://logstash.net/，http://kafka.apache.org/" target="_blank" rel="external">http://flume.apache.org/，http://logstash.net/，http://kafka.apache.org/</a><br><a href="http://mahout.apache.org/" target="_blank" rel="external">http://mahout.apache.org/</a></p>
<h3 id="3-5-网络安全知识"><a href="#3-5-网络安全知识" class="headerlink" title="3.5. 网络安全知识"></a>3.5. 网络安全知识</h3><h4 id="3-5-1-什么是DES、AES"><a href="#3-5-1-什么是DES、AES" class="headerlink" title="3.5.1. 什么是DES、AES"></a>3.5.1. 什么是DES、AES</h4><h4 id="3-5-2-什么是RSA、DSA"><a href="#3-5-2-什么是RSA、DSA" class="headerlink" title="3.5.2. 什么是RSA、DSA"></a>3.5.2. 什么是RSA、DSA</h4><h4 id="3-5-3-什么是MD5，SHA1"><a href="#3-5-3-什么是MD5，SHA1" class="headerlink" title="3.5.3. 什么是MD5，SHA1"></a>3.5.3. 什么是MD5，SHA1</h4><h4 id="3-5-4-什么是SSL、TLS，为什么HTTPS相对比较安全"><a href="#3-5-4-什么是SSL、TLS，为什么HTTPS相对比较安全" class="headerlink" title="3.5.4. 什么是SSL、TLS，为什么HTTPS相对比较安全"></a>3.5.4. 什么是SSL、TLS，为什么HTTPS相对比较安全</h4><h4 id="3-5-5-什么是中间人攻击、如果避免中间人攻击"><a href="#3-5-5-什么是中间人攻击、如果避免中间人攻击" class="headerlink" title="3.5.5. 什么是中间人攻击、如果避免中间人攻击"></a>3.5.5. 什么是中间人攻击、如果避免中间人攻击</h4><h4 id="3-5-6-什么是DOS、DDOS、CC攻击"><a href="#3-5-6-什么是DOS、DDOS、CC攻击" class="headerlink" title="3.5.6. 什么是DOS、DDOS、CC攻击"></a>3.5.6. 什么是DOS、DDOS、CC攻击</h4><h4 id="3-5-7-什么是CSRF攻击"><a href="#3-5-7-什么是CSRF攻击" class="headerlink" title="3.5.7. 什么是CSRF攻击"></a>3.5.7. 什么是CSRF攻击</h4><h4 id="3-5-8-什么是CSS攻击"><a href="#3-5-8-什么是CSS攻击" class="headerlink" title="3.5.8. 什么是CSS攻击"></a>3.5.8. 什么是CSS攻击</h4><h4 id="3-5-9-什么是SQL注入攻击"><a href="#3-5-9-什么是SQL注入攻击" class="headerlink" title="3.5.9. 什么是SQL注入攻击"></a>3.5.9. 什么是SQL注入攻击</h4><h4 id="3-5-10-什么是Hash碰撞拒绝服务攻击"><a href="#3-5-10-什么是Hash碰撞拒绝服务攻击" class="headerlink" title="3.5.10. 什么是Hash碰撞拒绝服务攻击"></a>3.5.10. 什么是Hash碰撞拒绝服务攻击</h4><h4 id="3-5-11-了解并学习下面几种增强安全的技术"><a href="#3-5-11-了解并学习下面几种增强安全的技术" class="headerlink" title="3.5.11. 了解并学习下面几种增强安全的技术"></a>3.5.11. 了解并学习下面几种增强安全的技术</h4><p><a href="http://www.openauthentication.org/" target="_blank" rel="external">http://www.openauthentication.org/</a><br>HOTP <a href="http://www.ietf.org/rfc/rfc4226.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc4226.txt</a><br>TOTP <a href="http://tools.ietf.org/rfc/rfc6238.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc6238.txt</a><br>OCRA <a href="http://tools.ietf.org/rfc/rfc6287.txt" target="_blank" rel="external">http://tools.ietf.org/rfc/rfc6287.txt</a><br><a href="http://en.wikipedia.org/wiki/Salt_(cryptography" target="_blank" rel="external">http://en.wikipedia.org/wiki/Salt_(cryptography</a>)</p>
<h4 id="3-5-12-用openssl签一个证书部署到apache或nginx"><a href="#3-5-12-用openssl签一个证书部署到apache或nginx" class="headerlink" title="3.5.12. 用openssl签一个证书部署到apache或nginx"></a>3.5.12. 用openssl签一个证书部署到apache或nginx</h4><h4 id="3-5-13-参考资料"><a href="#3-5-13-参考资料" class="headerlink" title="3.5.13. 参考资料"></a>3.5.13. 参考资料</h4><p><a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="external">http://en.wikipedia.org/wiki/Cryptographic_hash_function</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="external">http://en.wikipedia.org/wiki/Block_cipher</a><br><a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="external">http://en.wikipedia.org/wiki/Public-key_cryptography</a><br><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">http://en.wikipedia.org/wiki/Transport_Layer_Security</a><br><a href="http://www.openssl.org/" target="_blank" rel="external">http://www.openssl.org/</a><br><a href="https://code.google.com/p/google-authenticator/" target="_blank" rel="external">https://code.google.com/p/google-authenticator/</a></p>
<h2 id="四、-扩展篇"><a href="#四、-扩展篇" class="headerlink" title="四、 扩展篇"></a>四、 扩展篇</h2><h3 id="4-1-相关知识"><a href="#4-1-相关知识" class="headerlink" title="4.1. 相关知识"></a>4.1. 相关知识</h3><h4 id="4-1-1-云计算，分布式，高可用，可扩展"><a href="#4-1-1-云计算，分布式，高可用，可扩展" class="headerlink" title="4.1.1. 云计算，分布式，高可用，可扩展"></a>4.1.1. 云计算，分布式，高可用，可扩展</h4><h4 id="4-1-2-虚拟化"><a href="#4-1-2-虚拟化" class="headerlink" title="4.1.2. 虚拟化"></a>4.1.2. 虚拟化</h4><p><a href="https://linuxcontainers.org/" target="_blank" rel="external">https://linuxcontainers.org/</a><br><a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="external">http://www.linux-kvm.org/page/Main_Page</a><br><a href="http://www.xenproject.org/" target="_blank" rel="external">http://www.xenproject.org/</a><br><a href="https://www.docker.io/" target="_blank" rel="external">https://www.docker.io/</a></p>
<h4 id="4-1-3-监控"><a href="#4-1-3-监控" class="headerlink" title="4.1.3. 监控"></a>4.1.3. 监控</h4><p><a href="http://www.nagios.org/" target="_blank" rel="external">http://www.nagios.org/</a><br><a href="http://ganglia.info/" target="_blank" rel="external">http://ganglia.info/</a></p>
<h4 id="4-1-4-负载均衡"><a href="#4-1-4-负载均衡" class="headerlink" title="4.1.4. 负载均衡"></a>4.1.4. 负载均衡</h4><p><a href="http://www.linuxvirtualserver.org/" target="_blank" rel="external">http://www.linuxvirtualserver.org/</a></p>
<h4 id="4-1-5-学习使用"><a href="#4-1-5-学习使用" class="headerlink" title="4.1.5. 学习使用"></a>4.1.5. 学习使用</h4><p>git<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a><br><a href="https://git.oschina.net/" target="_blank" rel="external">https://git.oschina.net/</a></p>
<h4 id="4-1-6-学习使用"><a href="#4-1-6-学习使用" class="headerlink" title="4.1.6. 学习使用"></a>4.1.6. 学习使用</h4><p>maven<a href="http://maven.apache.org/" target="_blank" rel="external">http://maven.apache.org/</a></p>
<h4 id="4-1-7-学习使用"><a href="#4-1-7-学习使用" class="headerlink" title="4.1.7. 学习使用"></a>4.1.7. 学习使用</h4><p>gradle<a href="http://www.gradle.org/" target="_blank" rel="external">http://www.gradle.org/</a></p>
<h4 id="4-1-8-学习一个小语种语言"><a href="#4-1-8-学习一个小语种语言" class="headerlink" title="4.1.8. 学习一个小语种语言"></a>4.1.8. 学习一个小语种语言</h4><ul>
<li>Groovy</li>
<li>Scala</li>
<li>LISP, Common LISP, Schema, Clojure</li>
<li>R</li>
<li>Julia</li>
<li>Lua</li>
<li>Ruby</li>
</ul>
<h4 id="4-1-9-尝试了解编码的本质了解以下概念"><a href="#4-1-9-尝试了解编码的本质了解以下概念" class="headerlink" title="4.1.9. 尝试了解编码的本质了解以下概念"></a>4.1.9. 尝试了解编码的本质了解以下概念</h4><p>ASCII, ISO-8859-1<br>GB2312, GBK, GB18030<br>Unicode, UTF-8<br>不使用 String.getBytes() 等其他工具类/函数完成下面功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String str = <span class="string">"Hello, 我们是中国人。"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] utf8Bytes = toUTF8Bytes(str);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"f.txt"</span>);</span><br><span class="line">    fos.write(utf8Bytes);</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toUTF8Bytes(String str) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想一下上面的程序能不能写一个转GBK的？<br>写个程序自动判断一个文件是哪种编码</p>
<h4 id="4-1-10-尝试了解时间的本质时区-amp-冬令时、夏令时"><a href="#4-1-10-尝试了解时间的本质时区-amp-冬令时、夏令时" class="headerlink" title="4.1.10. 尝试了解时间的本质时区 &amp; 冬令时、夏令时"></a>4.1.10. 尝试了解时间的本质时区 &amp; 冬令时、夏令时</h4><p><a href="http://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="external">http://en.wikipedia.org/wiki/Time_zone</a><br>ftp://ftp.iana.org/tz/data/asia<br><a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80</a><br>闰年<br><a href="http://en.wikipedia.org/wiki/Leap_year" target="_blank" rel="external">http://en.wikipedia.org/wiki/Leap_year</a><br>闰秒<br>ftp://ftp.iana.org/tz/data/leapseconds<br>System.currentTimeMillis() 返回的时间是什么</p>
<h4 id="4-1-11-参考资料"><a href="#4-1-11-参考资料" class="headerlink" title="4.1.11. 参考资料"></a>4.1.11. 参考资料</h4><p><a href="http://git-scm.com/" target="_blank" rel="external">http://git-scm.com/</a><br><a href="http://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">http://en.wikipedia.org/wiki/UTF-8</a><br><a href="http://www.iana.org/time-zones" target="_blank" rel="external">http://www.iana.org/time-zones</a></p>
<h3 id="4-2-扩展学习"><a href="#4-2-扩展学习" class="headerlink" title="4.2. 扩展学习"></a>4.2. 扩展学习</h3><h4 id="4-2-1-JavaScript知识"><a href="#4-2-1-JavaScript知识" class="headerlink" title="4.2.1. JavaScript知识"></a>4.2.1. JavaScript知识</h4><h5 id="4-2-1-1-什么是prototype修改代码，使程序输出“1-3-5”："><a href="#4-2-1-1-什么是prototype修改代码，使程序输出“1-3-5”：" class="headerlink" title="4.2.1.1. 什么是prototype修改代码，使程序输出“1 3 5”："></a>4.2.1.1. 什么是prototype修改代码，使程序输出“1 3 5”：</h5><p><a href="http://jsfiddle.net/Ts7Fk/" target="_blank" rel="external">http://jsfiddle.net/Ts7Fk/</a></p>
<h5 id="4-2-1-2-什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This-is-button-1”，如何修改："><a href="#4-2-1-2-什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This-is-button-1”，如何修改：" class="headerlink" title="4.2.1.2. 什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改："></a>4.2.1.2. 什么是闭包看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改：</h5><p><a href="http://jsfiddle.net/FDPj3/1/" target="_blank" rel="external">http://jsfiddle.net/FDPj3/1/</a></p>
<h5 id="4-2-1-3-了解并学习一个JS框架jQuery"><a href="#4-2-1-3-了解并学习一个JS框架jQuery" class="headerlink" title="4.2.1.3. 了解并学习一个JS框架jQuery"></a>4.2.1.3. 了解并学习一个JS框架jQuery</h5><p>ExtJS<br>ArgularJS</p>
<h5 id="4-2-1-4-写一个Greasemonkey插件"><a href="#4-2-1-4-写一个Greasemonkey插件" class="headerlink" title="4.2.1.4. 写一个Greasemonkey插件"></a>4.2.1.4. 写一个Greasemonkey插件</h5><p><a href="http://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="external">http://en.wikipedia.org/wiki/Greasemonkey</a></p>
<h5 id="4-2-1-5-学习node"><a href="#4-2-1-5-学习node" class="headerlink" title="4.2.1.5. 学习node."></a>4.2.1.5. 学习node.</h5><p>js<a href="http://nodejs.org/" target="_blank" rel="external">http://nodejs.org/</a></p>
<h5 id="4-2-2-学习html5ArgularJS，"><a href="#4-2-2-学习html5ArgularJS，" class="headerlink" title="4.2.2. 学习html5ArgularJS，"></a>4.2.2. 学习html5ArgularJS，</h5><p><a href="https://docs.angularjs.org/api" target="_blank" rel="external">https://docs.angularjs.org/api</a></p>
<h4 id="4-2-3-参考资料"><a href="#4-2-3-参考资料" class="headerlink" title="4.2.3. 参考资料"></a>4.2.3. 参考资料</h4><p><a href="http://www.ecmascript.org/" target="_blank" rel="external">http://www.ecmascript.org/</a><br><a href="http://jsfiddle.net/" target="_blank" rel="external">http://jsfiddle.net/</a><br><a href="http://jsbin.com/" target="_blank" rel="external">http://jsbin.com/</a><br><a href="http://runjs.cn/" target="_blank" rel="external">http://runjs.cn/</a><br><a href="http://userscripts.org/" target="_blank" rel="external">http://userscripts.org/</a></p>
<h2 id="五、-推荐书籍"><a href="#五、-推荐书籍" class="headerlink" title="五、 推荐书籍"></a>五、 推荐书籍</h2><ul>
<li>《深入Java虚拟机》</li>
<li>《深入理解Java虚拟机》</li>
<li>《Effective Java》</li>
<li>《七周七语言》</li>
<li>《七周七数据》</li>
<li>《Hadoop技术内幕》</li>
<li>《Hbase In Action》</li>
<li>《Mahout In Action》</li>
<li>《这就是搜索引擎》</li>
<li>《Solr In Action》</li>
<li>《深入分析Java Web技术内幕》</li>
<li>《大型网站技术架构》</li>
<li>《高性能MySQL》</li>
<li>《算法导论》</li>
<li>《计算机程序设计艺术》</li>
<li>《代码大全》</li>
<li>《JavaScript权威指南》</li>
</ul>
<hr>
<h3 id="想要说的"><a href="#想要说的" class="headerlink" title="想要说的"></a>想要说的</h3><p>之所以要转载这篇文章，是感觉在做了一年多Java开发之后，发现自己很多的基础知识掌握得很不好，尤其是在面试中发现了自己很多的问题，所以准备系统再去学习一下，好好补补基础部分。</p>
<p>因此，准备在这两个多月的时间里按照这上面写的把Java基础好好学习总结总结，尽量都总结成博文形式，准备在Github上建立一个Repository，把Java基础中感觉比较重要的东西都写在里面。到时候会在本文中给出相应的链接。</p>
<h3 id="对应的文章更新"><a href="#对应的文章更新" class="headerlink" title="对应的文章更新"></a>对应的文章更新</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka之消息传输]]></title>
      <url>http://wangzzu.github.io/2016/03/09/kafka-transmit/</url>
      <content type="html"><![CDATA[<p>问题研究：</p>
<ol>
<li>研究Kafka consumer和broker之间的数据传输方式？</li>
<li>Kafka是如何保证可靠性？</li>
<li>消费机制是consumer pull还是broker push？, 如果是push的话，kafka是否知道数据传输成功</li>
</ol>
<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>昨天整理完<a href="http://wangzzu.github.io/2016/03/08/kafka-store">Kafka之数据存储</a>之后，今天决定再把笔记中kafka消息传输部分整理一下，逐步去完善kafka系列的博文。本文中讲述的kafka是<code>0.8.1</code>版，目前最新版的<code>0.9.0</code>版把consumer的<code>The high-level Consumer API</code>和<code>The SimpleConsumer API</code>结合到了一起，这个是最新版的变化的最大之处，这个以后再讲（本来打算分两篇讲解consumer的，看来这样写了）。</p>
<h2 id="1-消息传递机制"><a href="#1-消息传递机制" class="headerlink" title="1.消息传递机制"></a>1.消息传递机制</h2><p>kafka在保证消息在producer和consumer之间的传输，主要有以下几种可能的delivery guaratee:</p>
<ul>
<li><strong>At most once</strong>：消息可能会丢，但绝不会重复传输;</li>
<li><strong>At least one</strong>：消息绝不会丢，但可能会重复传输;</li>
<li><strong>Exactly once</strong>：每条消息肯定会被传输一次且仅传输一次.</li>
</ul>
<p><strong>producer到broker端</strong>，当kafka的producer向broker发送消息时，一旦这条消息被commit，因为有replication的存在，它就不会丢失。但如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经commit，（这一点有点像向一个自动生成primary key的数据库表中插入数据，虽然Kafka无法确定网络故障期间发生了什么，但是producer可以生成一种类似于primary key的东西，发生故障时幂等性的retry多次，这样就做到了Exactly one。这一feature可能会在kafka未来的版本中实现），目前默认的情况下，一条消息从producer到broker是确保了At least once，但可通过设置producer异步发送实现At most once（可以在<code>request.required.acks</code>中设置）。</p>
<p><strong>broker到consumer端</strong>（对于heigh level API），consumer在从broker读取消息后，可以选择commit，该操作会在zookeeper中存储下该consumer在该partition下读取消息的offset。该consumer下一次再读该partition时会从下一条开始读取。如未commit，下一次读取的开始位置会跟上一次commit之后的开始位置相同。当然可以将consumer设置为autocommit，即consumer一旦读到数据立即自动commit。如果只讨论这一读取消息的过程，那Kafka是确保了Exactly once。但实际上实际使用中consumer并非读取完数据就结束了，而是要进行进一步处理，而数据处理与commit的顺序在很大程度上决定了消息从broker和consumer的delivery guarantee semantic。下面介绍以下这两种情况的区别：</p>
<ol>
<li>读完消息先commit再处理消息。这种模式下，如果consumer在commit后还没来得及处理消息就crash了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于At most once；</li>
<li>读完消息先处理再commit。这种模式下，如果处理完了消息在commit之前consumer crash了，下次重新开始工作时还会处理刚刚未commit的消息，实际上该消息已经被处理过了。这就对应于At least once。</li>
</ol>
<p>如果一定要做到Exactly once，就需要协调offset和实际操作的输出。精典的做法是引入<strong>两阶段提交</strong>。如果能让offset和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer拿到数据后可能把数据放到HDFS，如果把最新的offset和数据本身一起写到HDFS，那就可以保证数据的输出和offset的更新要么都完成，要么都不完成，间接实现Exactly once。（目前就high level API而言，offset是存于Zookeeper中的，无法存于HDFS，而low level API的offset是由自己去维护的，可以将之存于HDFS中）。</p>
<p>总之，kafka默认保证At least once，并且允许通过设置producer异步提交来实现At most once。而Exactly once要求与目标存储系统协作，幸运的是kafka提供的offset可以使用这种方式非常直接非常容易。</p>
<h2 id="2-消费机制"><a href="#2-消费机制" class="headerlink" title="2. 消费机制"></a>2. 消费机制</h2><ul>
<li><strong>Topic</strong>：Topic在逻辑上可以认为是一个queue，每条消息必须指定它的topic，可以简单理解为把这条消息放进哪个queue里；</li>
<li><strong>partition</strong>：为了使kafka的吞吐率可以水平扩展，物理上把topic分成为一个或多个partition，每个partition物理上对应一个文件夹，该文件夹下存储这个partition的所有消息和索引文件。</li>
</ul>
<p>kafka消费高效率的原因：</p>
<ul>
<li>顺序写入磁盘；</li>
<li>broker是无状态的，不需要锁机制；</li>
</ul>
<h3 id="2-1-磁盘顺序写入"><a href="#2-1-磁盘顺序写入" class="headerlink" title="2.1.磁盘顺序写入"></a>2.1.磁盘顺序写入</h3><p>一个和磁盘性能有关的关键事实是：磁盘驱动器的吞吐量跟寻到延迟是相背离的，也就是说，线性写的速度远远大于随机写。比如：在一个6 7200rpm SATA RAID-5 的磁盘阵列上线性写的速度大概是600M/秒，但是随机写的速度只有100K/秒，两者相差将近6000倍。线性读写在大多数应用场景下是可以预测的，因此，操作系统利用read-ahead和write-behind技术来从大的数据块中预取数据，或者将多个逻辑上的写操作组合成一个大写物理写操作中（<a href="http://blog.csdn.net/suifeng3051/article/details/48053965" target="_blank" rel="external">Kafka设计原理详解</a>）。</p>
<h3 id="2-2-broker的无状态"><a href="#2-2-broker的无状态" class="headerlink" title="2.2.broker的无状态"></a>2.2.broker的无状态</h3><p>kafka在为每个consuemr group保留一些metadata信息（当前消费的position，即offset），这个offset由consumer控制，正常情况下consumer会在消费完一条消息后线性增加这个offset。因此，在一些情况下，kafka可以重新设置offset来重新消费一些信息。因为offset由consumer控制，所以broker是无状态的，它不需要标记哪些消息被哪些consumer消费过了，不需要通过broker去保证同一个consumer group只有一个consumer能消费同一条信息，因此不需要锁机制。</p>
<h4 id="2-2-1-replica"><a href="#2-2-1-replica" class="headerlink" title="2.2.1.replica"></a>2.2.1.replica</h4><p>先说一下kafka为何需要Replication，在Kafka在0.8以前的版本中，是没有Replication的，一旦某一个Broker宕机，则其上所有的Partition数据都不可被消费，这与kafka数据持久性及Delivery Guarantee的设计目标相悖。同时Producer都不能再将数据存于这些Partition中。</p>
<ul>
<li>如果Producer使用同步模式则Producer会在尝试重新发送<code>message.send.max.retries</code>（默认值为3）次后抛出Exception，用户可以选择停止发送后续数据也可选择继续选择发送。而前者会造成本应发往该Broker的数据的丢失，后者会造成数据的阻塞。</li>
<li>如果Producer使用异步模式，则Producer会尝试重新发<code>送message.send.max.retries</code>（默认值为3）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题。</li>
</ul>
<p>由此可见，在没有Replication的情况下，一旦某机器宕机或者某个Broker停止工作则会造成整个系统的可用性降低。随着集群规模的增加，整个集群中出现该类异常的几率大大增加，因此对于生产系统而言Replication机制的引入非常重要。 　　</p>
<p>当一个topic有多个partition，而每个partition又有多个replica时，kafka的Replica算法如下：</p>
<ol>
<li>将所有Broker（假设共有n个Broker）和待分配的Partition排序；</li>
<li>将第i个Partition分配到第<code>i mod n</code>个Broker上；</li>
<li>将第i个Partition的第j个Replica分配到第<code>(i + j) mod n</code>个Broker上。</li>
</ol>
<p>下面我们举一个例子，假设topic有3个partition，而每个partition又有3个replica，此时Broker有4个节点，Replica分配效果图如下：</p>
<p><img src="/images/2016-03-08-KafkaTransmit/broker.png" alt="broker"></p>
<h4 id="2-2-2-leader"><a href="#2-2-2-leader" class="headerlink" title="2.2.2.leader"></a>2.2.2.leader</h4><p>接着，我们再说一下kafka为何需要Leader Election。</p>
<p>在引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p>
<p>因为需要保证同一个Partition的多个Replica之间的数据一致性（其中一台宕机后其它Replica必须要能继续服务并且即不能造成数据重复也不能造成数据丢失）。如果没有一个Leader，所有Replica都可同时读/写数据，那就需要保证多个Replica之间互相（$N×N$条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了Replication实现的复杂性，同时也增加了出现异常的机率。而引入Leader后，只有Leader负责数据读写，Follower只向Leader顺序Fetch数据（N条通路），系统更加简单且高效。</p>
<p>leader的性质有以下几条：</p>
<ul>
<li>每个partition都有一个leader，所有的读写操作都在leader上完成；</li>
<li>一般情况下，partition大于等于broker的数量，并且所有partition的leader均匀分布在broker上，follower上的日志和其leader上的完全一样。</li>
<li>leader会track <code>in sync</code>的node list。如果一个follower宕机或者落后太多(超过预定值)，leader就把它从<code>in sync list</code>中移除。</li>
</ul>
<ul>
<li>一条消息只有被<code>in sync list</code>里的所有follower都从leader复制过来才会被认为已提交（避免了一些数据写入了leader，但还没来得及被任何follower复制就宕机了而造成数据丢失）。对于producer而言，它可以选择是否等待消息commit，这可以通过<code>request.required.acks</code>来设置，这种机制确保了只要<code>in sync list</code>有一个或一个以上的follower，一条被commit的消息就不会丢失。</li>
</ul>
<p>同步复制与异步复制的区别：</p>
<ul>
<li><strong>同步复制</strong>，要求alive状态的follower都复制完，这条消息才会被commit，这种复制方式极大的影响了吞吐率；</li>
<li><strong>异步复制</strong>，follower异步地从leader复制数据，数据只要被写入log就认为已经commit，这种情况下如果follower都落后于leader，而leader都落后于leader，而leader突然宕机则会丢失数据。</li>
</ul>
<p>kafka判断一台broker是否alive的条件有两个：</p>
<ul>
<li>broker必须维护与zookeeper的session（zookeeper的心跳机制）；</li>
<li>follower必须能够及时将leader的writting复制过来，不能落后太多（在<code>config/server.properties</code>设置，如下）；</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#If a replica falls more than this many messages behind the leader, the leader will remove the follower from ISR and treat it as dead</span><br><span class="line">replica.lag.max.messages=4000 </span><br><span class="line">#If a follower hasn't sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead</span><br><span class="line">replica.lag.time.max.ms=10000</span><br></pre></td></tr></table></figure>
<p>而kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。kafka使用了<code>in sync list</code>的方式，很好的均衡了确保数据不丢失以及吞吐率，follower可以批量的从leader复制数据，这样极大的提高复制能力（批量写入磁盘），极大地减少了follower与leader的差距。</p>
<p>这里介绍一下kafka的<strong>ISR(in-sync replicas)模式</strong>。kafka在zookeeper中动态地维护了一个ISR，这个ISR里的所有Replica都跟的上了leader，只有ISR成员才有被选为leader的可能。在这种模式下，对于f+1个Replica，一个Partition能在保证不丢失（已经commit）的前提下容忍f个Replica的失败。在大多数场景下，这种模式是非常有利的。</p>
<p><strong>当leader宕机的情况，leader election算法</strong></p>
<p>这种情况是很复杂的，当leader宕机时，我们需要在follower中选举出新的leader。因为follower可能落后于许多或者宕机了，所以必须保证“最新”的follower作为leader。一个基本的原则就是，如果leader不在了，新的leader必须拥有原来的leader commit的所有消息。这就需要做一个折衷，如果leader标明一条消息被commit前等待更多的follower确认，那它die之后就会有更多的leader可以作为新的leader，但这也会造成吞吐率的下降。</p>
<p>常见的leader election算法有：</p>
<ul>
<li><a href="http://blog.cloudera.com/blog/2012/10/quorum-based-journaling-in-cdh4-1/" target="_blank" rel="external">HDFS的HA feature</a></li>
<li><a href="http://web.stanford.edu/class/cs347/reading/zab.pdf" target="_blank" rel="external">zookeeper的Zzb</a></li>
<li><a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf" target="_blank" rel="external">zookeeper的Viewstamped Replication</a></li>
<li><a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf" target="_blank" rel="external">zookeeper的Raft</a></li>
<li><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=66814" target="_blank" rel="external">MS的PacificA算法</a></li>
</ul>
<p>kafka使用的leader elcetion算法与微软的Pacifica算法相似，就是上面所讲述的<code>ISR</code>模式。kafka在zookeeper中动态地维护了一个<code>ISR</code>set，这个set里的所有replica都跟上了leader，只有ISR里的成员才有被选为leader的可能。在这种模式下，对于f+1个replica，一个topic在保证不丢失已经commit的消息的前提下最多可以容忍f个replica的失败。</p>
<p><strong>如何处理所有Replica都不工作的情况</strong></p>
<p>前面已经提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某个Partition的所有Replica都宕机了，就无法保证数据不丢失了。这种情况下有两种可行的方案：</p>
<ul>
<li>等待ISR中的任一个Replica“活”过来，并且选它作为Leader；</li>
<li>选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader。
　</li>
</ul>
<p>这就需要在可用性和一致性当中作出一个简单的折衷。如果一定要等待ISR中的Replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中的所有Replica都无法“活”过来了，或者数据都丢失了，这个Partition将永远不可用。选择第一个“活”过来的Replica作为Leader，而这个Replica不是ISR中的Replica，那即使它并不保证已经包含了所有已commit的消息，它也会成为Leader而作为consumer的数据源（前文有说明，所有读写都由Leader完成）。Kafka0.8.*使用了第二种方式。根据Kafka的文档，在以后的版本中，Kafka支持用户通过配置选择这两种方式中的一种，从而根据不同的使用场景选择高可用性还是强一致性。</p>
<p><strong>如何选举Leader</strong></p>
<p>最简单最直观的方案是，所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>
<p>但是该方法会有3个问题： 　　</p>
<ul>
<li>split-brain，这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致；</li>
<li>herd effect，如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整；</li>
<li>Zookeeper负载过重，每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</li>
</ul>
<p>Kafka 0.8.*的Leader Election方案解决了上述问题，它在所有broker中选出一个<strong>controller</strong>，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>
<h3 id="2-3-consumer的reblance"><a href="#2-3-consumer的reblance" class="headerlink" title="2.3.consumer的reblance"></a>2.3.consumer的reblance</h3><p>kafka保证同一个consumer group中只有一个consumer会消费某条消息，实际上，kafka保证的事稳定状态下每一个consumer实例只会消费某一个或特定partition的数据，而某个partition的数据只会被某一个特定的consumer实例所消费。</p>
<p>这样设计的优点：</p>
<ul>
<li>每个consumer不用都跟broker进行大量的通信，减少通信开销，降低了分配难度；</li>
<li>同一个partition里的数据是有序的，保证每个partition里的数据是有序被消费的。</li>
</ul>
<p>设计的缺点：</p>
<ul>
<li>无法让同一个group里的consumer均匀消费数据。</li>
</ul>
<p>consumer的<strong>reblance算法</strong>如下（去看源码分析）：</p>
<ul>
<li>Sort $PT$ (all partitions in topic T)</li>
<li>Sort $CG$(all consumers in consumer group G)</li>
<li>Let i be the index position of $C_{i}$ in $CG$ and let $N=\lceil\frac{size(PT)}{size(CG)}\rceil$</li>
<li>Remove current entries owned by $C_{i}$ from the partition owner registry</li>
<li>Assign partitions from $iN$ to $(i+1)N-1$ to consumer $C_{i}$</li>
<li>Add newly assigned partitions to the partition owner registry</li>
</ul>
<p>consumer的<strong>reblance算法</strong>如下：</p>
<ol>
<li>对topic下的所有partition进行排序，结果记为$PT$；</li>
<li>对订阅这个topic的Group下的所有consumer进行排序，记为$CG$；</li>
<li>记i为CG中的idex，第i个consumer记为$C_{i}$，$N=\lceil\frac{size(PT)}{size(CG)}\rceil$；</li>
<li>解除原来$C_{i}$对分配的Partition的消费权；</li>
<li>将第 $iN$ 到 $(i+1)N-1$个partitions重新分配给$C_{i}$.</li>
</ol>
<p>目前consumer rebalance的控制策略是由每一个consumer通过Zookeeper完成的。具体的<strong>控制方式</strong>如下（去看源码分析）：</p>
<ul>
<li>Register itself in the consumer id registry under its group.</li>
<li>Register a watch on changes under the consumer id registry.</li>
<li>Register a watch on changes under the broker id registry.</li>
<li>If the consumer creates a message stream using a topic filter, it also registers a watch on changes under the broker topic registry.</li>
<li>Force itself to rebalance within in its consumer group.</li>
</ul>
<p>在这种策略下，每一个consumer或者broker的增加或者减少都会触发consumer rebalance。因为每个consumer只负责调整自己所消费的partition，为了保证整个consumer group的一致性，所以当一个consumer触发了rebalance时，该consumer group内的其它所有consumer也应该同时触发rebalance</p>
<p>这样的缺点是：</p>
<ul>
<li>Herd effect，任何broker或者consumer的增减都会触发所有的consumer的rebalance；</li>
<li>Split Brain，每个consumer分别单独通过Zookeeper判断哪些partition down了，那么不同consumer从Zookeeper“看”到的view就可能不一样，这就会造成错误的reblance尝试。而且有可能所有的consumer都认为rebalance已经完成了，但实际上可能并非如此。</li>
</ul>
<p>根据Kafka官方文档，Kafka作者正在考虑在还未发布的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+0.9+Consumer+Rewrite+Design" target="_blank" rel="external">0.9.x版本</a>中使用中心协调器(coordinator)。大体思想是选举出一个broker作为<code>coordinator</code>，由它watch Zookeeper，从而判断是否有partition或者consumer的增减，然后生成rebalance命令，并检查是否这些rebalance在所有相关的consumer中被执行成功，如果不成功则重试，若成功则认为此次rebalance成功（这个过程跟replication controller非常类似，所以我很奇怪为什么当初设计replication controller时没有使用类似方式来解决consumer rebalance的问题）</p>
<h2 id="3-pull"><a href="#3-pull" class="headerlink" title="3.pull"></a>3.pull</h2><p>参<a href="http://mp.weixin.qq.com/s?__biz=MzA4MzEzNjA0NA==&amp;mid=222594584&amp;idx=1&amp;sn=d64e5f5768ce48bd0bee1824b30fb1e3&amp;scene=0#rd" target="_blank" rel="external">流式计算-kafka（一）</a></p>
<p>作为一个message system，kafka遵循了传统的方式，选择由kafka的producer向broker push信息，而consumer从broker pull信息。</p>
<p>consumer获取消息，可以使用两种方式：push或pull模式。下面我们简单介绍一下这两种区别：</p>
<p><strong>push模式</strong></p>
<p>常见的push模式如storm的消息处理，由spout负责消息的推送。该模式下需要一个中心节点，负责消息的分配情况（哪段消息分配给consumer1，哪段消息分配给consumer2），同时还要监听consumer的ack消息用于判断消息是否处理成功，如果在timeout时间内为收到响应可以认为该consumer挂掉，需要重新分配sonsumer上失败的消息。这种模式有个问题，不太容易实现我们想要的消息回放功能，因为理想情况下由consumer决定我到底要消费什么，而这种模式完全由master决定。</p>
<p><strong>pull模式</strong></p>
<p>如上图模式，该模式为pull模式，由consumer决定消息的消费情况，这种模式有一个好处是我们不需要返回ack消息，因为当consumer申请消费下一批消息时就可以认为上一批消息已经处理完毕，也不需要处理超时的问题，consumer可以根据自己的消费能力来消费消息。但这个还有一个问题，如何保证处理的消息的不会重复呢，kafka具体做法就是增加队列的并发度（partition），可以一个partition对准一个consumer。</p>
<p>综上，kafka的consumer之所以没有采用push模式，是因为push模式很难适应消费者速率不同的消费者而且很难实现消息的回放功能，因为消息发送速率是由broker决定的。push模式的目标就是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞，而pull模式则可以根据consumer的消费能力以适当的速率消费message。</p>
<p>pull与push的区别</p>
<p>pull技术：</p>
<ul>
<li>客户机向服务器请求信息； </li>
<li>kafka中，consuemr根据自己的消费能力以适当的速率消费信息；</li>
</ul>
<p>push技术：</p>
<ul>
<li>服务器主动将信息发往客户端的技术；</li>
<li>push模式的目标就是尽可能以最快的速率传递消息。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://developer.51cto.com/art/201501/464491_all.htm" target="_blank" rel="external">发布&amp;订阅的消息系统Kafka的深度解析</a></li>
<li><a href="http://www.jasongj.com/2015/08/09/KafkaColumn4/" target="_blank" rel="external">Kafka Consumer设计解析</a></li>
<li><a href="http://blog.csdn.net/suifeng3051/article/details/48053965" target="_blank" rel="external">Kafka设计与原理详解</a></li>
<li><a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" target="_blank" rel="external">kafka设计解析2</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka之数据存储]]></title>
      <url>http://wangzzu.github.io/2016/03/08/kafka-store/</url>
      <content type="html"><![CDATA[<p>本文主要讲述以下两部分内容：</p>
<ul>
<li>kafka数据的存储方式；</li>
<li>kafka如何通过offset查找message。</li>
</ul>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>写介绍kafka的几个重要概念（可以参考之前的博文<a href="http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka">Kafka的简单介绍</a>）：</p>
<ul>
<li><strong>Broker</strong>：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群；</li>
<li><strong>Topic</strong>：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发；</li>
<li><strong>Partition</strong>：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队；</li>
<li><strong>Segment</strong>：每个partition又由多个segment file组成；</li>
<li><strong>offset</strong>：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息；</li>
<li><strong>message</strong>：这个算是kafka文件中最小的存储单位，即是 a commit log。</li>
</ul>
<p>kafka的message是以topic为基本单位，不同topic之间是相互独立的。每个topic又可分为几个不同的partition，每个partition存储一部的分message。topic与partition的关系如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/topic.png" alt="topic"></p>
<p>其中，partition是以文件夹的形式存储在具体Broker本机上。</p>
<h3 id="2-partition中的数据文件"><a href="#2-partition中的数据文件" class="headerlink" title="2.partition中的数据文件"></a>2.partition中的数据文件</h3><p>有了上面的介绍，下面我们开始介绍Topic中partition的数据文件类型。</p>
<h4 id="2-1-segment中的文件"><a href="#2-1-segment中的文件" class="headerlink" title="2.1.segment中的文件"></a>2.1.segment中的文件</h4><p>对于一个partition（在Broker中以文件夹的形式存在），里面又有很多大小相等的segment数据文件（这个文件的具体大小可以在<code>config/server.properties</code>中进行设置），这种特性可以方便old segment file的快速删除。</p>
<p>下面先介绍一下partition中的segment file的组成：</p>
<ul>
<li>segment file <strong>组成</strong>：由2部分组成，分别为index file和data file，这两个文件是一一对应的，后缀”.index”和”.log”分别表示索引文件和数据文件；</li>
<li>segment file <strong>命名规则</strong>：partition的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset,ofsset的数值最大为64位（long类型），20位数字字符长度，没有数字用0填充。如下图所示：</li>
</ul>
<p><img src="/images/2016-03-07-KafkaMessage/segment.png" alt="segment"></p>
<p>关于segment file中index与data file对应关系图，这里我们选用网上的一个图片，如下所示：</p>
<p><img src="/images/2016-03-07-KafkaMessage/index.png" alt="index"></p>
<p>segment的索引文件中存储着大量的元数据，数据文件中存储着大量消息，索引文件中的元数据指向对应数据文件中的message的物理偏移地址。以索引文件中的<code>3，497</code>为例，在数据文件中表示第3个message（在全局partition表示第368772个message），以及该消息的物理偏移地址为497。</p>
<p>注：Partition中的每条message由offset来表示它在这个partition中的偏移量，这个offset并不是该Message在partition中实际存储位置，而是逻辑上的一个值（如上面的3），但它却唯一确定了partition中的一条Message（可以认为offset是partition中Message的id）。</p>
<h4 id="2-2-message文件"><a href="#2-2-message文件" class="headerlink" title="2.2.message文件"></a>2.2.message文件</h4><p>message中的物理结构为：</p>
<p><img src="/images/2016-03-07-KafkaMessage/message.png" alt="message"></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 byte offset</td>
<td>在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td>
</tr>
<tr>
<td>4 byte message size</td>
<td>message大小</td>
</tr>
<tr>
<td>4 byte CRC32</td>
<td>用crc32校验message</td>
</tr>
<tr>
<td>1 byte “magic”</td>
<td>表示本次发布Kafka服务程序协议版本号</td>
</tr>
<tr>
<td>1 byte “attributes”</td>
<td>表示为独立版本、或标识压缩类型、或编码类型</td>
</tr>
<tr>
<td>4 byte key length</td>
<td>表示key的长度,当key为-1时，K byte key字段不填</td>
</tr>
<tr>
<td>K byte key</td>
<td>可选</td>
</tr>
<tr>
<td>value bytes payload</td>
<td>表示实际消息数据</td>
</tr>
</tbody>
</table>
<h4 id="2-3-数据文件的内部实现方法"><a href="#2-3-数据文件的内部实现方法" class="headerlink" title="2.3.数据文件的内部实现方法"></a>2.3.数据文件的内部实现方法</h4><p>Partition数据文件包含了若干上述格式的message，按照offset由小到大排列在一起，它实现的类是FileMessageSet，类图如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/filemessageset.png" alt="filemessageset"></p>
<p>它的主要方法如下：</p>
<ul>
<li><strong>append</strong>: 把给定的ByteBufferMessageSet中的Message写入到这个数据文件中。</li>
<li><strong>searchFor</strong>: 从指定的startingPosition开始搜索，找到第一个Message判断其offset是大于或者等于指定的offset，并返回其在文件中的位置Position。它的实现方式是从startingPosition开始读取12个字节，分别是当前MessageSet的offset和size。如果当前offset小于指定的offset，那么将position向后移动LogOverHead+MessageSize（其中LogOverHead为offset+messagesize，为12个字节）。</li>
<li><strong>read</strong>：准确名字应该是slice，它截取其中一部分返回一个新的FileMessageSet。它不保证截取的位置数据的完整性。</li>
<li><strong>sizeInBytes</strong>: 表示这个FileMessageSet占有了多少字节的空间。</li>
<li><strong>truncateTo</strong>: 把这个文件截断，这个方法不保证截断位置的Message的完整性。</li>
<li><strong>readInto</strong>: 从指定的相对位置开始把文件的内容读取到对应的ByteBuffer中。</li>
</ul>
<h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h4><h4 id="3-1-遇到的问题"><a href="#3-1-遇到的问题" class="headerlink" title="3.1.遇到的问题"></a>3.1.遇到的问题</h4><p>我们首先试想一下，如果对于Kafka的一个topic而言，如果topic的partition中只有一个数据文件的话会怎么样？</p>
<ul>
<li>新数据是添加在文件末尾（调用FileMessageSet的append方法），不论文件数据文件有多大，这个操作永远都是O(1)的。</li>
<li>查找某个offset的Message（调用FileMessageSet的searchFor方法）是顺序查找的。因此，如果数据文件很大的话，查找的效率就低。</li>
</ul>
<h4 id="3-2-如何去解决这个问题"><a href="#3-2-如何去解决这个问题" class="headerlink" title="3.2.如何去解决这个问题"></a>3.2.如何去解决这个问题</h4><p>由上述我们知道，如果在topic的partition中只有一个数据文件的话，Kafka插入的效率虽然很高，但是查找的效率非常低，那么Kafka在内部是如何解决查找效率的的问题呢？对于这个问题，Kafka有两大法宝：分段和索引。</p>
<p><strong>数据文件的分段</strong></p>
<p>这个是比较好理解的，加入有100条message，它们的offset是从0到99，假设将数据文件分为5端，第一段为0-19，第二段为20-39，依次类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</p>
<p><strong>为数据文件建索引</strong></p>
<p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的message了，但是这依然需要顺序扫描才能找到对应offset的message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为<code>.index</code>。</p>
<p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p>
<ul>
<li><strong>相对offset</strong>：因为数据文件分段以后，每个数据文件的起始offset不为0，相对offset表示这条message相对于其所属数据文件中最小的offset的大小。举例，分段后的一个数据文件的offset是从20开始，那么offset为25的message在index文件中的相对offset就是25-20 = 5。存储相对offset可以减小索引文件占用的空间。</li>
<li><strong>position</strong>：表示该条message在数据文件中的绝对位置。只要打开文件并移动文件指针到这个position就可以读取对应的message了。</li>
</ul>
<p>在kafka中，索引文件的实现类为OffsetIndex，它的类图如下：</p>
<p><img src="/images/2016-03-07-KafkaMessage/offsetindex.png" alt="offsetindex"></p>
<p>主要的方法有：</p>
<ul>
<li>append方法：添加一对offset和position到index文件中，这里的offset将会被转成相对的offset。</li>
<li>lookup：用二分查找的方式去查找小于或等于给定offset的最大的那个offset</li>
</ul>
<h4 id="3-3-通过offset查找message"><a href="#3-3-通过offset查找message" class="headerlink" title="3.3.通过offset查找message"></a>3.3.通过offset查找message</h4><p>假如我们想要读取offset=368776的message（见前面的第三个图），需要通过下面2个步骤查找。</p>
<ol>
<li><strong>查找segment file</strong><br>00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1.同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset <strong>二分查找</strong>文件列表，就可以快速定位到具体文件。<br>当offset=368776时定位到00000000000000368769.index|log</li>
<li>通过segment file<strong>查找message</strong><br>通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</li>
</ol>
<p>segment index file并没有为数据文件中的每条message建立索引，而是采取稀疏索引存储方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，通过map可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p>
<p>总结：</p>
<p>Kafka高效文件存储设计特点：</p>
<ul>
<li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li>
<li>通过索引信息可以快速定位message和确定response的最大大小。</li>
<li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</li>
<li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/jewes/article/details/42970799" target="_blank" rel="external">Kafka的Log存储解析</a></li>
<li><a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kakfa文件存储那些事</a></li>
<li><a href="http://blog.csdn.net/jewes/article/details/42744855" target="_blank" rel="external">Kafka的通讯协议</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce之Shuffle过程详述]]></title>
      <url>http://wangzzu.github.io/2016/03/02/hadoop-shuffle/</url>
      <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1.写在前面"></a>1.写在前面</h2><p>MapReduce作为Hadoop的编程框架，对于大数据开发或者想要接触大数据开发的开发者来说，是必须要掌握的，它是一种经典大数据计算框架，现在有很多开源项目的内部实现都会直接或间接地借鉴了MR过程的实现。我在经过了一些hadoop项目的开发，然后前几天又系统地学习MapReduc内部实现过程，尤其是学习中间的Shuffle过程之后，准备对这一块做一下总结，希望这篇文章能给需要的人带来一些帮助（文中Shuffle的分析还是以Hadoop1.0为例，这个跟2.0的区别并不是很大）。</p>
<h2 id="2总述"><a href="#2总述" class="headerlink" title="2总述"></a>2总述</h2><p>对于MapReduce作业，完整的作业运行流程，这里借用刘军老师的<a href="http://item.jd.com/11315351.html" target="_blank" rel="external">Hadoop大数据处理</a>中的一张图：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/hadoop.png" alt="hadoop"></p>
<p>完整过程应该是分为7部分，分别是：</p>
<ol>
<li>作业启动：开发者通过控制台启动作业；</li>
<li>作业初始化：这里主要是切分数据、创建作业和提交作业，与第三步紧密相联；</li>
<li>作业/任务调度：对于1.0版的Hadoop来说就是JobTracker来负责任务调度，对于2.0版的Hadoop来说就是Yarn中的Resource Manager负责整个系统的资源管理与分配，Yarn可以参考IBM的一篇博客<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-yarn/" target="_blank" rel="external">Hadoop新MapReduce框架Yarn详解</a>；</li>
<li>Map任务；</li>
<li>Shuffle；</li>
<li>Reduce任务；</li>
<li>作业完成：通知开发者任务完成。</li>
</ol>
<p>而这其中最主要的MapReduce过程，主要是第4、5、6步三部分，这也是本篇博客重点讨论的地方，详细作用如下：</p>
<ol>
<li><strong>Map</strong>:数据输入,做初步的处理,输出形式的中间结果；</li>
<li><strong>Shuffle</strong>:按照partition、key对中间结果进行排序合并,输出给reduce线程；</li>
<li><strong>Reduce</strong>:对相同key的输入进行最终的处理,并将结果写入到文件中。</li>
</ol>
<p>这里先给出官网上关于这个过程的经典流程图：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/mapreduce.png" alt="mapreduce"></p>
<p>上图是把MapReduce过程分为两个部分，而实际上从两边的Map和Reduce到中间的那一大块都属于Shuffle过程，也就是说，Shuffle过程有一部分是在Map端，有一部分是在Reduce端，下文也将会分两部分来介绍Shuffle过程。</p>
<p>对于Hadoop集群，当我们在运行作业时，大部分的情况下，map task与reduce task的执行是分布在不同的节点上的，因此，很多情况下，reduce执行时需要跨节点去拉取其他节点上的map task结果，这样造成了集群内部的网络资源消耗很严重，而且在节点的内部，相比于内存，磁盘IO对性能的影响是非常严重的。如果集群中运行的作业有很多，那么task的执行对于集群内部网络的资源消费非常大。因此，我们对于MapRedue作业Shuffle过程的期望是：</p>
<ul>
<li>完整地从map task端拉取数据到Reduce端；</li>
<li>在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗；</li>
<li>减少磁盘IO对task执行的影响。</li>
</ul>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>在进行海量数据处理时，外存文件数据<strong>I/O访问</strong>会成为一个制约系统性能的瓶颈，因此，Hadoop的Map过程实现的一个重要原则就是：<strong>计算靠近数据</strong>，这里主要指两个方面：</p>
<ol>
<li>代码靠近数据：<ul>
<li>原则：本地化数据处理（locality），即一个计算节点尽可能处理本地磁盘上所存储的数据；</li>
<li>尽量选择数据所在DataNode启动Map任务；</li>
<li>这样可以减少数据通信，提高计算效率；</li>
</ul>
</li>
<li>数据靠近代码：<ul>
<li>当本地没有数据处理时，尽可能从同一机架或最近其他节点传输数据进行处理（host选择算法）。</li>
</ul>
</li>
</ol>
<p>下面，我们分块去介绍Hadoop的Map过程，map的经典流程图如下：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/map-shuffle.png" alt="map-shuffle"></p>
<h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1.输入"></a><strong>1.输入</strong></h3><ol>
<li>map task只读取split分片，split与block（hdfs的最小存储单位，默认为64MB）可能是一对一也能是一对多，但是对于一个split只会对应一个文件的一个block或多个block，不允许一个split对应多个文件的多个block；</li>
<li>这里切分和输入数据的时会涉及到InputFormat的文件切分算法和host选择算法。</li>
</ol>
<p>文件切分算法，主要用于确定InputSplit的个数以及每个InputSplit对应的数据段。FileInputFormat以文件为单位切分生成InputSplit，对于每个文件，由以下三个属性值决定其对应的InputSplit的个数：</p>
<ul>
<li>goalSize： 它是根据用户期望的InputSplit数目计算出来的，即totalSize/numSplits。其中，totalSize为文件的总大小；numSplits为用户设定的Map Task个数，默认情况下是1；</li>
<li>minSize：InputSplit的最小值，由配置参数<code>mapred.min.split.size</code>确定，默认是1；</li>
<li>blockSize：文件在hdfs中存储的block大小，不同文件可能不同，默认是64MB。</li>
</ul>
<p>这三个参数共同决定InputSplit的最终大小，计算方法如下：</p>
<p><code>splitSize=max{minSize, min{gogalSize,blockSize}}</code></p>
<p>FileInputFormat的host选择算法参考《Hadoop技术内幕-深入解析MapReduce架构设计与实现原理》的p50.</p>
<h3 id="2-Partition"><a href="#2-Partition" class="headerlink" title="2.Partition"></a><strong>2.Partition</strong></h3><ul>
<li>作用：将map的结果发送到相应的reduce端，总的partition的数目等于reducer的数量。</li>
<li>实现功能：<ol>
<li>map输出的是key/value对，决定于当前的mapper的part交给哪个reduce的方法是：mapreduce提供的Partitioner接口，对key进行hash后，再以reducetask数量取模，然后到指定的job上（<strong>HashPartitioner</strong>，可以通过<code>job.setPartitionerClass(MyPartition.class)</code>自定义）。</li>
<li>然后将数据写入到内存缓冲区，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。key/value对以及Partition的结果都会被写入缓冲区。在写入之前，key与value值都会被序列化成字节数组。</li>
</ol>
</li>
<li>要求：负载均衡，效率；</li>
</ul>
<h3 id="3-spill（溢写）：sort-amp-combiner"><a href="#3-spill（溢写）：sort-amp-combiner" class="headerlink" title="3.spill（溢写）：sort &amp; combiner"></a><strong>3.spill（溢写）：sort &amp; combiner</strong></h3><ul>
<li>作用：把内存缓冲区中的数据写入到本地磁盘，在写入本地磁盘时先按照partition、再按照key进行排序（<code>quick sort</code>）；</li>
<li>注意：<ol>
<li>这个spill是由<strong>另外单独的线程</strong>来完成，不影响往缓冲区写map结果的线程；</li>
<li>内存缓冲区默认大小限制为100MB，它有个溢写比例（<code>spill.percent</code>），默认为0.8，当缓冲区的数据达到阈值时，溢写线程就会启动，先锁定这80MB的内存，执行溢写过程，maptask的输出结果还可以往剩下的20MB内存中写，互不影响。然后再重新利用这块缓冲区，因此Map的内存缓冲区又叫做<strong>环形缓冲区</strong>（两个指针的方向不会变，下面会详述）；</li>
<li>在将数据写入磁盘之前，先要对要写入磁盘的数据进行一次<strong>排序</strong>操作，先按<code>&lt;key,value,partition&gt;</code>中的partition分区号排序，然后再按key排序，这个就是<strong>sort操作</strong>，最后溢出的小文件是分区的，且同一个分区内是保证key有序的；</li>
</ol>
</li>
</ul>
<p><strong>combine</strong>：执行combine操作要求开发者必须在程序中设置了combine（程序中通过<code>job.setCombinerClass(myCombine.class)</code>自定义combine操作）。</p>
<ul>
<li>程序中有两个阶段可能会执行combine操作：<ol>
<li>map输出数据根据分区排序完成后，在写入文件之前会执行一次combine操作（前提是作业中设置了这个操作）；</li>
<li>如果map输出比较大，溢出文件个数大于3（此值可以通过属性<code>min.num.spills.for.combine</code>配置）时，在merge的过程（多个spill文件合并为一个大文件）中还会执行combine操作；</li>
</ol>
</li>
<li>combine主要是把形如<code>&lt;aa,1&gt;,&lt;aa,2&gt;</code>这样的key值相同的数据进行计算，计算规则与reduce一致，比如：当前计算是求key对应的值求和，则combine操作后得到<code>&lt;aa,3&gt;</code>这样的结果。</li>
<li>注意事项：不是每种作业都可以做combine操作的，只有满足以下条件才可以：<ol>
<li>reduce的输入输出类型都一样，因为combine本质上就是reduce操作；</li>
<li>计算逻辑上，combine操作后不会影响计算结果，像求和就不会影响；</li>
</ol>
</li>
</ul>
<h3 id="4-merge"><a href="#4-merge" class="headerlink" title="4.merge"></a><strong>4.merge</strong></h3><ul>
<li>merge过程：当map很大时，每次溢写会产生一个spill_file，这样会有多个spill_file，而最终的一个map task输出只有一个文件，因此，最终的结果输出之前会对多个中间过程进行多次溢写文件（spill_file）的合并，此过程就是merge过程。也即是，待Map Task任务的所有数据都处理完后，会对任务产生的所有中间数据文件做一次合并操作，以确保一个Map Task最终只生成一个中间数据文件。</li>
<li>注意：<ol>
<li>如果生成的文件太多，可能会执行多次合并，每次最多能合并的文件数默认为10，可以通过属性<code>min.num.spills.for.combine</code>配置；</li>
<li>多个溢出文件合并时，会进行一次排序，排序算法是<strong>多路归并排序</strong>；</li>
<li>是否还需要做combine操作，一是看是否设置了combine，二是看溢出的文件数是否大于等于3；</li>
<li>最终生成的文件格式与单个溢出文件一致，也是按分区顺序存储，并且输出文件会有一个对应的索引文件，记录每个分区数据的起始位置，长度以及压缩长度，这个索引文件名叫做<code>file.out.index</code>。</li>
</ol>
</li>
</ul>
<h3 id="内存缓冲区"><a href="#内存缓冲区" class="headerlink" title="内存缓冲区"></a><strong>内存缓冲区</strong></h3><ol>
<li>在Map Task任务的业务处理方法map()中，最后一步通过<code>OutputCollector.collect(key,value)</code>或<code>context.write(key,value)</code>输出Map Task的中间处理结果，在相关的<code>collect(key,value)</code>方法中，会调用<code>Partitioner.getPartition(K2 key, V2 value, int numPartitions)</code>方法获得输出的key/value对应的分区号(分区号可以认为对应着一个要执行Reduce Task的节点)，然后将<code>&lt;key,value,partition&gt;</code>暂时保存在内存中的MapOutputBuffe内部的环形数据缓冲区，该缓冲区的默认大小是100MB，可以通过参数<code>io.sort.mb</code>来调整其大小。</li>
<li>当缓冲区中的数据使用率达到一定阀值后，触发一次Spill操作，将环形缓冲区中的部分数据写到磁盘上，生成一个临时的Linux本地数据的spill文件；然后在缓冲区的使用率再次达到阀值后，再次生成一个spill文件。直到数据处理完毕，在磁盘上会生成很多的临时文件。 </li>
<li>缓存有一个阀值比例配置，当达到整个缓存的这个比例时，会触发spill操作；触发时，map输出还会接着往剩下的空间写入，但是写满的空间会被锁定，数据溢出写入磁盘。当这部分溢出的数据写完后，空出的内存空间可以接着被使用，形成像环一样的被循环使用的效果，所以又叫做<strong>环形内存缓冲区</strong>； </li>
<li>MapOutputBuffe内部存数的数据采用了两个索引结构，涉及三个环形内存缓冲区。下来看一下两级索引结构：</li>
</ol>
<p><img src="/images/2016-03-02-HadoopShuffle/buffer.jpg" alt="buffer"></p>
<p><strong>写入到缓冲区的数据采取了压缩算法 <a href="http://www.cnblogs.com/edisonchou/p/4298423.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4298423.html</a></strong><br>这三个环形缓冲区的含义分别如下： </p>
<ol>
<li><strong>kvoffsets</strong>缓冲区，也叫偏移量索引数组，用于保存key/value信息在位置索引kvindices中的偏移量。当kvoffsets的使用率超过<code>io.sort.spill.percent</code>(默认为80%)后，便会触发一次SpillThread线程的“溢写”操作，也就是开始一次Spill阶段的操作。 </li>
<li><strong>kvindices</strong>缓冲区，也叫位置索引数组，用于保存key/value在数据缓冲区kvbuffer中的起始位置。 </li>
<li><strong>kvbuffer</strong>即数据缓冲区，用于保存实际的key/value的值。默认情况下该缓冲区最多可以使用<code>io.sort.mb</code>的95%，当kvbuffer使用率超过<code>io.sort.spill.percent</code>(默认为80%)后，便会出发一次SpillThread线程的“溢写”操作，也就是开始一次Spill阶段的操作。</li>
</ol>
<p>写入到本地磁盘时，对数据进行排序，实际上是对<strong>kvoffsets</strong>这个偏移量索引数组进行排序。</p>
<h2 id="4-Reduce"><a href="#4-Reduce" class="headerlink" title="4.Reduce"></a>4.Reduce</h2><p>Reduce过程的经典流程图如下：</p>
<p><img src="/images/2016-03-02-HadoopShuffle/reduce-shuffle.png" alt="reduce-shuffle"></p>
<h3 id="1-copy过程"><a href="#1-copy过程" class="headerlink" title="1.copy过程"></a><strong>1.copy过程</strong></h3><ul>
<li>作用：拉取数据；</li>
<li>过程：Reduce进程启动一些数据copy线程(<code>Fetcher</code>)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为这时map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。 </li>
<li>默认情况下，当整个MapReduce作业的所有已执行完成的Map Task任务数超过Map Task总数的5%后，JobTracker便会开始调度执行Reduce Task任务。然后Reduce Task任务默认启动<code>mapred.reduce.parallel.copies</code>(默认为5）个MapOutputCopier线程到已完成的Map Task任务节点上分别copy一份属于自己的数据。 这些copy的数据会首先保存的内存缓冲区中，当内冲缓冲区的使用率达到一定阀值后，则写到磁盘上。</li>
</ul>
<p><strong>内存缓冲区</strong></p>
<ul>
<li>这个内存缓冲区大小的控制就不像map那样可以通过<code>io.sort.mb</code>来设定了，而是通过另外一个参数来设置：<code>mapred.job.shuffle.input.buffer.percent（default 0.7）</code>， 这个参数其实是一个百分比，意思是说，shuffile在reduce内存中的数据最多使用内存量为：0.7 × <code>maxHeap of reduce task</code>。</li>
<li>如果该reduce task的最大heap使用量（通常通过<code>mapred.child.java.opts</code>来设置，比如设置为-Xmx1024m）的一定比例用来缓存数据。默认情况下，reduce会使用其heapsize的70%来在内存中缓存数据。如果reduce的heap由于业务原因调整的比较大，相应的缓存大小也会变大，这也是为什么reduce用来做缓存的参数是一个百分比，而不是一个固定的值了。</li>
</ul>
<h3 id="2-merge过程"><a href="#2-merge过程" class="headerlink" title="2.merge过程"></a><strong>2.merge过程</strong></h3><ul>
<li>Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比 map 端的更为灵活，它基于 JVM 的<code>heap size</code>设置，因为 Shuffle 阶段 Reducer 不运行，所以应该把绝大部分的内存都给 Shuffle 用。</li>
<li>这里需要强调的是，merge 有三种形式：1)内存到内存  2)内存到磁盘  3)磁盘到磁盘。默认情况下第一种形式是不启用的。当内存中的数据量到达一定阈值，就启动内存到磁盘的 merge（图中的第一个merge，之所以进行merge是因为reduce端在从多个map端copy数据的时候，并没有进行sort，只是把它们加载到内存，当达到阈值写入磁盘时，需要进行merge） 。这和map端的很类似，这实际上就是溢写的过程，在这个过程中如果你设置有Combiner，它也是会启用的，然后在磁盘中生成了众多的溢写文件，这种merge方式一直在运行，直到没有 map 端的数据时才结束，然后才会启动第三种磁盘到磁盘的 merge （图中的第二个merge）方式生成最终的那个文件。 </li>
<li>在远程copy数据的同时，Reduce Task在后台启动了两个后台线程对内存和磁盘上的数据文件做合并操作，以防止内存使用过多或磁盘生的文件过多。 </li>
</ul>
<h3 id="3-reducer的输入文件"><a href="#3-reducer的输入文件" class="headerlink" title="3.reducer的输入文件"></a><strong>3.reducer的输入文件</strong></h3><ul>
<li>merge的最后会生成一个文件，大多数情况下存在于磁盘中，但是需要将其放入内存中。当reducer 输入文件已定，整个 Shuffle 阶段才算结束。然后就是 Reducer 执行，把结果放到 HDFS 上。</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="http://vdisk.weibo.com/u/1853811305" target="_blank" rel="external">北邮刘军老师的Hadoop课件</a></li>
<li><a href="http://blog.csdn.net/dianacody/article/details/39502917" target="_blank" rel="external">分Map和Redcue两部分介绍</a></li>
<li><a href="http://flyingdutchman.iteye.com/blog/1879642" target="_blank" rel="external">内存缓冲区的介</a></li>
<li>内存缓冲区以及map的各个阶段介绍:<a href="http://xigan.blog.51cto.com/5200121/1163820" target="_blank" rel="external">mapreduce shuffle过程问答</a></li>
<li><a href="http://blog.csdn.net/ebay/article/details/45722263" target="_blank" rel="external">MapReduce详细过程</a></li>
<li><a href="http://zheming.wang/hadoop-mapreduce-zhi-xing-liu-cheng-xiang-jie.html" target="_blank" rel="external">http://zheming.wang/hadoop-mapreduce-zhi-xing-liu-cheng-xiang-jie.html</a></li>
<li>hadoop中的一些压缩算法，<a href="http://www.cnblogs.com/edisonchou/p/4298423.html" target="_blank" rel="external">http://www.cnblogs.com/edisonchou/p/4298423.html</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Travel to Nanjing | 元旦南京之旅]]></title>
      <url>http://wangzzu.github.io/2016/01/14/TravelToNanjing/</url>
      <content type="html"><![CDATA[<p>这篇文章是我2016年的第一篇博客，之前本来想着新年的开篇应该写一篇掉炸天的技术博客，最后，想了想，还是准备写篇旅行博客吧，因为这次南京游玩不仅仅是旅行。</p>
<h2 id="1-Day1"><a href="#1-Day1" class="headerlink" title="1.Day1"></a>1.Day1</h2><p>第一天应该是最辛苦的，因为去的地方比较多，有：玄武湖，狮子桥，中山陵，明孝陵，美龄宫，秦淮河和夫子庙。大家出去玩的时候一定要穿双舒服的鞋（就是走很多路也不会磨脚的那种），这点要切记，森哥（一同去玩的朋友）就是因为这导致第一天就把脚磨破，再后面两天几非常惨了。</p>
<p>南京火车站南出口一出来就是玄武湖，只不过这天雾霾比较大，景色没有想象中得好。如果南京的空气要是好些的话，还确实是座宜居的城市，在玄武湖的周围有一个专门跑步的跑道，我本身比较喜欢跑步，所以我是特别喜欢这种湖边跑道，要是自己以后能住在湖边，而湖边又有跑道，那该多么幸福！我之所以会羡慕这种城市，可能主要我是北方人的原因，越是缺少什么东西越是喜欢什么吧。好了，先放几张图。</p>
<p>南京火车站南出站口</p>
<p><img src="/images/2016-01-14-TraveToNanJing/nanjing.jpg" alt="nanjing"></p>
<p>火车站对面的玄武湖</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu.jpg" alt="xuanwuhu"></p>
<p>去往玄武湖其中一个岛的小桥（旭桥，来自百度地图），还有森哥的背景</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu3.jpg" alt="xuanwuhu3"></p>
<p>小岛上的景色还是不错的</p>
<p><img src="/images/2016-01-14-TraveToNanJing/xuanwuhu2.jpg" alt="xuanwuhu2"></p>
<p>接下来，我们就是南京很有名的小吃街——湖南路狮子桥，去吃了一家南京本地的饭店——南京大排档，总体感觉还不错吧，算是比较有特色的当地饭店，没有吃的话，还是推荐去吃一下，就是里面椅子不太舒服不能往后靠。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi1.jpg" alt="meishi1"></p>
<p>吃完饭之后，我就坐车直接去了中山陵，到中山陵的时候就已经快一点了，这个时候中山陵的人已经很多了，如果要是还想去明孝陵，美龄宫，灵谷寺的话就得抓紧时间了，我们当时再去完中山陵之后，就去了明孝陵，然后又去了美龄宫，去完美龄宫就已经到五点多了，灵谷寺就没时间玩了。下面又是晒图的时候了。</p>
<p>2016元旦的中山陵</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshan1.jpg" alt="zhongshan1"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshan2.jpg" alt="zhongshan2"></p>
<p>中山陵这边的天气还是很不错的，虽然此时南京市区都环绕在中度污染之中，在这钟山风景区空气竟然没那么糟，还能清晰地看到蓝天白云。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zhongshanling3.jpg" alt="zhongshanling3"></p>
<p>明孝陵的方城明楼，还是能感受帝王的气派的，城楼都盖了几百年了，依然屹立不倒，与现在的豆腐渣工程形成鲜明对比</p>
<p><img src="/images/2016-01-14-TraveToNanJing/mingxiaoling.jpg" alt="mingxiaoling"></p>
<p>美龄宫，也曾经是中国的权利中心之一吧</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meilinggong.jpg" alt="meilinggong"></p>
<p>在去完美龄宫之后，我们就基本上没有力气，也没有时间再去灵谷寺和音乐台了，所以就选择了回市区吃饭，本来想着去吃鸭血粉丝的，但是离我们下车的地方太远了，所以就去吃了一个抄手，然后又去吃了南京一家比较有名的笑云开灌汤包。吃完之后就直接奔向了夫子庙。由于是晚上，手机的照相功能又一般般，选两张稍微好看一点的照片吧。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/fuzimiao.jpg" alt="fuzimiao"></p>
<p>夫子庙的聚贤楼，之所以晒这个，主要是因为这张照片感觉照得还不错，其他的照片就不好意思拿出手了。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/fuzimiao2.jpg" alt="fuzimiao2"></p>
<p>经过昨天一晚的长途奔波（北京到南京的硬座）和今天一天的到处转悠，我这天的运动步数也达到了4W+步，第一次取得了微信运动的第一名。晚上就直接住在好友祥子学校（东大九龙湖校区）附近了，祥子很给力，把住宿什么的都给我们安排好了，非常感谢哈。</p>
<h2 id="2-Day2"><a href="#2-Day2" class="headerlink" title="2.Day2"></a>2.Day2</h2><p>因为昨天太过劳累，今天直接睡到了早上9点，然后起床去东大食堂吃点，吃完早饭之后就直接坐地铁准备去南京博物院了，南京博物院号称仅次于故宫博物院和上海博物院的全国第三大博物院，尤其以其民国馆最著名，所以我们准备花半天的时间转。</p>
<p>在进博物院之前，我们先去一家南京本地很出名的糕点店——芳婆糕点去买了中午饭，我们去买饭的时候已经快上午11点了，但是还有很多人在排队。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi2.jpg" alt="meishi2"></p>
<p>买完饭之后，我们直接奔向博物院，先来张博物院的正门。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/bowuyuan.jpg" alt="bowuyuan"></p>
<p>其他的像博物馆里江南的历史这里就不在说了，晒几张民国馆的照片吧。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo1.jpg" alt="minguo1"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo2.jpg" alt="minguo2"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/minguo3.jpg" alt="minguo3"></p>
<p>转完博物院之后就已经三点多了，这时候我们就直接坐车去了总统府，到总统府的时候就已经快4点了，就要停止卖票了。要注意总统府停止卖票时间是<strong>下午4点</strong>，5店闭馆，也就是说我们只有一个小时的时间去转,这点去的时候人还是超多的，尤其到了那个有总统办公室的大楼，人超多，还没看清就被挤出去了。因为时间比较紧，我们转完中间和东边部分之后，西边的地方还没有转完，人家就已经要闭馆了，所以要去总统府的话一定要<strong>早点</strong>去。</p>
<p>总统府的大门，出来后照的，门口有卖明信片的，比总统府里和民国馆里卖得便宜</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu.jpg" alt="zongtongfu"></p>
<p>著名“天下为公”，第一次听说这个词，是在《走向共和》里看到，这也是我第一次对孙中山这个人有了稍微深入一点的了解，之前的了解全是从历史课本里得到，了解得很片面，不过依然认为孙中山还是非常伟大的，每个人都会有缺点，但是这些缺点也不能掩盖他的伟大。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu2.jpg" alt="zongtongfu2"></p>
<p>这个好像会议室，具体的忘了。。。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu3.jpg" alt="zongtongfu3"></p>
<p>下面这张是在总统府西边那边顺便照的一张，因为比较时间比较紧，并没有怎么转，就选一张作为代表吧</p>
<p><img src="/images/2016-01-14-TraveToNanJing/zongtongfu4.jpg" alt="zongtongfu4"></p>
<p>再去完总统府之后，我们就直接返回了东大，晚上在东大附近与以前好友们（其中四个在东大读研究生）一起大吃了一顿，非常感谢这几位好朋友的款待。</p>
<h2 id="3-Day3"><a href="#3-Day3" class="headerlink" title="3.Day3"></a>3.Day3</h2><p>前两天基本上把南京比较出名的地方都玩了一遍，所以今天就好好睡了一觉，我跟森哥直接睡到了早上11点才起来，起来之后又在东大吃了中饭，然后就跟着海坤兄一起先去了燕子矶公园，据说在那天气好的话可以看到南京第一长江大桥，而且它离南京第二长江大桥很近。</p>
<p>燕子矶公园，南京第二长江大桥的景色</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang2.jpg" alt="changjiang2"></p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang2-2.jpg" alt="changjiang2-2"></p>
<p>然后，我们就坐车去了南京第一长江大桥，因为这个桥建造的时间比较长，它的人行道跟自行车道是在一起，而且很窄，电动车非常多，只想说很<strong>危险</strong>，最好还是直接去长江大桥下面的那个什么公园，公园门票是15，可以直接坐电梯坐到桥，要不然就要绕很远的路才能到桥上，而且还很危险。冒着生命危险，终于走到了长江大桥上，不照照片非好汉啊，又一波照片来袭！</p>
<p>傍晚的大桥</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1.jpg" alt="changjiang1"></p>
<p>手机相机处理后的效果</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1-1.jpg" alt="changjiang1-1"></p>
<p>桥前面的石像，桥口还有武警站岗的</p>
<p><img src="/images/2016-01-14-TraveToNanJing/changjiang1-2.jpg" alt="changjiang1-2"></p>
<p>看到大桥之后，我们就去了一家叫做石记鸭血粉丝店专门去吃鸭血粉丝，下面是鸭血粉丝的全家桶的图</p>
<p><img src="/images/2016-01-14-TraveToNanJing/meishi3.jpg" alt="meishi3"></p>
<h2 id="4-好友重逢"><a href="#4-好友重逢" class="headerlink" title="4.好友重逢"></a>4.好友重逢</h2><p>相聚的时间总是短暂的，前面之所以说这次不仅仅旅行，主要是这次更多的是好友的相聚，大学毕业后的（毕业一年半）再次相聚，还感慨颇深的，尤其当在火车站与好友相别，在候车室与森哥相别的时候，心中平添了很多的伤感，下次再聚不知道会是什么时候。三天的相聚，更多的是那种熟悉的感觉，方佛又回到大学时光，让我感到由衷的亲切，这感觉远胜美景千万。希望以后大家还能再一起出去玩，最后附上我们几个合照（另外两位美女就不公开了）。</p>
<p><img src="/images/2016-01-14-TraveToNanJing/hezhao.jpg" alt="hezhao"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于Kafka学习的一些资料]]></title>
      <url>http://wangzzu.github.io/2015/12/21/kafka-learn/</url>
      <content type="html"><![CDATA[<h2 id="kafka一些重要博客参考"><a href="#kafka一些重要博客参考" class="headerlink" title="kafka一些重要博客参考"></a>kafka一些重要博客参考</h2><p>kafka设计部分的文档：</p>
<ul>
<li><a href="http://kafka.apache.org/documentation.html#design" target="_blank" rel="external">官网设计英文版</a></li>
<li><a href="http://www.oschina.net/translate/kafka-design" target="_blank" rel="external">Kafka设计中文版</a></li>
<li><a href="http://blog.csdn.net/lizhitao/article/details/39499283" target="_blank" rel="external">Kafka资源汇总</a></li>
<li><a href="http://www.jasongj.com/tags/Kafka/" target="_blank" rel="external">Json的Kafka深度解析博客</a></li>
</ul>
<p>kafka设计的一些特殊之处：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/145090" target="_blank" rel="external">Kafka源码调研系统1 特色</a></li>
</ul>
<p>kafka的存储：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/152837" target="_blank" rel="external">producer中partition的使用方式</a></li>
</ul>
<p>kafka监控：</p>
<ul>
<li><a href="http://my.oschina.net/u/591402/blog/158139" target="_blank" rel="external">Kafka监控之mx4j-tool</a></li>
<li><a href="http://my.oschina.net/u/591402/blog/158150" target="_blank" rel="external">Kafka监控之mx4jLoader</a></li>
<li><a href="http://wangzzu.github.io/2015/12/08/2015-12-8-kafka-monitor/">Kafka监控软件</a></li>
</ul>
<p>Kafka测试：</p>
<ul>
<li><a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines#userconsent#" target="_blank" rel="external">Benchmarking Apache Kafka: 2 Million Writes Per Second (On Three Cheap Machines)</a></li>
</ul>
<p>Kafka源码解析：</p>
<ul>
<li><a href="https://github.com/wyzssw/kafka--summary" target="_blank" rel="external">wyzssw/kafka–summary</a></li>
<li><a href="http://www.cnblogs.com/huxi2b/tag/Kafka/" target="_blank" rel="external">胡夕-Kafka详细代码解释</a></li>
<li><a href="http://zqhxuyuan.github.io/2017/01/01/Kafka-Code-Index/" target="_blank" rel="external">Kafka技术内幕</a></li>
<li><a href="https://www.gitbook.com/book/zqhxuyuan1/kafka/details" target="_blank" rel="external">Kafka源码分析的GitBook</a></li>
</ul>
<p>Kafka最新动态</p>
<ul>
<li>可以关注<a href="http://www.confluent.io/blog" target="_blank" rel="external">confluent博客</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka监控软件介绍]]></title>
      <url>http://wangzzu.github.io/2015/12/08/2015-12-8-kafka-monitor/</url>
      <content type="html"><![CDATA[<h2 id="1-KafkaOffsetMonitor"><a href="#1-KafkaOffsetMonitor" class="headerlink" title="1.KafkaOffsetMonitor"></a>1.KafkaOffsetMonitor</h2><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1.下载安装"></a>1.1.下载安装</h3><ul>
<li><a href="https://github.com/quantifind/KafkaOffsetMonitor" target="_blank" rel="external">源码下载地址</a></li>
<li><a href="https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar" target="_blank" rel="external">jar下载地址</a></li>
</ul>
<h3 id="1-2-使用方法"><a href="#1-2-使用方法" class="headerlink" title="1.2.使用方法"></a>1.2.使用方法</h3><p>This is a small webapp, you can run it locally or on a server, as long as you have access to the ZooKeeper nodes controlling kafka.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk serveIp1,serveIp2,serveIp3 --port 8080 --refresh 10.seconds --retain 2.days</span><br></pre></td></tr></table></figure>
<p>The arguments are:</p>
<ul>
<li><strong>ZK</strong>: the ZooKeeper hosts;</li>
<li><strong>port</strong>: on what port will the app be available;</li>
<li><strong>refresh</strong>: how often should the app refresh and store a point in the DB;</li>
<li><strong>retain</strong>: how long should points be kept in the DB;</li>
<li><strong>dbName</strong>: where to store the history (default ‘offsetapp’);</li>
</ul>
<h2 id="2-Kafka-Manager"><a href="#2-Kafka-Manager" class="headerlink" title="2.Kafka Manager"></a>2.Kafka Manager</h2><p><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="external">源码地址</a></p>
<h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1.安装"></a>2.1.安装</h3><p><a href="http://hengyunabc.github.io/kafka-manager-install/" target="_blank" rel="external">Kafka Manager安装</a></p>
<h4 id="2-1-1-sbt安装"><a href="#2-1-1-sbt安装" class="headerlink" title="2.1.1.sbt安装"></a>2.1.1.sbt安装</h4><p><a href="http://www.scala-sbt.org/download.html" target="_blank" rel="external">sbt安装</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://bintray.com/sbt/rpm/rpm &gt; bintray-sbt-rpm.repo</span><br><span class="line">sudo mv bintray-sbt-rpm.repo /etc/yum.repos.d/</span><br><span class="line">sudo yum install sbt</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-下载，编译"><a href="#2-1-2-下载，编译" class="headerlink" title="2.1.2.下载，编译"></a>2.1.2.下载，编译</h4><p>下载，并编译源码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yahoo/kafka-manager</span><br><span class="line"><span class="built_in">cd</span> kafka-manager</span><br><span class="line">sbt clean dist</span><br></pre></td></tr></table></figure>
<p>生成的包会在<code>kafka-manager/target/universal</code> 下面。生成的包只需要java环境就可以运行了，在部署的机器上不需要安装sbt.</p>
<h4 id="2-1-3-打包部署"><a href="#2-1-3-打包部署" class="headerlink" title="2.1.3.打包部署"></a>2.1.3.打包部署</h4><p>打好包好，在部署机器上解压，修改好配置文件，就可以运行了。</p>
<p>解压：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip kafka-manager-1.0-SNAPSHOT.zip</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-配置运行"><a href="#2-2-配置运行" class="headerlink" title="2.2.配置运行"></a>2.2.配置运行</h3><h4 id="2-2-1-配置"><a href="#2-2-1-配置" class="headerlink" title="2.2.1.配置"></a>2.2.1.配置</h4><p>修改<code>conf/application.conf</code>，把<code>kafka-manager.zkhosts</code>改为自己的zookeeper服务器地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-manager.zkhosts=<span class="string">"localhost:2181"</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-启动"><a href="#2-2-2-启动" class="headerlink" title="2.2.2.启动"></a>2.2.2.启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-manager -Dconfig.file=./conf/application.conf -Dhttp.port=8080</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-kafka-manager其他方面"><a href="#2-2-3-kafka-manager其他方面" class="headerlink" title="2.2.3.kafka-manager其他方面"></a>2.2.3.kafka-manager其他方面</h4><p>查看帮助</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-manager -h</span><br></pre></td></tr></table></figure>
<p>后台运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./kafka-manager -Dconfig.file=../conf/application.conf &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>默认http端口是9000，可以修改配置文件里的http.port的值，或者通过命令行参数传递：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-manager -Dhttp.port=9001</span><br></pre></td></tr></table></figure>
<p>如果不想自己编译源文件，也可以通过下面的地址直接下载，<a href="http://pan.baidu.com/s/1kTtFpGV" target="_blank" rel="external">kafka-manager-1.0-SNAPSHOT.zip下载地址</a></p>
<h3 id="3-Kafka-web-console"><a href="#3-Kafka-web-console" class="headerlink" title="3.Kafka-web-console"></a>3.Kafka-web-console</h3><p><a href="https://github.com/claudemamo/kafka-web-console" target="_blank" rel="external">源码地址</a></p>
<p>不过这个项目好像不再进行更新了，想了解这个项目的话可以进入github主页去研究研究。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka程序设计之Producer]]></title>
      <url>http://wangzzu.github.io/2015/11/27/kafka-code1/</url>
      <content type="html"><![CDATA[<p>本文主要是介绍一下kafka基于<code>Producer API</code>的程序设计，使用的kafka版本为<code>2.10-0.8.1.1</code>。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在写完<a href="http://wangzzu.github.io/2015/11/13/kafka-install/">Kafka集群的安装与配置</a>和<a href="http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka/">Kafka的简单介绍</a>这两篇博客之后，从本文开始准备介绍一下Kafka的程序设计部分，大概会分为三篇介绍，第一篇是基于<code>Kafka Producer API</code>的程序设计，也就是本文，第二篇是基于<code>Kafka High Level Consumer API</code>的程序设计，第三篇是基于<code>Kafka Simple Consumer API</code>的程序设计。本文主要是根据kafka提供的官方文档来介绍，希望能给刚接触kafka程序设计的初学者提供一些帮助。</p>
<p>我们知道，kafka的基本架构其实非常简单，但kafka作为管道传输为了保证其强大的功能与稳定的性能，kafka在内部实现上是做了非常多的努力的，这些我会在后续的文章中慢慢讲解。然而对大部分人而言重要的就是如何进行程序设计来实现所需的功能，kafka给我们提供了丰富而简介的API接口，本文的例子是通过<a href="https://github.com/apache/kafka/tree/trunk/examples/src/main/java/kafka/examples" target="_blank" rel="external">Kafka Examples</a>中的例子来讲解如何使用这些API接口来进行程序设计。本文中使用的kafka的版本为<code>kafka_2.10-0.8.1.1</code>，并且使用maven建立工程，需要在pom.xml文件加入如下的依赖包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.10<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.jms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jdmk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxri<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jmx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面具体讲解一下<code>Producer</code>。</p>
<h2 id="2-实例分析"><a href="#2-实例分析" class="headerlink" title="2.实例分析"></a>2.实例分析</h2><p>Producer是用来把消息发送到Kafka的Broker端，Producer应用非常广泛，在本文中只涉及发送随机消息和本地文件。</p>
<h3 id="2-1-API介绍"><a href="#2-1-API介绍" class="headerlink" title="2.1.API介绍"></a>2.1.API介绍</h3><p>实现Producer程序主要会使用到以下三个类：</p>
<ul>
<li>kafka.producer.ProducerConfig：配置Producer，比如定义metadata.bokers.list、partitioner.class等；</li>
<li>kafka.javaapi.producer.Producer：最主要的类，用来发送消息等；</li>
<li>kafka.producer.KeyedMessage：定义要发送的消息，比如发送到哪个topic的哪个partition等。</li>
</ul>
<h3 id="2-2-示例分析"><a href="#2-2-示例分析" class="headerlink" title="2.2.示例分析"></a>2.2.示例分析</h3><p>借用官方文档<a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+Producer+Example" target="_blank" rel="external">0.8.0 Producer Example</a>中给出的样例程序。</p>
<p>Producer的程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> events = Long.parseLong(args[<span class="number">0</span>]);</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"broker1:9092,broker2:9092 "</span>);</span><br><span class="line">        props.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">        props.put(<span class="string">"partitioner.class"</span>, <span class="string">"example.producer.SimplePartitioner"</span>);</span><br><span class="line">        props.put(<span class="string">"request.required.acks"</span>, <span class="string">"1"</span>);</span><br><span class="line"> </span><br><span class="line">        ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</span><br><span class="line"> </span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> Producer&lt;String, String&gt;(config);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> nEvents = <span class="number">0</span>; nEvents &lt; events; nEvents++) &#123; </span><br><span class="line">               <span class="keyword">long</span> runtime = <span class="keyword">new</span> Date().getTime();  </span><br><span class="line">               String ip = <span class="string">"192.168.2."</span> + rnd.nextInt(<span class="number">255</span>); </span><br><span class="line">               String msg = runtime + <span class="string">",www.example.com,"</span> ip; </span><br><span class="line">               KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);</span><br><span class="line">               producer.send(data);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Partitioner的程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePartitioner</span> <span class="params">(VerifiableProperties props)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object key, <span class="keyword">int</span> a_numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = <span class="number">0</span>;</span><br><span class="line">        String stringKey = (String) key;</span><br><span class="line">        <span class="keyword">int</span> offset = stringKey.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           partition = Integer.parseInt( stringKey.substring(offset+<span class="number">1</span>)) % a_numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> partition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个样例程序实现的功能非常简单，就是发送多条（参数指定）类似于<code>runtime + “,www.example.com,” + “192.168.2.” + rnd.nextInt(255);</code>的消息。通过这个程序可以看出实现Kafka producer功能主要有以下三点需要注意：</p>
<p><strong>Kafka Properties</strong></p>
<p>这是实现代码的第一步，在代码中定义了一个<code>Properties</code>。这个<code>Properties</code>是通过<code>kafka.producer.ProducerConfig</code>将一些参数传递给Producer，告诉Producer如何找到找到集群，怎么序列化消息和消息如何发给Partition等。</p>
<p>样例程序中的这些参数意义为：</p>
<ul>
<li><code>metadata.broker.list</code> 定义Producer为每个Partition选作Leader的broker，应至少有两个，而且这两个broker一定要是开启Kafka服务；</li>
<li><code>serializer.class</code>定义message传送给broker时，应该使用什么类型的序列化方式，但是注意这个类型的编码也一定要能够接受KeyMessage对象定义的类型（Java对象在传输前需要进行序列化）；</li>
<li><code>partitioner.class</code>决定了这个message应该发送给这个topic的哪个Partition（如果程序中为key指定了一个值但是没有定义一个partitioner.class，kafka就会使用默认的partitioner发送到指定的Partition，如果key没有定义，Producer就会把message发送到随机的Partition）；</li>
<li><code>request.required.acks</code>默认是0，可以设置0，1，-1；</li>
</ul>
<p>程序中可以传入的参数参考<a href="http://kafka.apache.org/documentation.html#producerconfigs" target="_blank" rel="external">Producer API</a>，经常使用参数有 <code>producer.type</code>, <code>batch.size</code>, <code>receive.buffer.bytes</code>, <code>send.buffer.bytes</code> 和 <code>acks</code>等。</p>
<p>使用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">"producer.type"</span>, async);</span><br><span class="line">props.put(<span class="string">"batch.num.messages"</span>, batch);</span><br></pre></td></tr></table></figure>
<p><strong>Producer object</strong></p>
<p>再定义完<code>Properties</code>和<code>Producer object</code>之后，下面就是将topic，partition和message传递给<code>KeyedMessage</code>，然后通过producer的<code>send</code>方法将消息发送出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> Producer&lt;String, String&gt;(config);</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 数据的处理过程</span><br><span class="line">*/</span></span><br><span class="line">KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(<span class="string">"page_visits"</span>, ip, msg);<span class="comment">//KeyedMessage&lt;String, String&gt;(topicName, partitionKey, msg)</span></span><br><span class="line">producer.send(data);</span><br></pre></td></tr></table></figure>
<p><strong>自定义Partition</strong></p>
<p>样例代码中的<code>SimplePartitioner</code>是自定义的，PartitionKey的值通过十进制ip地址小数点最后一位与a_numPartitions取余得到。在自定义Partition时，需要在程序（如：<code>props.put(&quot;partitioner.class&quot;, &quot;example.producer.SimplePartitioner&quot;)</code>）中指定Partitioner的位置。</p>
<h2 id="3-实例程序设计"><a href="#3-实例程序设计" class="headerlink" title="3.实例程序设计"></a>3.实例程序设计</h2><p>在解析完样例程序之后，下面我们通过一个实际案例来设计Producer程序。</p>
<h3 id="3-1-实现功能"><a href="#3-1-实现功能" class="headerlink" title="3.1.实现功能"></a>3.1.实现功能</h3><p>程序要实现的功能是监控本地一个文件目录，将此目录中文件数据发送到Kafka的Broker端，并且每当发送完一个文件后就删除该文件，然后当有新的文件传进来之后就发送这个文件。</p>
<h3 id="3-2-程序设计"><a href="#3-2-程序设计" class="headerlink" title="3.2.程序设计"></a>3.2.程序设计</h3><p>本例我们就不在使用自定义的Partition，而直接由参数传入PartitionKey的值。程序设计的思路：</p>
<ol>
<li>监控给定的目录；</li>
<li>如果目录没有文件，sleep一段时间（sleep的时间需要根据具体的应用来设置），返回第1步；</li>
<li>当目录中有文件时，将文件中的数据按行发送；</li>
<li>这个文件发送完，就将该文件删除，继续发送下一个文件，知道目录中文件发送完毕，再返回第1步。</li>
</ol>
<p>根据这个思路，程序主要实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length!=<span class="number">3</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"please input &lt;input&gt; &lt;topic&gt; &lt;partitionKey&gt; "</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		String input = args[<span class="number">0</span>];</span><br><span class="line">		String topic = args[<span class="number">1</span>];</span><br><span class="line">		String partitionKey=args[<span class="number">2</span>];</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		props.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"ip1:9092,ip2:9092"</span>);</span><br><span class="line">		props.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">		props.put(<span class="string">"key.serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">		 </span><br><span class="line">		ProducerConfig config = <span class="keyword">new</span> ProducerConfig(props);</span><br><span class="line">		BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> fileLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		File file = <span class="keyword">new</span> File(inputFold);<span class="comment">//输入目录由参数给定</span></span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">		    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//一直监控目录</span></span><br><span class="line">		    	File[] files = file.listFiles();</span><br><span class="line">			    <span class="keyword">if</span> (files.length == <span class="number">0</span>) &#123; </span><br><span class="line">			        System.out.println(<span class="string">"文件夹是空的!"</span>);</span><br><span class="line">			        <span class="keyword">try</span> &#123;</span><br><span class="line">			            Thread.sleep(<span class="number">60000</span>);<span class="comment">//sleep1min</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">			        <span class="keyword">continue</span>; </span><br><span class="line">			    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			        <span class="keyword">for</span> (File file2 : files) &#123;</span><br><span class="line">			        	<span class="keyword">if</span> (file2.isDirectory()) &#123; </span><br><span class="line">							System.out.println(<span class="string">"有递归目录："</span> + file2.getAbsolutePath());</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file2.getAbsolutePath())));</span><br><span class="line">							&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">								System.err.println(<span class="string">"输入文件错误"</span>);</span><br><span class="line">								System.exit(<span class="number">2</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">							String line=<span class="keyword">null</span>;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								line = reader.readLine();</span><br><span class="line">							&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            					System.err.println(<span class="string">"输入文件错误"</span>);</span><br><span class="line">            					e.printStackTrace();</span><br><span class="line">            					System.exit(<span class="number">2</span>);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span>(line==<span class="keyword">null</span>)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							KeyedMessage&lt;String, String&gt; data = <span class="keyword">new</span> KeyedMessage&lt;String, String&gt;(topic,partitionKey,line);</span><br><span class="line">							producer.send(data);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							reader.close();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					file2.delete();</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"目录不存在!"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    producer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">Kafka Documentation</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+Producer+Example" target="_blank" rel="external">0.8.0 Producer Example</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka的简单介绍]]></title>
      <url>http://wangzzu.github.io/2015/11/14/The-Introduce-of-Kafka/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是简单地把Kafka的背景，基础知识和应用场景介绍一下，算是一篇入门的文章。</p>
<h2 id="1-kafka介绍"><a href="#1-kafka介绍" class="headerlink" title="1.kafka介绍"></a>1.kafka介绍</h2><p>关于kafka入门的文章最好的就莫过于kafka的<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">官方文档</a>了，这上面对kafka的定义是：</p>
<blockquote>
<p>Kafka is a distributed, partitioned, replicated commit log service. It provides the functionality of a messaging system, but with a unique design.</p>
</blockquote>
<p>kafka是一个分布式的，可分区的，可备份的日志提交服务，它使用独特的设计实现了一个消息系统的功能。</p>
<p>到底kafka使用什么独特的设计可以让它在消息处理领域独占鳌头呢？这就涉及到kafka的内部机制，这些我会在后续的文章中向大家慢慢介绍，这里先介绍一下kafka集群的基本结构和kafka的一些专业术语。</p>
<h3 id="1-1-kafka集群的基本架构"><a href="#1-1-kafka集群的基本架构" class="headerlink" title="1.1.kafka集群的基本架构"></a>1.1.kafka集群的基本架构</h3><p>一个典型的kafka集群架构如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/kafka.png" alt="kafka"></p>
<p>kafka集群常用的场景就是，producer把日志信息推送（push）到broker节点上，然后consumer（可以是写入到hdfs或者其他的一些应用）再从broker拉取（pull）信息。kafka的push&amp;pull机制如下图所示，具体的这样设计的原因我会在后续的文章中进行介绍。</p>
<p><img src="/images/2015-11-14-kafka-introduce/pull.png" alt="pull"></p>
<p>作为一个message system，kafka遵循了传统的方式，选择由kafka的producer向broker push信息，而consumer从broker pull信息。kafka的consumer之所以没有采用push模式，主要是因为push模式很难适应速率不同的consumer，因为消息发送速率是由broker决定的。push模式的目标就是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞，而pull模式则可以根据consumer的消费能力以适当的速率消费message。</p>
<h3 id="1-2-专业术语"><a href="#1-2-专业术语" class="headerlink" title="1.2.专业术语"></a>1.2.专业术语</h3><p>kafka使用的一些主要的专业术语：</p>
<ul>
<li><strong>Topic</strong>：特指Kafka处理的消息源的不同分类，其实也可以理解为对不同消息源的区分的一个标识；</li>
<li><strong>Partition</strong>：Topic物理上的分组，一个topic可以设置为多个partition，每个partition都是一个有序的队列，partition中的每条消息都会被分配一个有序的id（offset）；</li>
<li><strong>Message</strong>：消息，是通信的基本单位，每个producer可以向一个topic（主题）发送一些消息；</li>
<li><strong>Producers</strong>：消息和数据生产者，向Kafka的一个topic发送消息的过程叫做producers（producer可以选择向topic哪一个partition发送数据）。</li>
<li><strong>Consumers</strong>：消息和数据消费者，接收topics并处理其发布的消息的过程叫做consumer，同一个topic的数据可以被多个consumer接收；</li>
<li><strong>Broker</strong>：缓存代理，Kafka集群中的一台或多台服务器统称为broker。</li>
</ul>
<p>理解了上述概念之后，再来看kafka就容易了。</p>
<h3 id="1-3-kafka的应用场景"><a href="#1-3-kafka的应用场景" class="headerlink" title="1.3.kafka的应用场景"></a>1.3.kafka的应用场景</h3><p>Kafka主要用于处理流式数据。流式数据在web网站应用中非常常见，这些数据包括网站的pv、用户访问了什么内容，搜索了什么内容等。这些数据通常以日志的形式记录下来，然后每隔一段时间进行一次统计处理。Kafka的作用类似于缓存，能够很好地处理实时和离线应用。</p>
<h2 id="2-组件详解"><a href="#2-组件详解" class="headerlink" title="2.组件详解"></a>2.组件详解</h2><h3 id="2-1-topic"><a href="#2-1-topic" class="headerlink" title="2.1.topic"></a>2.1.topic</h3><p>正如前面介绍的，topic是kafka发送消息的一个标识，一般以目录的形式存在，对于一个有三个partition的topic而言，它日志信息结构大概如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/log.png" alt="log"></p>
<p>每一个partition实际上都是一个有序的，不可变的消息序列，producer发送到broker的消息会写入到相应的partition目录下，每个partition都会有一个有序的id（<code>offset</code>），这个offset确定这个消息在partition中的具体位置。</p>
<p>举一个例子，我们在一个kafka集群中建立的名为<code>wangzzu</code>，partition数为3的topic，kafka就会在broker的<code>/tmp/kafka-logs</code>（目录可以修改，可参考我<a href="http://wangzzu.github.io/2015/11/13/kafka-install/">kafka集群安装与配置</a>）新建三个目录，这里我们直接指定将三个partition建立在同一个broker上，如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/topic.png" alt="topic"></p>
<p>当启动producer程序时，就会向kafka集群发送信息，而kafka就会把中间信息存储在这三个目录下，具体的发送方式和消息存储结构会在以后的文章中介绍。</p>
<h3 id="2-2-producer"><a href="#2-2-producer" class="headerlink" title="2.2.producer"></a>2.2.producer</h3><p>producer这部分相比较而言，是比较简单的，就是把消息发送给它所选择的topic，也可以具体指定发给这个topic的哪个一个partition，否则producer就会使用<code>hashing-based partitioner</code>来决定发送到哪个partition，这个问题还是需要多说一些，之前我在测试kafka速度的时候就遇到了这个问题，当我们增加broker的数量时，kafka的发送速度并没有线性增加，最后发现就是因为这个原因，没有指明发送数据到哪个partition，具体的解释我就引用官网<a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ" target="_blank" rel="external">WIKI</a>中给出回答：</p>
<blockquote>
<p>In Kafka producer, a partition key can be specified to indicate the destination partition of the message. By default, a hashing-based partitioner is used to determine the partition id given the key, and people can use customized partitioners also.<br>To reduce # of open sockets, in 0.8.0(<a href="https://issues.apache.org/jira/browse/KAFKA-1017" target="_blank" rel="external">High number of open file handles in 0.8 producer</a>), when the partitioning key is not specified or null, a producer will pick a random partition and stick to it for some time (default is 10 mins) before switching to another one. So, if there are fewer producers than partitions, at a given point of time, some partitions may not receive any data. To alleviate this problem, one can either reduce the metadata refresh interval or specify a message key and a customized random partitioner. For more detail see <a href="http://mail-archives.apache.org/mod_mbox/kafka-dev/201310.mbox/%3CCAFbh0Q0aVh%2Bvqxfy7H-%2BMnRFBt6BnyoZk1LWBoMspwSmTqUKMg%40mail.gmail.com%3E" target="_blank" rel="external">this thread</a></p>
</blockquote>
<h3 id="2-3-consumer"><a href="#2-3-consumer" class="headerlink" title="2.3.consumer"></a>2.3.consumer</h3><p>这里的consumer部分，主要是以<code>High Level Consumer API</code>为例。</p>
<p>consumer是一个抽象的概念，调用<code>Consumer API</code>的程序都可以称作为一个consumer，它从broker端订阅某个topic的消息。如果只有一个consumer的话，该topic（可能含有多个partition）下所有消息都会被这个consumer接收。但是在分布式的环境中，我们可能会遇到这样一种情景，对于一个有多个partition的topic，我们希望启动多个consumer去消费这些partition（如果发送速度较快，一个consumer是无法消费完的），并且要求topic的一条消息只能发给其中一个consumer，不希望这些conusmer出现重复接收一条消息的情况。对于这种情况，我们应该怎么办呢？kafka给我们提供了一种机制，可以很好来适应这种情况，那就是<strong>consumer group</strong>（当然也可以应用在第一种情况，实际上，如果只有一个consumer时，是不需要指定consumer group，这时kafka会自动给这个consumer生成一个group名）。</p>
<p>在调用conusmer API时，一般都会指定一个consumer group，该group订阅的topic的每一条消息都发送到这个group的某一台机器上。借用官网一张图来详细介绍一下这种情况，假如kafka集群有两台broker，集群上有一个topic，它有4个partition，partition 0和1在broker1上，partition 2和3在broker2上，这时有两个consumer group同时订阅这个topic，其中一个group有2个consumer，另一个consumer有4个consumer，则它们的订阅消息情况如下图所示：</p>
<p><img src="/images/2015-11-14-kafka-introduce/consumerGroup.png" alt="consumerGroup"></p>
<p>因为group A只有两个consumer，所以一个consumer会消费两个partition；而group B有4个consumer，一个consumer会去消费一个partition。这里要注意的是，kafka可以保证一个<strong>partition内的数据是有序的</strong>，所以group B中的consumer收到的数据是可以保证有序的，但是Group A中的consumer就无法保证了。</p>
<p>group读取topic，<strong>partition分配</strong>机制是：</p>
<ul>
<li>如果group中的consumer数小于topic中的partition数，那么group中的consumer就会消费多个partition；</li>
<li>如果group中的consumer数等于topic中的partition数，那么group中的一个consumer就会消费topic中的一个partition；</li>
<li>如果group中的consumer数大于topic中的partition数，那么group中就会有一部分的consumer处于空闲状态。</li>
</ul>
<h2 id="3-kafka的简单使用"><a href="#3-kafka的简单使用" class="headerlink" title="3.kafka的简单使用"></a>3.kafka的简单使用</h2><p>这部分是利用kafka自带的<code>kafka-console-producer.sh</code>和<code>kafka-console-consumer.sh</code>来发送和接收消息，而具体如何调用 kafka  API使用kafka会在后续的文章中介绍。</p>
<p>首先要启动kafka和建立topic，可参考<a href="http://wangzzu.github.io/2015/05/20/KafkaOrder/">Kafka常用的一些命令</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/kafka-server-start.sh config/server.properties &amp; <span class="comment">#启动kafka，并且使用nohup将日志输出到当前目录的nohup.out中，使用&amp;后台运行</span></span><br></pre></td></tr></table></figure>
<p>topic还接着使用<code>wangzzu</code>（建立topic命令参考2.1中的图片），下面开启<code>kafka-console-producer.sh</code>并发送几条消息</p>
<p><img src="/images/2015-11-14-kafka-introduce/produce.png" alt="producer"></p>
<p>然后，启动<code>kafka-console-consumer.sh</code>就可以收到我们发送的这几条消息</p>
<p><img src="/images/2015-11-14-kafka-introduce/consumer.png" alt="consumer"></p>
<p>这个就是kafka的最简单的使用情况了。</p>
<p>希望这篇文章对初学者能有所帮助（<code>转载请注明出处</code>）。</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">Kafka官方文档</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka集群的安装与配置]]></title>
      <url>http://wangzzu.github.io/2015/11/13/kafka-install/</url>
      <content type="html"><![CDATA[<p>使用过kafka的童鞋应该都知道，kafka的安装是比较简单的，尤其跟hadoop，storm这类相比。本文就主要介绍kafka集群的安装和配置方法。</p>
<h2 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h2><p>本人在安装kafka集群时，因为集群已经配置好了CDH的环境，在CDH环境安装kafka就变得非常简单。集群环境如下：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java版本</td>
<td>java 1.6.0_31</td>
</tr>
<tr>
<td>Linux版本</td>
<td>Centos 6.6</td>
</tr>
<tr>
<td>CDH版本</td>
<td>CDH 5.4.0</td>
</tr>
<tr>
<td>zookeeper版本</td>
<td>Zookeeper 3.4.5-cdh5.4.0</td>
</tr>
</tbody>
</table>
<h2 id="2-安装Kafka"><a href="#2-安装Kafka" class="headerlink" title="2.安装Kafka"></a>2.安装Kafka</h2><h3 id="2-1-下载相应kafka版本"><a href="#2-1-下载相应kafka版本" class="headerlink" title="2.1.下载相应kafka版本"></a>2.1.下载相应kafka版本</h3><p>这是kafka的<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="external">官网Download地址</a>，我们安装的kafka版本为<code>2.10-0.8.1.1</code>，就选择下载<code>kafka-0.8.1.1-src.tgz</code>.</p>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2.安装"></a>2.2.安装</h3><p>这个安装就是解压对应的压缩文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka-0.8.1.1-src.tgz</span><br></pre></td></tr></table></figure>
<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>这里的配置主要是<code>broker</code>的配置，修改<code>kafka-0.8.1.1-src/config/server.properties</code>文件，<a href="http://kafka.apache.org/08/configuration.html" target="_blank" rel="external">参数意义</a>,重要的设置参数，在下面的配置文件我们会加以说明：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements. See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License. You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment"># see kafka.server.KafkaConfig for additional details and defaults</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Server Basics #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class="line">broker.id=1    <span class="comment">#broker的标识，id为正数，kafka集群内不能重复，推荐用ip地址设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Socket Server Settings #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The port the socket server listens on</span></span><br><span class="line">port=9092     <span class="comment">#侦听的相应端口，Producer或Consumer在此端口建立连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hostname the broker will bind to. If not set, the server will bind to all interfaces</span></span><br><span class="line">host.name=192.168.80.1     <span class="comment">#指定broke绑定的网络接口地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hostname the broker will advertise to producers and consumers. If not set, it uses the</span></span><br><span class="line"><span class="comment"># value for "host.name" if configured. Otherwise, it will use the value returned from</span></span><br><span class="line"><span class="comment"># java.net.InetAddress.getCanonicalHostName().</span></span><br><span class="line"><span class="comment">#advertised.host.name=&lt;hostname routable by clients&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The port to publish to ZooKeeper for clients to use. If this is not set,</span></span><br><span class="line"><span class="comment"># it will publish the same port that the broker binds to.</span></span><br><span class="line"><span class="comment">#advertised.port=&lt;port accessible by clients&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of threads handling network requests</span></span><br><span class="line">num.network.threads=2 <span class="comment">#处理网络请求的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of threads doing disk I/O</span></span><br><span class="line">num.io.threads=8 <span class="comment">#磁盘读写的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class="line">socket.send.buffer.bytes=1048576 <span class="comment">#节点端口使用的发送缓存大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class="line">socket.receive.buffer.bytes=1048576 <span class="comment">#节点端口使用的接收缓存大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class="line">socket.request.max.bytes=104857600 <span class="comment">#节点端口能接收一个请求的最大大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Basics #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A comma seperated list of directories under which to store log files</span></span><br><span class="line"></span><br><span class="line">log.dirs=/tmp/kafka-logs,/hdfs/data1/tmp/kafka-logs    <span class="comment">#日志文件保存的目录，一台broker上可以设置多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default number of log partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="comment"># parallelism for consumption, but this will also result in more files across</span></span><br><span class="line"><span class="comment"># the brokers.</span></span><br><span class="line">num.partitions=2     <span class="comment">#此值越大将导致各个Server上同步时需要的延迟越高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Flush Policy #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Messages are immediately written to the filesystem but by default we only fsync() to sync</span></span><br><span class="line"><span class="comment"># the OS cache lazily. The following configurations control the flush of data to disk. </span></span><br><span class="line"><span class="comment"># There are a few important trade-offs here:</span></span><br><span class="line"><span class="comment"># 1. Durability: Unflushed data may be lost if you are not using replication.</span></span><br><span class="line"><span class="comment"># 2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.</span></span><br><span class="line"><span class="comment"># 3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to exceessive seeks. </span></span><br><span class="line"><span class="comment"># The settings below allow one to configure the flush policy to flush data after a period of time or</span></span><br><span class="line"><span class="comment"># every N messages (or both). This can be done globally and overridden on a per-topic basis.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of messages to accept before forcing a flush of data to disk</span></span><br><span class="line"><span class="comment">#log.flush.interval.messages=10000     #partition的buffer中，message达到阈值时，将flush到磁盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum amount of time a message can sit in a log before we force a flush</span></span><br><span class="line"><span class="comment">#log.flush.interval.ms=1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Retention Policy #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following configurations control the disposal of log segments. The policy can</span></span><br><span class="line"><span class="comment"># be set to delete segments after a period of time, or after a given size has accumulated.</span></span><br><span class="line"><span class="comment"># A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span></span><br><span class="line"><span class="comment"># from the end of the log.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></span><br><span class="line">log.retention.hours=168 <span class="comment">#信息保存时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span></span><br><span class="line"><span class="comment"># segments don't drop below log.retention.bytes.</span></span><br><span class="line"><span class="comment">#log.retention.bytes=1073741824 #logs目录下保存信息的最大大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line">log.segment.bytes=536870912 <span class="comment">#保存的一个segment file的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according </span></span><br><span class="line"><span class="comment"># to the retention policies</span></span><br><span class="line">log.retention.check.interval.ms=60000</span><br><span class="line"></span><br><span class="line"><span class="comment"># By default the log cleaner is disabled and the log retention policy will default to just delete segments after their retention expires.</span></span><br><span class="line"><span class="comment"># If log.cleaner.enable=true is set the cleaner will be enabled and individual logs can then be marked for log compaction.</span></span><br><span class="line">log.cleaner.enable=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Zookeeper #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Zookeeper connection string (see zookeeper docs for details).</span></span><br><span class="line"><span class="comment"># This is a comma separated host:port pairs, each corresponding to a zk</span></span><br><span class="line"><span class="comment"># server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".</span></span><br><span class="line"><span class="comment"># You can also append an optional chroot string to the urls to specify the</span></span><br><span class="line"><span class="comment"># root directory for all kafka znodes.</span></span><br><span class="line">zookeeper.connect=192.168.80.1:2181,192.168.80.2:2181,192.168.80.3:2181     <span class="comment">#连接的zookeeper对应的IP和端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Timeout in ms for connecting to zookeeper</span></span><br><span class="line">zookeeper.connection.timeout.ms=1000000</span><br></pre></td></tr></table></figure>
<p>配置好以上信息之后，单个节点的kafka环境也就配置好了，同样的我们在其他节点也这样安装配置即可。</p>
<p>最后，再补充一点，经过我之前对kafka速度的测试，发现这上面<code>Socket Server Settings</code>下的几个参数对于速度的提升比较重要（<a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">brokerconfigs</a>），根据服务器的配置情况，可以适当增大一些参数，比如我用的集群可以设置为下面这样：</p>
<ul>
<li><code>num.network.threads</code>:20</li>
<li><code>num.io.threads</code>:8</li>
<li><code>socket.send.buffer.bytes</code>:1048576</li>
<li><code>socket.receive.buffer.bytes</code>:1073741824</li>
<li><code>socket.request.max.buytes</code>:1073741824</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[收藏的一些不错的网站]]></title>
      <url>http://wangzzu.github.io/2015/11/12/WebsiteCollect/</url>
      <content type="html"><![CDATA[<p>这篇主要是整理一下自己书签里收藏一些个人感觉不错的网站，它们大都是一些比较小众的网站，因为是技术出身，推荐的很大一部分网站可能都是偏技术类的，这点希望大家能够理解～。</p>
<h3 id="1-在线教育"><a href="#1-在线教育" class="headerlink" title="1.在线教育"></a>1.在线教育</h3><p>主要是推荐一些我自己用过的，感觉对自己比较有帮助的一些网站，当然免费是最好的了。</p>
<ul>
<li><a href="https://www.shiyanlou.com/courses/" target="_blank" rel="external">实验楼</a>，这个感觉非常不错，尤其是学习一些技术的基础课程很nice；</li>
<li><a href="http://mooc.guokr.com/" target="_blank" rel="external">MOOC学院</a>，果壳的MOOC学院，课程种类和数量很多，对于想学习国外课程的童鞋来说，简直是福利啊；</li>
<li><a href="http://www.jikexueyuan.com/" target="_blank" rel="external">极客学院</a>，这种类型的网站就有很多了，比如：小象学院等，名气也比较大而且它们的模式基本上也一样，就不再推荐别的了；</li>
<li><a href="http://www.julyedu.com/" target="_blank" rel="external">七月算法</a>，July的公司，不说其它的，他的博客对于找工作还是很有帮助的；</li>
<li><a href="http://www.yiihuu.com/" target="_blank" rel="external">翼虎网</a>，一家关于做创意方面的教学网站；</li>
</ul>
<h3 id="2-视频"><a href="#2-视频" class="headerlink" title="2.视频"></a>2.视频</h3><p>这些视频的内容比较广泛，应该会涉及到方方面面，都是些很不错的节目，看完也会给人很多的感触。</p>
<ul>
<li><a href="https://www.ted.com/" target="_blank" rel="external">TED</a>，这个大家应该都知道；</li>
<li><a href="http://yixi.tv/" target="_blank" rel="external">一席</a>，这个就是中国版的TED，也是在我看到了方励那个讲座之后才听说的；</li>
<li><a href="http://www.soku.com/search_video/q_%E6%99%93%E6%9D%BE%E5%A5%87%E8%B0%88?f=1&amp;kb=04126020kv41000__%E6%99%93%E6%9D%BE%E5%A5%87%E8%B0%AD&amp;_rp=1447420045800KOVWIn&amp;_rp=1447420045800KOVWIn" target="_blank" rel="external">晓松奇谈</a>，高晓松的一些节目（奇葩说）质量都挺不错，没事的时候可以看一下，也可以弄成音频跑步的时候听听；</li>
<li><a href="http://v.youku.com/v_show/id_XMTM4NDM1ODM3Ng==.html" target="_blank" rel="external">罗辑思维</a>，当然也有很多人并不推荐这个节目，说有些地方根本没有任何逻辑性，可是我个人感觉这个节目还是不错的，可能因为我读书比较少的原因，这个节目确实也弥补了我很多知识的空白；</li>
<li><a href="http://www.iqiyi.com/a_19rrhadzit.html" target="_blank" rel="external">奇葩说</a>，一个网上辩论节目，个人感觉很不错的一个节目，尤其是对于接受了国内那么多年应试教育的童鞋而言，对于一个问题它能让你看到不一样的视角，而不是只有一个正确答案；</li>
</ul>
<h3 id="3-技术网站"><a href="#3-技术网站" class="headerlink" title="3.技术网站"></a>3.技术网站</h3><p>这类网站都是互联网技术类方面的，内容比较多而且大都是偏基础性的资料，很多都是一些基础知识文档，对于不熟悉某方面但又希望去了解的人还是很不错的选择。</p>
<ul>
<li><a href="http://www.w3school.com.cn/" target="_blank" rel="external">w3school</a>，这个大都是前端方面的，很多技术文档，偏基础；</li>
<li><a href="http://www.runoob.com/" target="_blank" rel="external">菜鸟教程</a>，不仅仅涉及前端，大都也是些基础类的文档；</li>
<li><a href="http://www.yiibai.com/" target="_blank" rel="external">易百教程</a>，大都也是些基础类的文档；</li>
<li><a href="http://www.kancloud.cn/explore" target="_blank" rel="external">看云</a>，最近才发现网站，资料还挺多的，很多都是新型技术，这个网站相当于是把那些厚厚技术类书籍提炼一下，出了一本精简版的，对于我这种不喜欢看厚书的人来说简直是福利；</li>
<li><a href="http://lxw1234.com/" target="_blank" rel="external">lxw的大数据田地</a>，这个专门针对于大数据技术学习的网站；</li>
<li><a href="http://toutiao.io/" target="_blank" rel="external">开发者头条</a>，这里面的文章质量还是蛮高的；</li>
<li><a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a>，很好的网站；</li>
<li><a href="http://wiki.jikexueyuan.com/#all-project" target="_blank" rel="external">极客学院的WIKI</a>，有很多的技术学习文档；</li>
<li><a href="http://www.slideshare.net/" target="_blank" rel="external">slideshare</a>，这个是的PPT分享的网站，主要是偏技术类，一般一些国际会议或者一些公司技术分享的PPT都会在这上面向大家分享；</li>
</ul>
<p>一些公司或个人的博客：</p>
<ul>
<li><a href="http://dongxicheng.org/" target="_blank" rel="external">董的博客</a>，偏大数据这一块，业内挺出名的；</li>
<li><a href="http://www.ibm.com/developerworks/cn/topics/" target="_blank" rel="external">IBM博客</a>，IBM的官方博客，质量很高，推荐；</li>
<li><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术团队博客</a>，涉及到了很多大数据方面的架构和设计;</li>
<li><a href="http://jm.taobao.org/" target="_blank" rel="external">阿里巴巴中间件博客</a>，有很多关于阿里消息中间件RocketMQ的一些内容，以及其它的一些分布式技术；</li>
</ul>
<h3 id="4-旅行类"><a href="#4-旅行类" class="headerlink" title="4.旅行类"></a>4.旅行类</h3><ul>
<li><a href="http://www.clctrip.com/" target="_blank" rel="external">草履虫旅行</a>，这个俱乐部，每周都会有一些短途的旅行，假期会有远途旅行，不过这个活动出发地仅仅局限在北京，其他城市还没有涉足，真心很赞的一个俱乐部；</li>
<li><a href="http://www.yerenbang.org/forum.php" target="_blank" rel="external">野人帮</a>，这个主要是对准户外过夜那种，比较有挑战性；</li>
<li><a href="http://www.iqingyi.com/" target="_blank" rel="external">青驿</a>，看别人推荐，还没有用过，感觉还不错。</li>
</ul>
<h3 id="5-媒体内容类"><a href="#5-媒体内容类" class="headerlink" title="5.媒体内容类"></a>5.媒体内容类</h3><ul>
<li><a href="http://36kr.com/" target="_blank" rel="external">36氪</a>，第一个肯定要推荐36氪，毕竟创始人是我们校友，主要是一些关于互联网圈内发生的一些事情，也经常会介绍一些国内外新兴的互联网创业公司；</li>
<li><a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a>，可以使用Markdown写文章，大家通过文章来交流一些想法；</li>
<li><a href="http://dataunion.org/" target="_blank" rel="external">数盟</a>，暂时把它归于媒体类吧，偏程序员的媒体网站。</li>
</ul>
<h3 id="其他的一些小网站："><a href="#其他的一些小网站：" class="headerlink" title="其他的一些小网站："></a>其他的一些小网站：</h3><ul>
<li><a href="http://www.zimuku.net/" target="_blank" rel="external">字幕库</a>，美剧迷的福利；</li>
<li><a href="http://www.haitou.cc/" target="_blank" rel="external">海投网</a>，可查看高校工作宣讲会；</li>
<li><a href="https://www.zybuluo.com/" target="_blank" rel="external">作业部落</a>，Markdown的在线编辑器；</li>
<li><a href="https://selfstore.io/" target="_blank" rel="external">selfstore</a>，专门由专业人士翻译国外技术书籍，然后买电子书的网站，当然，它们的翻译质量确实比某些出版社高太多了；</li>
<li><a href="http://www.meetup.com/" target="_blank" rel="external">Meetup</a>，通过Meetup可以组织一些专业的线下活动，像Spark这种线下技术分享活动都会在这上面发布；</li>
</ul>
<blockquote>
<p>注：本文为会一直保持更新，只要遇到一些比较优秀的网站，都会更新到这篇博客上。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java的几个基本类型之间的相互转换]]></title>
      <url>http://wangzzu.github.io/2015/10/27/TheTransformOfJava/</url>
      <content type="html"><![CDATA[<p>之前在写java程序的时候，经常会遇到很多的需要需要转换基础数据类型的情况，然后我就一直去记录这些情况，今天做了一下总结，当然转换的方法肯定不止我写的这些，有的我可能只会写其中的一种，以后再遇到其他的情况的话，我会慢慢来补充，希望这篇文章会对大家能有所帮助。</p>
<hr>
<h2 id="1-String的转换"><a href="#1-String的转换" class="headerlink" title="1.String的转换"></a>1.String的转换</h2><p>首先介绍一下String类型的转换，一般遇到的情况可能会有以下几种：Strng转int，String转long，String转byte数组，String转float，下面主要介绍这四种情况。</p>
<h3 id="1-1-String转int"><a href="#1-1-String转int" class="headerlink" title="1.1.String转int"></a>1.1.String转int</h3><p>把String类型转换为int类型，常用的有以下三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String number = <span class="string">"123456"</span>;</span><br><span class="line">		<span class="keyword">int</span> num1 = Integer.parseInt(number);<span class="comment">//使用Integer的parseInt方法</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="keyword">new</span> Integer(number);<span class="comment">//强制转换</span></span><br><span class="line">		<span class="keyword">int</span> num3 = Integer.valueOf(number).intValue();<span class="comment">//先转Integer类型，再调用intValue()转为int</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-String转long"><a href="#1-2-String转long" class="headerlink" title="1.2.String转long"></a>1.2.String转long</h3><p>把String类型转换为long类型的方法跟上面的方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToLong</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String number = <span class="string">"1234567890"</span>;</span><br><span class="line">		<span class="keyword">long</span> num1 = Long.parseLong(number);<span class="comment">//调用Long类型的parseLong方法</span></span><br><span class="line">		<span class="keyword">long</span> num2 = <span class="keyword">new</span> Long(number);<span class="comment">//强制转换</span></span><br><span class="line">		<span class="keyword">long</span> num3 = Long.valueOf(number).longValue();<span class="comment">//先转换Long类型，再使用longValue方法转为long</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-String转float"><a href="#1-3-String转float" class="headerlink" title="1.3.String转float"></a>1.3.String转float</h3><p>把String类型转换为float类型的方法也跟上面的类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToFloat</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String number = <span class="string">"1234.202"</span>;</span><br><span class="line">		<span class="keyword">float</span> num1 = Float.parseFloat(number);<span class="comment">//调用Float的parseFloat方法</span></span><br><span class="line">		<span class="keyword">float</span> num2 = <span class="keyword">new</span> Float(number);<span class="comment">//强制转换</span></span><br><span class="line">		<span class="keyword">float</span> num3 = Float.valueOf(number).floatValue();<span class="comment">//先转为Float类型再使用floatValue转为float</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-String转byte"><a href="#1-4-String转byte" class="headerlink" title="1.4.String转byte[]"></a>1.4.String转byte[]</h3><p>String类型转byte数组方法一般使用String类自带的<code>getBytes()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToByte</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] num = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">200</span>];</span><br><span class="line">		String number = <span class="string">"1234567890"</span>;</span><br><span class="line">		num = number.getBytes();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里补充一个path类型转换为String类型的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fileName=path.getFileName().toString();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-long类型转换"><a href="#2-long类型转换" class="headerlink" title="2.long类型转换"></a>2.long类型转换</h2><p>long类型的转换，这一部分用的情况也很多，下面介绍几种常见的情况。</p>
<h3 id="2-1-long转String"><a href="#2-1-long转String" class="headerlink" title="2.1.long转String"></a>2.1.long转String</h3><p>long类型转String类型，这里主要介绍三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToString</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> number = <span class="number">1234567890l</span>;</span><br><span class="line">		String num1 = Long.toString(number);<span class="comment">//Long的tostring方法</span></span><br><span class="line">		String num2 = String.valueOf(number);<span class="comment">//使用String的valueOf方法</span></span><br><span class="line">		String num3 = <span class="string">""</span> + number;<span class="comment">//这个应该属于强制转换吧</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-long转int"><a href="#2-2-long转int" class="headerlink" title="2.2.long转int"></a>2.2.long转int</h3><p>long类型转换为int类型，这里也主要介绍三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> number = <span class="number">121121121l</span>;</span><br><span class="line">		<span class="keyword">int</span> num1 = (<span class="keyword">int</span>) number;<span class="comment">// 强制类型转换</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="keyword">new</span> Long(number).intValue();<span class="comment">// 调用intValue方法</span></span><br><span class="line">		<span class="keyword">int</span> num3 = Integer.parseInt(String.valueOf(number));<span class="comment">// 先把long转换位字符串String，然后转换为Integer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-long与byte数组的相互转换"><a href="#2-3-long与byte数组的相互转换" class="headerlink" title="2.3.long与byte数组的相互转换"></a>2.3.long与byte数组的相互转换</h3><p>一直都感觉byte数组转换比较繁琐，这里也不再叙述，我就给出一篇别人的博客让大家作为参考吧，这里面byte数组与多种数据类型的转换——<a href="http://blog.csdn.net/cshichao/article/details/9813973" target="_blank" rel="external"> java Byte和各数据类型(short,int,long,float,double)之间的转换</a></p>
<hr>
<h2 id="3-int类型的转换"><a href="#3-int类型的转换" class="headerlink" title="3.int类型的转换"></a>3.int类型的转换</h2><p>int类型的转换也是我们经常使用的情况，下面也主要介绍几种常见的情况。</p>
<h3 id="3-1-int转String"><a href="#3-1-int转String" class="headerlink" title="3.1.int转String"></a>3.1.int转String</h3><p>int类型转换为String类型与long转String的类似，一般也有以下三种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToString</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">121121</span>;</span><br><span class="line">		String num1 = Integer.toString(number);<span class="comment">//使用Integer的toString方法</span></span><br><span class="line">		String num2 = String.valueOf(number);<span class="comment">//使用String的valueOf方法</span></span><br><span class="line">		String num3 = <span class="string">""</span> + number;<span class="comment">//也是强制转换吧</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-int与Byte的相互转换"><a href="#3-2-int与Byte的相互转换" class="headerlink" title="3.2.int与Byte的相互转换"></a>3.2.int与Byte的相互转换</h3><p>关于int类型与byte[]数组的转换，一般情况下，我们使用条件都是在这里转换过来，在另外一个地方就要转换回来，这里介绍两种int与byte数组互相转换的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int类型转换为byte[]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByteArray(<span class="keyword">int</span> i) &#123;</span><br><span class="line">	<span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">	<span class="comment">// 由高位到低位</span></span><br><span class="line">	result[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	result[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	result[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">	result[<span class="number">3</span>] = (<span class="keyword">byte</span>) (i &amp; <span class="number">0xFF</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//byte数组转换为int类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteArrayToInt</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 由高位到低位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> shift = (<span class="number">4</span> - <span class="number">1</span> - i) * <span class="number">8</span>;</span><br><span class="line">		value += (bytes[i] &amp; <span class="number">0x000000FF</span>) &lt;&lt; shift;<span class="comment">// 往高位游</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int类型转换为byte[]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByteArray(<span class="keyword">int</span> x) &#123;</span><br><span class="line">	<span class="keyword">byte</span>[] bb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">	bb[<span class="number">3</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">24</span>);</span><br><span class="line">	bb[<span class="number">2</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	bb[<span class="number">1</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	bb[<span class="number">0</span>] = (<span class="keyword">byte</span>) (x &gt;&gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//byte数组转换为int类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteArrayToInt</span><span class="params">(<span class="keyword">byte</span>[] bb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">int</span>) ((((bb[<span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) | ((bb[<span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) | ((bb[<span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>) | ((bb[<span class="number">0</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-int转long"><a href="#3-3-int转long" class="headerlink" title="3.3.int转long"></a>3.3.int转long</h3><p>int类型转换为long类型的情况并不是大多，这里主要接收几种转换方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToLong</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">123111</span>;</span><br><span class="line">		<span class="keyword">long</span> num1 = (<span class="keyword">long</span>) number;<span class="comment">//强制</span></span><br><span class="line">		<span class="keyword">long</span> num2 = Long.parseLong(<span class="keyword">new</span> Integer(number).toString());<span class="comment">//先转String再进行转换</span></span><br><span class="line">		<span class="keyword">long</span> num3 = Long.valueOf(number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-int转Interger"><a href="#3-4-int转Interger" class="headerlink" title="3.4.int转Interger"></a>3.4.int转Interger</h3><p>int类型转换为Interger类型的情况，我是基本上每怎么遇到过，在这里也上网查询一些资料找到了两种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntToInterge</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">123456</span>;</span><br><span class="line">		Integer num1 = Integer.valueOf(number);</span><br><span class="line">		Integer num2 = <span class="keyword">new</span> Integer(number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-byte数组的转换"><a href="#4-byte数组的转换" class="headerlink" title="4.byte数组的转换"></a>4.byte数组的转换</h2><p>关于byte数组的转换，上面有几个都是它们只见相互转换的，所以这里就不再介绍那么多，只介绍一个byte数组转换String类型的方法，其他的类型可以通过String类型再进行转换。</p>
<p>byte数组转String类型的方法经常用的可能就是下面这种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToString</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] number = <span class="string">"121121"</span>.getBytes();</span><br><span class="line">		String num1 = <span class="keyword">new</span> String(number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>最后简单补充以下Java基本数据类型的一些知识：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>类名称</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>4字节</td>
<td>Interger</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>Short</td>
<td>-32768 ～ 32767</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>Long</td>
<td>-9223372036854775808 ～ 9223372036854775807</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>Byte</td>
<td>-128 ～ 127</td>
</tr>
<tr>
<td>float</td>
<td>4字节</td>
<td>Float</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>Double</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java关键字之final和static]]></title>
      <url>http://wangzzu.github.io/2015/10/17/The-keyword-of-java/</url>
      <content type="html"><![CDATA[<p>本篇文章主要对java中经常使用<code>final</code>和<code>static</code>两个关键字的用法做一下总结，主要参考了《Java编程思想》和网上的一些博客。</p>
<h2 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h2><p>final应该是程序中经常使用的关键字之一，final关键字使用的对象是：类、方法、变量，下面依次介绍这几种使用final的情况。</p>
<h3 id="1-1-final类"><a href="#1-1-final类" class="headerlink" title="1.1.final类"></a>1.1.final类</h3><p>当一个类声明为final类，也就证明这个类是不能够被继承的，即禁止继承，因此final类的成员方法是没有机会被覆盖的，这个final类的功能是完整的。在Java中有很多类是final的，如String、Interger以及其他包装类。</p>
<p>final类的好处：</p>
<ul>
<li>不可变类有很多的好处，它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的开销。</li>
</ul>
<p>下面是final类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonalLoan</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title">PersonalLoan</span></span>&#123; <span class="comment">//compilation error: cannot inherit from final class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-final方法"><a href="#1-2-final方法" class="headerlink" title="1.2.final方法"></a>1.2.final方法</h3><p>如果一个类不允许其子类覆盖某个方法，即不能被重写，则可以把这个方法声明为final方法。（类中所有的private方法都隐式的指定为final）。</p>
<p>使用final方法的原因：</p>
<ul>
<li>方法锁定，防止任何继承类修改它的含义，确保在继承中使方法行为保持不变且不被覆盖；</li>
<li>效率，将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转化为内嵌调用（相当于在编译的时候已经静态绑定，不需要在运行时再动态绑定）。</li>
</ul>
<p>下面是final方法的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"f1"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"f2"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Test1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        System.out.println(<span class="string">"Test1父类方法f1被覆盖!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Test2 t=<span class="keyword">new</span> Test2(); </span><br><span class="line">        t.f1(); <span class="comment">//子类重写父类的方法 </span></span><br><span class="line">        t.f2(); <span class="comment">//调用从父类继承过来的final方法 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-final变量"><a href="#1-3-final变量" class="headerlink" title="1.3.final变量"></a>1.3.final变量</h3><p>程序中有些数据的恒定不变是很有必要的，比如：</p>
<ul>
<li>一个永不改变的<strong>编译时常量</strong>；</li>
<li>一个在运行时被初始化的值，而在程序的后面不希望它被改变。</li>
</ul>
<p>这种类型的变量只能被赋值一次，一旦被赋值之后，就不能够再更改了。 </p>
<p>有几点要注意的：</p>
<ul>
<li>一个既是static又是final的域只占据一段不能改变的存储空间，一般用大写来表示；</li>
<li>final使数值恒定不变，而当用于对象时，final使引用恒定不变（一旦引用指向一个对象，就无法再把它改为指向另一个对象）；</li>
</ul>
<p>final变量的好处：</p>
<ul>
<li>提高性能，JVM和Java应用程序都会缓存final变量；</li>
<li>final变量可以在安全的在多线程环境下进行共享，而不需要额外的开销。</li>
</ul>
<p>下面是final类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PI = <span class="number">3.14</span>;<span class="comment">//这个变量是只读的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT; <span class="comment">//final空白,必须在初始化对象的时候赋初值 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">        INIT = x; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Test t = <span class="keyword">new</span> Test(<span class="number">2</span>); </span><br><span class="line">        <span class="comment">//t.PI=3.1415;//出错,final变量的值一旦给定就无法改变 </span></span><br><span class="line">        System.out.println(t.INIT); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>final数据还有另外三个比较特殊的情况：与static合用，空白final和final参数。</p>
<h4 id="1-3-1-static-final"><a href="#1-3-1-static-final" class="headerlink" title="1.3.1.static final"></a>1.3.1.static final</h4><p>一个既是static又是final的域只占据一段不能改变的存储空间:</p>
<ul>
<li>对于变量，它表示一旦给定就不可更改，并且可以通过类名直接访问（使用大写和下划线命名）；</li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。</li>
</ul>
<h4 id="1-3-2-空白final"><a href="#1-3-2-空白final" class="headerlink" title="1.3.2.空白final"></a>1.3.2.空白final</h4><p>从上面的例子中，我们就可以看到<code>空白final</code>的使用方法，它指的是：被声明为final但又未给出初值的域。无论什么情况下，编译器都确保空白final在使用前必须被初始化（在域的定义处或每个构造器中用表达式对final赋值）。</p>
<h4 id="1-3-3-final参数"><a href="#1-3-3-final参数" class="headerlink" title="1.3.3.final参数"></a>1.3.3.final参数</h4><p>Java时允许在参数列表的声明中以声明的方式将参数指明为final。</p>
<ul>
<li>当对象被指明为final时，这就意味着我们无法在方法中更改参数引用所指向的对象。</li>
<li>当基本类型的参数被指明为final时，我们可以读取参数但是无法修改参数。</li>
</ul>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4.总结"></a>1.4.总结</h3><p>总结一下final关键字的一些重要特点：</p>
<ol>
<li>本地变量必须在声明的时候赋值；</li>
<li>在匿名类中所有变量都必须是final变量；</li>
<li>final方法不能被重写；</li>
<li>final类不能被继承；</li>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误；</li>
<li>接口中声明的所有变量本身是final的；</li>
<li>final方法在编译阶段绑定，称为静态绑定(static binding)；</li>
<li>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容；</li>
</ol>
<h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h2><p>通常来说，当我们创建类时，就是在描述那个类的外观与行为。除非使用<code>new</code>创建那个类的对象，否则并为获得任何对象。执行<code>new</code>来创建对象时，数据存储空间才被分配，其方法才能被外界调用。</p>
<p>但是，试想在一种情况下，我们只想为某一特定区域分配单一存储空间，而不用去考虑它创建了多少对象。另一种情形是，希望某个方法不与包含它的类的任何对象联系在一起，也就是说，即使没有创建对象，也能够调用这个方法。这就是<code>static</code>关键字主要使用的地方。</p>
<p>static一个很重要的用途就是多个对象可以共享一些存储空间，static关键字使用的对象为：类、方法、代码块。</p>
<p>static关键字有几个需要注意的地方：</p>
<ul>
<li>被static修饰的成员变量和成员方法<strong>独立</strong>于该类的任何对象，它不依赖类的特定实例，被类的所有实例共享；</li>
<li>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例<strong>共享</strong>同一个static变量；</li>
<li>static变量前可以有private修饰，这时就不能使用类名直接访问流。</li>
</ul>
<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：</p>
<ul>
<li>ClassName.Varibale</li>
<li>ClassName.method()</li>
</ul>
<h3 id="2-1-static变量"><a href="#2-1-static变量" class="headerlink" title="2.1.static变量"></a>2.1.static变量</h3><p>按照是否静态的对类成员变量进行分类可分两种：</p>
<ul>
<li>一种是被static修饰的变量，叫<strong>静态变量</strong>或<strong>类变量</strong>；</li>
<li>另一种是没有被static修饰的变量，叫<strong>实例变量</strong>。</li>
</ul>
<p>两者的区别是：</p>
<ul>
<li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问；</li>
<li>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</li>
</ul>
<p>一般在在对象之间使用共享值和方便访问变量时，就会去使用静态变量。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.j=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test.i="</span> + Test.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-static方法"><a href="#2-2-static方法" class="headerlink" title="2.2.static方法"></a>2.2.static方法</h3><p><strong>静态方法</strong>也叫做<strong>类方法</strong>，静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用<code>this</code>和<code>super</code>关键字，不能直接访问所属类的实例变量和实例方法（因为它们是与具体方法关联的），只能访问所属类的静态成员变量和成员方法。</p>
<p>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>Java中很多使用static的方法，如Math类中所有的方法都是静态的，而一般类内部的static方法也是方便其它类对该方法的调用。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = Test.sum(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"10+10="</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-static代码块"><a href="#2-3-static代码块" class="headerlink" title="2.3.static代码块"></a>2.3.static代码块</h3><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"Now in static block."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test method: i="</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test.i="</span> + Test.i);</span><br><span class="line">        <span class="keyword">new</span> Test().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4.总结"></a>2.4.总结</h3><p>下面是关于静态变量和静态方法的一些总结：</p>
<ul>
<li>一个类的静态方法只能访问其静态变量；</li>
<li>一个类的静态方法不能够直接调用非静态方法；</li>
<li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>静态方法不能被非静态方法覆盖；</li>
<li>构造方法不允许声明为 static 的；</li>
<li>局部变量不能使用static修饰。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven之仓库配置]]></title>
      <url>http://wangzzu.github.io/2015/10/14/the-setting-of-repertory-maven/</url>
      <content type="html"><![CDATA[<p>徐晓斌的《Maven实战》，实在是一本很不错的书，本文也是在我读过这本书的仓库一章后，根据自己的经验，做的一个总结。</p>
<h2 id="1-仓库"><a href="#1-仓库" class="headerlink" title="1.仓库"></a>1.仓库</h2><p>先介绍一个构件和仓库的概念。</p>
<p>构件：在Maven中，任何一个依赖、插件或者项目构建的输出，都是一个构件。如：依赖包是一个构件、编译的插件是一个构件；</p>
<p>仓库：Maven在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p>
<h2 id="2-仓库的分类"><a href="#2-仓库的分类" class="headerlink" title="2.仓库的分类"></a>2.仓库的分类</h2><p>对于Maven来说，仓库只有两种：本地仓库和远程仓库。但是还有一类特殊的远程仓库——私服，它是在局域网内架设的私有仓库服务器。</p>
<p><img src="/images/2015-10-14-theSettingOfRepertoryOfMaven/repertory.jpg" alt="Repertory"></p>
<h3 id="2-1-本地仓库"><a href="#2-1-本地仓库" class="headerlink" title="2.1.本地仓库"></a>2.1.本地仓库</h3><h4 id="2-1-1-配置"><a href="#2-1-1-配置" class="headerlink" title="2.1.1.配置"></a>2.1.1.配置</h4><p>默认情况下，不管在window还是在Linux系统上，每一个用户在自己用户目录下都有一个<code>.m2/repository/</code>的仓库目录。</p>
<p>当然，Maven是允许我们自定义本地仓库目录地址的，在Maven的安装目录的<code>conf</code>下找到<code>settings.xml</code>文件，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/home/matt/maven/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样本地仓库就被设置在<code>/home/matt/maven/repo</code>下。</p>
<p>关于<code>settings.xml</code>文件，有一点需要注意的是：</p>
<ul>
<li><code>$M2_HOME/conf/settings.xml</code>：是全局范围的，整台机器上的所有用户都会直接受到该配置的影响；</li>
<li><code>~/.m2/settings.xml</code>：是用户范围的，只有当前用户才会受到该配置的影响（若目录下没有此文件，可将上个<code>settings.xml</code>复制一份到本目录下再去修改）。</li>
</ul>
<h4 id="2-1-2-本地项目安装到本地仓库"><a href="#2-1-2-本地项目安装到本地仓库" class="headerlink" title="2.1.2.本地项目安装到本地仓库"></a>2.1.2.本地项目安装到本地仓库</h4><p>在这个本地项目下，执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clwan install</span><br></pre></td></tr></table></figure>
<p>Install插件的install目标就是将项目的构建输出文件安装到本地仓库。</p>
<h3 id="2-2-中央仓库"><a href="#2-2-中央仓库" class="headerlink" title="2.2.中央仓库"></a>2.2.中央仓库</h3><p>最原始的本地仓库是空的，Maven的安装文件中自带了中央仓库的配置。在Maven的安装目录下的<code>/lib/maven-model-builder-XX.jar</code>的jar包中的<code>pom-4.0.0.xml</code>中有如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置了默认的中央仓库，所有的Maven项目都会继承这个POM，所以都会有这个配置。该中央仓库包含了世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证等。上面的<code>snapshots</code>元素的子元素<code>enabled</code>设置为<code>false</code>，表示不会从该中央仓库下载快照版本的构件。</p>
<h3 id="2-3-私服"><a href="#2-3-私服" class="headerlink" title="2.3.私服"></a>2.3.私服</h3><p>私服是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网用户使用。当Maven需要下载构件的时候，他从私服请求，如果私服不存在当前构件，则从外部的远程仓库缓存到私服上之后再为Maven的下载请求提供服务，此外一些无法从外部仓库下载到的构件也可以手工上传到私服上供大家使用。</p>
<p>它主要有以下几个优点：</p>
<ul>
<li>节省外网带宽；</li>
<li>加速Maven构建；</li>
<li>部署第三方构件（尤其是组织内部的构件）；</li>
<li>提高稳定性，增强控制；</li>
<li>降低中央仓库的负荷。</li>
</ul>
<h2 id="3-远程仓库的配置"><a href="#3-远程仓库的配置" class="headerlink" title="3.远程仓库的配置"></a>3.远程仓库的配置</h2><h3 id="3-1-配置远程仓库"><a href="#3-1-配置远程仓库" class="headerlink" title="3.1.配置远程仓库"></a>3.1.配置远程仓库</h3><p>很多情况下，默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另外一个远程仓库，可以在<code>POM</code>进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于配置远程仓库，主要有以下几点需要注意：</p>
<ul>
<li>任何仓库的<code>id</code>必须唯一；</li>
<li>在<code>repositories</code>元素下，可以使用<code>repository</code>子元素声明一个或者多个远程仓库；</li>
<li>元素<code>releases</code>和<code>snapshots</code>用来控制Maven对于发布版本构件和快照版构件的下载。</li>
</ul>
<p>对于元素<code>releases</code>和<code>snapshots</code>，除了<code>enabled</code>子元素外，它们还包括另外两个子元素<code>updatePolicy</code>和<code>checksumPolicy</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>updatePolicy</code>:配置Maven从远程仓库检查更新的频率，默认值是<code>daily</code>（<code>never</code>：从不检查、<code>always</code>：每次构建时都检查、<code>interval：X</code>：每隔X分钟检查一次）；</li>
<li><code>checksumPolicy</code>：配置Maven检验和文件的策略，默认值为<code>warn</code>：在执行构建时输出警告信息（<code>ignore</code>：完全忽略校验和错误，<code>fail</code>：遇到校验和错误就让构建失败）。</li>
</ul>
<h3 id="3-2-认证"><a href="#3-2-认证" class="headerlink" title="3.2.认证"></a>3.2.认证</h3><p>有些远程仓库基于安全的考虑需要提供认证信息才可以访问。配置认证信息需要在<code>settings.xml</code>文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>deploymentRepo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>repouser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>repopwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Maven使用<code>settings.xml</code>文件中并不显而易见的<code>server</code>子元素配置仓库认证信息。</p>
<p>配置认证信息和配置仓库信息不同，仓库信息可以这配置在<code>POM</code>文件中，但是认证信息必须配置在<code>settings.xml</code>文件中。、</p>
<h3 id="3-3-部署到远程仓库"><a href="#3-3-部署到远程仓库" class="headerlink" title="3.3.部署到远程仓库"></a>3.3.部署到远程仓库</h3><p>Maven除了对项目进行编译，测试和打包之外，还能将项目部署到仓库中，首先编辑POM文件添加<code>distributionManagementy</code>元素。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Releases Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Snapshots Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>distributionManagement</code>包含<code>repository</code>和<code>snapshotRepository</code>子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。这两个元素下都需要配置<code>id</code>、<code>name</code>和<code>url</code>，<code>id</code>为该仓库的唯一标识，<code>name</code>是为了方便人阅读，关键的<code>url</code>表示该仓库的地址。</p>
<p>配置正确后，执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure>
<p>Maven就会将构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本仓库地址，否则就部署到发布版本仓库地址。</p>
<h2 id="4-镜像"><a href="#4-镜像" class="headerlink" title="4.镜像"></a>4.镜像</h2><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的镜像。配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirrorId<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>repositoryId<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://my.repository.com/repo/path<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;mirrorOf&gt; central&lt;/mirrorOf&gt;</code>表示只为central仓库做镜像，如果想为所有的仓库做镜像那么可以改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>mirrorOf</code>可选择的配置主要有以下几个：</p>
<ul>
<li><strong>*</strong>：配置所有的仓库；</li>
<li><strong>external*</strong>：匹配所有的远程仓库，使用localhost的除外，使用<code>file：//</code>的除外；</li>
<li><strong>repo1,repo2</strong>：匹配仓库repo1和repo2，使用逗号分隔多个仓库；</li>
<li><strong>*,!repo1</strong>：匹配所有的远程仓库除了repo1.</li>
</ul>
<h2 id="5-仓库的内部机制"><a href="#5-仓库的内部机制" class="headerlink" title="5.仓库的内部机制"></a>5.仓库的内部机制</h2><p>这一部分主要介绍一下Maven仓库的三个内部机制，一个仓库的布局方式，两个是仓库的解析机制和更新策略。</p>
<h3 id="5-1-仓库的布局方式"><a href="#5-1-仓库的布局方式" class="headerlink" title="5.1.仓库的布局方式"></a>5.1.仓库的布局方式</h3><p>任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven仓库布局方式。例如，<code>log4j:log4j:1.2.15</code>这一依赖，其对应的仓库路径为<code>log4j/log4j/1.2.15/log4j-1.2.15.jar</code>。该路径与坐标的大致对应关系为<code>groupId/artifactId/version/artifactId-version.packaging</code>。</p>
<p>具体的可以参看Maven参考布局的源码部分，也可以参考<a href="http://www.amazon.cn/Maven%E5%AE%9E%E6%88%98-%E8%AE%B8%E6%99%93%E6%96%8C/dp/B004CLZ7BA/ref=sr_1_1?ie=UTF8&amp;qid=1444818561&amp;sr=8-1&amp;keywords=maven%E5%AE%9E%E6%88%98" target="_blank" rel="external">《Maven实战》</a>P76-77。</p>
<h3 id="5-2-仓库解析依赖机制"><a href="#5-2-仓库解析依赖机制" class="headerlink" title="5.2. 仓库解析依赖机制"></a>5.2. 仓库解析依赖机制</h3><p>Maven是根据怎么的跪着从仓库解析并使用依赖构件的呢？</p>
<p>当本地仓库没有依赖构件的时候，Maven会自动从远程仓库下载相应构件，当依赖版本为快照版本的时候，Maven会自动找到最新的快照。详细的依赖机制为：</p>
<ol>
<li>当依赖的范围是<code>system</code>的时候，Maven直接从本地文件系统解析构件；</li>
<li>根据依赖坐标计算仓库路径后，尝试直接从本地仓库寻找构件，如果发现相应构件，则解析成功;</li>
<li>在本地仓库不存在相应构件的情况下，如果依赖的版本是显式的发布版本构件，如：1.2，2.1等，则遍历所有的远程仓库，发现后，下载并解析使用;</li>
<li>如果依赖的版本是<code>RELEASE</code>或者<code>LATEST</code>，则基于更新策略读取所有远程仓库的元数据<code>groupId/artifactId/mavenmetadata.xml</code>，将其与本地仓库的对应元数据合并后，计算出<code>RELEASE</code>或者<code>LATEST</code>真实的值，然后基于这个真实的值检查本地和远程仓库，如步骤1和3;</li>
<li>如果依赖的版本是<code>SNAPSHOT</code>，则基于更新策略读取所有远程仓库的元数据<code>groupId/artifactId/version/mavenmetadata.xml</code>，将其与本地仓库的对应元数据合并后，得到最新快照版本的值，然后基于该值检查本地仓库，或者从远程仓库下载;</li>
<li>.如果最后解析得到的构件版本是时间戳格式的快照，如：<code>1.4-20091104.121450-121</code>,则复制其时间戳格式的文件到非时间戳格式，如：<code>SNAPSHOT</code>，并使用该非时间戳格式的构件.</li>
</ol>
<p>当依赖的版本不明晰的时候，如:<code>RELEASE</code>,<code>LATEST</code>和<code>SNAPSHOT</code>，Maven就需要基于更新远程仓库的更新策略来检查更新。</p>
<h3 id="5-3-仓库的更新策略"><a href="#5-3-仓库的更新策略" class="headerlink" title="5.3.仓库的更新策略"></a>5.3.仓库的更新策略</h3><p>主要有以下几个配置与Maven仓库的更新有关：</p>
<ul>
<li>首先是<code>&lt;releases&gt;&lt;enabled&gt;</code>和<code>&lt;snapshots&gt;&lt;enabled&gt;</code>，只有仓库开启了对于发布版本的支持时，才能访问该仓库的发布版本构件信息，对于快照版本也是同理；</li>
<li>其次要注意的是<br><code>&lt;releases&gt;</code>和<code>&lt;snapshots&gt;</code>的子元素<code>&lt;updatePolicy&gt;</code>，该元素配置了检查更新的频率;</li>
<li>最后，用户还可以从命令行加入参数<code>-U</code>,强制检查更新，使用参数后，Maven就会忽略<code>&lt;updatePolicy&gt;</code>的配置。</li>
</ul>
<p>当Maven检查完更新策略，并决定检查依赖更新的时候，就需要检查仓库元数据<code>maven-metadata.xml</code>。前面提到的<code>RELEASE</code>和<code>LATEST</code>版本，它们分别对应了仓库中存在的该构件的最新发布版本和最新版本(包含快照)，而这两个”最新”是基于<code>groupId/artifactId/maven-metadata.xml</code>计算出来的，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">latest</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">latest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">release</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">release</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">versions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在XML文件列出了仓库中存在的该构件所有可用的版本，同时<code>latest</code>元素指向了这些版本中最新的那个版本。而<code>release</code>元素指向了这些版本中最新的发布版本。Maven通过合并多个远程仓库及本地仓库的元数据，就能计算出基于所有仓库的<code>latest</code>和<code>release</code>分别是什么，然后再解析具体的构件。</p>
<p> 有几点需要的注意的：</p>
<ul>
<li>在依赖声明中使用LATEST和RELEASE是<strong>不推荐</strong>的做法（因为Maven随时都可能解析到不同的构件，可能今天<code>LATEST</code>是<code>1.3.6</code>,明天就成了<code>1.4.0-SNAPSHOT</code>了，且Maven不会明确告诉用户这样的变化）；</li>
<li>Maven3不再支持在插件配置中使用<code>LATEST</code>和<code>RELEASE</code>；</li>
<li>如果不设置插件版本，其效果就和RELEASE一样，Maven只会解析最新的发布版本构件；</li>
</ul>
<p>当依赖的版本设为<strong>快照版本</strong>的时候，Maven也需要检查更新，这时，Maven会检查仓库元数据<code>groupId/artifactId/version/maven-metadata.xml</code>，这个与发布版本的有所不同。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20091214.221414<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>13<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20091214221558<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该xml文件的<code>snapshot</code>元素包含<code>timestamp</code>和<code>buildNumber</code>两个子元素，分别代表了这一快照的时间戳和构建号，基于这两个元素可以得到该仓库中此快照的最新构件版本实际为<code>1.4.2-20091213.221414-13</code>。通过合并所有远程仓库和本地仓库的元数据，Maven就能知道所有仓库中该构件的最新快照。 </p>
<h2 id="6-快照版本"><a href="#6-快照版本" class="headerlink" title="6.快照版本"></a>6.快照版本</h2><p>在Maven的世界中，任何一个项目或者构件都必须有自己的版本。版本的值可能是<code>1.0.0,1.3-alpha-4</code>,<code>2.0</code>,<code>2.1-SNAPSHOT</code>或者<code>2.1-20091214.221414-13</code>。其中，<code>1.0</code>、<code>1.3-alpha-4</code>和<code>2.0</code>是稳定的发布版本，而<code>2.1-SNAPSHOT</code>和<code>2.1-20091214.221414-13</code>是不稳定的快照版本。</p>
<p>快照版本对于Maven来说是很重要的，下面举个例子来说明。小张在开发模块A的2.1版本，该版本还未正式发布，与模块A一同开发的还有模块B，它由小张的同事季MM开发，B的功能依赖于A。在开发的过程中，小张需要经常将自己最新的构建输出，交给季MM，供她开发和集成调试，问题是，这个工作如何进行呢？如果不停更新版本2.1.1、2.1.2、2.1.3….呢？首先，小张和季MM两人都需要频繁地更改POM，如果有更多的模块依赖于模块A，就会涉及更多的POM更改；其次，大量的版本其实仅仅包含了微小的差异，这样也会造成为版本号的滥用。</p>
<p>Maven的快照版本机制就是为了解决上述问题。在该例中，小张只需要将模块A的版本设定为<code>2.1-SNAPSHOT</code>，然后发布到私服中，在发布的过程中，Maven会自动为构件打上时间戳。比如:<code>2.1-20091214.221414-13</code>就表示2009年12月14日 22点14分14秒的第13次快照。有了该时间戳，Maven就能随时找到仓库中该构件<code>2.1-SNAPSHOT</code>版本最新的文件。这时，季MM配置对于模块A的<code>2.1-SNAPSHOT</code>版本的依赖，当她构件模块B的时候，Maven会自动从仓库中检查模块A的<code>2.1-SNAPSHOT</code>的最新构件，当发现有更新时便进行下载。默认情况下，Maven每天检查一次更新(由仓库配置的<code>updatePolicy</code>控制)，用户也可以使用命令行-U参数强制让Maven检查更新，如：<code>mvn clean install-U</code>。</p>
<p>基于快照版本机制，小张在构建成功之后才能将构件部署至仓库，而季MM可以完全不用考虑模块A的构建，并且她能确保随时得到模块A的最新可用的快照构件，而这一切都不需要额外的手工操作。</p>
<p>最后要注意的是，快照版本一般只在组织内部的项目或模块间依赖使用，而且项目不应该依赖于组织外部的快照版本依赖（因为快照版本是不稳定的）。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10476794.html" target="_blank" rel="external">Maven实战</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven之依赖]]></title>
      <url>http://wangzzu.github.io/2015/10/11/the-dependency-of-maven/</url>
      <content type="html"><![CDATA[<p>最近一年做项目时，一直在与Maven打交道，在网上也看了很多的博客，也看了《Maven实战》这本书，感觉受益匪浅，但是过一段时间很多东西也会忘记，所以就想根据这本书上看到的，还有自己的经验，写几篇Maven的博客来梳理一下核心点。</p>
<h3 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h3><p>一个依赖包的声明主要包括以下的一些元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>...<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>...<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先简单介绍一下上面这几个元素的意义：</p>
<ul>
<li><strong>groupId、artifactId和version</strong>：依赖的基本坐标（这个本文就不在讲解了）；</li>
<li><strong>type</strong>：依赖的类型，对应于项目坐标定义的<code>packaging</code>，一般情况下，该元素不用声明，默认为<code>jar</code>；</li>
<li><strong>scope</strong>：依赖的范围；</li>
<li><strong>optional</strong>：标记依赖是否可选；</li>
<li><strong>exclusions</strong>：用来排除传递性依赖。</li>
</ul>
<h3 id="2-依赖范围"><a href="#2-依赖范围" class="headerlink" title="2.依赖范围"></a>2.依赖范围</h3><p>Maven依赖的依赖范围有一下几类，分别是：<code>compile</code>、<code>test</code>、<code>provided</code>、<code>runtime</code>、<code>system</code>和<code>import</code>。</p>
<p>之所以Maven会有这么多依赖范围，主要原因是：Maven在编译项目主代码的时候需要使用一套classpath；Maven在编译和执行测试的时候会使用另外一套classpath；Maven实际运行项目的时候，又会使用一套classpath。依赖范围就是用来控制依赖与这三种classpath的关系。</p>
<ul>
<li><strong>compile</strong>：编译依赖范围（默认值），对编译、测试、运行三种classpath都有效；</li>
<li><strong>test</strong>：测试依赖范围，只对测试classpath有效；</li>
<li><strong>provided</strong>：已提供依赖范围，对编译和测试classpath有效；</li>
<li><strong>runtime</strong>：运行时依赖范围，对测试和运行classpath有效；</li>
<li><strong>system</strong>：系统依赖范围，以provided依赖范围一致，但使用<code>system</code>范围时必须通过<code>systemPath</code>元素显示地制定依赖文件的路径；</li>
<li><strong>import</strong>：导入依赖范围，该依赖不会对三种classpath产生实际影响。</li>
</ul>
<p>使用<code>system</code>的例子如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collection<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>system<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>用表格的形式表示以上依赖如下所示：</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>对编译有效</th>
<th>对测试有效</th>
<th>对运行有效</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="3-传递性依赖"><a href="#3-传递性依赖" class="headerlink" title="3.传递性依赖"></a>3.传递性依赖</h3><p><strong>传递性依赖</strong>：比如一个项目<code>account-email</code>有一个compile范围的<code>spring-core</code>依赖，而<code>spring-core</code>有一个compile范围的<code>commons-logging</code>的依赖，那么<code>commons-logging</code>就会成为<code>account-email</code>的compile范围依赖，<code>commons-logging</code>是<code>account-email</code>的一个传递性依赖。</p>
<p>有个传递性依赖机制，在使用<code>account-email</code>的时候就不用去考虑它依赖了什么。明白了传递性依赖，下面就看一下传递性依赖和依赖范围的关系，假设A依赖于B，B依赖于C，我们说A对于B是第一直接依赖范围，B对于C是第二依赖范围，A对于C是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围，如下表所示，最左边一列表示第一直接依赖，最上面一行表示第二直接依赖范围，中间的结果就表示传递性依赖范围。</p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>compile</th>
<th>test</th>
<th>provided</th>
<th>runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>compile</td>
<td>——</td>
<td>——</td>
<td>runtime</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>——</td>
<td>——</td>
<td>test</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>——</td>
<td>provided</td>
<td>provided</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>——</td>
<td>——</td>
<td>runtime</td>
</tr>
</tbody>
</table>
<p>仔细观察上表，我们可以得到以下结论：</p>
<ol>
<li>当第二直接依赖的范围是<code>compile</code>的时候，传递性依赖的范围与第一直接依赖的范围一致；</li>
<li>当第二直接依赖的范围是<code>test</code>的时候，依赖不会得以传递；</li>
<li>当第二直接依赖的范围是<code>provided</code>的时候，只传递第一直接依赖范围也为<code>provided</code>的依赖，且传递性依赖的范围同样为<code>provided</code>；</li>
<li>当第二直接依赖的范围是<code>runtime</code>的时候，传递性依赖的范围与第一依赖的范围一致，但<code>compile</code>例外，此时传递性依赖的范围为<code>runtime</code>。</li>
</ol>
<h3 id="4-依赖调解"><a href="#4-依赖调解" class="headerlink" title="4.依赖调解"></a>4.依赖调解</h3><p>假如项目A有这样的依赖的关系：A-&gt;B-&gt;C-&gt;X(1.0)，A-&gt;D-&gt;X(2.0)，X是A的传递性依赖，但是有两条路径，那么应该选择哪个版本呢？</p>
<p>Maven依赖调解（Dependency Mediation）有两个原则：</p>
<ul>
<li>路径最近者优先；</li>
<li>第一声明者优先（路径相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用）；</li>
</ul>
<h3 id="5-可选依赖"><a href="#5-可选依赖" class="headerlink" title="5.可选依赖"></a>5.可选依赖</h3><p>假设有这样一个依赖关系，项目A依赖与项目B，项目B依赖于项目X和Y，B对于X和Y的依赖都是可选依赖：A-&gt;B、B-&gt;X（可选）、B-&gt;Y（可选），那么X、Y就是A的传递性依赖。然而，由于这里X、Y是可选依赖，依赖将不会得以传递。</p>
<p>下面是设置可选依赖的一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;<span class="name">optional</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，不应该使用可选依赖，使用可选依赖的原因是某一个项目实现了多个特性，在面向对象设计中，有个单一职责性原则，意指一个类应该只有一项职责，而不应该糅合太多的功能。当项目需要某个依赖的可选依赖，可以显式地声明这一依赖。</p>
<h3 id="6-排除依赖"><a href="#6-排除依赖" class="headerlink" title="6.排除依赖"></a>6.排除依赖</h3><p>有时候会出现这样的情况，你的<code>Hibernate</code>依赖于<code>Sun JTA API</code>，但是因为版权原因，<code>Sun JTA API</code>并不在仓库中。而<code>Apache Geronimo</code>项目有一个对应的实现。这时你就可以排除<code>Sun JAT API</code>，再声明<code>Geronimo</code>的<code>JTA API</code>实现，见代码清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 排除对project-c的依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-c<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，项目A依赖于项目B，但是由于一些原因，不想引入传递性依赖C，而是自己显示声明对于项目C1.0.0版本的依赖。代码中用exclusions元素可以包含<strong>多个</strong>exclusion子元素。需要注意的是声明exslusion的时候只需要groupId和artifactId，而<strong>不需要</strong>version元素(Maven解析后的依赖中，不可能出现groupId和artifactId相同，但是version不同的两个依赖)。</p>
<h3 id="7-归类依赖"><a href="#7-归类依赖" class="headerlink" title="7.归类依赖"></a>7.归类依赖</h3><p>当我们使用<code>Spring Framework</code>的依赖时，会有许多依赖，如：<code>spring-core:2.5.6.org</code>、<code>org.springframework:spring-beans:2.5.6</code>等，它们是来自同一项目下的不同模块。它们依赖的版本都是相同时，当需要升级<code>Spring Framework</code>时，这些依赖的版本都会一起升级。这时候我们可以用Maven属性的方式来定义一个名为<code>springframework.version</code>的属性，让所有的<code>spring framework</code>子模块都引用它。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--类似于设置一个变量--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>3.1.2.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样当我们需要升级的时候,就只需要改属性值<code>springframework.version</code>就可以了。</p>
<h3 id="8-优化依赖"><a href="#8-优化依赖" class="headerlink" title="8.优化依赖"></a>8.优化依赖</h3><ul>
<li>使用<code>mvn dependency:list</code>命令可以查看项目已解析的依赖;</li>
<li>使用<code>mvn dependency:tree</code>命令可以查看项目构成的依赖树;</li>
<li>使用<code>mvn dependency:analyze</code>命令可以分析当前项目的依赖.</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://item.jd.com/10476794.html" target="_blank" rel="external">Maven实战</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Travel to Qinghai Lake | 青海湖骑行之旅]]></title>
      <url>http://wangzzu.github.io/2015/09/27/Travel-to-Qinghai-Lake/</url>
      <content type="html"><![CDATA[<p>今年的青海湖之行给我留下了很美好的回忆，骑行的过程确实是很艰辛，但我们每一个人都按照原计划到达了终点。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一段姑且算作是前言吧。首先介绍一下我自己，我是北京邮电大学的一名研究生，17年毕业，也就是明年就要找工作了，所以今年暑假是学生时代的最后一个暑假了。之前我一直有个梦想，就是想来一段说走就走的旅行，刚好在朋友圈看到朋友经常骑行的照片，而我也是一个热爱旅行、热爱骑行的人，所以就想来一段短期的旅行————去青海。</p>
<h3 id="骑行前准备"><a href="#骑行前准备" class="headerlink" title="骑行前准备"></a>骑行前准备</h3><p>骑行前第一步首先是招募小伙伴。我就在学校的BBS上，发了一个帖子（征友去青海骑行），第二天帖子居然被坛友们顶上了十大，有很多小伙伴跟我的想法一样，我们就很顺利组建了我们的青海小分队。</p>
<p>先说一下骑行的需要的准备的东西：</p>
<ol>
<li><strong>骑行相关物件</strong>：头盔、雨衣、驮包、码表、硅胶坐垫、束带、简易修理工具和备胎（一辆一车至少准备一个备胎，也可以多带几个，大不了回来的时再还给老板）这些都是可以在租车的地方一并租到（顺便宣传一下我们选的<a href="http://www.qinghaihu.cc/ShowGongyi?id=164" target="_blank" rel="external">圣湖单车俱乐部</a>）,墨镜、骑行手套、魔术巾等(这些是需要自己准备的);</li>
<li><strong>旅行需要物品</strong>：现金、手机、身份证、银行卡、相机、充电宝、电池充电器、水壶（喝热水）、报纸、防晒霜（必备，尽量买防晒级别偏高的那种）等；</li>
<li><strong>衣物</strong>：8月不算特别冷，但早晚温差大，下雨的时候还是很冷的，建议带上一件厚外套（冲锋衣）；</li>
<li><strong>药品</strong>：抗高反的药（高原安，红景天）、感冒药（连花清瘟等）、发烧（感康）、肠胃药（藿香正气液）、外伤药（创可贴）等；</li>
<li><strong>食物</strong>：士力架、巧克力、棒棒糖（补充糖），自己再带一些想吃的零食用来路上补充能量。另外，也可以带好充足的食物中午时候找一块合适的地方来野餐。</li>
</ol>
<p>旅行途中需要注意的：</p>
<ul>
<li>一定保护自己的脸，首先涂上防晒霜，然后用魔术巾遮住脸，再带个鸭舌帽，最后套头盔，这样是最保险的（不担心自己脸被晒黑的小伙伴就不用这样了哈）；</li>
<li>以防万一会下雨，可能提前在淘宝买双防雨鞋，要不下雨的话，鞋会被雨水打湿的；</li>
<li>人多的话，住宿可以提前定，不过到地方再找住宿也没事，镇上青旅特别多； </li>
</ul>
<p>下面就是我们当时骑行的行程：</p>
<h3 id="8-1西宁集合"><a href="#8-1西宁集合" class="headerlink" title="8.1西宁集合"></a>8.1西宁集合</h3><p>1号上午11点半，我们一行七人在西宁火车站集合，那天西宁的天气很不错的，一出火车站就能感受到青海火辣的太阳，外面很晒，防晒霜是绝对对不能缺少的。我们人员到齐之后，就在火车站旁边一家川菜馆饭店吃的中饭，大家第一次是在一起吃饭，吃得还是满开心的，那里东西也不贵。下面一张是在西宁汽车站旁边的拍得一张照片。<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-station.jpg" alt="station"></p>
<p>吃完中饭后，我们就在火车站旁边的汽车站买了去西海镇的汽车票，每人25元（回西宁的时候买的票是23一个人，不知道这怎么回事）。西宁汽车站给我的第一印象就是，很安静。虽然汽车站等车的人很多，但是相比于内地而言，非常安静，可能在内地吵杂的环境呆的时间长了，有点不习惯吧。</p>
<p>下午达到西海镇时，西海镇给我的第一个印象是：这是一个很干净、很宁静的一个小镇，西海镇就像是江浙那边的小镇一样，感觉挺发达的，可能因为这是环青海湖的起点，旅游业很发达吧。下面这张是雨后的西海镇：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XihaiZhen.jpg" alt="XihaiZhen"></p>
<p>我们在西海镇下了车之后，我们就跟提前联系的圣湖自行车俱乐部打了电话，老板特别热情，老板娘亲自开车来车站接我们。在俱乐部休整一下之后，基本上就到了该吃晚饭的时间，我们就去了老板推荐的西宁肥牛烤肉去吃烤肉，那里烤肉吃着的确很爽，尤其烤羊排，都是大块的羊肉（烤羊排是80元/斤，有点小贵）。不幸的是在吃烤肉的时候，外面突然下起了暴雨，我们就只能在店里边聊天边吃饭了。暴雨下的快走的也快，等雨停的时候，我们准备赶紧回去，不过就那一会的暴雨，镇中心那一块已经全部被淹了，不得不感慨一下西海镇的水利系统（不过这个问题，貌似全国都一样）。青海的天气变化很快，暴雨过后，天气突然又转晴了。</p>
<p>西海肥牛烤肉的美食：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHFood.jpg" alt="XHFood"></p>
<p>雨后西海镇的镇中心：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHRain.jpg" alt="XHRain"></p>
<p>今天的花费：<br>中饭27，晚饭44，西海镇车费25，水6。</p>
<h3 id="8-2-DAY1-西海镇——江西沟（96-3km）"><a href="#8-2-DAY1-西海镇——江西沟（96-3km）" class="headerlink" title="8.2 DAY1.西海镇——江西沟（96.3km）"></a>8.2 DAY1.西海镇——江西沟（96.3km）</h3><p>今天应该整个行程最兴奋的一天，景色也相当的不错。早上起来我们整理好东西之后，就在西海镇随便找了一家早餐馆吃饭，早上每个早餐店人都很多，这里的早餐还算可以，跟后面的几天比，应该算是最好的，大概人均10块。吃完早饭，买了一些必需品之后（一定、一定、一定要买包<strong>夜用大包</strong>的卫生巾，在屁股上垫上一个，重要的事情说三遍，要不然屁股会非常、非常、非常疼），就向着我们的目标出发了。今天的风景还是很不错的，远处的山可以感受山在云上的感觉。今天天气也不算特别，中间还滴了点小雨。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-XHStart.jpg" alt="XHSart"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j6.jpg" alt="j6"></p>
<p>Notes：</p>
<ol>
<li>从西海镇出发时，有很多上下坡，下坡很多，也非常刺激，最高的速度可以达到50Km/h；</li>
<li>上午的话，路上可以看到沙漠、草原的景观，不过进去玩的话都是都要收费的；</li>
<li>在快要进入109国道的时候会看到另外一个湖，当地人们好像叫它叫小湖（名字记不太清楚了，大体意思就是比青海湖小的湖），周边有直接通到湖边的小路，不过进去要收费的，每个人10元。这里感觉没必要进去，第三天的时候去湖边应该最爽的，而且去的是真正的青海湖（不是小湖）旁边。</li>
<li>109国道车很多，不过在到二郎剑之前，路的右边一直有一条骑行专用的小路（感觉路上不是特别好，没有前面的路好走），在这条专用路上不必担心车辆的问题。这条小路上有很多专门提供给游客照相的油菜花地，同样进去的话每人10元，可以路边拍几张，当地人可能说你俩句，不过也没什么问题。第四天的时候也有油菜花，不过感觉第一天的油菜花地应该最漂亮的，应该油菜花前面就是湖。</li>
<li>至于过了二郎剑之后，小心点其实也没啥事。</li>
</ol>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh1.jpg" alt="qh1"></p>
<p>旁边的沙漠<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh2.jpg" alt="qh2"></p>
<p>远处的湖：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh3.jpg" alt="qh3"></p>
<p>青海湖的油菜花、很美的油菜花：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh4.jpg" alt="qh4"></p>
<p>骑行专用的小道：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh5.jpg" alt="qh5"></p>
<p>中饭我们是在109国道的丁字路口的一个蒙古包里解决的，我当时吃得是拉面，好像12块钱一碗，不过量很少，吃不饱，吃碗面之后就接着吃了自己带的一些饼干。下面是我们吃饭的那个蒙古包：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh6.jpg" alt="qh6"></p>
<p>下午五点到达江西沟之后，先到提前预定的青年旅舍（<a href="http://hotels.ctrip.com/hotel/1232070.html" target="_blank" rel="external">仓央嘉措青年旅舍</a>），感觉这个青旅一般般吧，我们住的是八人间，60元/人，不过是可以洗澡的。晚饭我们就在江西沟乡镇上找的一家，当时我们是在大众点评上找的，具体叫什么忘了，在那里我们点了牦牛肉（80元/斤）吃，饭菜还可以吧。吃完饭之后，我们就直接回去休息了，然后大概在八点多的时候，突然就开始下暴雨了，而且还下了冰雹，这种大雨在内地应该是很少见的。<br>下面是大块的牦牛肉：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-maoniurou.jpg" alt="maoniurou"></p>
<p>今天的花费：<br>早饭10，中饭14，晚饭47，水10，住宿60。</p>
<h3 id="8-3-Day2-江西沟——黑马河-（50-2km）"><a href="#8-3-Day2-江西沟——黑马河-（50-2km）" class="headerlink" title="8.3 Day2.江西沟——黑马河 （50.2km）"></a>8.3 Day2.江西沟——黑马河 （50.2km）</h3><p>今天是最悲催的一天，早上起来之后依然下着中雨。我们收拾完东西之后，等雨小一点的时候，就赶紧去吃了早饭，江西沟的早饭比较贵，平均一个人都快20了。等我们出发的时候，天气仍然是阴沉沉，还有点小雨，因为我们的行程之前已经全定好了，没有什么备选计划，所以我们打算冒雨前行了。穿上雨衣之后，我们就开始出发了，刚出发之后，就有一名队友的前胎被扎破了，那会雨已经下大了。因为我们没人会修自行车，我们就在路上向其他的骑友求救，骑友们都很热情，马上就有人停下来帮我们换胎了，前胎比较好换，看了一遍之后我们就学会了。修好之后，我们就开始出发，结果过了一会又有两位队友车胎被扎破了，一路上感觉都很曲折。而且这会基本上一直都是中雨，我们身上很鞋上都湿透了（提前在网上买双防雨鞋套非常有必要）。而且下雨骑车的时候尽量骑在白线以内，因为白线外很多小石子，特别容易扎破胎，所以只能占一点机动车车道了。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-Rain.jpg" alt="Rain"></p>
<p>骑到十一点多的时候，我们在路上补充了一些能量，感觉吃到这辈子最好吃的饼干、最好喝的热水、最好吃的士力架。补充完能量后，我们接着骑行，前方又遇到了大堵车，很多时候我们都是在推着自行车走的。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-traffic.jpg" alt="traffic"></p>
<p>中午13点的时候，终于到达了我们定的青旅，因为定的这个青旅离黑马河镇上还有四公里多，结果导致骑在最前面的学长，骑过头了，很悲催，就只能骑回来了。定的这个青旅是八人间65元/人（住蒙古包的话50元/人，蒙古包晚上比较冷，而且是地铺，没有60的住得舒服），名字叫做<a href="http://bnb.qunar.com/city/hainanzangzu/dt-7481/?citytag=hainanzangzu#fromDate=2015-08-02&amp;toDate=2015-08-03&amp;q=%E9%BB%91%E9%A9%AC%E6%B2%B3&amp;filterid=92179149-08a2-4cea-a564-1e83a5abae19&amp;from=bnbDSearch%7Csug&amp;showMap=0&amp;QHFP=KZL_B682D07A&amp;QHPR=1_7_0_0" target="_blank" rel="external">青海湖拉毛叶措天堂牧家宾馆</a>。在青旅里休息一会之后，因为天气的原因，我们就在犹豫还是否去茶卡盐湖，为了不留遗憾，我们最后决定去茶卡盐湖。我们就让青旅的老板帮我联系去茶卡的车，我们6个人包了两辆车（300元/辆），在黑马河镇上买了一些零食以及泡面（晚饭，晚上可能会回来很晚）。在去黑马河的路上，感觉每翻过一座山，天气就不一样，黑马河这边还是阴天，结果翻了一座山之后，在去茶卡的路上都是晴天。到达茶卡镇的时候又遇到了堵车，虽然茶卡是阴天，但是来的人依然是路易不绝，两公里的路走了快一个小时。茶卡的门票是25元/人（学生票，成人票50），茶卡里有卖鞋套，鞋套是没有必要，盐湖里可以直接脱掉鞋下去玩的，不过要注意，湖里有很多黑色的洞，那些洞都很深，我们有一个队友就一下子掉进两次，水都到大腿那。在那呆了两个多小时之后，我们开始返回黑马河，到青旅的时候都快九点了，吃完泡面之后，我们就赶紧睡了。</p>
<p>Notes：</p>
<ul>
<li>黑马黑镇上去茶卡的车很多，基本上都是300一辆；</li>
<li>在茶卡那不用买什么鞋套，晴天比较好看，如果是阴天就差很多了；</li>
<li>下雨天骑车尽量=骑在白线以内，防止小石头扎破胎；</li>
<li>黑马河是青海观看日出的最佳地点（有日出的情况下）；</li>
</ul>
<p>茶卡盐湖： </p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-chaka.jpg" alt="chaka"></p>
<p>今日花费：<br>早饭19，中饭晚饭34，住宿65，茶卡门票25，包车86。</p>
<h3 id="8-4-Day3-黑马河——刚察县（115km）"><a href="#8-4-Day3-黑马河——刚察县（115km）" class="headerlink" title="8.4 Day3.黑马河——刚察县（115km）"></a>8.4 Day3.黑马河——刚察县（115km）</h3><p>今天应该是最期待的一天，因为黑马河是青海湖看日出的最佳地点，而且今天还是离湖最近的一天，不过今天也是骑行距离最远的一天。队友兵哥哥就是因为害怕骑不完，所以一路上基本上没怎么欣赏风景，一直在骑车，中饭都是带的干粮，结果是最早到达刚察县的。</p>
<p>早上五点多的时候，被师兄喊醒，说想看日出可以看日出了，当时那是一个困，黑马河那天睡的是最安稳的一个觉，但是为了看日出，还是决定起来了。那会天空中最东边有一道光，天空的其他地方都是阴沉沉的。而且那会有转晴的趋势，我们都很期待能看到日出，但是结果还是很令我们失望的，没看到青海湖的日出。带着遗憾我们开始出发了。好在我们出发的时候已经没有雨了，天气开始转晴了。在黑马河镇上吃完早饭（比江西沟便宜一些）之后，我们按着计划出发了。今天的天气非常好，我们看到了最美的青海湖，中间我们在青海湖湖边（去青海湖一个人5块钱）玩了将近一个小时。上午有三四个小时车程风景都特别好，这段路可以稍微骑慢一点，因为过了石乃亥之后，风景就一般了，就可以好好赶路程了，前面的风景还是好好欣赏才能不留遗憾。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh7.jpg" alt="qh7"></p>
<p>那天对我来说，还是挺悲催的，因为那边天气很干燥（感觉比北京要干燥很多，大家一定要多喝水），然后因为下雨的时候有点感冒，今天早上一起来的鼻子就流鼻血了。更悲催的是，在骑车的时候，突然流鼻血了，然后就是用卫生纸边塞着鼻子边骑车。骑到八十多公里时，还躺在草坪上休息半个多小时（那叫一个爽啊）。最后终于在七点多的时候骑到了刚察，我们定的是<a href="http://you.ctrip.com/food/qinghaihu281/151539-food.html#restaurant" target="_blank" rel="external">德吉央宗青年旅舍</a>，这个青旅（50元/人，可以洗澡）还不错。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh13.jpg" alt="qh13"></p>
<p>下面放几张自认为风景不错的照片（包括本人照哈）</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j1.jpg" alt="j1"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j4.jpg" alt="j4"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j5.jpg" alt="j5"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j3.jpg" alt="j3"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/j2.jpg" alt="j2"><br>因为刚擦是个县城，住宿的地方、吃饭的地方特别多，晚上就在大众点评上评价比较好的那家店吃的饭。下面这家的美食，很不错的。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food.jpg" alt="food"></p>
<p>今天师兄带的无人机终于派上了用场，下面晒几张师兄用无人机拍的照片。</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh8.JPG" alt="qh8"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh9.JPG" alt="qh9"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh10.JPG" alt="qh10"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh11.JPG" alt="qh11"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh12.JPG" alt="qh12"></p>
<p>Notes：</p>
<ul>
<li>在青海一定要多喝水；</li>
<li>今天行程比较远，大家一定要注意好时间，上午风景比较好，大家可以多玩玩，中午过了石乃亥之后就要抓紧时间赶路了；</li>
<li>今天也有几个比较大的坡，大家要注意了，还是多补充点能量，路上有卖西瓜的，大概1块一斤，还挺便宜的；</li>
</ul>
<p>今天的花费：<br>早饭13，中饭13，晚饭44，车胎14，看病59，住宿50。</p>
<h3 id="8-5-Day4-刚察县——西海镇（90km）"><a href="#8-5-Day4-刚察县——西海镇（90km）" class="headerlink" title="8.5 Day4.刚察县——西海镇（90km）"></a>8.5 Day4.刚察县——西海镇（90km）</h3><p>几天的路径虽然不算太长，但是今天是最后一天，而且前面50公里大部分都是在上坡，最蛋疼的是这段距离是逆风，基本上全程逆风，所以今天感觉是最累的，骑到西海镇的时候，我直接躺在床上休息了一个多小时才缓过劲。</p>
<p>第四天的油菜花：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh14.jpg" alt="qh14"></p>
<p>漫漫的长路：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh15.jpg" alt="qh15"></p>
<p>快到西海镇的那个小摊：<br><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qh16.jpg" alt="qh16"></p>
<p>晚饭我们是在西宁吃的，是师兄请的客，非常感谢谷歌那位师兄，下面晒几张西宁的美食：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food3.jpg" alt="food3"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food4.jpg" alt="food4"></p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-food2.jpg" alt="food2"></p>
<p>这几天的记录的骑行路线：</p>
<p><img src="/images/2015-09-27-TraveltoQinghaiLake/2015-09-27-qixing.jpg" alt="qixing"></p>
<p>Notes：</p>
<ul>
<li>刚察的早餐挺便宜的，比前面几个镇都好吃、都便宜；</li>
<li>刚出刚察的时候会有一个比较难爬的大坡，这个坡并不是最长的那个坡，中间有个坡当时我直接绝望了，推着上去的，因为又是逆风，所以不是一般的累。</li>
<li>前面三分之一的路还算比较好走，大多是平路，还有一些比较好的风景，而且有一段较长油菜花地，但我感觉没有第一天的油菜花好看。虽然是大都是平路，但逆风的原因，骑着还是很累的。</li>
<li>中间三分之一的路程是最困难的，最令人绝望的路段，这段路程开始进入山地，其间有几个个很长很高的上坡（其中最长有至少有三公里，爬的时候翻过一个山坡之后，发现前面居然还有一个山坡，这个坡真的用惨绝人寰才能形容）。</li>
<li>最后三分之一，也就是最后二十多公里的路段，有个超长的下坡，是这几天最爽的一段，一路狂奔，基本上不用怎么骑，一口气可以跑出二十公里，不过大家还是一定要注意安全的。</li>
</ul>
<p>今日花费：<br>吃饭35（晚饭是师兄请的，很感谢师兄），到西宁车费23，青旅住宿65.</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>这次行程终于圆了我的环骑青海湖的梦，很高兴我当时能找到这几个小伙伴，在这几天里我们一起玩耍，给我留下很深刻的影响。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm之配置文件]]></title>
      <url>http://wangzzu.github.io/2015/07/27/storm-configuration/</url>
      <content type="html"><![CDATA[<p>Storm的配置文件一般存放在<code>$STORM_HOME/conf</code>下，通常名为<code>storm.yaml</code>，它符合yaml格式要求。Storm的配置参数对任务的稳定运行以及吞吐率至关重要，这里介绍一下storm常见的配置项参数。</p>
<h3 id="1-storm基本配置"><a href="#1-storm基本配置" class="headerlink" title="1.storm基本配置"></a>1.storm基本配置</h3><ul>
<li><strong>storm.local.dir</strong>: nimbus 和supervisor进程存储一些状态信息（conf或者jars）的本地路径，需要每台storm node单独创建该目录并保证该目录有正确的读写权限;</li>
<li><strong>storm.log4j2.conf.dir</strong>： log4j的配置目录;</li>
<li><strong>storm.zookeeper.servers</strong>: storm严重依赖zookeeper存储状态信息，要保证zookeeper的高可用，最好设置多个zk地址;</li>
<li><strong>storm.zookeeper.port</strong>: 默认2181;</li>
<li><strong>storm.zookeeper.root</strong>: 在zookeeper中存储的根目录，如果多个storm集群公用一个zk集群，需要修改其根目录名称即可;</li>
<li><strong>storm.session.timeout</strong>: 默认20s，nimbus和supervisor和zk的session超时时间，如果log中常用sessiontimeout错误，考虑增加其值或者修改gc参数。该值并不能无限设置，zk有自己的最大session时间（默认20 ticktime）；</li>
<li><strong>storm.zookeeper.connection.timeout</strong>：连接超时时间；</li>
<li><strong>storm.zookeeper.retry.times</strong>: 默认5，执行zk操作重试次数；</li>
<li><strong>storm.zookeeper.retry.interval</strong>: 默认1000，即间隔1s；</li>
<li><strong>storm.zookeeper.retry.intervalceiling.millis</strong>: 300000 （5分钟）执行重试的时间间隔最长时间；</li>
<li><strong>storm.messaging.transport</strong>：”backtype.storm.messaging.netty.Context” task之间的消息传输协议，默认使用netty传输；</li>
<li><strong>storm.cluster.mode</strong>: “distributed” storm集群模式；</li>
<li><strong>storm.id</strong>：运行中拓扑的id,由storm name和一个唯一随机数组成；</li>
<li><strong>storm.local.mode.zmq</strong>：Local模式下是否使用ZeroMQ作消息系统，如果设置为false则使用java消息系统。默认为false；<br>注：Storm严重依赖zookeeper，而且zk在分布式使用中扮演了非常重要的角色。</li>
</ul>
<h3 id="2-nimbus相关设置"><a href="#2-nimbus相关设置" class="headerlink" title="2.nimbus相关设置"></a>2.nimbus相关设置</h3><ul>
<li><strong>storm.nimbus.retry.times</strong>： 5 nimbus操作的重试次数</li>
<li><strong>storm.nimbus.retry.interval.millis</strong>： 2s 重试间隔</li>
<li><strong>storm.nimbus.retry.intervalceiling.millis</strong>: 60000 最大重试时间 10分钟</li>
<li><strong>nimbus.seeds</strong>: [] 用于leader nimbus发现的nimbus hosts 列表，解决nimbus的单点故障问题，代替了原来的nimbus.host 配置</li>
<li><strong>nimbus.thrift.port</strong>: 6627 nimbus工作的thrift端口，客户端上传jar和提交拓扑的端口（nimbus的thrift监听端口）</li>
<li><strong>nimbus.thrift.threads</strong>: 64 nimbus thrift 线程数目</li>
<li><strong>nimbus.thrift.max_buffer_size</strong>: 1048576 1m</li>
<li><strong>nimbus.childopts</strong>: “-Xmx1024m” nimbus java 进程jvm设置</li>
<li><strong>nimbus.task.timeout.secs</strong>：30 与task没有心跳时多久nimbus可以认为该task已经死掉并且可以重新分配该task</li>
<li><strong>nimbus.supervisor.timeout.secs</strong>: 60 一分钟没有心跳 nimbus可以认为该supervisor已经dead，不会分配新的work</li>
<li><strong>nimbus.monitor.freq.secs</strong>: 10 nimbus多久查询下supervisor心跳信息并且重新分配工作。注意当一台机子曾经挂掉，nimbus会立即采取一些操作</li>
<li><strong>nimbus.reassign</strong>：当发现task失败时nimbus是否重新分配执行。默认为真，不建议修改。</li>
<li><strong>nimbus.cleanup.inbox.freq.secs</strong>: 600 多久时间启动清理inbox文件的线程</li>
<li><strong>nimbus.inbox.jar.expiration.secs</strong>: 3600 一个小时 jar过期时间</li>
<li><strong>nimbus.code.sync.freq.secs</strong>: 300 5分钟同步一次未执行的拓扑的代码</li>
<li><strong>nimbus.task.launch.secs</strong>: 120 用于task 第一次启动时的超时时间</li>
<li><strong>nimbus.file.copy.expiration.secs</strong>: 600 上传下载文件超时时间</li>
<li><strong>nimbus.topology.validator</strong>: “backtype.storm.nimbus.DefaultTopologyValidator” 拓扑验证，控制该拓扑是否可以执行</li>
<li><strong>topology.min.replication.count</strong>: 1 当nimbus seeds中该拓扑代码的备份达到最小数目时leader nimbus才可以执行拓扑动作。</li>
<li><strong>topology.max.replication.wait.time.sec</strong>: 60 当代码备份在nimbus list中达到topology.min.replication.count设置的最大等待时间，如果超时，不管有没有最小备份个数，都要执行该拓扑</li>
</ul>
<h3 id="3-supervisor相关配置"><a href="#3-supervisor相关配置" class="headerlink" title="3.supervisor相关配置"></a>3.supervisor相关配置</h3><ul>
<li><strong>supervisor.slots.ports</strong>: 设置当台机子上可跑的worker数目，每个worker对应一个port，通常情况下多少个cpu core就设置多少个worker，类似与hadoop中nodemanager中slot的设置</li>
<li><strong>supervisor.childopts</strong>: “-Xmx256m” supervisor jvm参数设置</li>
<li><strong>supervisor.worker.start.timeout.secs</strong>: 120 supervisor等待worker启动的最长时间</li>
<li><strong>supervisor.worker.timeout.secs</strong>: 30 worker的最长超时时间</li>
<li><strong>supervisor.worker.shutdown.sleep.secs</strong>: 1秒 supervisor shutdown worker需要等待的时间</li>
<li><strong>supervisor.monitor.frequency.secs</strong>: 3s检查一次worker的心跳确保是否要重启这些worker</li>
<li><strong>supervisor.heartbeat.frequency.secs</strong>: 5s supervisor和nimbus心跳的频率</li>
<li><strong>supervisor.enable</strong>: true supervisor是否要启动分配它的worker</li>
</ul>
<h3 id="4-worker-配置"><a href="#4-worker-配置" class="headerlink" title="4.worker 配置"></a>4.worker 配置</h3><ul>
<li><strong>worker.childopts</strong>: “-Xmx768m”</li>
<li><strong>worker.gc.childopts</strong>: “” worker gc set 可以被topology.worker.gc.childopts.覆盖</li>
<li><strong>worker.heartbeat.frequency.secs</strong>: 1 worker 和supervisor的heartbeat时间</li>
<li><strong>topology.worker.receiver.thread.count</strong>: 1 每个worker设置的receiver 线程个数</li>
<li><strong>task.heartbeat.frequency.secs</strong>: 3s task向nimbus发送心跳的频率</li>
<li><strong>task.refresh.poll.secs</strong>: 10 多久和其他task同步连接（如果task重新分配，发往该task信息的那些task需要重练他们之间的连接）</li>
</ul>
<h3 id="5-message传递相关参数"><a href="#5-message传递相关参数" class="headerlink" title="5.message传递相关参数"></a>5.message传递相关参数</h3><ul>
<li><strong>storm.messaging.netty.server_worker_threads</strong>：1， server端接收信息的线程个数</li>
<li><strong>storm.messaging.netty.client_worker_threads</strong>: 1， client端发送信息的线程个数</li>
<li><strong>storm.messaging.netty.buffer_size</strong>: 5M，netty buffer大小</li>
<li><strong>storm.messaging.netty.max_retries</strong>: 300 重试次数</li>
<li><strong>storm.messaging.netty.max_wait_ms</strong>: 1000ms=1s 最大等待时间要大于task launchtime and worker launch time默认120s，重连间隔要大于zk的sessiontimeout 以确保worker是否已挂</li>
<li><strong>storm.messaging.netty.min_wait_ms</strong>: 100</li>
<li><strong>storm.messaging.netty.transfer.batch.size</strong>: 262144 如果netty 发送消息非常忙，client客户端可以batch发送消息，否则尽快的flush消息以减少延迟。</li>
</ul>
<blockquote>
<p>注：我们的使用场景是storm kafka读取kafka里面的数据，发现运行一段时间以后，kafka消费的offset不再更新（2s更新一次消费的offset），spout 中的task不断重启导致offset一直不更新，查看log发现task失败的原因是gc设置不对以致netty连接超时，task会重新分配。在生产环境中应该调大该值，我们在线上设置该值为20s，并且调整worker的gc参数。</p>
</blockquote>
<h3 id="6-topology相关的设置，-针对特定拓扑的配置"><a href="#6-topology相关的设置，-针对特定拓扑的配置" class="headerlink" title="6.topology相关的设置， 针对特定拓扑的配置"></a>6.topology相关的设置， 针对特定拓扑的配置</h3><p>正如上一讲的，以下参数控制消息是否被完全处理：</p>
<ul>
<li><strong>topology.enable.message.timeouts</strong>: true 保证数据完全处理；</li>
<li><strong>topology.acker.executors</strong>: null 设置acker线程个数；</li>
<li><strong>topology.message.timeout.secs</strong>: 30 当一个消息的处理超时多长时间多少认为该tuple处理失败；</li>
<li><strong>topology.max.spout.pending</strong>: null 当spout 发送一个tuple时会将该tuple放到一个pending list，此字段控制在storm中处理的spout tuple数，可以根据超时时间以及每秒处理的消息数估算；</li>
</ul>
<p>下面这几个参数和拓扑的并行度（parallelism)，并行度的概念就是为该拓扑启动的线程数，TopologyBuilder#setSpout() 和TopologyBuilder#setbolt()中可以指定excutor数目，该excutor是从worker进程spawn的线程，task是处理数据的实际工作单元，跑在一个excutor上。</p>
<ul>
<li><strong>topology.workers</strong>: 1，Config#setNumWorkers，设置worker数，一个worker执行一个拓扑的一个子集任务，其上可以跑多个excutors，可能是多个bolt或者spout；</li>
<li><strong>topology.tasks</strong>: null，top.setNumtasks，设置task数目；</li>
<li><strong>topology.max.task.parallelism</strong>: null，拓扑最大线程数；</li>
</ul>
<p>worker <strong>gc设置</strong></p>
<ul>
<li><strong>topology.worker.childopts</strong>: null；</li>
<li><strong>topology.worker.logwriter.childopts</strong>: “-Xmx64m”；</li>
<li><strong>topology.worker.shared.thread.pool.size</strong>: 4 worker task 共享线程池大小；</li>
</ul>
<p>worker内消息传送的参数，与disruptor相关：</p>
<ul>
<li><strong>topology.executor.receive.buffer.size</strong>: 1024 #batched；</li>
<li><strong>topology.executor.send.buffer.size</strong>: 1024 #individual messages；</li>
<li><strong>topology.transfer.buffer.size</strong>: 1024 # batched；</li>
<li><strong>topology.disruptor.wait.strategy</strong>:com.lmax.disruptor.BlockingWaitStrategy 延迟和吞吐率权衡；</li>
<li><strong>topology.disruptor.wait.timeout.millis</strong>: 1000 延迟和cpu使用权衡，使用长延时时会减少cpu使用，减少等待时间可以保证延时小，但cpu负载高；</li>
</ul>
<p>其他参数配置：</p>
<ul>
<li><strong>topology.debug</strong>: false debug模式关闭；</li>
<li><strong>topology.tick.tuple.freq.secs</strong>: null 用于定时处理逻辑的拓扑使用；</li>
<li><strong>topology.spout.wait.strategy</strong>: “backtype.storm.spout.SleepSpoutWaitStrategy” 两种情形下等待1. no data 2. 达到最大pending大小；</li>
<li><strong>topology.sleep.spout.wait.strategy.time.ms</strong>: 1 sleep时间；</li>
</ul>
<p>drpc logview ui的设置就不介绍了。</p>
<p>通过上面所讲的设置参数，可以发现gc设置和zookeeper设置非常重要，而且在message传输的相关设置中，有一系列参数如：receiver buffer size 、transfer buffer size，transfer buffer size，以及netty receiver thread 和worker receiver count 又有什么关系，上面提到到disruptor是什么东东，还有很多问题。所以在设置参数这个主题下还会再详细介绍下面三个问题：</p>
<ul>
<li>jvm 参数设置和调整，这个对于java程序的稳定运行至关重要（尤其是在大数据平台下，因为目前开源的大数据工具大部分都是java写的，jvm调优是必不可少的;</li>
<li>zookeeper的维护和管理，在hadoop生态系统以及分布式系统中中必不可少的工具</li>
<li>storm worker间和worker内的消息传递，包含disruptor的使用，通过这一节的介绍就会知道buffer size 设置为啥都是2的幂次方，这里buffer size 的单位是字节还是其他等等一些疑惑</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://xstarcd.github.io/wiki/Cloud/storm_config_detail.html" target="_blank" rel="external">Storm配置项详解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Json文件的读取]]></title>
      <url>http://wangzzu.github.io/2015/07/13/json/</url>
      <content type="html"><![CDATA[<p>本人遇到的情况：在一个工程中需要引用另外一个jar包，而引用的jar里有Json配置文件，这里出现了Json文件找不到的错误。这实际上也是java从jar包中读取配置文件的问题。</p>
<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>取stackoverflow上的一个例子来说明。<br>我们的Json文件为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">        <span class="attr">"time"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"host"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"serverip"</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">"clientip"</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"separator"</span>: <span class="string">"\t"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是与Json文件对应的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jsonLog</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String separator;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> separator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeparator</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.separator = separator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.map = map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的是将Json文件的内容读取到jsonLog对象中，遇到两个问题：</p>
<ol>
<li>Json文件是存在config目录下，打jar包时如何将Json文件连同config目录一同打入jar包；</li>
<li>Json文件打进jar包，其他工程再引用该jar包时，此时Json所在目录已经变化，如何动态获取Json文件所在位置。</li>
</ol>
<h3 id="2-打jar包"><a href="#2-打jar包" class="headerlink" title="2.打jar包"></a>2.打jar包</h3><p>这里需要修改Maven工程的pom文件，加入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build<span class="string">&gt;</span><br><span class="line">	&lt;resources&gt;</span><br><span class="line">		&lt;resource&gt;</span><br><span class="line">			&lt;directory&gt;config&lt;/directory&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.json&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;targetPath&gt;config&lt;/targetPath&gt;</span><br><span class="line">		&lt;/resource&gt;</span><br><span class="line">	&lt;/resources&gt; </span><br><span class="line">&lt;/build&gt;</span></span><br></pre></td></tr></table></figure>
<p>这几行的意思就是打包时把目录<code>config</code>（directory）下的json文件也打进去，并且放<code>在config</code>（targetPath）目录下。</p>
<h3 id="3-读取Json文件"><a href="#3-读取Json文件" class="headerlink" title="3.读取Json文件"></a>3.读取Json文件</h3><p>动态获得json文件位置并读取的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">InputStream inputstream = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/config/xx.json"</span>);</span><br><span class="line">LogConfig config = objectMapper.readValue(inputstream, LogConfig.class);</span><br></pre></td></tr></table></figure>
<p>通过<code>Class</code>类的<code>getResourceAsStream()</code>方法来获取Json文件，这种方法是专门读取jar中的资源文件的。可参考<a href="http://blog.csdn.net/b_h_l/article/details/7767829" target="_blank" rel="external">java从jar包中读取资源文件</a>一文。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storm简单介绍]]></title>
      <url>http://wangzzu.github.io/2015/05/26/the-basis-of-storm/</url>
      <content type="html"><![CDATA[<p>本文是参考网上的博客以及一些书籍根据自己的一些理解整理得到的，主要是为了更好地理解storm的内部机制（当时使用Storm的版本是<code>0.9.3</code>）。</p>
<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><h4 id="1-1-Storm的Topology模型"><a href="#1-1-Storm的Topology模型" class="headerlink" title="1.1.Storm的Topology模型"></a>1.1.Storm的Topology模型</h4><p>一个storm Topology的一般模型为：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-topology.png" alt="topology"></p>
<h5 id="1-1-1-tuple"><a href="#1-1-1-tuple" class="headerlink" title="1.1.1.tuple"></a>1.1.1.tuple</h5><p>storm中传输的数据类型是tuple，tuple到底是什么？感觉还是用英语来说比较容易理解吧，”A tuple is a named of values where each value can be any type.”  tuple是一个类似于列表的东西，存储的每个元素叫做field（字段）。我们用getString(i)可以获得tuple的第i个字段。而其中的每个字段都可以任意类型的，也可以一个很长的字符串。我们可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String A = tuple.getString(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">long</span> a= tuple.getLong(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>来拿到我们所需的数据，不过前提你是要知道你的tuple的组成。具体tuple是什么类型，完全取决于自己的程序，取决于spout中nextTuple()方法中emit发送的类型。<br>storm的streams就是一个无限的tuple流，我们可以把storm tuples当做CEP(complex event processing)中events来理解。</p>
<h5 id="1-1-2-spout"><a href="#1-1-2-spout" class="headerlink" title="1.1.2.spout"></a>1.1.2.spout</h5><p>spout是storm topology的数据入口，连接到数据源，将数据转换为一个个tuple，并将tuple作为数据流进行发射。一个spout可以供多个topology使用。通常spouts从外部资源读取元组，然后发射元组到拓扑中（例如，Kestrel队列或Twitter API）。Spouts即可以是可靠的，也可是不可靠的。可靠的spout可以重新执行一个失败元组，但一个不可靠的spout一发射元组就会忘记它。</p>
<p>Spouts可以发射多个流。要发射多个流，使用OutputFieldDeclarer的declareStream方法声明多个流，并在使用SpoutOutputCollector的emit方法时指定流ID。但是由于由spouts和bolts组成的单流应用最为普遍，因此OutputFieldDeclarer提供便利的方法声明一个不需要指定ID的单流，此时，流被分配一个默认ID为“default”。</p>
<p>Spouts的重要方法是nextTuple方法。nextTuple方法发射一个新的元组到拓扑，或如果没有新的元组发射，简单的返回。注意任务spout的nextTuple方法都不要实现成阻塞的，因为storm是在相同的线程中调用spout的方法。</p>
<p>Spout的另外两个重要方法是ack和fail方法。当spout发射的元组被拓扑成功处理时，调用ack方法；当处理失败时，调用fail方法。Ack和fail方法仅被可靠spouts调用。</p>
<h5 id="1-1-3-bolt"><a href="#1-1-3-bolt" class="headerlink" title="1.1.3.bolt"></a>1.1.3.bolt</h5><p>bolt可以理解为计算机程序中的运算或函数，将一个或者多个数据流作为输入，对数据实施运算后，选择性地输出一个或者多个数据流。一个bolt可以订阅(subscribe)多个由spout或其他bolt发射的数据流。</p>
<p>Topology中的所有处理都在bolts中完成。Bolts什么都可以做，如过滤、业务功能、聚合、连接（合并）、访问数据库等等。</p>
<p>Bolts可以做简单的流转换。复杂的流转换经常需要多步完成，因此也需要多个bolts。例如，转换tweets数据流到流行图片数据流至少需要两步：一个bolt 对retweets的图片进行滚动计数，另外的bolt找出Top X（前几位）的图片（你可以用更具伸缩性的方式处理这部分流）。</p>
<p>Bolts可以发射多个流。要发射多个流，使用OutputFieldDeclarer的declareStream方法声明多个流，并在使用SpoutOutputCollector的emit方法时指定流ID。</p>
<p>当你声明一个bolt的输入流时，你总是以另一个组件的指定流作为输入。如果你想订阅另一个组件的所有流，你必须分别订阅每一个流。InputDeclarer提供了使用默认流ID订阅流的语法糖，调用declarer.shuffleGrouping(“1”)订阅组件“1”上的默认流，作用等同于declarer.shuffleGrouping(“1”, DEFAULT_STREAM_ID)。</p>
<p>Bolts的主要方法是execute方法，任务在一个新的元组输入时执行该方法。Bolts使用OutputCollector对象发射新的元组。Bolts必须对每个处理的元组调用OutputCollector的ack方法，因此storm知道这个元组完成处理（并且能最终确定ack原始元组是安全的）。一般情况，处理一个输入元组，基于此元组再发射0-N个元组，然后ack输入元组。Strom提供了一个IBasicBolt接口自动调用ack方法。</p>
<p>在Bolts中载入新的线程进行异步处理。OutputCollector是线程安全的，并随时都可调用它。</p>
<h5 id="1-1-4-Streams"><a href="#1-1-4-Streams" class="headerlink" title="1.1.4.Streams"></a>1.1.4.Streams</h5><p>Storm核心的抽象概念是“流”。流是一个分布式并行创建和处理的无界的连续元组（tuple）。流通过一种模式来定义，该模式是给流元组中字段命名。默认情况下，元组可以包含整型、长整型、短整型、字节、字符串、双精度浮点数、单精度浮点数、布尔型和字节数组。您还可以自定义序列化，在元组中使用自定义类型。</p>
<p>而消息流Streams是storm里的最关键的抽象。一个消息流是一个没有边界的tuple序列，而这些tuples会被以一种分布式的方式并行地创建和处理。对消息流的定义主要是对消息流里面的tuple的定义， 我们会给tuple里的每个字段一个名字。 并且不同tuple的对应字段的类型必须一样。 也就是说： 两个tuple的第一个字段的类型必须一样， 第二个字段的类型必须一样， 但是第一个字段和第二个字段可以有不同的类型。 在默认的情况下， tuple的字段类型可以是： integer, long, short, byte, string, double, float, boolean和byte array。 你还可以自定义类型 — 只要你实现对应的序列化器。</p>
<h4 id="1-2-storm并发机制"><a href="#1-2-storm并发机制" class="headerlink" title="1.2.storm并发机制"></a>1.2.storm并发机制</h4><p>在 Storm 的间接中提到过,Storm 计算支持在多台机器上水平扩容,通过将计算切分为多个独立的 tasks 在集群上并发执行来实现。在 Storm 中,一个 <strong>task</strong> 可以简单地理解为在集群某节点上运行的一个spout 或者 bolt 实例。</p>
<ul>
<li><p><strong>Nodes</strong>： 指配置在一个 Storm 集群中的服务器,会执行 topology 的一部分运算。一个 Storm 集群可以包括一个或者多个工作 node。</p>
</li>
<li><p><strong>Workers</strong>(JVM虚拟机)：指一个 node 上相互独立运行的 JVM 进程。每个 node 可以配置运行一个或者多个 worker。一个 topology 会分配到一个或者多个 worker 上运行。</p>
</li>
<li><strong>Executeor</strong>：指一个 worker 的 jvm 进程中运行的 Java 线程。多个 task 可以指派给同一个 executer 来执行。除非是明确指定,Storm 默认会给每个 executor 分配一个 task。</li>
<li><strong>Task</strong>：task 是 spout 和 bolt 的 实 例, 它 们 的 nextTuple() 和execute() 方法会被executors 线程调用执行。</li>
</ul>
<h5 id="1-2-1-默认的并发机制"><a href="#1-2-1-默认的并发机制" class="headerlink" title="1.2.1.默认的并发机制"></a>1.2.1.默认的并发机制</h5><p>在我们修改 topology 的并发度之前,先来看默认配置下 topology 是如何执行的。假设<br>我们有一台服务器(node),为 topology 分配了一个 worker,并且每个 executer 执行一个<br>task。我们的 topology 执行过程如下图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node1.png" alt="Node1"></p>
<p>正如在图中看到的,唯一的并发机制出现在线程级。每个任务在同一个 JVM 的不<br>同线程中执行。如何增加并发度以充分利用硬件能力?让我们来增加分配给 topology 的<br>worker 和 executer 的数量。</p>
<h5 id="1-2-2-给topology增加worker"><a href="#1-2-2-给topology增加worker" class="headerlink" title="1.2.2.给topology增加worker"></a>1.2.2.给topology增加worker</h5><p>增加额外的 worker 是增加 topology 计算能力的简单方法。为此 Storm 提供了 API 和修改配置项两种修改方法。无论采取哪种方法,spout 和 bolt 组件都不需要做变更,可以直接复用。<br>为了增加分配给一个 topology 的worker 数量,只需要简单的调用一下Config对象的setNumWorkers()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config.config = <span class="keyword">new</span> Config();</span><br><span class="line">config.setNumworkers(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这样就给 topology 分配了两个 worker 而不是默认的一个。从而增加了 topology 的计算资源,也更有效的利用了计算资源。我们还可以调整 topology 中的 executor 个数以及每个 executor 分配的 task 数量。</p>
<h5 id="1-2-3-配置executor和task"><a href="#1-2-3-配置executor和task" class="headerlink" title="1.2.3.配置executor和task"></a>1.2.3.配置executor和task</h5><p>我们已经知道,Storm 给 topology 中定义的每个组件建立一个 task,默认的情况下,每个 task 分配一个 executor。Storm 的并发机制 API 对此提供了控制方法,允许设定每个task 对应的 executor 个数和每个 executor 可执行的 task 的个数。<br>在定义数据流分组时,可以设置给一个组件指派的 executor 的数量。为了说明这个功能,修改 topology 的定义代码,设置 SentenceSpout 并发为两个 task,每个 task 指派各自的 executor 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setSpout (SENTENCE_SPOUT_ID, spout, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>如果只使用一个 worker,topology 的执行如下图所示：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node2.png" alt="Node2"></p>
<p>我们给语句分割 bolt SplitSentenceBolt 设置 4 个 task 和 2 个 executor。每个executor 线程指派 2 个 task 来执行(4/2=2)。还将配置单词计数 bolt 运行四个 task,每个task 由一个 executor 线程执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.setBolt(SPLIT_BOLT_ID, splitBolt, <span class="number">2</span>).setNumTasks(<span class="number">4</span>).shuffleGrouping(SENTENCE_SPOUT_ID);</span><br><span class="line"></span><br><span class="line">builder.setBolt(COUNT_BOLT_ID, countBolt, <span class="number">4</span>).fieldsGrouping(SPLIT_SPOUT_ID, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br></pre></td></tr></table></figure>
<p>在2个worker的情况下，topology的执行如图所示：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-Node3.png" alt="Node3"></p>
<p>要重点指出的是,当 topology 执行在本地模式时,增加 worker 的数量不会达到提高速度的效果。因为 topology 在本地模式下是在同一个 JVM 进程中执行的,所以只有增加 task 和 executor 的并发度配置才会生效。Storm 的本地模式提供了接近集群模式的模拟,对开发是否有帮助。但程序在投入生产环境之前,必须在真实的集群环境下进行测试。</p>
<h4 id="1-3-数据流分组"><a href="#1-3-数据流分组" class="headerlink" title="1.3.数据流分组"></a>1.3.数据流分组</h4><p>Storm 定义了七种内置数据流分组的方式:</p>
<ul>
<li><strong>Shuffle grouping</strong>(随即分组)：这种方式会随机分发 tuple 给 bolt 的各个 task,每个bolt 实例接收到的相同数量的 tuple;</li>
<li><strong>Fields grouping</strong>(按字段分组)：根据指定字段的值进行分组。比如说,一个数据流根据“ word ”字段进行分组,所有具有相同“ word ”字段值的 tuple 会路由到同一个 bolt 的 task 中；</li>
<li><strong>All grouping</strong>(全复制分组)：将所有的 tuple 复制后分发给所有 bolt task。每个订阅数据流的 task 都会接收到 tuple 的拷贝；</li>
<li><strong>Globle Grouping</strong>(全局分组)：这种分组方式将所有的 tuples 路由到唯一一个 task 上。Storm 按照最小的 task ID 来选取接收数据的 task。注意,当使用全局分组方式时,设置 bolt 的 task 并发度是没有意义的,因为所有 tuple 都转发到同一个 task 上了。使用全局分组的时候需要注意,因为所有的 tuple 都转发到一个 JVM 实例上,可能会引起 Storm 集群中某个 JVM 或者服务器出现性能瓶颈或崩溃；</li>
<li><strong>None grouping</strong>(不分组)：在功能上和随机分组相同,是为将来预留的；</li>
<li><strong>Direct gouping</strong>(直接分组/指向型分组)：数据源会调用 emitDirect() 方法来判断一个 tuple 应该由哪个 Storm 组件来接收。只能在声明了是指向型的数据流上使用；</li>
<li><strong>Local or shuffle grouping</strong>(本地或随即分组)：和随机分组类似,但是,会将 tuple 分发给同一个 worker 内的 bolt task(如果 worker 内有接收数据的 bolt task)。其他情况下,采用随机分组的方式。取决于 topology 的并发度,本地或随机分组可以减少网络传输,从而提高 topology 性能。</li>
</ul>
<p>除了预定义好的分组方式之外,还可以通过实现 CustomStreamGrouping(自定义分组)<br>接口来自定义分组方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> backtype.storm.generated.GlobalStreamId;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.task.WorkerTopologyContext;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomStreamGrouping</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(WorkerTopologyContext context, GlobalStreamId stream, List&lt;Integer&gt; targetTasks)</span></span>;<span class="comment">//prepare()方法在调用时，用来初始化分组信息，分组的具体实现会使用这些信息决定如何向接收task分发tuple。WorkerTopologyContext 对象提供了topology的上下文信息，GlobalStreamId提供了待分组数据流的属性，targetTasks时分组所有待选task的标识符列表。</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//会将 targetTasks 的引用存在变量里作为 chooseTasks() 的参数</span></span><br><span class="line">    <span class="function">List&lt;Integer&gt; <span class="title">chooseTasks</span><span class="params">(<span class="keyword">int</span> taskId, List&lt;Object&gt; values)</span></span>; <span class="comment">//chooseTasks() 方法返回一个 tuple 发送目标 task 的标识符列表。它的两个参数是发送tuple 的组件的 id 和 tuple 的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-可靠的消息处理机制"><a href="#1-4-可靠的消息处理机制" class="headerlink" title="1.4.可靠的消息处理机制"></a>1.4.可靠的消息处理机制</h4><p>Storm 提供了一种 API 能够保证 spout 发送出来的每个 tuple 都能够执行完整的处理过程。</p>
<p>在storm里一个tuple被完全处理的意思是：这个tuple以及由这个tuple所导致的所有的tuple都被成功处理。而一个tuple会被认为处理失败了如果这个tuple在timeout所指定的时间内没有成功处理。而这个<code>timeout</code>可以通过<code>Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS</code>来指定。</p>
<p>作为storm的使用者，有两件事情要做以更好的利用storm的可靠性特征。 首先，在你生成一个新的tuple的时候要通知storm; 其次，完成处理一个tuple之后要通知storm。 这样storm就可以检测整个tuple树有没有完成处理，并且通知源spout处理结果。storm提供了一些简洁的api来做这些事情。</p>
<h5 id="1-4-1-spout的可靠性"><a href="#1-4-1-spout的可靠性" class="headerlink" title="1.4.1.spout的可靠性"></a>1.4.1.spout的可靠性</h5><p>在有保障数据的处理过程中,bolt每收到一个 tuple,都需要向上游确认应答(ack)者报错。对主干 tuple 中的一个 tuple,如果 tuple 树上的每个 bolt 进行了确认应答,spout 会调用 ack 方法来标明这条消息已经完全处理了。如果树中任何一个 bolt 处理 tuple 报错,或者处理超时,spout 会调用 fail方法。<br>tuple树的结构如图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-tuple_tree.png" alt="tuple_tree"></p>
<p>Spout的nextuple()发送一个tuple，为了实现可靠的消息处理，首先要给每个发出的tuple带上唯一的ID，并且将ID作为参数传递给SpoutOutputCollector的emit()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collector.emit(<span class="keyword">new</span> Values(<span class="string">"value1"</span>,<span class="string">"value2"</span>),msgId);</span><br></pre></td></tr></table></figure>
<p>接下来，这个发射的tuple被传送到消息处理者bolt那里，storm会跟踪由此所产生的这课tuple树。如果storm检测到一个tuple被完全处理了，那么storm会以最开始的那个message-id作为参数来调用消息源的ack方法；反之storm会调用spout的fail方法。要注意的是，storm调用ack或者fail的task始终是产生这个tuple的那个task。所以如果一个spout被分成很多个task来执行，消息执行的成功失败与否始终会通知最开始发出tuple的那个task。</p>
<p>给tuple指定ID告诉Storm系统，无论执行成功还是失败，spout都要接收所有发出tuple返回的通知。如果处理成功，spout的ack()方法将会对编号是ID的消息应答确认，如果执行失败或者超时，会调用fail()方法。</p>
<h5 id="1-4-2-bolt的可靠性"><a href="#1-4-2-bolt的可靠性" class="headerlink" title="1.4.2.bolt的可靠性"></a>1.4.2.bolt的可靠性</h5><p>bolt要实现可靠的消息处理机制要包含两个步骤：</p>
<ol>
<li>当发射衍生的tuple时，需要锚定读入的tuple；</li>
<li>当处理消息成功或者失败时分别确认应答或者报错。</li>
</ol>
<p>由一个tuple产生一个新的tuple称为：anchoring(锚定)。你发射一个新tuple的同时也就完成了以西anchring。</p>
<p>锚定一个tuple的意思是，建立读入tuple和衍生出的tuple之间的对应关系，这样下游的bolt就可以通过应答确认，报错或超时来加入到tuple树结构中。<br>可以通过调用OutputCollect中emit()的一个重载函数锚定一个或者一组tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collector.emit(tuple, <span class="keyword">new</span> Values(word));<span class="comment">//anchoring</span></span><br></pre></td></tr></table></figure>
<p>这里，我们将读入的tuple和发射的新tuple锚定(anchoring)起来，下游的bolt就需要对输出的tuple进行确认应答或者报错。因为这个tuple被anchoring在上一个tuple， 这整个就构成了tuple树，如果这一级tuple处理出错了，那么这整个tuple处理过程都会被重新处理。</p>
<p>另外一个emit()方法会发射非锚定的tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collector.emit(<span class="keyword">new</span> Values(word));<span class="comment">// unanchoring</span></span><br></pre></td></tr></table></figure>
<p>用这种方法发射会导致新发射的这个tuple脱离原来的tuple树(unanchoring), unanchoring的tuple不会对数据流的可靠性起作用。如果一个unanchoring的tuple在下游处理过程中失败了，原始的根tuple是不会重新发送，到底要anchoring还是要 unanchoring则完全取决于你的业务需求。﻿</p>
<p>当处理完成或者发送了新tuple之后，可靠数据流中的bolt需要应答读入的tuple：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.collector.ack(tuple);</span><br></pre></td></tr></table></figure>
<p>如果处理失败，这样的话spout必须发射tuple，bolt就要明确地对处理失败的tuple报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.collector.fail(tuple);</span><br></pre></td></tr></table></figure>
<p>如果因为超时的原因，或者显式调用OutputCollector.fail()方法，spout都会重新发送源是的tuple。</p>
<p>每个处理tuple，都必须进行ack或者fail。因为storm会追踪每个tuple要占用内存。所以如果你不ack/fail每一个tuple，那么最终年会看到<code>OutOfMemory</code>错误。</p>
<p>对于SplitSentence这一部分，如果用IRichBolt来做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line">        OutputCollector _collector;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,</span><br><span class="line">                            TopologyContext context,</span><br><span class="line">                            OutputCollector collector)</span> </span>&#123;</span><br><span class="line">            _collector = collector;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">            String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">                _collector.emit(tuple, <span class="keyword">new</span> Values(word));</span><br><span class="line">            &#125;</span><br><span class="line">            _collector.ack(tuple);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大多数Bolt遵循这样的规律：读取一个tuple；发射一些新的tuple；在execute的结束的时候ack这个tuple。这些Bolt往往是一些过滤器或者简单函数。Storm为这类规律封装了一个BasicBolt类。如果用BasicBolt来做， 上面那个SplitSentence可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">implements</span> <span class="title">IBasicBolt</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf,</span><br><span class="line">                            TopologyContext context)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple,</span><br><span class="line">                            BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">            String sentence = tuple.getString(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(String word: sentence.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">                collector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(</span><br><span class="line">                        OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">            declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个实现比之前的实现简单多了， 但是功能上是一样的。发送到BasicOutputCollector的tuple会自动和输入tuple相关联，而在execute方法结束的时候那个输入tuple会被自动ack的。</p>
<h5 id="1-4-3-acker"><a href="#1-4-3-acker" class="headerlink" title="1.4.3.acker"></a>1.4.3.acker</h5><p>storm里面有一类特殊的task称为：acker， 他们负责跟踪spout发出的每一个tuple的tuple树。当acker发现一个tuple树已经处理完成了。它会发送一个消息给产生这个tuple的那个task。你可以通过<code>Config.TOPOLOGY_ACKERS</code>来设置一个topology里面的acker的数量， 默认值是一。 如果你的topology里面的tuple比较多的话， 那么把acker的数量设置多一点，效率会高一点.</p>
<p>理解storm的可靠性的最好的方法是来看看tuple和tuple树的生命周期， 当一个tuple被创建， 不管是spout还是bolt创建的， 它会被赋予一个64位的id，而acker就是利用这个id去跟踪所有的tuple的。每个tuple知道它的祖宗的id(从spout发出来的那个tuple的id), 每当你新发射一个tuple， 它的祖宗id都会传给这个新的tuple。所以当一个tuple被ack的时候，它会发一个消息给acker，告诉它这个tuple树发生了怎么样的变化。具体来说就是：它告诉acker： 我呢已经完成了， 我有这些儿子tuple, 你跟踪一下他们吧。下面这个图演示了C被ack了之后，这个tuple树所发生的变化。<br>tuple ack示例:</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-acker.png" alt="acker"></p>
<p>关于storm怎么跟踪tuple还有一些细节， 前面已经提到过了， 你可以自己设定你的topology里面有多少个acker。而这又给我们带来一个问题， 当一个tuple需要ack的时候，它到底选择<code>哪个acker</code>来发送这个信息呢？</p>
<p>storm使用一致性哈希来把一个spout-tuple-id对应到acker， 因为每一个tuple知道它所有的祖宗的tuple-id， 所以它自然可以算出要通知哪个acker来ack。（这里所有的祖宗是指这个tuple所对应的所有的根tuple。这里注意因为一个tuple可能存在于多个tuple树，所以才有所有一说）。</p>
<p>storm的另一个细节是acker是怎么知道每一个spout tuple应该交给哪个task来处理。当一个spout发射一个新的tuple， 它会简单的发一个消息给一个合适的acker，并且告诉acker它自己的id(taskid)， 这样storm就有了taskid-tupleid的对应关系。 当acker发现一个树完成处理了， 它知道给哪个task发送成功的消息.</p>
<p>acker task并不现式的跟踪tuple树。对于那些有成千上万个节点的tuple树，把那么多的tuple信息都跟踪起来会消耗太多的内存。相反，acker永了一种不同的凡是，使得对于每一个spout tuple所需要的内存量都是恒定的(20bytes)。这个<strong>跟踪算法</strong>是storm如何工作的关键。</p>
<h3 id="2-Storm集群框架"><a href="#2-Storm集群框架" class="headerlink" title="2.Storm集群框架"></a>2.Storm集群框架</h3><h4 id="2-1-nimbus守护进程"><a href="#2-1-nimbus守护进程" class="headerlink" title="2.1.nimbus守护进程"></a>2.1.nimbus守护进程</h4><p>nimbus守护进程的主要职责是管理，协调和监控在集群上运行的topology。包括topology的发布，任务支派，事件处理失败时重新指派任务。</p>
<p>将topology发布到Storm集群，将预先打包的jar文件的topology和配置信息提交到nimbus服务器上，一旦nimbus接收到了topology的压缩包，会将jar包分发到足够数量的supervisor节点上。当supervisor节点接收到了topology压缩文件，nimbus就会指派task(bolt和spout实例)到每个supervisor并且发送信号指示supervisor生成足够的worker来执行指派的task。</p>
<p>nimbus记录所有supervisor节点的状态和分配给它们的task。如果nimbus发现某个supervisor没有上报心跳或者已经不可达了，它会将故障supervisor分配的task重新分配到集群中的其他supervisor节点。</p>
<p>严格意义上讲 nimbus 不会引起单点故障。这个特性是因为 nimubs 并不参与 topology 的数据处理过程,它仅仅是管理 topology 的初始化,任务分发和进行监控。实际上,如果 nimbus 守护进程在 topology 运行时停止了,只要分配的 supervisor 和worker 健康运行,topology 一直继续数据处理。要注意的是,在 nimbus 已经停止的情况下 supervisor 异常终止,因为没有 nimbus 守护进程来重新指派失败这个终止的 supervisor的任务,数据处理就会失败。</p>
<h4 id="2-2-supervisor守护进程"><a href="#2-2-supervisor守护进程" class="headerlink" title="2.2.supervisor守护进程"></a>2.2.supervisor守护进程</h4><p>supervisor守护进程等待nimbus分配任务后生成并监控workers(JVM进程)执行任务。supervisor和worker都是运行在不同的 JVM 进程上,如果由 supervisor 拉起的一个woker 进程因为错误(或者因为 Unix 终端的 kill-9 命令,Window 的 tskkill 命令强制结束)异常退出,supervisor 守护进程会尝试重新生成新的 worker 进程。</p>
<p>如果一个worker甚至整个supervisor节点都故障了，Storm怎么保障出错时正在处理的tuples的传输呢？答案就在Storm的tuple的锚定和应答确认机制中。当打开了可靠i传输的选项，传输到故障节点上的tuples将不会收到应答确认，spout会因为超时而重新发射原始的tuple。这样的过程会一直重复直到topology从故障中恢复开始正常处理数据。</p>
<h4 id="2-3-Zookeeper的作用"><a href="#2-3-Zookeeper的作用" class="headerlink" title="2.3.Zookeeper的作用"></a>2.3.Zookeeper的作用</h4><p>Storm 主要使用 ZooKeeper 来协调一个集群中的状态信息,比如任务的分配情况,worker 的状态,supervisor 之间的 nimbus 的拓扑度量。nimbus 和 supervisor 节点之间的通信主要是结合 ZooKeeper 的状态变更通知和监控通知来处理的。</p>
<h3 id="3-Storm程序框架"><a href="#3-Storm程序框架" class="headerlink" title="3.Storm程序框架"></a>3.Storm程序框架</h3><h4 id="3-1-topology提交"><a href="#3-1-topology提交" class="headerlink" title="3.1.topology提交"></a>3.1.topology提交</h4><h5 id="3-1-1-本地模式"><a href="#3-1-1-本地模式" class="headerlink" title="3.1.1.本地模式"></a>3.1.1.本地模式</h5><p>使用LocalCluster类将topolog运行在本地模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalCluster cluster=<span class="keyword">new</span> LocalCluster();</span><br><span class="line">cluster.submitTopology(TOPOLOGY_NAME, config, builder.createTopology());</span><br></pre></td></tr></table></figure>
<p>一般得例子为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalRunningTopology</span> <span class="keyword">extends</span> <span class="title">ExclaimBasicTopo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        LocalRunningTopology topo = <span class="keyword">new</span> LocalRunningTopology();</span><br><span class="line">        Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">        conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        cluster.submitTopology(<span class="string">"test"</span>, conf, topo.buildTopology());</span><br><span class="line">        Utils.sleep(<span class="number">100000</span>);</span><br><span class="line">        cluster.killTopology(<span class="string">"test"</span>);</span><br><span class="line">        cluster.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-集群模式"><a href="#3-1-2-集群模式" class="headerlink" title="3.1.2.集群模式"></a>3.1.2.集群模式</h5><p>提交一个topology到远程集群就非常简单了，只需要利用StormSubmitter类中同样的方法和名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology(TOPOLOGY_NAME, config, builder.createrTopology());</span><br></pre></td></tr></table></figure>
<p>一般的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterRunningTopology</span> <span class="keyword">extends</span> <span class="title">ExclaimBasicTopo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        String topoName = <span class="string">"test"</span>;</span><br><span class="line">         </span><br><span class="line">        ClusterRunningTopology topo = <span class="keyword">new</span> ClusterRunningTopology();</span><br><span class="line">        Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">        conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        conf.setNumWorkers(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        StormSubmitter.submitTopology(topoName, conf, topo.buildTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-实际的例子"><a href="#3-1-3-实际的例子" class="headerlink" title="3.1.3.实际的例子"></a>3.1.3.实际的例子</h5><p>在实际的程序里，本地和集群是混绑在一起的，用传入参数以示区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         </span><br><span class="line">        ExclaimBasicTopo topo = <span class="keyword">new</span> ExclaimBasicTopo();</span><br><span class="line">        Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">        conf.setDebug(<span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conf.setNumWorkers(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">            StormSubmitter.submitTopology(args[<span class="number">0</span>], conf, topo.buildTopology());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">            LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">            cluster.submitTopology(<span class="string">"test"</span>, conf, topo.buildTopology());</span><br><span class="line">            Utils.sleep(<span class="number">100000</span>);</span><br><span class="line">            cluster.killTopology(<span class="string">"test"</span>);</span><br><span class="line">            cluster.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-Spout"><a href="#3-2-Spout" class="headerlink" title="3.2.Spout"></a>3.2.Spout</h4><p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-spout.jpg" alt="spout"></p>
<p>Spout最顶层抽象的是<strong>ISPout</strong>接口：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-ISpout.jpg" alt="ISpout"></p>
<h4 id="3-3-Bolt"><a href="#3-3-Bolt" class="headerlink" title="3.3.Bolt"></a>3.3.Bolt</h4><p>自带的Blot类的关系见下图：</p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-bolt.jpg" alt="bolt"></p>
<p><img src="/images/2015-05-26-theBasisOfStorm/2015-05-26-IBolt.jpg" alt="IBolt"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS7.0的常用配置]]></title>
      <url>http://wangzzu.github.io/2015/05/25/centos70/</url>
      <content type="html"><![CDATA[<h3 id="1-Windows开机引导"><a href="#1-Windows开机引导" class="headerlink" title="1.Windows开机引导"></a>1.Windows开机引导</h3><p>在<code>/etc/grub.d/40_custom</code>中加入以下代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menuentry <span class="string">"Windows"</span>&#123;</span><br><span class="line">    <span class="built_in">set</span> root=(hd0,1)</span><br><span class="line">    chainloader +1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新引导</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.conf</span><br></pre></td></tr></table></figure>
<h3 id="2-挂载NTFS分区的硬盘"><a href="#2-挂载NTFS分区的硬盘" class="headerlink" title="2.挂载NTFS分区的硬盘"></a>2.挂载NTFS分区的硬盘</h3><p><a href="http://www.rpmfind.net/linux/rpm2html/search.php" target="_blank" rel="external">linux仓库</a><br>用yum安装ntfs-3g</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fuse-ntfs-3g</span><br></pre></td></tr></table></figure>
<p>安装好ntfs-3g之后，系统就可以识别NTFS分区的硬盘了。</p>
<h3 id="3-开机自动挂载Windows下的ntfs磁盘"><a href="#3-开机自动挂载Windows下的ntfs磁盘" class="headerlink" title="3.开机自动挂载Windows下的ntfs磁盘"></a>3.开机自动挂载Windows下的ntfs磁盘</h3><p><code>fdisk -l</code>查看windows分区信息</p>
<p>用/mnt/winE挂载Windows下的E盘:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line">mkdir winE</span><br><span class="line">mount -t ntfs-3g /dev/sda3 /mnt/winE</span><br></pre></td></tr></table></figure>
<p>输入以下命令，查看信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></table></figure>
<p>实现开机自动挂载，需要编辑<code>/etc/fstab</code>文件(编辑之前尽量先备份)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/fstab /etc/fstab_cp</span><br><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>保存后退出就可以实现开机自动挂载了。</p>
<h3 id="4-为软件建立桌面快捷方式"><a href="#4-为软件建立桌面快捷方式" class="headerlink" title="4.为软件建立桌面快捷方式"></a>4.为软件建立桌面快捷方式</h3><p>在<code>/usr/share/applications</code>下建立一个.desktop文件即可。<br>以eclipse为例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Categories=Development;</span><br><span class="line">Comment[zh_CN]=</span><br><span class="line">Comment=</span><br><span class="line">Exec=/home/Matt/Software/eclipse/eclipse</span><br><span class="line">GenericName[zh_CN]=IDE</span><br><span class="line">GenericName=IDE</span><br><span class="line">Icon=/home/Matt/Software/eclipse/icon0.png</span><br><span class="line">MimeType=</span><br><span class="line">Name[zh_CN]=Eclipse</span><br><span class="line">Name=eclipse</span><br><span class="line">Path=</span><br><span class="line">StartupNotify=<span class="literal">true</span></span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">X-DBUS-ServiceName=</span><br><span class="line">X-DBUS-StartupType=</span><br><span class="line">X-KDE-SubstituteUID=<span class="literal">false</span></span><br><span class="line">X-KDE-Username=owen</span><br></pre></td></tr></table></figure>
<p>一般只有三个地方<code>Exec, Icon, Name</code>需要我们去修改。<br>建立好eclipse.desktop文件后，把这个文件移到<code>/home/WM/Desktop</code>下，并改变这个文件的所有者和所属用户组。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> chmod +x IntelliJIDE.desktop</span><br><span class="line">cp IntelliJIDE.desktop /home/Matt/Desktop/</span><br><span class="line"><span class="built_in">cd</span> /home/Matt/Desktop</span><br><span class="line">chown Matt IntelliJIDE.desktop</span><br><span class="line">chgrp Matt IntelliJIDE.desktop</span><br></pre></td></tr></table></figure>
<h3 id="5-安装chrome"><a href="#5-安装chrome" class="headerlink" title="5.安装chrome"></a>5.安装chrome</h3><p><a href="http://chrome.richardlloyd.org.uk/install_chrome.sh" target="_blank" rel="external">下载</a>自动安装脚本<br>然后使用gedit编辑install—chrome.sh，使用find功能查找并将</p>
<p>其中的<code>http://omahaproxy.appspot.com</code>改为<code>https://dl.google.com/linux/direct
/google-chrome-stable_current_x86_64.rpm</code></p>
<p>打开终端，进入chrome.sh文件所在目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x install_chrome.sh</span><br><span class="line">./install_chrome.sh</span><br></pre></td></tr></table></figure>
<p><a href="http://www.google.cn/intl/zh-CN/chrome/browser/thankyou.html?brand=CHUN&amp;installdataindex=chinabookmarkcontrol&amp;platform=linux" target="_blank" rel="external">下载chrome最新版rpm包</a></p>
<h3 id="6-为Terminal设置快捷键"><a href="#6-为Terminal设置快捷键" class="headerlink" title="6.为Terminal设置快捷键"></a>6.为Terminal设置快捷键</h3><p>一般设置为：Ctrl+Alt+T</p>
<p> <a href="http://jingyan.baidu.com/album/cb5d61053598ed005d2fe05c.html?picindex=7" target="_blank" rel="external">Terminal</a></p>
<p>Setting》》点击Keyboard》》选择左边Shortcuts –&gt;Custom Shortcuts：</p>
<p>点击旁边的+号，然后输入（Name那儿随便写）,Command填写<code>/usr/bin/gnome-terminal</code>.</p>
<p>点Apply，然后将它的快捷键设置为Ctrl+Alt+T:</p>
<h3 id="7-网络配置"><a href="#7-网络配置" class="headerlink" title="7.网络配置"></a>7.网络配置</h3><p><a href="http://www.centoscn.com/CentOS/config/2014/1023/3993.html" target="_blank" rel="external">网络配置</a></p>
<h3 id="8-局域网内共享文件夹"><a href="#8-局域网内共享文件夹" class="headerlink" title="8.局域网内共享文件夹"></a>8.局域网内共享文件夹</h3><p>进入文件内，输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>
<p>然后用在firewall中把端口8080打开即可，用tcp连接。</p>
<h3 id="9-软件库"><a href="#9-软件库" class="headerlink" title="9.软件库"></a>9.软件库</h3><p>安装软件库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm</span><br><span class="line">rpm -Uvh http://ftp6.sjtu.edu.cn/fedora/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><a href="http://www.dedoimedo.com/computers/centos-7-perfect-desktop.html" target="_blank" rel="external">常用软件</a></p>
<h3 id="10-中文乱码问题"><a href="#10-中文乱码问题" class="headerlink" title="10.中文乱码问题"></a>10.中文乱码问题</h3><p><a href="http://dargonjack.blog.51cto.com/6294601/1334685" target="_blank" rel="external">乱码问题</a></p>
<h4 id="10-1-gedit中文乱码"><a href="#10-1-gedit中文乱码" class="headerlink" title="10.1.gedit中文乱码"></a>10.1.gedit中文乱码</h4><p>在终端输入一下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gsettings <span class="built_in">set</span> org.gnome.gedit.preferences.encodings auto-detected <span class="string">"['UTF-8', 'GB18030', 'GB2312', 'GBK', 'BIG5', 'CURRENT', 'UTF-16']"</span></span><br><span class="line">$ gsettings <span class="built_in">set</span> org.gnome.gedit.preferences.encodings shown-in-menu <span class="string">"['UTF-8', 'GB18030', 'GB2312', 'GBK', 'BIG5', 'CURRENT', 'UTF-16']"</span></span><br></pre></td></tr></table></figure>
<h4 id="10-2-Vim中文编码"><a href="#10-2-Vim中文编码" class="headerlink" title="10.2.Vim中文编码"></a>10.2.Vim中文编码</h4><p>编辑用户主目录下.vimrc(如果没有这创建touch  .vimrc)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$vim</span> .vimrc</span><br><span class="line"><span class="keyword">if</span> (has(<span class="string">"gui_running"</span>))</span><br><span class="line">    <span class="built_in">set</span> guifont=Bitstream\ Vera\ Sans\ Mono\ 10</span><br><span class="line">endif</span><br><span class="line"><span class="built_in">set</span> fencs=utf-8,ucs-bom,<span class="built_in">shift</span>-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="built_in">set</span> termencoding=utf-8</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br><span class="line"><span class="built_in">set</span> fileencodings=ucs-bom,utf-8,cp936</span><br><span class="line"><span class="built_in">set</span> fileencoding=utf-8</span><br></pre></td></tr></table></figure>
<p>保存退出<br>此时不论是正文还是标题都不会有乱码出现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Strom之tuple]]></title>
      <url>http://wangzzu.github.io/2015/05/21/stromtuple/</url>
      <content type="html"><![CDATA[<p>这几天一直在看storm，其中注意到了storm中主要的数据结构类型tuple，刚开始对这种数据还是很不理解，看几个程序之后，才豁然开朗，下面就主要介绍一些storm中最简单的、最基础的东西——tuple。</p>
<p>storm中的数据首先是有spout收集，类似于一个消息源，spout的open()函数一般就是接收数据的地方，然后spout的 nextTuple()是发送(emit)tuple的地方。tuple到底是什么？感觉还是用英语来说比较容易理解吧，”A tuple is a named of values where each value can be any type.”  tuple是一个类似于列表的东西，存储的每个元素叫做field（字段）。我们用getString(i)可以获得tuple的第i个字段。而其中的每个字段都可以任意类型的，也可以一个很长的字符串。我们可以用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String A = tuple.getString(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">long</span> a= tuple.getLong(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>来得到我想要的数据，不过前提你是要知道你的tuple的组成。具体tuple是什么类型，完全取决于自己的程序，取决于spout中nextTuple()方法中emit发送的类型。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kafka常用的一些命令]]></title>
      <url>http://wangzzu.github.io/2015/05/20/KafkaOrder/</url>
      <content type="html"><![CDATA[<h3 id="1-开启Kafka"><a href="#1-开启Kafka" class="headerlink" title="1.开启Kafka"></a>1.开启Kafka</h3><p>先进入kafka的安装目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<h3 id="2-运行程序"><a href="#2-运行程序" class="headerlink" title="2.运行程序"></a>2.运行程序</h3><p>有以下两种方式来运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.ext.dirs=/opt/kafka_2.10-0.8.1.1/libs -jar <span class="built_in">test</span>Producer.jar  </span><br><span class="line">java -cp traffic-distribution.jar producer.producer /home/matt/<span class="built_in">test</span>/ topicName ...</span><br></pre></td></tr></table></figure>
<p>第一种是jar包中没有打入相关依赖包的情况；<br>第二种是jar宝中已经包含相关依赖包。</p>
<h3 id="3-列出所有的topic"><a href="#3-列出所有的topic" class="headerlink" title="3.列出所有的topic"></a>3.列出所有的topic</h3><p>列出当前集群上的所有topic：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper serverIP:serverPort</span><br></pre></td></tr></table></figure>
<p>注：serverIP为zookeeper所在机器的IP，serverPort为对应的端口。</p>
<h3 id="4-删除topic"><a href="#4-删除topic" class="headerlink" title="4.删除topic"></a>4.删除topic</h3><p>删除topic的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.admin.DeleteTopicCommand -topic <span class="built_in">test</span> -zookeeper serverIP:serverPort</span><br></pre></td></tr></table></figure>
<p>这种删除方式只是删除了topic，但是该topic中Partition的数据依然存在，等数据过期之后就会自动删除。（也可以手动删除/tmp/kafka-logs/下的partition信息）</p>
<h3 id="5-kafka集群设置"><a href="#5-kafka集群设置" class="headerlink" title="5.kafka集群设置"></a>5.kafka集群设置</h3><p>主要是配置kafka的config的<code>server.properties</code>文件，后面我写一篇kafka安装配置的blog。</p>
<h3 id="6-查看topic的信息"><a href="#6-查看topic的信息" class="headerlink" title="6.查看topic的信息"></a>6.查看topic的信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper serverIP:serverPort --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="7-删除group"><a href="#7-删除group" class="headerlink" title="7.删除group"></a>7.删除group</h3><p>进入zookeeper的安装目录，如<code>/opt/cloudera/parcels/CDH/bin/</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh zookeeper-client</span><br><span class="line">ls /consumers</span><br><span class="line">rmr /consumers/groupName</span><br></pre></td></tr></table></figure>
<h3 id="8-开启topic"><a href="#8-开启topic" class="headerlink" title="8.开启topic"></a>8.开启topic</h3><p>建立topic的几种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper serverIP:serverPort --create --topic <span class="built_in">test</span> --partitions 1 --replication-factor 1</span><br><span class="line">bin/kafka-topics.sh --zookeeper serverIP:serverPort --create --topic <span class="built_in">test</span> --replica-assignment 29,29</span><br></pre></td></tr></table></figure>
<p>第一种是一般的方式，建立的topic的partition为1，replication为1；<br>第二种是直接指定partition所在机器。</p>
<h3 id="9-KafkaOffsetMonitor"><a href="#9-KafkaOffsetMonitor" class="headerlink" title="9.KafkaOffsetMonitor"></a>9.KafkaOffsetMonitor</h3><p>使用KafkaOffsetMonitor对kafka集群进行监控。</p>
<p>KafkaOffsetMonitor的<a href="https://github.com/quantifind/KafkaOffsetMonitor/releases/download/v0.2.1/KafkaOffsetMonitor-assembly-0.2.1.jar" target="_blank" rel="external">jar包下载</a>,<a href="https://github.com/quantifind/KafkaOffsetMonitor" target="_blank" rel="external">源码地址</a>。</p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp KafkaOffsetMonitor-assembly-0.2.1.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk serverIP1,serverIP2 --port 8080 --refresh 10.seconds --retain 2.days</span><br></pre></td></tr></table></figure>
<p>参数的意思是：</p>
<ul>
<li><strong>ZK</strong> the ZooKeeper hosts</li>
<li><strong>port</strong> on what port will the app be available</li>
<li><strong>refresh</strong> how often should the app refresh and store a point in the DB</li>
<li><strong>retain</strong> how long should points be kept in the DB</li>
<li><strong>dbName</strong> where to store the history (default ‘offsetapp’)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么你应该（从现在就开始）写博客【转】]]></title>
      <url>http://wangzzu.github.io/2014/10/24/hello-world/</url>
      <content type="html"><![CDATA[<p>向大家推荐一篇blog，刘未鹏大神的<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a>.下面的内容<strong>转载</strong>于这篇博文。</p>
<h3 id="1-为什么你应该（从现在开始就）写博客"><a href="#1-为什么你应该（从现在开始就）写博客" class="headerlink" title="1.为什么你应该（从现在开始就）写博客"></a>1.为什么你应该（从现在开始就）写博客</h3><p>用一句话来说就是，写一个博客有很多好处，却没有任何明显的坏处。（阿灵顿的情况属于例外，而非常态，就像不能拿抽烟活到一百岁的英国老太太的个例来反驳抽烟对健康的极大损伤一样）</p>
<p>让我说得更明确一点：用博客的形式来记录下你有价值的思考，会带来很多好处，却没有任何明显的坏处。Note：碎碎念不算思考、心情琐记不算思考、唠唠叨叨也不算思考、没话找话也不算思考，请以此类推。</p>
<p>下面是我个人认为写一个长期的<strong>价值博客</strong>的最大的几点好处：</p>
<p>1). <strong>能够交到很多志同道合的朋友</strong>。我自己既写博客，也读别人的博客，在这个时代，对于生活中的绝大多数人来说，拓宽朋友圈子的途径几乎只有一个，通过网络，而如何在网络中寻找到气味相投的朋友，如何判断别人和自己是否有共同语言？显然，通过天天在SNS上碎碎念的那些日记是难以做到的。我佩服的一些朋友几乎全都是长期用博客记录想法的人，<strong>因此，和他们即便不打照面，也是心照不宣</strong>。即便素未谋面也能坐下来就聊得热火朝天。</p>
<p>为什么博客在结交志同道合的朋友方面的潜力要远胜于原始的交谈方式？很简单，<strong>第一，博客无地域限制，整个互联网上从A到B只有一个点击的距离</strong>，而传统的建立朋友圈子的方法则受到地域限制,<strong>第二</strong>，也是更重要的一点，即如果按照以前结交朋友的方式，需要互相聊天，交流观点，然后才逐渐熟悉起来，这需要一个较长的过程，而且更糟糕的是，当你遇到另一个陌生人，又要把整个过程重复一次，表达你已经对老友表达过的那番想法。可博客却做到了“<strong>一次表达，无数次阅读</strong>”，当我看到一个写了好几年的博客，看完了之后我仿佛和这个人交谈了很久，用程序员们喜欢听的话来说就是，“<strong>博客极大地增强了话语的复用性</strong>”。</p>
<p>我曾在CSDN上写了近六年的博客，在一年半前建立了一个Google Groups（TopLanguage），由于我的博客的长期阅读者都是互相有共同语言的，因此这个Group一开始就热火朝天，而高质量的技术讨论则进一步吸引了更多的牛人的参与，雪球滚起来之后，就很难停下来了，将近一年半下来，从这个Group的讨论中我获益良多[1]。而对于非程序员朋友，科学松鼠会则是一个很好的例子。</p>
<p>2). <strong>书写是为了更好的思考</strong>。我在<a href="http://delicious.com/pongba/toplanguage" target="_blank" rel="external">《书写是为了更好的思考》</a>里面详细总结了书写的好处，这里就不拷贝粘贴了。有些想法如果不写下来，也就忘掉了，有一个广为流传的《数学牛人们的轶事》（荣耀属于ukim）里面讲了希尔伯特的一个故事：一次在Hilbert的讨论班上，一个年轻人报告，其中用了一个很漂亮的定理，Hilbert说“这真是一个妙不可言（wunderbaschon）的定理呀,是谁发现的？”那个年轻人茫然的站了很久，对Hilbert说：“是你.……”。</p>
<p>3). <strong>“教”是最好的“学”。如果一件事情你不能讲清楚，十有八九你还没有完全理解</strong>。绝大多数人应该都知道在程序员行业面试官经常要求你讲解一个东西给他听，他会说他不懂这个东西（他如果真的不懂的话效果其实是最好的），而你的任务则是说到让他理解为止。</p>
<p>为了让一个不明白的人做到明白，你必须要知道从明白到不明白他究竟需要掌握哪些概念，这就迫使我们对我们大脑中整个的知识体系来个寻根究底，把藏在水面之下的那些东西统统挖出来，把大脑中的那些我们知道、但不知道自己知道的潜在概念或假设（assumptions）都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道、并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。</p>
<p>但是，你可能会怀疑，那除了能够讲清楚之外，弄清自己到底知道哪些东西还有其他什么好处吗？如果没有其他好处，那我又何必费这个劲呢？我又不当老师。</p>
<p>TopLanguage上的一位朋友sagasw曾经讲了这样一个小故事：<strong>据说在某个著名软件公司里，开发组的桌上会放着一只小熊，大家互相问问题之前，先对着小熊把问题说一遍，看能不能把问题描述的清晰，基本上说的比较有条理以后，答案也就随之而来了</strong>。当然，你不一定要对小熊说，你可以在大脑中虚构一个听众，一个不懂行的听众，然后你说给他听。这是可行的，我经常在路上用。不过如果你能坐下来，我建议你还是说给实际的听众听——即写下你的思考，因为书写是更好的思考。</p>
<p>我们的绝大多数知识在绝大多数时候都隐藏在潜意识中，其实我们意识的窗口很小，我们的工作记忆只能容纳寥寥数个条目（记得那个“看你能够记住屏幕上同时闪现的多少个数字”的flash小游戏吗？），我们平时所作的推理过程很大部分都是自动的，发生在潜意识中，而我们只能感知到一些中间结论。不信你回忆一下你在和别人讨论问题的时候有多少次觉得“<strong>反正就是这样，我感觉得到它是对的，但是你问我，我也说不清到底怎么回事”，对此你不觉得很奇怪吗？如果你都不能从逻辑上支持你的结论，你怎么就能确信它是对的呢？仅仅因为你的直觉强烈地告诉你它是对的？那如果旁边有另一个人，他和你持相反的观念，而他的直觉也强烈地告诉他他是对的。这时候你又怎么想？“他的直觉错了，我的直觉是对的”？难道你这么自信你的直觉是世界上最可靠的？</strong></p>
<p>我自己则是非常珍惜类似这样的机会，即当“我强烈地觉得它是对的，但我却说不出所以然来”，这时候<strong>往往是到大脑中翻箱倒柜的时候，弄清来龙去脉的时候，深入反思的时候，纠正一直以来错误的潜在前提假设的时候。另一方面，“我强烈地觉得这个说法有问题，但我却说不清它为什么有问题，到底哪有问题”</strong>，这也是一个极有意义的瞬间，它几乎总是意味着你对一个问题的认识有潜在的偏差，肯定是在你自己都没有觉知到的地方引入了一个潜在的假设、偷换了一个重要的概念，等等。而这种时候就是深入反思的时候，当你终于潜到问题的底层，触摸到问题的实质，把水面之下的冰山整体看清了的时候你会有一种通体舒泰的感觉。</p>
<p>为什么说以上这些？因为刚才说的是你必须等待这样的反思机会，<strong>但如果你选择经常总结自己的知识体系，并说出来给你的读者听，你就会发现你自己创造了这样的机会</strong>。如果我们平时不反思，我们觉得很多事情都是当然的，但结果如果要你一开口说给别人听，常常会发现事情就开始变得不那么明显了，你说着说着，就开始莫名其妙地发现自己需要用到“反正”这个词了。</p>
<p>于是，反思的机会就来了。</p>
<p><strong>一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能，而不是任它们在幕后阴险地左右你的思维</strong>。很多时候我们的思路出了问题并不是我们不会反思，而是不知道自己的思维中有那些隐含的假设（assumptions），如果你只感觉到答案，却不知道你大脑得到这个答案之前做了哪些推理，你又怎么知道哪一环可能出了问题呢？另一方面，一旦你弄清了自己到底是怎么想的，离意识到问题就不远了，很简单的道理——如果别人和你争辩的时候总是只摆立场，你就很难和他辩，但如果他把自己的推理过程原原本本暴露给你，批判起来总是容易得多的。（也正因为这个原因有很多人总是把逻辑藏在背后，不敢暴露出来）</p>
<p>绝大多数时候其实我们都会不假思索地得出一些结论，就像上了发条的自动机，但其实我们并不知道这些结论到底怎么来的，在思维的背后到底发生了哪些事情，故而当我们发现我们的结论错了的时候，一头雾水，没法着手寻找到底在哪错了。如果你注意一下很多人的发言（论坛、博客等等），如果你把他们的发言分为“前提”、“假设”、“逻辑”、“结论”这四个部分，你会发现一大堆人只会不停地下结论，摆立场，却见不到这些结论或离场的前提、假设和个中逻辑，倒也不是他们不愿意写出逻辑，而是因为反思自己的思维过程实在是一件困难非常的事情，我们的推理过程很大一部分发生在意识的水面之下，只有当有了重要结论的时候这条逻辑链才会浮出来冒一个泡，让我们的意识捕捉到。更何况绝大多数时候我们用的其实并不是完整严密的逻辑思维，而是思维捷径。</p>
<p><strong>去教一个完全不懂的人，则是一种最最强大和彻底的反思途径</strong>——因为他没有任何预备的知识，所以要让他弄懂你所知道的，你就必须彻底反思你的知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的，你不能自己站在11层上，然后假设你的读者站在第10层，指望着只要告诉他第11层有那些内容就让他明白。你的读者站在第一层，你必须知道你脚下踩着的另外10层到底是怎么构造的。<strong>这就迫使你对你所掌握的、或之前认为正确的那些东西作彻彻底底的、深刻的反思，你的受众越是不懂，你需要反思得就越深刻</strong>。</p>
<p>4). <strong>讨论是绝佳的反思</strong>。另一方面，<strong>很多时候我们并不是有机会说给完全不懂的人听，更大的可能性是说给同领域有一定基础的人听</strong>，这个时候并不代表就不能促使反思了，实际上，你会发现，如果你公开你的想法，<strong>几乎总能看到与你持不同意见的人</strong>，然后你通过比较你和他的观念之间的差别，会发现你们在一开始的思路上就存在差异，差异从哪里来的？在进一步讨论中你们就会不断地迫使对方拿出更深层次的理由，这同样也是一种非常有效地促使自己反思的方法，在讨论的过程中双方的理由自然会变得越来越深入，越来越接近问题的本质，<strong>一些平时难以注意到的深层面的差异性就会逐渐浮现出来，你也就多了一次难得的机会去审视自己的思维中到底存放了哪些错误的信息</strong>。</p>
<p>5). <strong>激励你去持续学习和思考</strong>。如果你没有持续学习和思考的习惯，你的博客很快就会没有内容可写，就只能整点碎碎念或者转载，然后你就会失去读者，然后你就会关掉博客，然后一旦关掉博客之后你也就死了写博客的心，然后就少了一条激励你去思考和总结的途径，然后你变得更不高兴总结和思考，然后…</p>
<p>为了打破这个死循环，不要永久停止更新你的博客，就算你两个月，三个月都不写，只要你每篇都是写自己思考的产物，写有价值的东西，在互联网上，金子的确总是会发光的，因为有无数的信息聚合平台在期待这些有价值的内容，有搜索引擎为你的内容提供海量的潜在读者，有海量的人肉在手动挖掘和转载那些有价值的东西。<strong>我们所能做的最差的一个决策莫过于停止做一件没有任何坏处，却有一大堆好处的事情</strong>。</p>
<p>为了让你的博客有价值，你必须不断总结自己学习的结果，你必须不断思考，给出比别人深刻、独到的见解。这看起来有点本末倒置，但很快本和末就会正过来。</p>
<p>6). <strong>学会持之以恒地做一件事情</strong>。很多人在生活中容易觉得迷失，不知道想要做什么，是因为没有一件能够持续地做的事情，用俗话来说就是没有主心骨。用积极心理学的话来说就是没有一件能够创造流体验的事情，而书写自己的思想则是一件容易产生流体验的事情，在书写的时候，特别是理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。不过前提是你得开始，并且坚持过一开始的困难期，以后的一切便成了习惯成自然。</p>
<p>7). <strong>一个长期的价值博客是一份很好的简历</strong>。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到<strong>价值博客的时代</strong>，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但<strong>至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环</strong>。</p>
<h3 id="2-怎么做到长期写一个价值博客"><a href="#2-怎么做到长期写一个价值博客" class="headerlink" title="2.怎么做到长期写一个价值博客"></a>2.怎么做到长期写一个价值博客</h3><p>注意到我并没有说“怎么做到长期<strong>坚持</strong>写一个价值博客”，因为当思考和总结成为习惯之后，诉诸文字以及借助书写来进一步思考就变成了一件自然而然的事情，就变成了一件“因为你在思考和总结从而必须书写下来”的事情，博客就变成了副产品。</p>
<p>一开始的时候你是因为要写博客而去使劲地思考和总结，指望给出令人眼睛一亮的东西，到了后来，就变成了因为你习惯了思考和总结，因为你意识到书写是更好的思考，你就必须使你的想法成为文字。至此本和末就会各归原位，不再颠倒。</p>
<p>怎样做到长期写一个价值博客？也许有人会给出很多有趣有用的小技巧来提供动机和激励，譬如如何做SEO，如何鼓励读者留言等等，但是这些我都不想说，我只想说最最重要的，那就是：</p>
<p><strong>让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来</strong>。</p>
<p>就像那句经常被人传阅的话：只做你最感兴趣的事情，钱会随之而来[2]。</p>
<p>这方面的具体例子大家可以留意一下，随处可见，就不一一举了。我想再重复一下的是，千万不要碎碎念，我能理解每个人都想偶尔发发牢骚的冲动，但是现在已经有了一个很好的窗口：twitter，所以立即停止在你的博客上碎碎念，阅读博客的人希望得到信息而非噪音。<strong>如果实在忍不住想碎碎念的话不妨换一下位置，这么来告诉自己：如果你看到别人博客来上这么一段，你会有兴趣看吗？</strong></p>
<h3 id="3-可能出现的问题以及怎样应付"><a href="#3-可能出现的问题以及怎样应付" class="headerlink" title="3.可能出现的问题以及怎样应付"></a>3.可能出现的问题以及怎样应付</h3><p>即便上文给出了N条写博客的理由，但有时候只要一条不写的理由就会让人停止做一件事情。所以我特别加上一节“可能出现的问题以及怎样应付”，《影响力2》[3]第五章雄辩地证明，“Much of Will is Skill”，<strong>意志力很大程度上来源于有正确的方法，而非天生</strong>。</p>
<p>1). <strong>担心别人认为没有价值</strong>。事实是，你面临过的问题总会有人面临过，你独立思考了，别人没有，你的文章对他们就会有价值。当然，肯定会对某些人没有价值，他们早就知道了，但就算你再厉害，也总是有人比你厉害的，不能说因为这些原因就不记录你自己的想法了，你自己思考了之后理解得最深刻，就算有别人想过了，总有人没有想到的。况且，思考成了习惯，你的思考能力也会越来越强，你的文章也会越来越有价值。重复，<strong>无论你面临什么困惑，总会有很多人同样面临过，于是你苦苦思索之后的结果，肯定会对很多人有意义</strong>。</p>
<p>或者，<strong>你想通了之后觉得其实也很简单于是不愿意或者不好意思写了，但要知道，问题在想通了之后总是简单的，问题的困难程度不在于想通了之后还觉得有多难，而在于从你觉得它难到你觉得它简单需要耗费多少思维体力</strong>，你耗费的时间越长，说明有越多的人最终还是没有想明白（路越长走到底的人越少）。</p>
<p>最后，虽然我现在看一年前的文章觉得挺不成熟，但是如果没有那些不成熟的思考，也不会有现在更成熟的思考，我几年后来看现在写的东西，还是会觉得不成熟。</p>
<p>2). <strong>担心想法太幼稚或有漏洞等等被别人笑话</strong>。人非圣贤。正是因为单个人的想法总是有漏洞，才值得拿出来交流（《书写是更好的思考》，讨论是绝佳的反思），被别人指出问题正是改进的空间，藏着掖着的想法永远不可能变得更成熟。</p>
<p>Much of intelligence is knowledge，有这么一个非常发人深省的经典心理学实验[4]：</p>
<p>将孩子们分成两组，通过给他们不同的阅读材料让一组相信智力是天生的，不可在后天改变的，另一组则让他们相信智力其实只是知识和技能的代名词，完全是后天习得的。接下来让他们做一组任务，那些被相信智力天生说的孩子，倾向于回避困难的任务，选择较容易的任务，这里的逻辑想必是这样的：如果做困难的任务，就增大了失败的几率，就在降低了自己在别人和自己心目中的智力的值。为了保护这个智力的值不被降低，应该避免那些有失败风险的项目。而另一组孩子则对于有挑战性的事情跃跃欲试，并且在失败的时候明显没有前者沮丧，因为失败也是学得新的东西，不管怎样都是“智力”的提高。</p>
<p>况且，只会批判乃至嘲笑别人的人是最不知道怎么建设的人，忽略他们。</p>
<p>3).  <strong>得不到激励</strong>。这其实是个最无聊的问题了，只有写碎碎念的博客才会面对“激励”的问题。如果写自己的总结，写自己独立的思考，那么书写下来、理解通透，本身就是一个极大的激励。就算放在自己的私密笔记本里面也一样有成就感。况且，如果你真做到了书写价值博客，那么绝对不用担心你的观点得不到传播，也许一开始会耗时长一点，但是这在任何事情上都是必要的初始阶段，Gmail小组的核心人物、FriendFeed创始人Paul Buchheit，和编程界名博Coding Horror的博主Jeff Atwood都曾经感叹过：Overnight success takes a long time （(1)，(2)），不过对于价值博客来说，现在网络上的聚合类服务这么多，机器的、人肉的、半人肉的都有，情况又要好得多了，而且我相信情况还会越来越好。</p>
<p>4). <strong>写不出来</strong>。这个问题也比较无聊，思考本不是一件急于求成的事情。长期订阅我的博客的朋友知道我一般发文频率在一个月三五篇，实际上有不少次我个把月也不发布文章，原因很简单，要么是有手头的事情要处理思考的时间被压缩了，要么是遇到比较大或者比较困难的问题需要长时间的思考和积淀，没有关系，如果没有想清楚就再想想，爱思考的人和不爱思考的人有一个本质的区别，前者在生活中总是挂着几个问题在大脑中，它们时常都会冒出来骚扰你一下，让你琢磨琢磨，不爱思考的则是没事不主动想问题，遇到问题还要先想想是否能找捷径（找人帮忙）解决。</p>
<p>无论如何，不用急于求成，在一个主题上深入下去思考，总能挖到别人挖不到的角落。你能让一个问题在大脑中停留的时间越长，就越是能够发现新的东西，一般来说，我认为有价值的问题我会让他在意识或潜意识中待短则一个星期，长则一个月（视问题大小而定），利用走路吃饭的时间琢磨（我发现很多我佩服的人也都有这个习惯），<strong>有时即便已经想通了写下来了发出去了，大脑仍然还是会在回味问题，还没有把它撤出潜意识，然后看到某篇文章或某本书的时候忽然又有所新的感悟</strong>。</p>
<p><strong>能够把问题长时间停靠在潜意识中是一种技能，能够带来很大的好处，停留得越长你越琢磨得透彻，比别人看到的就越多</strong>。我们必须要带着问题的眼镜看待事物才能发现新的视角，否则就会出现视而不见效应，别的不说，广为人知的例子是阿基米德的“尤里卡！”，如果不是长时间琢磨着一个问题，一直把它放在思维中，是不会从洗澡领悟到“排水测体积”的，否则他洗了那么多年澡怎么不早发现呢？[5]</p>
<p>所以，如果你习惯了思考问题，就总会有东西写，先有思考，然后有总结，然后在总结中进一步思考。</p>
<p>当然你也可以试试把不成熟的想法写下来，试图整理成条理清晰的文字，然后看看能否在整理的过程中走得更远。这往往是可行的。比如这篇文章在我的简记里面原本其实只有三行字（包含大约十来个备忘关键词），而最初在我的大脑里面其实只有一个走路时冒出来的问题——为什么要写博客？</p>
<p>–</p>
<p>[1] 你可以看一下我<a href="http://delicious.com/pongba/toplanguage" target="_blank" rel="external">收藏的一些精彩主题</a>。</p>
<p>[2] 尽管我并不完全同意这句话本身，但它这种解决问题链上更基本环节的问题的精神是我赞同的。</p>
<p>[3] 《影响力2》这个名字起得很聪明，其实它并不是《影响力》的作者写的。</p>
<p>[4] 我忘了这则实验的出处了，但实验的精神是记忆犹新的，哪位同学记得原始出处的麻烦提醒我一下。</p>
<p>[5] 对于阿基米德这个故事的真实性是有争议的，毕竟几千年久远的事情谁弄得清呢。但是故事的道理是很本质的，我们平时也经常有类似的体验，加上阿基米德的“尤里卡”实在太出名了，所以我相信用用无妨。</p>
]]></content>
    </entry>
    
  
  
</search>
