<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Stateful Serverless 背后的 Flink StateFun 内部机制实现【译】 | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Stateful Serverless 背后的 Flink StateFun 内部机制实现【译】</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">柳年思水</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Stateful Serverless 背后的 Flink StateFun 内部机制实现【译】</h1><div class="post-meta">Oct 31, 2020<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">2,811</span><span> 字</span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2020/10/31/statefun-serverless-internals/" href="/2020/10/31/statefun-serverless-internals/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个-StateFun-示例-Shopping-Cart"><span class="toc-number">1.</span> <span class="toc-text">一个 StateFun 示例: Shopping Cart</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stateful-Functions-Runtime-是如何工作的？"><span class="toc-number">2.</span> <span class="toc-text">Stateful Functions Runtime 是如何工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Remote-Invocation-Request-Reply-Protocol"><span class="toc-number">2.1.</span> <span class="toc-text">Remote Invocation Request-Reply Protocol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function-state-consistency-and-fault-tolerance"><span class="toc-number">2.2.</span> <span class="toc-text">Function state consistency and fault-tolerance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-by-step-walkthrough-of-function-invocations"><span class="toc-number">2.3.</span> <span class="toc-text">Step-by-step walkthrough of function invocations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>本篇是 Flink StateFun 的第二篇文章，文中的内容是来自 <a href="https://flink.apache.org/news/2020/10/13/stateful-serverless-internals.html" target="_blank" rel="external">Stateful Functions Internals: Behind the scenes of Stateful Serverless</a> 的翻译，这篇文章从上层把 Flink StateFun 的内核做了一个比较深入的介绍，个人认为它是一篇很不错的、用来了解 StateFun 内部机制的文章。</p>
<p>Stateful Functions (StateFun) 的出现简化了分布式有状态应用的构建，它将有状态流处理（有状态的强一致性保证）与事件驱动的 FAAS 平台（基于云原生架构带来的弹性和 Serverless 体验）结合起来。一个典型的 StateFun 应用包括两个部分：使用现代平台（kubernetes 等）部署 FAAS 服务以及一个 StateFun 集群，StateFun 集群扮演着事件驱动数据库的角色，来为 Functions 的状态和 Event 提供一致性和容错性保证。</p>
<p>那么，StateFun 内部是如何实现的呢？一个 StateFun 集群是如何与这些 Functions 通信呢？本篇文章就带大家深入了解一下 StateFun Runtime 的内部实现原理（文中的示例是完全部署在 AWS 上运行的）。本篇文章的主要目标就是让读者能够比较清楚地理解 StateFun Runtime 与 Functions 之间的交互，以及如何开发一个 Stateful Serverless 应用，并且能够将应用部署到类似于 GCP 或 Microsoft Azure 之类的云平台上。</p>
<h2 id="一个-StateFun-示例-Shopping-Cart"><a href="#一个-StateFun-示例-Shopping-Cart" class="headerlink" title="一个 StateFun 示例: Shopping Cart"></a>一个 StateFun 示例: Shopping Cart</h2><p>这里先来看下一个示例 —— a shopping cart application（购物车应用），下图展示了这个示例中涉及到的两个 Functions、Functions 中维护的 state 以及两个 Function 之间传递的 msg 类型：</p>
<p><img src="/images/statefun/shopping-cart-overview.png" alt=" An overly simplified shopping cart application"></p>
<blockquote>
<p>本文的示例代码见 <a href="https://github.com/tzulitai/statefun-aws-demo/blob/master/app/shopping_cart.py" target="_blank" rel="external">shopping_cart</a>，这里使用的 <a href="https://ci.apache.org/projects/flink/flink-statefun-docs-master/sdk/python.html" target="_blank" rel="external">Python SDK</a> 开发。</p>
</blockquote>
<p>这个应用包含了两个 Function：</p>
<ol>
<li><strong>Cart Function</strong>：该函数每个实例都是与具体的 user 相关联，它的 state 记录了用户购物车中的商品信息（<code>ItemsInCart</code>）；</li>
<li><strong>Inventory Function</strong>：这个函数主要是用于查询商品的库存信息，它维护了每件商品的库存信息（<code>NumInStock</code>）以及每件商品在所有用户购物车中的数量（<code>NumReserved</code>）；</li>
</ol>
<p>应用中的所有 Msg 都是通过逻辑地址发往相应的 Function 实例，这个逻辑地址会包含 Function Type 及 Intance ID 信息（如：<code>cart:Kim</code>、<code>inventory:socks</code>）。本应用中发送到 Ingress 的数据类型是 <code>AddToCart</code>，它表示是一个将相应的商品加到用户的购物车中的操作，发送给 Egress 的类型是 <code>AddToCartResult</code>，它表示的是这个将商品添加到用户购物车中操作的结果（可能会因为库存情况加入失败）。</p>
<p>这几种数据类型定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// ---------------------------------------------------------------------</span><br><span class="line">// Shopping cart messages</span><br><span class="line">// ---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">message AddToCart &#123;</span><br><span class="line">    string item_id = 1;</span><br><span class="line">    int32 quantity = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddToCartResult &#123;</span><br><span class="line">    enum Type &#123;</span><br><span class="line">        SUCCESS = 0;</span><br><span class="line">        FAIL = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type type = 1;</span><br><span class="line">    string item_id = 2;</span><br><span class="line">    int32 quantity = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ---------------------------------------------------------------------</span><br><span class="line">// Shopping cart state type</span><br><span class="line">// ---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">message ItemsInCart &#123;</span><br><span class="line">    map<span class="tag">&lt;<span class="name">string,</span> <span class="attr">int32</span>&gt;</span> items = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Cart</code> Function 是用来处理 <code>AddToCart</code> 类型数据的，它会在应用逻辑中再触发其他的 Function，为了简化这个示例，这里在两个 Function 之间传递的数据只抽象了两种简单的数据类型：</p>
<ul>
<li><code>RequestItem</code>：从 <code>Cart</code> Function 发送到 <code>Inventory</code> Function 的请求类型（用来查询商品库存）；</li>
<li><code>ItemReserved</code>：<code>Inventory</code> Function 返回的结果（表示可以加到购物车的商品数量）。</li>
</ul>
<h2 id="Stateful-Functions-Runtime-是如何工作的？"><a href="#Stateful-Functions-Runtime-是如何工作的？" class="headerlink" title="Stateful Functions Runtime 是如何工作的？"></a>Stateful Functions Runtime 是如何工作的？</h2><p>上面已经详细介绍了购物车应用示例的处理逻辑，这部分注重看一下 StateFun Cluster 是如何保证 Functions 状态及 msg 发送的一致性和容错的。</p>
<p><img src="/images/statefun/abstract-deployment.png" alt="Simplified view of a StateFun app deployment"></p>
<p>StateFun Runtime 是构建在 Apache Flink 之上，并且基于 Flink 的底层机制 —— <strong>co-location of state and messaging</strong> 来保证一致性和容错性。在一个 StateFun 应用中，所有 messages 的路由转发都是经过 StateFun Cluster 的，包括从 Ingress 中发送的数据、Functions 之间传输的数据以及 Function 发往 Egress 的数据。而且，Function 的 state 都是在 StateFun Cluster 中维护的，如同 Flink 应用一样，StateFun Cluster 中 messages 与 Function State 是 <code>co-partitioned</code> 的，所以计算都是本地 state 访问，而且都是没有任何负作用的原子操作。</p>
<p>这里举个例子，假设一条 target 逻辑地址为 <code>(cart, &quot;Kim&quot;)</code> 的 message 经过 StateFun Cluster 路由转发，这个逻辑地址将被用做数据传输和 state 的 <code>partition key</code>（对应的 Flink 作业中就是 <code>keyby</code> 操作中的 <code>key</code> 值），这样的话，StateFun Cluster 接收到的数据都具有本地 state 可用性。与 Flink 相比，StateFun 的区别在于实际的计算逻辑不会发生在 StateFun Cluster Partitions 中，而是由远程 Function Service 来触发。那么 StateFun 是如何做到将 message 路由转发到远程 Function Service、并且提供【如同 state 和计算都在一起的一致性保证的】 state 访问的呢？</p>
<h3 id="Remote-Invocation-Request-Reply-Protocol"><a href="#Remote-Invocation-Request-Reply-Protocol" class="headerlink" title="Remote Invocation Request-Reply Protocol"></a>Remote Invocation Request-Reply Protocol</h3><p>StateFun Cluster Partition 与 Function 的交互使用的是一个简洁、定义优雅的 request-reply 协议，如下图所示。一旦 Cluster Partition 接收到相应的 message，就会通过 HTTP 请求根据 target 逻辑地址将其发送到相应的 target Function Service 中。请求的 body 中会包含 input events 和这个 Function 计算需要的状态信息（从本地获取），在 Function 处理完请求后，会将需要返回的结果集合及所有变化的 state 作为 Service Response 都发送回 StateFun Cluster。当 StateFun Cluster Partition 接收到 Response 后，所有的 state 变化都会被写会到本地 State 中，message 会根据 target 逻辑地址路由转发到其他 Cluster Partition 中，触发其他的 Function 调用。</p>
<p><img src="/images/statefun/request-reply-protocol.png" alt="The remote invocation request/reply protocol"></p>
<p>在这个框架下，StateFun SDKs 如 Python SDK 以及其他语言的 SDK 都可以基于这个协议来实现；从用户的角度来看，他们部署的 Function 操作的状态都像是本地状态一样，而实际上，这些都是由 StateFun 来维护和保证的，并且通过 HTTP/gRPC 协议来交互。</p>
<h3 id="Function-state-consistency-and-fault-tolerance"><a href="#Function-state-consistency-and-fault-tolerance" class="headerlink" title="Function state consistency and fault-tolerance"></a>Function state consistency and fault-tolerance</h3><p>StateFun Runtime 端会保证在任何时刻，每条 event（如 <code>(cart, &quot;Kim&quot;)</code>）只会进行一次触发调用，并且每个实体的触发都是串行进行的（可以理解为一个 StateFun Cluster Partition 上一个 Function 的触发操作都是串行的），如果对于一个实体来说，一个 Function<br>正在触发，那么新到的数据将会被缓存在 state 中，只有正在进行的触发结束后才能处理后面的请求。另外，因为请求是串行发送，它保证了每个请求都是完全隔离的，并且由于一个请求会将需要的所有信息都放在请求中，所以 Function 的触发是完全幂等的操作（这可以原生地避免 Function 在调用故障时可能会出现的一致性问题）。</p>
<p>关于容错机制，所有由 StateFun Cluster 管理的 Function state 会利用 Flink 原生的分布式快照机制周期性、异步地产生 Checkpoint，并且存储到 HDFS/GCS 这类的远程文件系统。这些 Checkpoint 会包含这个应用所有 Function 的全局一致性状态快照，并且包括 Ingress 中的 offset 信息和 Egress 中正在进行的事务状态信息。如果应用因为某些异常而挂掉，系统会从最新一次成功的 Checkpoint 中恢复，所有 Function 的状态信息都会被恢复、在 Checkpoint 与系统 Crash 之间的 event 也都会按照之前同样的逻辑进行处理，就好像失败从未发生一样。</p>
<h3 id="Step-by-step-walkthrough-of-function-invocations"><a href="#Step-by-step-walkthrough-of-function-invocations" class="headerlink" title="Step-by-step walkthrough of function invocations"></a>Step-by-step walkthrough of function invocations</h3><p>在这一小节，通过上面那个购物车的示例，来看下一条真实的 event 是如何在 StateFun Cluster 与 Function 之间传递的。顾客 <code>Kim</code> 想将 2 双袜子（<code>sock</code>）添加到其购物车中，这条 event 触发的一系列操作如下图所示：</p>
<p><img src="/images/statefun/protocol-walkthrough-1.png" alt="Message flow walkthrough"></p>
<p>结合上图，下面一步步来看下这条 event 的处理过程：</p>
<ol>
<li>一条 Event <code>AddToCart(&quot;Kim&quot;, &quot;socks&quot;, 2)</code> 从 Ingress Partition 中发送出来 <strong><code>(1)</code></strong>，在这个应用中，Ingress event router 配置的 Function Type 是 <code>Cart Function</code>，并且使用 user ID <code>Kim</code> 作为 Instance ID。Function Type 和 Instance ID 它们会确定这个 event 的 target 逻辑地址（<code>(cart:Kim)</code>）；</li>
<li>这里假设这条 event 是被 StateFun <code>partition B</code> 读取到的，但是 <code>(cart:Kim)</code> 的地址实际上应该路由到 <code>partition A</code>，因此，这条 event 会先被路由到 <code>partition A</code> 中 <strong><code>(2)</code></strong>；</li>
<li>StateFun <code>partition A</code> 接收到这条 event 后开始做相应的处理：<ol>
<li>首先，先从本地状态中获取 <code>(cart:Kim)</code> 的状态信息 —— Kim 购物车中已经存在商品列表 <strong><code>(3)</code></strong>；</li>
<li>接着，它会标记 <code>(cart:Kim)</code> 为 <code>busy</code> 的状态，除非当前的 event 处理完，否则不会再处理其他的 event 信息（先将后面的请求其缓存起来），这样可以避免状态一致性的问题；</li>
<li>StateFun Runtime 会通过一个 HTTP Client 向 <code>Cart</code> Function Service 发送请求 <strong><code>(4)</code></strong>，这个请求会包含 <code>AddToCart(&quot;Kim&quot;, &quot;socks&quot;, 2)</code> 数据及当前 <code>(cart:Kim)</code> 的状态信息（这里要注意的是，每个请求的路由转发，都会将这个状态信息作为请求的一部分发送到 Function Service 中，这是一个比较有意思的设计）；</li>
<li>远程 <code>Cart</code> Function Service 在接收到数据后，会尝试查询一下库存状态（通过 <code>Inventory</code> Function Service 来查询），因此，它会返回一个 target 逻辑地址为 <code>(inventory:socks)</code> 的 <code>RequestItem(&quot;socks&quot;, 2)</code> 请求。在这里，经过 <code>Cart</code> Function Service 处理后的任何状态变化都会随着请求返回给 StateFun Cluster 中 <strong><code>(5)</code></strong>；</li>
<li>StateFun Runtime 接收到 response 后，再将 <code>RequestItem</code> 信息路由到其他的 Partition 上，并且将 <code>(cart:Kim)</code> 标记为可用状态；</li>
</ol>
</li>
<li>这里假设 <code>(inventory:socks)</code> 的地址应该路由到 <code>partition B</code> 上，这里，会将对应的 event 再路由转发到 <code>partition B</code> 上 <strong><code>(6)</code></strong>；</li>
<li>一旦 <code>partition B</code> 接收到 <code>RequestItem</code> msg 后，Runtime 将会再次按照上面类似的逻辑进行相应触发 <strong><code>(7)</code></strong>。</li>
</ol>
<p>通过这个示例，我们可以清晰地看到一条 event 在 StateFun Cluster 中的处理流程，对于理解其内部机制很有帮助。</p>
<blockquote>
<p>这里比较有意思的点是流程 2 和 6，本质上 StateFun Cluster Partition 代表的是 Flink Job 中具体执行的 Task，Stateful Function 在实现时增加了一个 Feedback Loop 支持，来使得数据流的传输不受限于 DAG 的限制，在 StateFun 中，真实的数据流还可以是有环的，这个将会在下一篇文章中给大家揭秘其内部机制。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://flink.apache.org/news/2020/10/13/stateful-serverless-internals.html" target="_blank" rel="external">Stateful Functions Internals: Behind the scenes of Stateful Serverless</a> 这篇文章的最后是关于在公有云平台部署的介绍，我们就不再详述了，本文通过一个应用示例把 StateFun 内部的实现机制给大家做了一个简单的介绍，比较核心的内容都有所涉及，对于想了解 StateFun 内部原理的同学，本文应该就足以让我们有个清晰的认识。因为之前对 Flink StateFun 做过一些调研，把 StateFun 源码的核心流程简单看了一遍，在下篇文章中将会针对 StateFun 的具体实现做一个梳理，更深入地介绍一下 StateFun 的实现。</p>
</div><div class="copyright"><h2 id="版权说明"><a href="#版权说明" title="版权说明" class="headerlink">版权说明</a></h2><p><strong><big><a href="http://matt33.com/copyright/">博客版权说明</a></big></strong></p><p>所有文章以 <strong><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external">知识共享署名 4.0 国际许可协议 </a></strong>进行授权，转载时请注明原文链接</p></div><div class="weixin"><h2 id="公众号"><a href="#公众号" title="公众号" class="headerlink">公众号</a></h2><p>个人公众号（柳年思水）已经上线，最新文章会同步在公众号发布，欢迎大家关注~</p><p></p><p><img src="/images/wangm92-3.png" style="text-align:center" width="600"></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://matt33.com/2020/10/31/statefun-serverless-internals/" data-id="ckgxmw5w2005f89cb8zamvz4i" class="article-share-link">分享到</a><div class="tags"><a href="/tags/flink/">flink</a></div><div class="post-nav"><a href="/2020/10/25/statefun-introduce/" class="next">Flink StateFun 2.0 浅谈</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2020/10/31/statefun-serverless-internals/';
var disqus_title = 'Stateful Serverless 背后的 Flink StateFun 内部机制实现【译】';
var disqus_url = 'http://matt33.com/2020/10/31/statefun-serverless-internals/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/system/" style="font-size: 15px;">system</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/bk/" style="font-size: 15px;">bk</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/calcite/" style="font-size: 15px;">calcite</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/10/31/statefun-serverless-internals/">Stateful Serverless 背后的 Flink StateFun 内部机制实现【译】</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/statefun-introduce/">Flink StateFun 2.0 浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/02/kubernetes-start/">Kubenetes 之新手入门篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/16/cpu-branch-predictor/">浅谈 CPU 分支预测技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/flink-task-mailbox/">Flink 基于 MailBox 实现的 StreamTask 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/flink-taskmanager-7/">Flink TaskManager 详解（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/flink-jobmanager-6/">Flink JobManager 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/flink-master-5/">Flink Master 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/20/flink-execution-graph-4/">Flink 如何生成 ExecutionGraph</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/flink-job-graph-3/">Flink Streaming 作业如何转化为 JobGraph</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://matt33.com/about/" title="个人公众号：柳年思水" target="_blank">个人公众号：柳年思水</a><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>