<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="与一群有趣的人，做一些有趣的事."><title>Kafka 源码分析之 topic 创建过程（三） | Matt's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kafka 源码分析之 topic 创建过程（三）</h1><a id="logo" href="/.">Matt's Blog</a><p class="description">wangzzu</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kafka 源码分析之 topic 创建过程（三）</h1><div class="post-meta">Jul 21, 2017<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><span> | </span><span class="post-count">4,641</span><span> 字</span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Times</span></span></div><a data-disqus-identifier="2017/07/21/kafka-topic-create/" href="/2017/07/21/kafka-topic-create/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#topic-介绍"><span class="toc-number">1.</span> <span class="toc-text">topic 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#topic-如何创建"><span class="toc-number">2.</span> <span class="toc-text">topic 如何创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-topics-sh-创建-topic"><span class="toc-number">2.1.</span> <span class="toc-text">kafka-topics.sh 创建 topic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer-创建-topic"><span class="toc-number">2.2.</span> <span class="toc-text">Producer 创建 topic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replica-如何分配"><span class="toc-number">3.</span> <span class="toc-text">replica 如何分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建时指定-replicas-分配"><span class="toc-number">3.1.</span> <span class="toc-text">创建时指定 replicas 分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicas-自动分配算法"><span class="toc-number">3.2.</span> <span class="toc-text">replicas 自动分配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replicas-更新到-zk-后触发的操作"><span class="toc-number">4.</span> <span class="toc-text">replicas 更新到 zk 后触发的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partition-状态机"><span class="toc-number">4.1.</span> <span class="toc-text">Partition 状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replica-状态机"><span class="toc-number">4.2.</span> <span class="toc-text">Replica 状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onNewPartitionCreation-详解"><span class="toc-number">4.3.</span> <span class="toc-text">onNewPartitionCreation() 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#partitionStateMachine-gt-NewPartition"><span class="toc-number">4.3.1.</span> <span class="toc-text">partitionStateMachine > NewPartition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicaStateMachine-gt-NewReplica"><span class="toc-number">4.3.2.</span> <span class="toc-text">replicaStateMachine > NewReplica</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#partitionStateMachine-gt-OnlinePartition"><span class="toc-number">4.3.3.</span> <span class="toc-text">partitionStateMachine > OnlinePartition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicaStateMachine-gt-OnlineReplica"><span class="toc-number">4.3.4.</span> <span class="toc-text">replicaStateMachine > OnlineReplica</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>本文是 Kafka 源码解析的第三篇，主要讲述一个 topic 的创建过程，从 topic 是如何创建到 topic 真正创建成功的中间详细过程，文章主要内容可以分为以下几个部分：</p>
<ol>
<li>topic 是如何创建的？<ul>
<li>命令行创建；</li>
<li>Producer 发送数据时，自动创建；</li>
</ul>
</li>
<li>topic 创建时，replicas 是如何分配的？<ul>
<li>指定 replicas 的分配；</li>
<li>自动 replicas 分配；</li>
</ul>
</li>
<li>replicas 更新到 zk 后，底层如何创建一个 topic？<ul>
<li>创建 Partition 对象及状态更新；</li>
<li>创建 Partition 的 replica 对象及状态更新。</li>
</ul>
</li>
</ol>
<p>一个 topic 的完整创建过程如下图所示（以 topic 的 replicas 自动创建，且 broker 没有机架感知为例）</p>
<p><img src="/images/kafka/create_topic.png" alt="Topic 完整创建过程"></p>
<p>上图只是列出一些主要的方法调用，具体内容下面会详细讲述（在看下面的内容时，最后配合上面这张图来看）。</p>
<h2 id="topic-介绍"><a href="#topic-介绍" class="headerlink" title="topic 介绍"></a>topic 介绍</h2><p>topic 是 Kafka 中的一个消息队列的标识，也可以认为是消息队列的一个 id，用于区分不同的消息队列，一个 topic 由多个 partition 组成，这些 partition 是通常是分布在不同的多台 Broker 上的，为了保证数据的可靠性，一个 partition 又会设置为多个副本（replica），通常会设置两副本或三副本。如下图所示，这个一个名为『topic』的 topic，它由三个 partition 组成，两副本，假设 Kafka 集群有三台 Broker（replica 0_1 代表 partition 0 的第一个副本）。</p>
<p><img src="/images/kafka/topic-replicas.png" alt="Kafka Topic 的组成"></p>
<p>在设置副本时，副本数是必须大于集群的 Broker 数的，副本只有设置在不同的机器上才有作用。</p>
<h2 id="topic-如何创建"><a href="#topic-如何创建" class="headerlink" title="topic 如何创建"></a>topic 如何创建</h2><p>topic 在创建时有两种方式：</p>
<ol>
<li>通过 <code>kafka-topics.sh</code> 创建一个 topic，可以设置相应的副本数让 Server 端自动进行 replica 分配，也可以直接指定手动 replica 的分配；</li>
<li>Server 端如果 <code>auto.create.topics.enable</code> 设置为 true 时，那么当 Producer 向一个不存在的 topic 发送数据时，该 topic 同样会被创建出来，此时，副本数默认是1。</li>
</ol>
<p>下面看一下这两种方式的底层实现。</p>
<h3 id="kafka-topics-sh-创建-topic"><a href="#kafka-topics-sh-创建-topic" class="headerlink" title="kafka-topics.sh 创建 topic"></a>kafka-topics.sh 创建 topic</h3><p>在 Kafka 的安装目录下，通过下面这条命令可以创建一个 partition 为3，replica 为2的 topic（test）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --partitions 3 --replication-factor 2</div></pre></td></tr></table></figure>
<p><code>kafka-topics.sh</code> 实际上是调用 <code>kafka.admin.TopicCommand</code> 的方法来创建 topic，其实现如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 创建 topic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>, opts: <span class="type">TopicCommandOptions</span>) &#123;</div><div class="line">  <span class="keyword">val</span> topic = opts.options.valueOf(opts.topicOpt)</div><div class="line">  <span class="keyword">val</span> configs = parseTopicConfigsToBeAdded(opts)</div><div class="line">  <span class="keyword">val</span> ifNotExists = opts.options.has(opts.ifNotExistsOpt)</div><div class="line">  <span class="keyword">if</span> (<span class="type">Topic</span>.hasCollisionChars(topic))</div><div class="line">    println(<span class="string">"WARNING: Due to limitations in metric names, topics with a period ('.') or underscore ('_') could collide. To avoid issues it is best to use either, but not both."</span>)</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (opts.options.has(opts.replicaAssignmentOpt)) &#123;<span class="comment">//note: 指定 replica 的分配,直接向 zk 更新即可</span></div><div class="line">      <span class="keyword">val</span> assignment = parseReplicaAssignment(opts.options.valueOf(opts.replicaAssignmentOpt))</div><div class="line">      <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, assignment, configs, update = <span class="literal">false</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//note: 未指定 replica 的分配,调用自动分配算法进行分配</span></div><div class="line">      <span class="type">CommandLineUtils</span>.checkRequiredArgs(opts.parser, opts.options, opts.partitionsOpt, opts.replicationFactorOpt)</div><div class="line">      <span class="keyword">val</span> partitions = opts.options.valueOf(opts.partitionsOpt).intValue</div><div class="line">      <span class="keyword">val</span> replicas = opts.options.valueOf(opts.replicationFactorOpt).intValue</div><div class="line">      <span class="keyword">val</span> rackAwareMode = <span class="keyword">if</span> (opts.options.has(opts.disableRackAware)) <span class="type">RackAwareMode</span>.<span class="type">Disabled</span></div><div class="line">                          <span class="keyword">else</span> <span class="type">RackAwareMode</span>.<span class="type">Enforced</span></div><div class="line">      <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, partitions, replicas, configs, rackAwareMode)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"Created topic \"%s\"."</span>.format(topic))</div><div class="line">  &#125; <span class="keyword">catch</span>  &#123;</div><div class="line">    <span class="keyword">case</span> e: <span class="type">TopicExistsException</span> =&gt; <span class="keyword">if</span> (!ifNotExists) <span class="keyword">throw</span> e</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果指定了 partition 各个 replica 的分布，那么将 partition replicas 的结果验证之后直接更新到 zk 上，验证的 replicas 的代码是在 <code>parseReplicaAssignment</code> 中实现的，如下所示</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseReplicaAssignment</span></span>(replicaAssignmentList: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">  <span class="keyword">val</span> partitionList = replicaAssignmentList.split(<span class="string">","</span>)</div><div class="line">  <span class="keyword">val</span> ret = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]]()</div><div class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until partitionList.size) &#123;</div><div class="line">    <span class="keyword">val</span> brokerList = partitionList(i).split(<span class="string">":"</span>).map(s =&gt; s.trim().toInt)</div><div class="line">    <span class="keyword">val</span> duplicateBrokers = <span class="type">CoreUtils</span>.duplicates(brokerList)</div><div class="line">    <span class="keyword">if</span> (duplicateBrokers.nonEmpty)<span class="comment">//note: 同一个 partition 对应的 replica 是不能相同的</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminCommandFailedException</span>(<span class="string">"Partition replica lists may not contain duplicate entries: %s"</span>.format(duplicateBrokers.mkString(<span class="string">","</span>)))</div><div class="line">    ret.put(i, brokerList.toList)</div><div class="line">    <span class="keyword">if</span> (ret(i).size != ret(<span class="number">0</span>).size)<span class="comment">//note: 同一个 topic 的副本数必须相同</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Partition "</span> + i + <span class="string">" has different replication factor: "</span> + brokerList)</div><div class="line">  &#125;</div><div class="line">  ret.toMap</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有指定 parittion replicas 分配的话，将会调用 <code>AdminUtils.createTopic</code> 方法创建 topic，这个方法首先会检测当前的 Kafka 集群是否机架感知，如果有的话先获取 Broker 的机架信息，接着再使用 Replica 自动分配算法来分配 Partition 的 replica，最后就跟指定 replica 方式一样，将 replicas 的结果更新到 zk 中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(zkUtils: <span class="type">ZkUtils</span>,</div><div class="line">                topic: <span class="type">String</span>,</div><div class="line">                partitions: <span class="type">Int</span>,</div><div class="line">                replicationFactor: <span class="type">Int</span>,</div><div class="line">                topicConfig: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>,</div><div class="line">                rackAwareMode: <span class="type">RackAwareMode</span> = <span class="type">RackAwareMode</span>.<span class="type">Enforced</span>) &#123;</div><div class="line">  <span class="keyword">val</span> brokerMetadatas = getBrokerMetadatas(zkUtils, rackAwareMode)<span class="comment">//note: 有机架感知的情况下,返回 Broker 与机架之间的信息</span></div><div class="line">  <span class="keyword">val</span> replicaAssignment = <span class="type">AdminUtils</span>.assignReplicasToBrokers(brokerMetadatas, partitions, replicationFactor)<span class="comment">//note: 获取 partiiton 的 replicas 分配</span></div><div class="line">  <span class="type">AdminUtils</span>.createOrUpdateTopicPartitionAssignmentPathInZK(zkUtils, topic, replicaAssignment, topicConfig)<span class="comment">//note: 更新到 zk 上</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Producer-创建-topic"><a href="#Producer-创建-topic" class="headerlink" title="Producer 创建 topic"></a>Producer 创建 topic</h3><p>只有当 Server 端的 <code>auto.create.topics.enable</code> 设置为 true 时，Producer 向一个不存在的 topic 发送数据，该 topic 才会被自动创建。</p>
<p>当 Producer 在向一个 topic 发送 produce 请求前，会先通过发送 Metadata 请求来获取这个 topic 的 metadata。Server 端在处理 Metadata 请求时，如果发现要获取 metadata 的 topic 不存在但 Server 允许 producer 自动创建 topic 的话（如果开启权限时，要求 Producer 需要有相应权限：对 topic 有 Describe 权限，并且对当前集群有 Create 权限），那么 Server 将会自动创建该 topic.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 获取 topic 的 metadata 信息</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getTopicMetadata</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], listenerName: <span class="type">ListenerName</span>, errorUnavailableEndpoints: <span class="type">Boolean</span>): <span class="type">Seq</span>[<span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> topicResponses = metadataCache.getTopicMetadata(topics, listenerName, errorUnavailableEndpoints)</div><div class="line">  <span class="keyword">if</span> (topics.isEmpty || topicResponses.size == topics.size) &#123;</div><div class="line">    topicResponses</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">val</span> nonExistentTopics = topics -- topicResponses.map(_.topic).toSet<span class="comment">//note: 集群上暂时不存在的 topic 列表</span></div><div class="line">    <span class="keyword">val</span> responsesForNonExistentTopics = nonExistentTopics.map &#123; topic =&gt;</div><div class="line">      <span class="keyword">if</span> (topic == <span class="type">Topic</span>.<span class="type">GroupMetadataTopicName</span>) &#123;</div><div class="line">        createGroupMetadataTopic()</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.autoCreateTopicsEnable) &#123;<span class="comment">//note: auto.create.topics.enable 为 true 时,即允许自动创建 topic</span></div><div class="line">        createTopic(topic, config.numPartitions, config.defaultReplicationFactor)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>, topic, <span class="literal">false</span>,</div><div class="line">          java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    topicResponses ++ responsesForNonExistentTopics</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>createTopic</code> 还是调用了 <code>AdminUtils.createTopic</code> 来创建 topic，与命令行创建的底层实现是一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTopic</span></span>(topic: <span class="type">String</span>,</div><div class="line">                        numPartitions: <span class="type">Int</span>,</div><div class="line">                        replicationFactor: <span class="type">Int</span>,</div><div class="line">                        properties: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>()): <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span> = &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//note: 还是调用 AdminUtils 命令创建 topic</span></div><div class="line">    <span class="type">AdminUtils</span>.createTopic(zkUtils, topic, numPartitions, replicationFactor, properties, <span class="type">RackAwareMode</span>.<span class="type">Safe</span>)</div><div class="line">    info(<span class="string">"Auto creation of topic %s with %d partitions and replication factor %d is successful"</span></div><div class="line">      .format(topic, numPartitions, replicationFactor))</div><div class="line">    <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">      java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125; <span class="keyword">catch</span> &#123;</div><div class="line">    <span class="keyword">case</span> _: <span class="type">TopicExistsException</span> =&gt; <span class="comment">// let it go, possibly another broker created this topic</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.<span class="type">LEADER_NOT_AVAILABLE</span>, topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">    <span class="keyword">case</span> ex: <span class="type">Throwable</span>  =&gt; <span class="comment">// Catch all to prevent unhandled errors</span></div><div class="line">      <span class="keyword">new</span> <span class="type">MetadataResponse</span>.<span class="type">TopicMetadata</span>(<span class="type">Errors</span>.forException(ex), topic, <span class="type">Topic</span>.isInternal(topic),</div><div class="line">        java.util.<span class="type">Collections</span>.emptyList())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="replica-如何分配"><a href="#replica-如何分配" class="headerlink" title="replica 如何分配"></a>replica 如何分配</h2><p>通过前面的内容，可以看到，无论使用哪种方式，最后都是通过 <code>AdminUtils.createOrUpdateTopicPartitionAssignmentPathInZK()</code> 将 topic 的 Partition replicas 的更新到 zk 上，这中间关键的一点在于：Partition 的 replicas 是如何分配的。在创建时，我们既可以指定相应 replicas 分配，也可以使用默认的算法自动分配。</p>
<h3 id="创建时指定-replicas-分配"><a href="#创建时指定-replicas-分配" class="headerlink" title="创建时指定 replicas 分配"></a>创建时指定 replicas 分配</h3><p>在创建 topic 时，可以通过以下形式直接指定 topic 的 replica</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic <span class="built_in">test</span> --zookeeper XXXX --replica-assignment 1:2,3:4,5:6</div></pre></td></tr></table></figure>
<p>该 topic 有三个 partition，其中，partition 0 的 replica 分布在1和2上，partition 1 的 replica 分布在3和4上，partition 3 的 replica 分布在4和5上。</p>
<p>这样情况下，在创建 topic 时，Server 端会将该 replica 分布直接更新到 zk 上。</p>
<h3 id="replicas-自动分配算法"><a href="#replicas-自动分配算法" class="headerlink" title="replicas 自动分配算法"></a>replicas 自动分配算法</h3><p>在创建 topic 时，Server 通过 <code>AdminUtils.assignReplicasToBrokers()</code> 方法来获取该 topic partition 的 replicas 分配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 副本分配时,有三个原则:</div><div class="line">   * 1. 将副本平均分布在所有的 Broker 上;</div><div class="line">   * 2. partition 的多个副本应该分配在不同的 Broker 上;</div><div class="line">   * 3. 如果所有的 Broker 有机架信息的话, partition 的副本应该分配到不同的机架上。</div><div class="line">   *</div><div class="line">   * 为实现上面的目标,在没有机架感知的情况下，应该按照下面两个原则分配 replica:</div><div class="line">   * 1. 从 broker.list 随机选择一个 Broker,使用 round-robin 算法分配每个 partition 的第一个副本;</div><div class="line">   * 2. 对于这个 partition 的其他副本,逐渐增加 Broker.id 来选择 replica 的分配。</div><div class="line">   *</div><div class="line">   * @param brokerMetadatas</div><div class="line">   * @param nPartitions</div><div class="line">   * @param replicationFactor</div><div class="line">   * @param fixedStartIndex</div><div class="line">   * @param startPartitionId</div><div class="line">   * @return</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokers</span></span>(brokerMetadatas: <span class="type">Seq</span>[<span class="type">BrokerMetadata</span>],</div><div class="line">                             nPartitions: <span class="type">Int</span>,</div><div class="line">                             replicationFactor: <span class="type">Int</span>,</div><div class="line">                             fixedStartIndex: <span class="type">Int</span> = <span class="number">-1</span>,</div><div class="line">                             startPartitionId: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">if</span> (nPartitions &lt;= <span class="number">0</span>) <span class="comment">// note: 要增加的 partition 数需要大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidPartitionsException</span>(<span class="string">"number of partitions must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &lt;= <span class="number">0</span>) <span class="comment">//note: replicas 应该大于0</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">"replication factor must be larger than 0"</span>)</div><div class="line">   <span class="keyword">if</span> (replicationFactor &gt; brokerMetadatas.size) <span class="comment">//note: replicas 超过了 broker 数</span></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidReplicationFactorException</span>(<span class="string">s"replication factor: <span class="subst">$replicationFactor</span> larger than available brokers: <span class="subst">$&#123;brokerMetadatas.size&#125;</span>"</span>)</div><div class="line">   <span class="keyword">if</span> (brokerMetadatas.forall(_.rack.isEmpty))<span class="comment">//note: 没有开启机架感知</span></div><div class="line">     assignReplicasToBrokersRackUnaware(nPartitions, replicationFactor, brokerMetadatas.map(_.id), fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   <span class="keyword">else</span> &#123; <span class="comment">//note: 机架感知的情况</span></div><div class="line">     <span class="keyword">if</span> (brokerMetadatas.exists(_.rack.isEmpty)) <span class="comment">//note: 并不是所有的机架都有机架感知</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AdminOperationException</span>(<span class="string">"Not all brokers have rack information for replica rack aware assignment"</span>)</div><div class="line">     assignReplicasToBrokersRackAware(nPartitions, replicationFactor, brokerMetadatas, fixedStartIndex,</div><div class="line">       startPartitionId)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里没有开启机架感知模式来介绍 topic partition replicas 的分配情况，其分配算法主要是 <code>assignReplicasToBrokersRackUnaware()</code> 方法中实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: partition 分配</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">assignReplicasToBrokersRackUnaware</span></span>(nPartitions: <span class="type">Int</span>,</div><div class="line">                                                replicationFactor: <span class="type">Int</span>,</div><div class="line">                                                brokerList: <span class="type">Seq</span>[<span class="type">Int</span>],</div><div class="line">                                                fixedStartIndex: <span class="type">Int</span>,</div><div class="line">                                                startPartitionId: <span class="type">Int</span>): <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] = &#123;</div><div class="line">   <span class="keyword">val</span> ret = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]]()</div><div class="line">   <span class="keyword">val</span> brokerArray = brokerList.toArray</div><div class="line">   <span class="keyword">val</span> startIndex = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length) <span class="comment">//note: 随机选择一个Broker</span></div><div class="line">   <span class="keyword">var</span> currentPartitionId = math.max(<span class="number">0</span>, startPartitionId) <span class="comment">//note: 开始增加的第一个 partition</span></div><div class="line">   <span class="keyword">var</span> nextReplicaShift = <span class="keyword">if</span> (fixedStartIndex &gt;= <span class="number">0</span>) fixedStartIndex <span class="keyword">else</span> rand.nextInt(brokerArray.length)</div><div class="line">   <span class="keyword">for</span> (_ &lt;- <span class="number">0</span> until nPartitions) &#123; <span class="comment">//note: 对每个 partition 进行分配</span></div><div class="line">     <span class="keyword">if</span> (currentPartitionId &gt; <span class="number">0</span> &amp;&amp; (currentPartitionId % brokerArray.length == <span class="number">0</span>))</div><div class="line">       nextReplicaShift += <span class="number">1</span> <span class="comment">//note: 防止 partition 过大时,其中某些 partition 的分配（leader、follower）完全一样</span></div><div class="line">     <span class="keyword">val</span> firstReplicaIndex = (currentPartitionId + startIndex) % brokerArray.length <span class="comment">//note: partition 的第一个 replica</span></div><div class="line">     <span class="keyword">val</span> replicaBuffer = mutable.<span class="type">ArrayBuffer</span>(brokerArray(firstReplicaIndex))</div><div class="line">     <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until replicationFactor - <span class="number">1</span>) <span class="comment">//note: 其他 replica 的分配</span></div><div class="line">       replicaBuffer += brokerArray(replicaIndex(firstReplicaIndex, nextReplicaShift, j, brokerArray.length))</div><div class="line">     ret.put(currentPartitionId, replicaBuffer)</div><div class="line">     currentPartitionId += <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   ret</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: 为 partition 设置完第一个 replica 后,其他 replica 分配的计算</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">replicaIndex</span></span>(firstReplicaIndex: <span class="type">Int</span>, secondReplicaShift: <span class="type">Int</span>, replicaIndex: <span class="type">Int</span>, nBrokers: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</div><div class="line">   <span class="keyword">val</span> shift = <span class="number">1</span> + (secondReplicaShift + replicaIndex) % (nBrokers - <span class="number">1</span>)<span class="comment">//note: 在 secondReplicaShift 的基础上增加一个 replicaIndex</span></div><div class="line">   (firstReplicaIndex + shift) % nBrokers</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里举一个栗子，假设一个 Kafka 集群有5个节点，新建的 topic 有10个 partition，并且是三副本，假设最初随机选择的 <code>startIndex</code> 和 <code>nextReplicaShift</code> 节点均为0</p>
<ul>
<li>partition 为0时，那第一副本在 <code>(0+0)%5=0</code>，第二个副本在 <code>(0+(1+(0+0)%5)))%5=1</code>，第三副本在 <code>(0+(1+(0+1)%5)))%5=2</code>；</li>
<li>partition 为2时，那第一副本在 <code>(0+2)%5=2</code>，第二个副本在 <code>(2+(1+(0+0)%5)))%5=3</code>，第三副本在 <code>(2+(1+(0+1)%5)))%5=4</code>；</li>
<li>partition 为5时，那第一副本在 <code>(0+5)%5=0</code>，第二个副本在 <code>(0+(2+(0+0)%5)))%5=2</code>，第三副本在 <code>(0+(2+(0+1)%5)))%5=3</code>（partition 数是 Broker 数一倍时，<code>nextReplicaShift</code> 值会增加1）；</li>
<li>partition 为8时，那第一副本在 <code>(0+8)%5=3</code>，第二个副本在 <code>(3+(2+(0+0)%5)))%5=0</code>，第三副本在 <code>(3+(2+(0+1)%5)))%5=1</code>。</li>
</ul>
<p>分配如下表所示：</p>
<table>
<thead>
<tr>
<th>broker-0</th>
<th>broker-1</th>
<th>broker-2</th>
<th>broker-3</th>
<th>broker-4</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>p4</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>(1st replica)</td>
</tr>
<tr>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>p3</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>p7</td>
<td>(2nd replica)</td>
</tr>
<tr>
<td>p3</td>
<td>p4</td>
<td>p0</td>
<td>p1</td>
<td>p2</td>
<td>(3nd replica)</td>
</tr>
<tr>
<td>p7</td>
<td>p8</td>
<td>p9</td>
<td>p5</td>
<td>p6</td>
<td>(3nd replica)</td>
</tr>
</tbody>
</table>
<h2 id="replicas-更新到-zk-后触发的操作"><a href="#replicas-更新到-zk-后触发的操作" class="headerlink" title="replicas 更新到 zk 后触发的操作"></a>replicas 更新到 zk 后触发的操作</h2><p>这一部分的内容是由 Kafka Controller 来控制的（Kafka Controller 将会在后续文章中讲解），当一个 topic 的 replicas 更新到 zk 上后，监控 zk 这个目录的方法会被触发（<code>TopicChangeListener.doHandleChildChange()</code>方法），可以配合文章第一张图来看。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 zk 上 topic 节点上有变更时,这个方法就会调用</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doHandleChildChange</span></span>(parentPath: <span class="type">String</span>, children: <span class="type">Seq</span>[<span class="type">String</span>]) &#123;</div><div class="line">      inLock(controllerContext.controllerLock) &#123;</div><div class="line">        <span class="keyword">if</span> (hasStarted.get) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">val</span> currentChildren = &#123;</div><div class="line">              debug(<span class="string">"Topic change listener fired for path %s with children %s"</span>.format(parentPath, children.mkString(<span class="string">","</span>)))</div><div class="line">              children.toSet</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">val</span> newTopics = currentChildren -- controllerContext.allTopics<span class="comment">//note: 新创建的 topic 列表</span></div><div class="line">            <span class="keyword">val</span> deletedTopics = controllerContext.allTopics -- currentChildren<span class="comment">//note: 已经删除的 topic 列表</span></div><div class="line">            controllerContext.allTopics = currentChildren</div><div class="line"></div><div class="line">            <span class="comment">//note: 新创建 topic 对应的 partition 列表</span></div><div class="line">            <span class="keyword">val</span> addedPartitionReplicaAssignment = zkUtils.getReplicaAssignmentForTopics(newTopics.toSeq)</div><div class="line">            controllerContext.partitionReplicaAssignment = controllerContext.partitionReplicaAssignment.filter(p =&gt;</div><div class="line">              !deletedTopics.contains(p._1.topic))<span class="comment">//note: 把已经删除 partition 过滤掉</span></div><div class="line">            controllerContext.partitionReplicaAssignment.++=(addedPartitionReplicaAssignment)<span class="comment">//note: 将新增的 tp-replicas 更新到缓存中</span></div><div class="line">            info(<span class="string">"New topics: [%s], deleted topics: [%s], new partition replica assignment [%s]"</span>.format(newTopics,</div><div class="line">              deletedTopics, addedPartitionReplicaAssignment))</div><div class="line">            <span class="keyword">if</span> (newTopics.nonEmpty)<span class="comment">//note: 处理新建的 topic</span></div><div class="line">              controller.onNewTopicCreation(newTopics, addedPartitionReplicaAssignment.keySet)</div><div class="line">          &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">"Error while handling new topic"</span>, e)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法主要做了以下内容：</p>
<ul>
<li>获取 zk 的 topic 变更信息，得到新创建的 topic 列表（<code>newTopics</code>）以及被删除的 topic 列表（<code>deletedTopics</code>）；</li>
<li>将 <code>deletedTopics</code> 的 replicas 从 controller 的缓存中删除，并将新增 topic 的 replicas 更新到 controller 的缓存中；</li>
<li>调用 KafkaController 的 <code>onNewTopicCreation()</code> 创建 partition 和 replica 对象。</li>
</ul>
<p>KafkaController 中 <code>onNewTopicCreation()</code> 方法先对这些 topic 注册 <code>PartitionChangeListener</code>，然后再调用 <code>onNewPartitionCreation()</code> 方法创建 partition 和 replicas 的实例对象，<strong>topic 创建的主要实现是在 KafkaController <code>onNewPartitionCreation()</code> 这个方法中</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition state machine 监控到有新 topic 或 partition 时,这个方法将会被调用</span></div><div class="line"> <span class="comment">/**</span></div><div class="line">   * 1. 注册 partition change listener;</div><div class="line">   * 2. 触发 the new partition callback,也即是 onNewPartitionCreation()</div><div class="line">   * 3. 发送 metadata 请求给所有的 Broker</div><div class="line">   * @param topics</div><div class="line">   * @param newPartitions</div><div class="line">   */</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewTopicCreation</span></span>(topics: <span class="type">Set</span>[<span class="type">String</span>], newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New topic creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   <span class="comment">// subscribe to partition changes</span></div><div class="line">   topics.foreach(topic =&gt; partitionStateMachine.registerPartitionChangeListener(topic))</div><div class="line">   onNewPartitionCreation(newPartitions)</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">//note: topic 变化时,这个方法将会被调用</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 partition 置为 NewPartition 状态; 2.从 NewPartition 改为 OnlinePartition 状态</span></div><div class="line"> <span class="comment">//note: 1. 将新创建的 Replica 置为 NewReplica 状态; 2.从 NewReplica 改为 OnlineReplica 状态</span></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">onNewPartitionCreation</span></span>(newPartitions: <span class="type">Set</span>[<span class="type">TopicAndPartition</span>]) &#123;</div><div class="line">   info(<span class="string">"New partition creation callback for %s"</span>.format(newPartitions.mkString(<span class="string">","</span>)))</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">NewPartition</span>)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">NewReplica</span>)</div><div class="line">   partitionStateMachine.handleStateChanges(newPartitions, <span class="type">OnlinePartition</span>, offlinePartitionSelector)</div><div class="line">   replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), <span class="type">OnlineReplica</span>)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在详细介绍这四个方法的调用之前，先简单详述一下 Partition 和 Replica 状态机的变化。</p>
<h3 id="Partition-状态机"><a href="#Partition-状态机" class="headerlink" title="Partition 状态机"></a>Partition 状态机</h3><p>关于 Partition 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/PartitionStateMachine.scala" target="_blank" rel="external">PartitionStateMachine</a>，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/partition_stat.png" alt="Partition 状态机"></p>
<p>一个 Partition 对象有四种状态：</p>
<ol>
<li><code>NonExistentPartition</code>：这个 partition 不存在；</li>
<li><code>NewPartition</code>：这个 partition 刚创建，有对应的 replicas，但还没有 leader 和 isr；</li>
<li><code>OnlinePartition</code>：这个 partition 的 leader 已经选举出来了，处理正常的工作状态；</li>
<li><code>OfflinePartition</code>：partition 的 leader 挂了。</li>
</ol>
<p>partition 只有在 <code>OnlinePartition</code> 这个状态时，才是可用状态。</p>
<h3 id="Replica-状态机"><a href="#Replica-状态机" class="headerlink" title="Replica 状态机"></a>Replica 状态机</h3><p>关于 Replica 状态的变化可以参考 Kafka 中的这个方法 <a href="https://github.com/apache/kafka/blob/0.10.2/core/src/main/scala/kafka/controller/ReplicaStateMachine.scala" target="_blank" rel="external">ReplicaStateMachine</a>，，状态机的具体转换情况如下图所示</p>
<p><img src="/images/kafka/replica_stat.png" alt="Replica 状态机"></p>
<p>Replica 对象有七种状态，中文解释的比较难以理解，直接上原文对这几种状态的解释。</p>
<ol>
<li><code>NewReplica</code>：The controller can create new replicas during partition reassignment. In this state, a replica can only get become follower state change request.</li>
<li><code>OnlineReplica</code>：Once a replica is started and part of the assigned replicas for its partition, it is in this state. In this state, it can get either become leader or become follower state change requests.</li>
<li><code>OfflineReplica</code>：If a replica dies, it moves to this state. This happens when the broker hosting the replica is down.</li>
<li><code>ReplicaDeletionStarted</code>：If replica deletion starts, it is moved to this state.</li>
<li><code>ReplicaDeletionSuccessful</code>：If replica responds with no error code in response to a delete replica request, it is moved to this state.</li>
<li><code>ReplicaDeletionIneligible</code>：If replica deletion fails, it is moved to this state.</li>
<li><code>NonExistentReplica</code>：If a replica is deleted successfully, it is moved to this state.</li>
</ol>
<h3 id="onNewPartitionCreation-详解"><a href="#onNewPartitionCreation-详解" class="headerlink" title="onNewPartitionCreation() 详解"></a><code>onNewPartitionCreation()</code> 详解</h3><p>这个方法有以下四步操作：</p>
<ol>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, NewPartition)</code>： 创建 Partition 对象，并将其状态置为 <code>NewPartition</code> 状态</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), NewReplica)</code>：创建 Replica 对象，并将其状态置为 <code>NewReplica</code> 状态；</li>
<li><code>partitionStateMachine.handleStateChanges(newPartitions, OnlinePartition, offlinePartitionSelector)</code>：将 partition 对象从 <code>NewPartition</code> 改为 <code>OnlinePartition</code> 状态；</li>
<li><code>replicaStateMachine.handleStateChanges(controllerContext.replicasForPartition(newPartitions), OnlineReplica)</code>：将 Replica 对象从 <code>NewReplica</code> 改为 <code>OnlineReplica</code> 状态。</li>
</ol>
<h4 id="partitionStateMachine-gt-NewPartition"><a href="#partitionStateMachine-gt-NewPartition" class="headerlink" title="partitionStateMachine &gt; NewPartition"></a>partitionStateMachine &gt; NewPartition</h4><p>这部分的作用是，创建分区对象，并将其状态设置为 <code>NewPartition</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">  <span class="comment">//note: 新建一个 partition</span></div><div class="line">  assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NonExistentPartition</span>), <span class="type">NewPartition</span>)</div><div class="line">  partitionState.put(topicAndPartition, <span class="type">NewPartition</span>) <span class="comment">//note: 缓存 partition 的状态</span></div><div class="line">  <span class="keyword">val</span> assignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition).mkString(<span class="string">","</span>)</div><div class="line">  stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed partition %s state from %s to %s with assigned replicas %s"</span></div><div class="line">                            .format(controllerId, controller.epoch, topicAndPartition, currState, targetState,</div><div class="line">                                    assignedReplicas))</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-NewReplica"><a href="#replicaStateMachine-gt-NewReplica" class="headerlink" title="replicaStateMachine &gt; NewReplica"></a>replicaStateMachine &gt; NewReplica</h4><p>这部分是为每个 Partition 创建对应的 replica 对象，并将其状态设置为 <code>NewReplica</code>，参照状态机的变化图更好理解。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica, <span class="type">List</span>(<span class="type">NonExistentReplica</span>), targetState)  <span class="comment">//note: 验证</span></div><div class="line">          <span class="comment">// start replica as a follower to the current leader for its partition</span></div><div class="line">          <span class="keyword">val</span> leaderIsrAndControllerEpochOpt = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topic, partition)</div><div class="line">          leaderIsrAndControllerEpochOpt <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">Some</span>(leaderIsrAndControllerEpoch) =&gt;</div><div class="line">              <span class="keyword">if</span>(leaderIsrAndControllerEpoch.leaderAndIsr.leader == replicaId)<span class="comment">//note: 这个状态的 Replica 不能作为 leader</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(<span class="string">"Replica %d for partition %s cannot be moved to NewReplica"</span></div><div class="line">                  .format(replicaId, topicAndPartition) + <span class="string">"state as it is being requested to become leader"</span>)</div><div class="line">              <span class="comment">//note: 向所有 replicaId 发送 LeaderAndIsr 请求,这个方法同时也会向所有的 broker 发送 updateMeta 请求</span></div><div class="line">              brokerRequestBatch.addLeaderAndIsrRequestForBrokers(<span class="type">List</span>(replicaId),</div><div class="line">                                                                  topic, partition, leaderIsrAndControllerEpoch,</div><div class="line">                                                                  replicaAssignment)</div><div class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// new leader request will be sent to this replica when one gets elected</span></div></pre></td></tr></table></figure>
<h4 id="partitionStateMachine-gt-OnlinePartition"><a href="#partitionStateMachine-gt-OnlinePartition" class="headerlink" title="partitionStateMachine &gt; OnlinePartition"></a>partitionStateMachine &gt; OnlinePartition</h4><p>这个方法的主要的作用是将 partition 对象的状态由 <code>NewPartition</code> 设置为 <code>OnlinePartition</code>，从状态机图中可以看到，会有以下两步操作：</p>
<ol>
<li>初始化 leader 和 isr，replicas 中的第一个 replica 将作为 leader，所有 replica 作为 isr，并把 leader 和 isr 信息更新到 zk；</li>
<li>发送 LeaderAndIsr 请求给所有的 replica，发送 UpdateMetadata 给所有 Broker。</li>
</ol>
<p>具体操作如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// post: partition has been assigned replicas</span></div><div class="line">       <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt;</div><div class="line">         assertValidPreviousStates(topicAndPartition, <span class="type">List</span>(<span class="type">NewPartition</span>, <span class="type">OnlinePartition</span>, <span class="type">OfflinePartition</span>), <span class="type">OnlinePartition</span>)</div><div class="line">         partitionState(topicAndPartition) <span class="keyword">match</span> &#123;</div><div class="line">           <span class="keyword">case</span> <span class="type">NewPartition</span> =&gt;</div><div class="line">             <span class="comment">// initialize leader and isr path for new partition</span></div><div class="line">             initializeLeaderAndIsrForPartition(topicAndPartition) <span class="comment">//note: 为新建的 partition 初始化 leader 和 isr</span></div><div class="line">           <span class="keyword">case</span> <span class="type">OfflinePartition</span> =&gt;</div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> <span class="type">OnlinePartition</span> =&gt; <span class="comment">// invoked when the leader needs to be re-elected</span></div><div class="line">             electLeaderForPartition(topic, partition, leaderSelector)</div><div class="line">           <span class="keyword">case</span> _ =&gt; <span class="comment">// should never come here since illegal previous states are checked above</span></div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<p>实际的操作是在 <code>initializeLeaderAndIsrForPartition()</code> 方法中完成，这个方法是当 partition 对象的状态由 NewPartition 变为 OnlinePartition 时触发的，用来初始化该 partition 的 leader 和 isr。简单来说，就是选取 Replicas 中的第一个 Replica 作为 leader，所有的 Replica 作为 isr，最后调用 <code>brokerRequestBatch.addLeaderAndIsrRequestForBrokers</code> 向所有 replicaId 发送 LeaderAndIsr 请求以及向所有的 broker 发送 UpdateMetadata 请求（关于 Server 对 LeaderAndIsr 和 UpdateMetadata 请求的处理将会后续文章中讲述）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//note: 当 partition 状态由 NewPartition 变为 OnlinePartition 时,将触发这一方法,用来初始化 partition 的 leader 和 isr</span></div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initializeLeaderAndIsrForPartition</span></span>(topicAndPartition: <span class="type">TopicAndPartition</span>) &#123;</div><div class="line">   <span class="keyword">val</span> replicaAssignment = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">   <span class="keyword">val</span> liveAssignedReplicas = replicaAssignment.filter(r =&gt; controllerContext.liveBrokerIds.contains(r))</div><div class="line">   liveAssignedReplicas.size <span class="keyword">match</span> &#123;</div><div class="line">     <span class="keyword">case</span> <span class="number">0</span> =&gt;</div><div class="line">       <span class="keyword">val</span> failMsg = (<span class="string">"encountered error during state change of partition %s from New to Online, assigned replicas are [%s], "</span> +</div><div class="line">                      <span class="string">"live brokers are [%s]. No assigned replica is alive."</span>)</div><div class="line">                        .format(topicAndPartition, replicaAssignment.mkString(<span class="string">","</span>), controllerContext.liveBrokerIds)</div><div class="line">       stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">     <span class="keyword">case</span> _ =&gt;</div><div class="line">       debug(<span class="string">"Live assigned replicas for partition %s are: [%s]"</span>.format(topicAndPartition, liveAssignedReplicas))</div><div class="line">       <span class="comment">// make the first replica in the list of assigned replicas, the leader</span></div><div class="line">       <span class="keyword">val</span> leader = liveAssignedReplicas.head <span class="comment">//note: replicas 中的第一个 replica 选做 leader</span></div><div class="line">       <span class="keyword">val</span> leaderIsrAndControllerEpoch = <span class="keyword">new</span> <span class="type">LeaderIsrAndControllerEpoch</span>(<span class="keyword">new</span> <span class="type">LeaderAndIsr</span>(leader, liveAssignedReplicas.toList),</div><div class="line">         controller.epoch)</div><div class="line">       debug(<span class="string">"Initializing leader and isr for partition %s to %s"</span>.format(topicAndPartition, leaderIsrAndControllerEpoch))</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         zkUtils.createPersistentPath(</div><div class="line">           getTopicPartitionLeaderAndIsrPath(topicAndPartition.topic, topicAndPartition.partition),</div><div class="line">           zkUtils.leaderAndIsrZkData(leaderIsrAndControllerEpoch.leaderAndIsr, controller.epoch))<span class="comment">//note: zk 上初始化节点信息</span></div><div class="line">         <span class="comment">// <span class="doctag">NOTE:</span> the above write can fail only if the current controller lost its zk session and the new controller</span></div><div class="line">         <span class="comment">// took over and initialized this partition. This can happen if the current controller went into a long</span></div><div class="line">         <span class="comment">// GC pause</span></div><div class="line">         controllerContext.partitionLeadershipInfo.put(topicAndPartition, leaderIsrAndControllerEpoch)</div><div class="line">         brokerRequestBatch.addLeaderAndIsrRequestForBrokers(liveAssignedReplicas, topicAndPartition.topic,</div><div class="line">           topicAndPartition.partition, leaderIsrAndControllerEpoch, replicaAssignment)<span class="comment">//note: 向 live 的 Replica 发送  LeaderAndIsr 请求</span></div><div class="line">       &#125; <span class="keyword">catch</span> &#123;</div><div class="line">         <span class="keyword">case</span> _: <span class="type">ZkNodeExistsException</span> =&gt;</div><div class="line">           <span class="comment">// read the controller epoch</span></div><div class="line">           <span class="keyword">val</span> leaderIsrAndEpoch = <span class="type">ReplicationUtils</span>.getLeaderIsrAndEpochForPartition(zkUtils, topicAndPartition.topic,</div><div class="line">             topicAndPartition.partition).get</div><div class="line">           <span class="keyword">val</span> failMsg = (<span class="string">"encountered error while changing partition %s's state from New to Online since LeaderAndIsr path already "</span> +</div><div class="line">                          <span class="string">"exists with value %s and controller epoch %d"</span>)</div><div class="line">                            .format(topicAndPartition, leaderIsrAndEpoch.leaderAndIsr.toString(), leaderIsrAndEpoch.controllerEpoch)</div><div class="line">           stateChangeLogger.error(<span class="string">"Controller %d epoch %d "</span>.format(controllerId, controller.epoch) + failMsg)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">StateChangeFailedException</span>(failMsg)</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="replicaStateMachine-gt-OnlineReplica"><a href="#replicaStateMachine-gt-OnlineReplica" class="headerlink" title="replicaStateMachine &gt; OnlineReplica"></a>replicaStateMachine &gt; OnlineReplica</h4><p>这一步也就是最后一步，将 Replica 对象的状态由 <code>NewReplica</code> 更新为 <code>OnlineReplica</code> 状态，这些 Replica 才真正可用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="type">OnlineReplica</span> =&gt;</div><div class="line">          assertValidPreviousStates(partitionAndReplica,</div><div class="line">            <span class="type">List</span>(<span class="type">NewReplica</span>, <span class="type">OnlineReplica</span>, <span class="type">OfflineReplica</span>, <span class="type">ReplicaDeletionIneligible</span>), targetState)</div><div class="line">          replicaState(partitionAndReplica) <span class="keyword">match</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="type">NewReplica</span> =&gt;</div><div class="line">              <span class="comment">// add this replica to the assigned replicas list for its partition</span></div><div class="line">              <span class="comment">//note: 向 the assigned replicas list 添加这个 replica（正常情况下这些 replicas 已经更新到 list 中了）</span></div><div class="line">              <span class="keyword">val</span> currentAssignedReplicas = controllerContext.partitionReplicaAssignment(topicAndPartition)</div><div class="line">              <span class="keyword">if</span>(!currentAssignedReplicas.contains(replicaId))</div><div class="line">                controllerContext.partitionReplicaAssignment.put(topicAndPartition, currentAssignedReplicas :+ replicaId)</div><div class="line">              stateChangeLogger.trace(<span class="string">"Controller %d epoch %d changed state of replica %d for partition %s from %s to %s"</span></div><div class="line">                                        .format(controllerId, controller.epoch, replicaId, topicAndPartition, currState,</div><div class="line">                                                targetState))</div></pre></td></tr></table></figure>
<p>一直到这一步，一个 topic 就才算真正被创建完成。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/huxi2b/p/5923252.html" target="_blank" rel="external">Kafka如何创建topic？</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://wangzzu.github.io/2017/07/21/kafka-topic-create/" data-id="cj5gc54t4006avdagvqq8qo7h" class="article-share-link">分享到</a><div class="copyright"><a href="http://matt33.com/copyright/">博客版权说明</a></div><div class="tags"><a href="/tags/kafka/">kafka</a></div><div class="post-nav"><a href="/2017/07/16/linux-system-cmd/" class="next">Linux 常用的一些系统命令</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'http-matt33-com';
var disqus_identifier = '2017/07/21/kafka-topic-create/';
var disqus_title = 'Kafka 源码分析之 topic 创建过程（三）';
var disqus_url = 'http://wangzzu.github.io/2017/07/21/kafka-topic-create/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//http-matt33-com.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 微博</i></div><iframe width="100%" height="90" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=100&fansRow=1&ptype=1&speed=0&skin=1&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=2650396571&verifier=f2f0e397&colors=D8D8D8,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/书屋/">书屋</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/影如人生/">影如人生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅行/">旅行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/storm/" style="font-size: 15px;">storm</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/travel/" style="font-size: 15px;">travel</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/learn/" style="font-size: 15px;">learn</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/thrift/" style="font-size: 15px;">thrift</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/bug/" style="font-size: 15px;">bug</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/电影随想/" style="font-size: 15px;">电影随想</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/cv/" style="font-size: 15px;">cv</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/kafka-topic-create/">Kafka 源码分析之 topic 创建过程（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/linux-system-cmd/">Linux 常用的一些系统命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/08/kafka-producer-metadata/">Kafka 源码分析之 Producer Metadata 更新机制（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/buy-little-room/">买房感想</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/kafka-producer-send-module/">Kafka 源码分析之 Producer 发送模型（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/21/css-summary/">CSS 一些常用方法的总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/18/html-summary/">HTML 一些常用方法的总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/induction-training-think/">入职培训感想</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/16/tencent-read/">腾讯传，一个激情澎湃的时代</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/04/read/">欧洲简史</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//http-matt33-com.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Matt's Blog 柳年思水.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><div class="analytics"><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1256517224'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256517224' type='text/javascript'%3E%3C/script%3E"));</script></div><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-64518924-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5cf44757fa0d23bc7637935e44a9104a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>